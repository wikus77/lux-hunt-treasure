// @ts-nocheck
// Agents Layer for MapLibre 3D - Red markers using native MapLibre markers
// ðŸ”¥ FIX: Converted from HTML overlay to native markers for perfect map sync
import React, { useEffect, useState, useMemo, useRef } from 'react';
import type { Map as MLMap } from 'maplibre-gl';
import maplibregl from 'maplibre-gl';
import type { AgentDTO } from '@/features/living-map/adapters/readOnlyData';
import { getLiveAgents, onAgentsChanged } from '@/features/living-map/adapters/readOnlyData';

interface AgentsLayer3DProps {
  map: MLMap | null;
  enabled: boolean;
  agents?: AgentDTO[]; // Optional override for dev mocks
  mePosition?: { lat: number; lng: number } | null;
  currentUserId?: string | null; // ID utente corrente per unificare marker
  onAgentClick?: (agent: AgentDTO) => void;
}

const AgentsLayer3D: React.FC<AgentsLayer3DProps> = ({ map, enabled, agents: agentsProp, mePosition, currentUserId, onAgentClick }) => {
  const [agents, setAgents] = useState<AgentDTO[]>([]);
  
  // ðŸ”¥ Native MapLibre markers ref for cleanup
  const markersRef = useRef<Map<string, maplibregl.Marker>>(new Map());

  // ðŸ”¥ UNIFIED FIX: Aggiorna la posizione dell'agente corrente invece di crearne uno nuovo
  const augmentedAgents = useMemo(() => {
    const result = [...agents];
    
    if (mePosition) {
      // Cerca l'agente corrente nella lista (per user_id)
      const myAgentIndex = currentUserId 
        ? result.findIndex(a => a.id === currentUserId)
        : -1;
      
      if (myAgentIndex >= 0) {
        // ðŸŽ¯ UNIFICA: Aggiorna le coordinate dell'agente esistente con GPS reale
        result[myAgentIndex] = {
          ...result[myAgentIndex],
          lat: mePosition.lat,
          lng: mePosition.lng,
          status: 'online',
          lastSeen: new Date().toISOString()
        };
      } else {
        // Se l'utente NON Ã¨ nella lista dal DB, aggiungi marker locale "me"
        const existingMeIndex = result.findIndex(a => a.id === 'me-local');
        if (existingMeIndex >= 0) {
          result[existingMeIndex] = {
            ...result[existingMeIndex],
            lat: mePosition.lat,
            lng: mePosition.lng,
            status: 'online',
            lastSeen: new Date().toISOString()
          };
        } else {
          result.push({
            id: 'me-local',
            lat: mePosition.lat,
            lng: mePosition.lng,
            username: 'Tu',
            status: 'online',
            lastSeen: new Date().toISOString()
          } as AgentDTO);
        }
      }
    }
    
    return result;
  }, [agents, mePosition?.lat, mePosition?.lng, currentUserId]);

  useEffect(() => {
    if (!enabled) return;

    // If agents prop is provided (dev or live), use it
    if (agentsProp) {
      setAgents(agentsProp);
    } else {
      // Otherwise, load from adapter (dev mock or real if implemented)
      getLiveAgents().then(setAgents);
      const unsubscribe = onAgentsChanged(setAgents);
      return () => unsubscribe();
    }
  }, [enabled, agentsProp]);

  // ðŸ”¥ FIX: Use native MapLibre markers for perfect map sync (no floating!)
  useEffect(() => {
    if (!map || !enabled) return;

    const currentMarkerIds = new Set(augmentedAgents.map(a => a.id));
    
    // Remove markers that no longer exist
    markersRef.current.forEach((marker, id) => {
      if (!currentMarkerIds.has(id)) {
        marker.remove();
        markersRef.current.delete(id);
      }
    });

    // Add or update markers
    augmentedAgents.forEach(agent => {
      const isMe = agent.id === 'me-local' || (currentUserId && agent.id === currentUserId);
      const existingMarker = markersRef.current.get(agent.id);
      
      if (existingMarker) {
        // Update position of existing marker
        existingMarker.setLngLat([agent.lng, agent.lat]);
      } else {
        // Create new marker element
        const el = document.createElement('div');
        el.className = 'maplibre-agent-marker';
        el.style.cssText = `
          cursor: pointer;
          display: flex;
          flex-direction: column;
          align-items: center;
        `;
        
        // Agent dot
        const dot = document.createElement('div');
        dot.className = isMe ? 'm1-agent-dot m1-agent-dot--me' : 'm1-agent-dot';
        dot.title = isMe ? 'Tu (la tua posizione)' : (agent.username || 'Agente');
        el.appendChild(dot);
        
        // "TU" label for current user
        if (isMe) {
          const label = document.createElement('div');
          label.style.cssText = `
            font-size: 10px;
            font-weight: bold;
            color: #00D1FF;
            white-space: nowrap;
            text-shadow: 0 0 4px rgba(0,0,0,0.8);
            margin-top: 2px;
          `;
          label.textContent = 'TU';
          el.appendChild(label);
        }
        
        // Click handler
        el.addEventListener('click', (e) => {
          e.stopPropagation();
          onAgentClick?.(agent);
        });
        
        // Create native MapLibre marker
        const marker = new maplibregl.Marker({ 
          element: el,
          anchor: 'center'
        })
          .setLngLat([agent.lng, agent.lat])
          .addTo(map);
        
        markersRef.current.set(agent.id, marker);
      }
    });

    // Cleanup function
    return () => {
      markersRef.current.forEach(marker => marker.remove());
      markersRef.current.clear();
    };
  }, [map, augmentedAgents, enabled, currentUserId, onAgentClick]);

  // Component doesn't render any JSX - markers are added directly to the map
  return null;
};

export default AgentsLayer3D;

// Â© 2025 Joseph MULÃ‰ â€“ M1SSIONâ„¢ â€“ ALL RIGHTS RESERVED â€“ NIYVORA KFTâ„¢
