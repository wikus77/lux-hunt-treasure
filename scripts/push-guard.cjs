#!/usr/bin/env node
// Â© 2025 Joseph MULÃ‰ â€“ M1SSIONâ„¢ â€“ NIYVORA KFTâ„¢
// SAFE Guard - Prebuild security check for push notification infrastructure
// Blocks builds if SW/VAPID/secrets are compromised

const fs = require('fs');
const path = require('path');

// Utility functions
function die(msg) {
  console.error(`\nâŒ PUSH GUARD FAILED: ${msg}\n`);
  process.exit(1);
}

function ok(msg) {
  console.log(`âœ… ${msg}`);
}

function warn(msg) {
  console.warn(`âš ï¸  ${msg}`);
}

const root = process.cwd();
const publicDir = path.join(root, 'public');
const srcDir = path.join(root, 'src');

console.log('\nðŸ”’ M1SSIONâ„¢ Push SAFE Guard - Starting checks...\n');

// ===== CHECK 1: Unique Service Worker =====
console.log('ðŸ“‹ Check 1: Service Worker uniqueness');
if (!fs.existsSync(publicDir)) {
  die('public/ directory not found');
}

const publicFiles = fs.readdirSync(publicDir);
const swCandidates = publicFiles.filter(f => 
  /sw\.js$/i.test(f) || /-sw\.js$/i.test(f) || /service-worker\.js$/i.test(f)
);

const unauthorizedSW = swCandidates.filter(f => f !== 'sw.js');
if (unauthorizedSW.length > 0) {
  die(`Unauthorized service workers found: ${unauthorizedSW.join(', ')}. Only public/sw.js is allowed.`);
}

if (!swCandidates.includes('sw.js')) {
  die('public/sw.js not found');
}

ok('Service Worker: Only public/sw.js exists');

// ===== CHECK 2: Headers Configuration =====
console.log('\nðŸ“‹ Check 2: Cache headers configuration');
const headersPath = path.join(publicDir, '_headers');

if (!fs.existsSync(headersPath)) {
  die('public/_headers file missing. Required for no-cache directives.');
}

const headersContent = fs.readFileSync(headersPath, 'utf8');

// Check VAPID headers
const vapidHeaderCheck = /\/vapid-public\.txt[\s\S]*?Cache-Control:\s*no-store/i.test(headersContent);
if (!vapidHeaderCheck) {
  die('public/_headers missing Cache-Control: no-store for /vapid-public.txt');
}

// Check SW headers
const swHeaderCheck = /\/sw\.js[\s\S]*?Cache-Control:\s*no-store/i.test(headersContent);
const swAllowedCheck = /\/sw\.js[\s\S]*?Service-Worker-Allowed:\s*\//i.test(headersContent);

if (!swHeaderCheck) {
  die('public/_headers missing Cache-Control: no-store for /sw.js');
}

if (!swAllowedCheck) {
  warn('public/_headers missing Service-Worker-Allowed: / for /sw.js (recommended but not critical)');
}

ok('Headers: Cache-Control directives properly configured');

// ===== CHECK 3: VAPID Key Validation =====
console.log('\nðŸ“‹ Check 3: VAPID public key validation');
const vapidPath = path.join(publicDir, 'vapid-public.txt');

if (!fs.existsSync(vapidPath)) {
  die('public/vapid-public.txt not found');
}

const vapidKey = fs.readFileSync(vapidPath, 'utf8').trim();

if (!vapidKey || vapidKey.length < 60) {
  die('VAPID public key appears invalid (too short)');
}

// Base64URL to bytes conversion
function base64urlToBytes(str) {
  const padding = '='.repeat((4 - (str.length % 4)) % 4);
  const base64 = (str + padding).replace(/-/g, '+').replace(/_/g, '/');
  return Buffer.from(base64, 'base64');
}

try {
  const keyBytes = base64urlToBytes(vapidKey);
  
  // P-256 public key must be 65 bytes, starting with 0x04 (uncompressed point)
  if (keyBytes.length !== 65) {
    die(`VAPID key invalid length: ${keyBytes.length} bytes (expected 65 for P-256)`);
  }
  
  if (keyBytes[0] !== 0x04) {
    die(`VAPID key invalid format: first byte is 0x${keyBytes[0].toString(16)} (expected 0x04 for uncompressed P-256)`);
  }
  
  ok(`VAPID: Valid P-256 public key (65 bytes, prefix: ${vapidKey.slice(0, 7)}â€¦)`);
} catch (err) {
  die(`VAPID key decode error: ${err.message}`);
}

// ===== CHECK 4: Forbidden Patterns in Source =====
console.log('\nðŸ“‹ Check 4: Scanning source for hardcoded secrets');

const FORBIDDEN_PATTERNS = [
  { regex: /x-admin-token\s*[:=]/i, desc: 'x-admin-token header' },
  { regex: /PUSH_ADMIN_TOKEN\s*[:=]/i, desc: 'PUSH_ADMIN_TOKEN constant' },
  { regex: /ADMIN_BROADCAST_TOKEN\s*[:=]/i, desc: 'ADMIN_BROADCAST_TOKEN constant' },
  { regex: /VAPID_PRIVATE_KEY\s*[:=]/i, desc: 'VAPID_PRIVATE_KEY constant' },
  { regex: /Bearer\s+eyJ[A-Za-z0-9_-]{20,}/i, desc: 'Hardcoded JWT token' },
  { regex: /SUPABASE_URL\s*[:=]\s*["'][^"']{20,}["']/i, desc: 'Hardcoded SUPABASE_URL' },
  { regex: /SUPABASE_ANON_KEY\s*[:=]\s*["']eyJ[^"']+["']/i, desc: 'Hardcoded SUPABASE_ANON_KEY' },
  { regex: /vkjrqirvdvjbemsfzxof/i, desc: 'Supabase project ref hardcoded' },
];

const ALLOWED_VAPID_LOADER = 'src/lib/vapid-loader.ts';

// Files allowed to contain Supabase config (these are the official config files)
const ALLOWED_SUPABASE_CONFIG_FILES = [
  'src/integrations/supabase/client.ts', // Generated by Lovable
  'src/lib/supabase/clientUtils.ts',      // Config utility
  'src/hooks/buzz/useBuzzApi.ts',         // Uses fallback from client
];

// Patterns that are allowed in Supabase config files
const SUPABASE_CONFIG_PATTERNS = [
  'Supabase project ref hardcoded',
  'Hardcoded SUPABASE_URL',
  'Hardcoded SUPABASE_ANON_KEY',
];

function scanDirectory(dir, relativePath = '') {
  const entries = fs.readdirSync(dir);
  
  for (const entry of entries) {
    const fullPath = path.join(dir, entry);
    const relPath = path.join(relativePath, entry);
    const stat = fs.statSync(fullPath);
    
    if (stat.isDirectory()) {
      // Skip node_modules, dist, build directories
      if (!['node_modules', 'dist', 'build', '.git'].includes(entry)) {
        scanDirectory(fullPath, relPath);
      }
    } else if (/\.(ts|tsx|js|jsx|mjs|cjs)$/.test(entry)) {
      const content = fs.readFileSync(fullPath, 'utf8');
      
      // Check forbidden patterns
      for (const { regex, desc } of FORBIDDEN_PATTERNS) {
        // Skip allowed files for Supabase config patterns
        const isAllowedSupabaseFile = ALLOWED_SUPABASE_CONFIG_FILES.some(
          allowed => relPath.endsWith(allowed.replace(/\//g, path.sep))
        );
        const isSupabasePattern = SUPABASE_CONFIG_PATTERNS.includes(desc);
        
        if (isSupabasePattern && isAllowedSupabaseFile) {
          continue; // Allow Supabase config in designated files
        }
        
        if (regex.test(content)) {
          die(`Forbidden pattern found in ${relPath}: ${desc}`);
        }
      }
      
      // Check VAPID loader usage
      if (/vapid/i.test(content) && !relPath.includes('vapid-loader')) {
        // Look for old VAPID helpers
        const oldHelpers = [
          /import.*vapid.*from.*['"](?!.*vapid-loader)/i,
          /vapid-helper/i,
          /getVapidPublicKey\s*\(/i,
          /loadVapidKey\s*\(/i,
        ];
        
        if (oldHelpers.some(r => r.test(content))) {
          die(`Unauthorized VAPID helper usage in ${relPath}. Use only ${ALLOWED_VAPID_LOADER}`);
        }
      }
    }
  }
}

if (fs.existsSync(srcDir)) {
  scanDirectory(srcDir, 'src');
  ok('Source scan: No hardcoded secrets or unauthorized VAPID helpers detected');
} else {
  warn('src/ directory not found - skipping source scan');
}

// ===== CHECK 5: Service Worker Bump Header (Optional) =====
console.log('\nðŸ“‹ Check 5: Service Worker version bump');
const swPath = path.join(publicDir, 'sw.js');
const swContent = fs.readFileSync(swPath, 'utf8');
const firstLine = swContent.split('\n')[0] || '';

if (!/^\/\/\s*sw-bump-/.test(firstLine)) {
  warn('Service Worker missing version bump header (// sw-bump-YYYY-MM-DD-NN). Recommended for tracking changes.');
} else {
  const version = firstLine.match(/sw-bump-([^\s]+)/)?.[1] || 'unknown';
  ok(`Service Worker: Version ${version}`);
}

// ===== CHECK 6: VAPID Loader Exists =====
console.log('\nðŸ“‹ Check 6: VAPID loader module');
const vapidLoaderPath = path.join(srcDir, 'lib', 'vapid-loader.ts');

if (!fs.existsSync(vapidLoaderPath)) {
  die('src/lib/vapid-loader.ts not found. This is the only authorized VAPID access point.');
}

ok('VAPID loader: src/lib/vapid-loader.ts exists');

// ===== ALL CHECKS PASSED =====
console.log('\n' + '='.repeat(60));
console.log('âœ… ALL PUSH GUARD CHECKS PASSED');
console.log('='.repeat(60));
console.log('\nðŸš€ Proceeding with build...\n');

process.exit(0);
