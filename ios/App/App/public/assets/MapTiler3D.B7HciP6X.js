const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index.BEQCqgv7.js","assets/three-vendor.B3e0mz6d.js","assets/react-vendor.CAU3V3le.js","assets/ui-vendor.CkkPodTS.js","assets/supabase-vendor.Be5pfGoK.js","assets/animation-vendor.BBMfCuXy.js","assets/map-vendor.DP0KRNIP.js","assets/stripe-vendor.DYHkqekj.js","assets/router-vendor.opNAzTki.js","assets/index.D6lIHvJk.css"])))=>i.map(i=>d[i]);
import { j as jsxRuntimeExports, g as useControllableState, h as createContextScope, k as createCollection, n as composeEventHandlers, m as Primitive, l as useComposedRefs, f as useDirection, E as useSize } from './ui-vendor.CkkPodTS.js';
import { e as commonjsGlobal, r as reactExports, c as React, a as reactDomExports } from './react-vendor.CAU3V3le.js';
import { c as createLucideIcon, a as useAuthContext, b as useCashbackWallet, d as useM1UnitsRealtime, L as Lock, s as supabase, e as ue, f as showInsufficientM1UToast, g as useBuzzApi, n as notifyShadowContext, B as Button, X, T as Target, h as emitSubscribed, i as emitError, j as getCurrentWeekOfYear, k as useUnifiedAuth, l as useLocalStorage, R as Radio, Z as Zap, E as Eye, S as Sparkles, G as Gift, m as Shield, o as TriangleAlert, p as useDebugFlag, q as useBuzzMapPricingNew, M as MapPin, I as Input, r as Textarea, U as Users, C as Circle, F as FileText, t as ChevronUp, v as Card, w as Settings, x as RefreshCw, y as Crosshair, P as Plus, z as Trash2, A as CardHeader, D as Swords, H as CardTitle, J as Clock, K as ChevronDown, N as CardDescription, O as CardContent, Q as Activity, V as ScrollArea, W as Select, Y as SelectTrigger, _ as SelectValue, $ as SelectContent, a0 as SelectItem, a1 as clamp, a2 as usePrevious, a3 as cn, a4 as LoaderCircle, a5 as Badge, a6 as useToast, a7 as Label, a8 as Search, a9 as STAKE_TYPES, aa as STAKE_PERCENTS, ab as Coins, ac as Tabs, ad as TabsList, ae as TabsTrigger, af as TabsContent, ag as ShoppingCart, ah as useSafeNavigate, ai as ExternalLink, aj as acceptBattle, ak as CircleCheckBig, al as CircleAlert, am as Trophy, an as CircleX, ao as Star, ap as CopyJsonButton, aq as useMapGlitchEffect, ar as useGeolocation, as as useProfileImage, at as useNotificationManager, au as usePerformanceSettings, av as UnifiedHeader, aw as NotificationsBanner, ax as Compass, ay as RotateCcw, az as M1UPill, aA as BottomNavigation } from './index.BEQCqgv7.js';
import { m as motion, A as AnimatePresence } from './animation-vendor.BBMfCuXy.js';
import { _ as __vitePreload } from './three-vendor.B3e0mz6d.js';
import './supabase-vendor.Be5pfGoK.js';
import './map-vendor.DP0KRNIP.js';
import './stripe-vendor.DYHkqekj.js';
import './router-vendor.opNAzTki.js';

/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */


const Layers = createLucideIcon("Layers", [
  [
    "path",
    {
      d: "m12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83Z",
      key: "8b97xw"
    }
  ],
  ["path", { d: "m22 17.65-9.17 4.16a2 2 0 0 1-1.66 0L2 17.65", key: "dd6zsq" }],
  ["path", { d: "m22 12.65-9.17 4.16a2 2 0 0 1-1.66 0L2 12.65", key: "ep9fru" }]
]);

/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */


const LockOpen = createLucideIcon("LockOpen", [
  ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2", key: "1w4ew1" }],
  ["path", { d: "M7 11V7a5 5 0 0 1 9.9-1", key: "1mm8w8" }]
]);

/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */


const Navigation = createLucideIcon("Navigation", [
  ["polygon", { points: "3 11 22 2 13 21 11 13 3 11", key: "1ltx0t" }]
]);

/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */


const Package = createLucideIcon("Package", [
  [
    "path",
    {
      d: "M11 21.73a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73z",
      key: "1a0edw"
    }
  ],
  ["path", { d: "M12 22V12", key: "d0xqtd" }],
  ["path", { d: "m3.3 7 7.703 4.734a2 2 0 0 0 1.994 0L20.7 7", key: "yx3hmr" }],
  ["path", { d: "m7.5 4.27 9 5.15", key: "1c824w" }]
]);

/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */


const ShoppingBag = createLucideIcon("ShoppingBag", [
  ["path", { d: "M6 2 3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4Z", key: "hou9p0" }],
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M16 10a4 4 0 0 1-8 0", key: "1ltviw" }]
]);

var maplibreGl = {exports: {}};

/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.13.0/LICENSE.txt
 */

(function (module, exports$1) {
	(function(global, factory) {
	  module.exports = factory() ;
	})(commonjsGlobal, function() {
	  var maplibregl = {};
	  var modules = {};
	  function define2(moduleName, _dependencies, moduleFactory) {
	    modules[moduleName] = moduleFactory;
	    if (moduleName !== "index") {
	      return;
	    }
	    var workerBundleString = "var sharedModule = {}; (" + modules.shared + ")(sharedModule); (" + modules.worker + ")(sharedModule);";
	    var sharedModule = {};
	    modules.shared(sharedModule);
	    modules.index(maplibregl, sharedModule);
	    if (typeof window !== "undefined") {
	      maplibregl.setWorkerUrl(window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" })));
	    }
	    return maplibregl;
	  }
	  define2("shared", ["exports"], function(e) {
	    function t(e2, t2, r2, n2) {
	      return new (r2 || (r2 = Promise))(function(i2, s2) {
	        function o2(e3) {
	          try {
	            l2(n2.next(e3));
	          } catch (e4) {
	            s2(e4);
	          }
	        }
	        function a2(e3) {
	          try {
	            l2(n2.throw(e3));
	          } catch (e4) {
	            s2(e4);
	          }
	        }
	        function l2(e3) {
	          var t3;
	          e3.done ? i2(e3.value) : (t3 = e3.value, t3 instanceof r2 ? t3 : new r2(function(e4) {
	            e4(t3);
	          })).then(o2, a2);
	        }
	        l2((n2 = n2.apply(e2, t2 || [])).next());
	      });
	    }
	    function r(e2, t2) {
	      this.x = e2, this.y = t2;
	    }
	    function n(e2) {
	      return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
	    }
	    var i, s;
	    "function" == typeof SuppressedError && SuppressedError, r.prototype = { clone() {
	      return new r(this.x, this.y);
	    }, add(e2) {
	      return this.clone()._add(e2);
	    }, sub(e2) {
	      return this.clone()._sub(e2);
	    }, multByPoint(e2) {
	      return this.clone()._multByPoint(e2);
	    }, divByPoint(e2) {
	      return this.clone()._divByPoint(e2);
	    }, mult(e2) {
	      return this.clone()._mult(e2);
	    }, div(e2) {
	      return this.clone()._div(e2);
	    }, rotate(e2) {
	      return this.clone()._rotate(e2);
	    }, rotateAround(e2, t2) {
	      return this.clone()._rotateAround(e2, t2);
	    }, matMult(e2) {
	      return this.clone()._matMult(e2);
	    }, unit() {
	      return this.clone()._unit();
	    }, perp() {
	      return this.clone()._perp();
	    }, round() {
	      return this.clone()._round();
	    }, mag() {
	      return Math.sqrt(this.x * this.x + this.y * this.y);
	    }, equals(e2) {
	      return this.x === e2.x && this.y === e2.y;
	    }, dist(e2) {
	      return Math.sqrt(this.distSqr(e2));
	    }, distSqr(e2) {
	      const t2 = e2.x - this.x, r2 = e2.y - this.y;
	      return t2 * t2 + r2 * r2;
	    }, angle() {
	      return Math.atan2(this.y, this.x);
	    }, angleTo(e2) {
	      return Math.atan2(this.y - e2.y, this.x - e2.x);
	    }, angleWith(e2) {
	      return this.angleWithSep(e2.x, e2.y);
	    }, angleWithSep(e2, t2) {
	      return Math.atan2(this.x * t2 - this.y * e2, this.x * e2 + this.y * t2);
	    }, _matMult(e2) {
	      const t2 = e2[2] * this.x + e2[3] * this.y;
	      return this.x = e2[0] * this.x + e2[1] * this.y, this.y = t2, this;
	    }, _add(e2) {
	      return this.x += e2.x, this.y += e2.y, this;
	    }, _sub(e2) {
	      return this.x -= e2.x, this.y -= e2.y, this;
	    }, _mult(e2) {
	      return this.x *= e2, this.y *= e2, this;
	    }, _div(e2) {
	      return this.x /= e2, this.y /= e2, this;
	    }, _multByPoint(e2) {
	      return this.x *= e2.x, this.y *= e2.y, this;
	    }, _divByPoint(e2) {
	      return this.x /= e2.x, this.y /= e2.y, this;
	    }, _unit() {
	      return this._div(this.mag()), this;
	    }, _perp() {
	      const e2 = this.y;
	      return this.y = this.x, this.x = -e2, this;
	    }, _rotate(e2) {
	      const t2 = Math.cos(e2), r2 = Math.sin(e2), n2 = r2 * this.x + t2 * this.y;
	      return this.x = t2 * this.x - r2 * this.y, this.y = n2, this;
	    }, _rotateAround(e2, t2) {
	      const r2 = Math.cos(e2), n2 = Math.sin(e2), i2 = t2.y + n2 * (this.x - t2.x) + r2 * (this.y - t2.y);
	      return this.x = t2.x + r2 * (this.x - t2.x) - n2 * (this.y - t2.y), this.y = i2, this;
	    }, _round() {
	      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
	    }, constructor: r }, r.convert = function(e2) {
	      if (e2 instanceof r) return e2;
	      if (Array.isArray(e2)) return new r(+e2[0], +e2[1]);
	      if (void 0 !== e2.x && void 0 !== e2.y) return new r(+e2.x, +e2.y);
	      throw new Error("Expected [x, y] or {x, y} point format");
	    };
	    var o = function() {
	      if (s) return i;
	      function e2(e3, t2, r2, n2) {
	        this.cx = 3 * e3, this.bx = 3 * (r2 - e3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t2, this.by = 3 * (n2 - t2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e3, this.p1y = t2, this.p2x = r2, this.p2y = n2;
	      }
	      return s = 1, i = e2, e2.prototype = { sampleCurveX: function(e3) {
	        return ((this.ax * e3 + this.bx) * e3 + this.cx) * e3;
	      }, sampleCurveY: function(e3) {
	        return ((this.ay * e3 + this.by) * e3 + this.cy) * e3;
	      }, sampleCurveDerivativeX: function(e3) {
	        return (3 * this.ax * e3 + 2 * this.bx) * e3 + this.cx;
	      }, solveCurveX: function(e3, t2) {
	        if (void 0 === t2 && (t2 = 1e-6), e3 < 0) return 0;
	        if (e3 > 1) return 1;
	        for (var r2 = e3, n2 = 0; n2 < 8; n2++) {
	          var i2 = this.sampleCurveX(r2) - e3;
	          if (Math.abs(i2) < t2) return r2;
	          var s2 = this.sampleCurveDerivativeX(r2);
	          if (Math.abs(s2) < 1e-6) break;
	          r2 -= i2 / s2;
	        }
	        var o2 = 0, a2 = 1;
	        for (r2 = e3, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - e3) < t2)); n2++) e3 > i2 ? o2 = r2 : a2 = r2, r2 = 0.5 * (a2 - o2) + o2;
	        return r2;
	      }, solve: function(e3, t2) {
	        return this.sampleCurveY(this.solveCurveX(e3, t2));
	      } }, i;
	    }(), a = n(o);
	    let l, u;
	    function c() {
	      return null == l && (l = "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap), l;
	    }
	    function h() {
	      if (null == u && (u = false, c())) {
	        const e2 = 5, t2 = new OffscreenCanvas(e2, e2).getContext("2d", { willReadFrequently: true });
	        if (t2) {
	          for (let r3 = 0; r3 < e2 * e2; r3++) {
	            const n2 = 4 * r3;
	            t2.fillStyle = `rgb(${n2},${n2 + 1},${n2 + 2})`, t2.fillRect(r3 % e2, Math.floor(r3 / e2), 1, 1);
	          }
	          const r2 = t2.getImageData(0, 0, e2, e2).data;
	          for (let t3 = 0; t3 < e2 * e2 * 4; t3++) if (t3 % 4 != 3 && r2[t3] !== t3) {
	            u = true;
	            break;
	          }
	        }
	      }
	      return u || false;
	    }
	    var p = 1e-6, f = "undefined" != typeof Float32Array ? Float32Array : Array;
	    function d() {
	      var e2 = new f(9);
	      return f != Float32Array && (e2[1] = 0, e2[2] = 0, e2[3] = 0, e2[5] = 0, e2[6] = 0, e2[7] = 0), e2[0] = 1, e2[4] = 1, e2[8] = 1, e2;
	    }
	    function y(e2) {
	      return e2[0] = 1, e2[1] = 0, e2[2] = 0, e2[3] = 0, e2[4] = 0, e2[5] = 1, e2[6] = 0, e2[7] = 0, e2[8] = 0, e2[9] = 0, e2[10] = 1, e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0, e2[15] = 1, e2;
	    }
	    function m() {
	      var e2 = new f(3);
	      return f != Float32Array && (e2[0] = 0, e2[1] = 0, e2[2] = 0), e2;
	    }
	    function g(e2) {
	      var t2 = e2[0], r2 = e2[1], n2 = e2[2];
	      return Math.sqrt(t2 * t2 + r2 * r2 + n2 * n2);
	    }
	    function x(e2, t2, r2) {
	      var n2 = new f(3);
	      return n2[0] = e2, n2[1] = t2, n2[2] = r2, n2;
	    }
	    function v(e2, t2, r2) {
	      return e2[0] = t2[0] + r2[0], e2[1] = t2[1] + r2[1], e2[2] = t2[2] + r2[2], e2;
	    }
	    function b(e2, t2, r2) {
	      return e2[0] = t2[0] * r2, e2[1] = t2[1] * r2, e2[2] = t2[2] * r2, e2;
	    }
	    function w(e2, t2, r2) {
	      var n2 = t2[0], i2 = t2[1], s2 = t2[2], o2 = r2[0], a2 = r2[1], l2 = r2[2];
	      return e2[0] = i2 * l2 - s2 * a2, e2[1] = s2 * o2 - n2 * l2, e2[2] = n2 * a2 - i2 * o2, e2;
	    }
	    var _, S = g;
	    function A(e2, t2, r2) {
	      var n2 = t2[0], i2 = t2[1], s2 = t2[2], o2 = t2[3];
	      return e2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12] * o2, e2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13] * o2, e2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14] * o2, e2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15] * o2, e2;
	    }
	    function T() {
	      var e2 = new f(4);
	      return f != Float32Array && (e2[0] = 0, e2[1] = 0, e2[2] = 0), e2[3] = 1, e2;
	    }
	    function I(e2, t2, r2, n2) {
	      var i2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "zyx", s2 = Math.PI / 360;
	      t2 *= s2, n2 *= s2, r2 *= s2;
	      var o2 = Math.sin(t2), a2 = Math.cos(t2), l2 = Math.sin(r2), u2 = Math.cos(r2), c2 = Math.sin(n2), h2 = Math.cos(n2);
	      switch (i2) {
	        case "xyz":
	          e2[0] = o2 * u2 * h2 + a2 * l2 * c2, e2[1] = a2 * l2 * h2 - o2 * u2 * c2, e2[2] = a2 * u2 * c2 + o2 * l2 * h2, e2[3] = a2 * u2 * h2 - o2 * l2 * c2;
	          break;
	        case "xzy":
	          e2[0] = o2 * u2 * h2 - a2 * l2 * c2, e2[1] = a2 * l2 * h2 - o2 * u2 * c2, e2[2] = a2 * u2 * c2 + o2 * l2 * h2, e2[3] = a2 * u2 * h2 + o2 * l2 * c2;
	          break;
	        case "yxz":
	          e2[0] = o2 * u2 * h2 + a2 * l2 * c2, e2[1] = a2 * l2 * h2 - o2 * u2 * c2, e2[2] = a2 * u2 * c2 - o2 * l2 * h2, e2[3] = a2 * u2 * h2 + o2 * l2 * c2;
	          break;
	        case "yzx":
	          e2[0] = o2 * u2 * h2 + a2 * l2 * c2, e2[1] = a2 * l2 * h2 + o2 * u2 * c2, e2[2] = a2 * u2 * c2 - o2 * l2 * h2, e2[3] = a2 * u2 * h2 - o2 * l2 * c2;
	          break;
	        case "zxy":
	          e2[0] = o2 * u2 * h2 - a2 * l2 * c2, e2[1] = a2 * l2 * h2 + o2 * u2 * c2, e2[2] = a2 * u2 * c2 + o2 * l2 * h2, e2[3] = a2 * u2 * h2 - o2 * l2 * c2;
	          break;
	        case "zyx":
	          e2[0] = o2 * u2 * h2 - a2 * l2 * c2, e2[1] = a2 * l2 * h2 + o2 * u2 * c2, e2[2] = a2 * u2 * c2 - o2 * l2 * h2, e2[3] = a2 * u2 * h2 + o2 * l2 * c2;
	          break;
	        default:
	          throw new Error("Unknown angle order " + i2);
	      }
	      return e2;
	    }
	    function E() {
	      var e2 = new f(2);
	      return f != Float32Array && (e2[0] = 0, e2[1] = 0), e2;
	    }
	    function M(e2, t2) {
	      var r2 = new f(2);
	      return r2[0] = e2, r2[1] = t2, r2;
	    }
	    m(), _ = new f(4), f != Float32Array && (_[0] = 0, _[1] = 0, _[2] = 0, _[3] = 0), m(), x(1, 0, 0), x(0, 1, 0), T(), T(), d(), E();
	    const k = 8192;
	    function F(e2, t2, r2) {
	      return t2 * (k / (e2.tileSize * Math.pow(2, r2 - e2.tileID.overscaledZ)));
	    }
	    function D(e2, t2) {
	      return (e2 % t2 + t2) % t2;
	    }
	    function P(e2, t2, r2) {
	      return e2 * (1 - r2) + t2 * r2;
	    }
	    function B(e2) {
	      if (e2 <= 0) return 0;
	      if (e2 >= 1) return 1;
	      const t2 = e2 * e2, r2 = t2 * e2;
	      return 4 * (e2 < 0.5 ? r2 : 3 * (e2 - t2) + r2 - 0.75);
	    }
	    function z(e2, t2, r2, n2) {
	      const i2 = new a(e2, t2, r2, n2);
	      return (e3) => i2.solve(e3);
	    }
	    const V = z(0.25, 0.1, 0.25, 1);
	    function C(e2, t2, r2) {
	      return Math.min(r2, Math.max(t2, e2));
	    }
	    function L(e2, t2, r2) {
	      const n2 = r2 - t2, i2 = ((e2 - t2) % n2 + n2) % n2 + t2;
	      return i2 === t2 ? r2 : i2;
	    }
	    function O(e2, ...t2) {
	      for (const r2 of t2) for (const t3 in r2) e2[t3] = r2[t3];
	      return e2;
	    }
	    let R = 1;
	    function N(e2, t2, r2) {
	      const n2 = {};
	      for (const r3 in e2) n2[r3] = t2.call(this, e2[r3], r3, e2);
	      return n2;
	    }
	    function $(e2, t2, r2) {
	      const n2 = {};
	      for (const r3 in e2) t2.call(this, e2[r3], r3, e2) && (n2[r3] = e2[r3]);
	      return n2;
	    }
	    function U(e2) {
	      return Array.isArray(e2) ? e2.map(U) : "object" == typeof e2 && e2 ? N(e2, U) : e2;
	    }
	    const q = {};
	    function j(e2) {
	      q[e2] || ("undefined" != typeof console && console.warn(e2), q[e2] = true);
	    }
	    function G(e2, t2, r2) {
	      return (r2.y - e2.y) * (t2.x - e2.x) > (t2.y - e2.y) * (r2.x - e2.x);
	    }
	    function X(e2) {
	      return "undefined" != typeof WorkerGlobalScope && void 0 !== e2 && e2 instanceof WorkerGlobalScope;
	    }
	    let Y = null;
	    function Z(e2) {
	      return "undefined" != typeof ImageBitmap && e2 instanceof ImageBitmap;
	    }
	    const H = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
	    function K(e2, r2, n2, i2, s2) {
	      return t(this, void 0, void 0, function* () {
	        if ("undefined" == typeof VideoFrame) throw new Error("VideoFrame not supported");
	        const t2 = new VideoFrame(e2, { timestamp: 0 });
	        try {
	          const o2 = null == t2 ? void 0 : t2.format;
	          if (!o2 || !o2.startsWith("BGR") && !o2.startsWith("RGB")) throw new Error(`Unrecognized format ${o2}`);
	          const a2 = o2.startsWith("BGR"), l2 = new Uint8ClampedArray(i2 * s2 * 4);
	          if (yield t2.copyTo(l2, function(e3, t3, r3, n3, i3) {
	            const s3 = 4 * Math.max(-t3, 0), o3 = (Math.max(0, r3) - r3) * n3 * 4 + s3, a3 = 4 * n3, l3 = Math.max(0, t3), u2 = Math.max(0, r3);
	            return { rect: { x: l3, y: u2, width: Math.min(e3.width, t3 + n3) - l3, height: Math.min(e3.height, r3 + i3) - u2 }, layout: [{ offset: o3, stride: a3 }] };
	          }(e2, r2, n2, i2, s2)), a2) for (let e3 = 0; e3 < l2.length; e3 += 4) {
	            const t3 = l2[e3];
	            l2[e3] = l2[e3 + 2], l2[e3 + 2] = t3;
	          }
	          return l2;
	        } finally {
	          t2.close();
	        }
	      });
	    }
	    let W, J;
	    function Q(e2, t2, r2, n2) {
	      return e2.addEventListener(t2, r2, n2), { unsubscribe: () => {
	        e2.removeEventListener(t2, r2, n2);
	      } };
	    }
	    function ee(e2) {
	      return e2 * Math.PI / 180;
	    }
	    function te(e2) {
	      return e2 / Math.PI * 180;
	    }
	    const re = { touchstart: true, touchmove: true, touchmoveWindow: true, touchend: true, touchcancel: true }, ne = { dblclick: true, click: true, mouseover: true, mouseout: true, mousedown: true, mousemove: true, mousemoveWindow: true, mouseup: true, mouseupWindow: true, contextmenu: true, wheel: true }, ie = "AbortError";
	    function se() {
	      return new Error(ie);
	    }
	    const oe = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
	    function ae(e2) {
	      return oe.REGISTERED_PROTOCOLS[e2.substring(0, e2.indexOf("://"))];
	    }
	    const le = "global-dispatcher";
	    class ue extends Error {
	      constructor(e2, t2, r2, n2) {
	        super(`AJAXError: ${t2} (${e2}): ${r2}`), this.status = e2, this.statusText = t2, this.url = r2, this.body = n2;
	      }
	    }
	    const ce = () => X(self) ? self.worker && self.worker.referrer : ("blob:" === window.location.protocol ? window.parent : window).location.href, he = function(e2, r2) {
	      if (/:\/\//.test(e2.url) && !/^https?:|^file:/.test(e2.url)) {
	        const t2 = ae(e2.url);
	        if (t2) return t2(e2, r2);
	        if (X(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: e2, targetMapId: le }, r2);
	      }
	      if (!(/^file:/.test(n2 = e2.url) || /^file:/.test(ce()) && !/^\w+:/.test(n2))) {
	        if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(e3, r3) {
	          return t(this, void 0, void 0, function* () {
	            const t2 = new Request(e3.url, { method: e3.method || "GET", body: e3.body, credentials: e3.credentials, headers: e3.headers, cache: e3.cache, referrer: ce(), signal: r3.signal });
	            let n3, i2;
	            "json" !== e3.type || t2.headers.has("Accept") || t2.headers.set("Accept", "application/json");
	            try {
	              n3 = yield fetch(t2);
	            } catch (t3) {
	              throw new ue(0, t3.message, e3.url, new Blob());
	            }
	            if (!n3.ok) {
	              const t3 = yield n3.blob();
	              throw new ue(n3.status, n3.statusText, e3.url, t3);
	            }
	            i2 = "arrayBuffer" === e3.type || "image" === e3.type ? n3.arrayBuffer() : "json" === e3.type ? n3.json() : n3.text();
	            const s2 = yield i2;
	            if (r3.signal.aborted) throw se();
	            return { data: s2, cacheControl: n3.headers.get("Cache-Control"), expires: n3.headers.get("Expires") };
	          });
	        }(e2, r2);
	        if (X(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: e2, mustQueue: true, targetMapId: le }, r2);
	      }
	      var n2;
	      return function(e3, t2) {
	        return new Promise((r3, n3) => {
	          var i2;
	          const s2 = new XMLHttpRequest();
	          s2.open(e3.method || "GET", e3.url, true), "arrayBuffer" !== e3.type && "image" !== e3.type || (s2.responseType = "arraybuffer");
	          for (const t3 in e3.headers) s2.setRequestHeader(t3, e3.headers[t3]);
	          "json" === e3.type && (s2.responseType = "text", (null === (i2 = e3.headers) || void 0 === i2 ? void 0 : i2.Accept) || s2.setRequestHeader("Accept", "application/json")), s2.withCredentials = "include" === e3.credentials, s2.onerror = () => {
	            n3(new Error(s2.statusText));
	          }, s2.onload = () => {
	            if (!t2.signal.aborted) if ((s2.status >= 200 && s2.status < 300 || 0 === s2.status) && null !== s2.response) {
	              let t3 = s2.response;
	              if ("json" === e3.type) try {
	                t3 = JSON.parse(s2.response);
	              } catch (e4) {
	                return void n3(e4);
	              }
	              r3({ data: t3, cacheControl: s2.getResponseHeader("Cache-Control"), expires: s2.getResponseHeader("Expires") });
	            } else {
	              const t3 = new Blob([s2.response], { type: s2.getResponseHeader("Content-Type") });
	              n3(new ue(s2.status, s2.statusText, e3.url, t3));
	            }
	          }, t2.signal.addEventListener("abort", () => {
	            s2.abort(), n3(se());
	          }), s2.send(e3.body);
	        });
	      }(e2, r2);
	    };
	    function pe(e2) {
	      if (!e2 || e2.indexOf("://") <= 0 || 0 === e2.indexOf("data:image/") || 0 === e2.indexOf("blob:")) return true;
	      const t2 = new URL(e2), r2 = window.location;
	      return t2.protocol === r2.protocol && t2.host === r2.host;
	    }
	    function fe(e2, t2, r2) {
	      r2[e2] && -1 !== r2[e2].indexOf(t2) || (r2[e2] = r2[e2] || [], r2[e2].push(t2));
	    }
	    function de(e2, t2, r2) {
	      if (r2 && r2[e2]) {
	        const n2 = r2[e2].indexOf(t2);
	        -1 !== n2 && r2[e2].splice(n2, 1);
	      }
	    }
	    class ye {
	      constructor(e2, t2 = {}) {
	        O(this, t2), this.type = e2;
	      }
	    }
	    class me extends ye {
	      constructor(e2, t2 = {}) {
	        super("error", O({ error: e2 }, t2));
	      }
	    }
	    class ge {
	      on(e2, t2) {
	        return this._listeners = this._listeners || {}, fe(e2, t2, this._listeners), { unsubscribe: () => {
	          this.off(e2, t2);
	        } };
	      }
	      off(e2, t2) {
	        return de(e2, t2, this._listeners), de(e2, t2, this._oneTimeListeners), this;
	      }
	      once(e2, t2) {
	        return t2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, fe(e2, t2, this._oneTimeListeners), this) : new Promise((t3) => this.once(e2, t3));
	      }
	      fire(e2, t2) {
	        "string" == typeof e2 && (e2 = new ye(e2, t2 || {}));
	        const r2 = e2.type;
	        if (this.listens(r2)) {
	          e2.target = this;
	          const t3 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : [];
	          for (const r3 of t3) r3.call(this, e2);
	          const n2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : [];
	          for (const t4 of n2) de(r2, t4, this._oneTimeListeners), t4.call(this, e2);
	          const i2 = this._eventedParent;
	          i2 && (O(e2, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i2.fire(e2));
	        } else e2 instanceof me && console.error(e2.error);
	        return this;
	      }
	      listens(e2) {
	        return this._listeners && this._listeners[e2] && this._listeners[e2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e2] && this._oneTimeListeners[e2].length > 0 || this._eventedParent && this._eventedParent.listens(e2);
	      }
	      setEventedParent(e2, t2) {
	        return this._eventedParent = e2, this._eventedParentData = t2, this;
	      }
	    }
	    var xe = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, "font-faces": { type: "array", value: "fontFaces" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, encoding: { type: "enum", values: { mvt: {}, mlt: {} }, default: "mvt" }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, "color-relief": {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_color-relief": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: false, expression: { interpolated: true, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, "paint_color-relief": { "color-relief-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "color-relief-color": { type: "color", transition: false, expression: { interpolated: true, parameters: ["elevation"] }, "property-type": "color-ramp" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
	    const ve = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
	    function be(e2, t2) {
	      const r2 = {};
	      for (const t3 in e2) "ref" !== t3 && (r2[t3] = e2[t3]);
	      return ve.forEach((e3) => {
	        e3 in t2 && (r2[e3] = t2[e3]);
	      }), r2;
	    }
	    function we(e2, t2) {
	      if (Array.isArray(e2)) {
	        if (!Array.isArray(t2) || e2.length !== t2.length) return false;
	        for (let r2 = 0; r2 < e2.length; r2++) if (!we(e2[r2], t2[r2])) return false;
	        return true;
	      }
	      if ("object" == typeof e2 && null !== e2 && null !== t2) {
	        if ("object" != typeof t2) return false;
	        if (Object.keys(e2).length !== Object.keys(t2).length) return false;
	        for (const r2 in e2) if (!we(e2[r2], t2[r2])) return false;
	        return true;
	      }
	      return e2 === t2;
	    }
	    function _e(e2, t2) {
	      e2.push(t2);
	    }
	    function Se(e2, t2, r2) {
	      _e(r2, { command: "addSource", args: [e2, t2[e2]] });
	    }
	    function Ae(e2, t2, r2) {
	      _e(t2, { command: "removeSource", args: [e2] }), r2[e2] = true;
	    }
	    function Te(e2, t2, r2, n2) {
	      Ae(e2, r2, n2), Se(e2, t2, r2);
	    }
	    function Ie(e2, t2, r2) {
	      let n2;
	      for (n2 in e2[r2]) if (Object.prototype.hasOwnProperty.call(e2[r2], n2) && "data" !== n2 && !we(e2[r2][n2], t2[r2][n2])) return false;
	      for (n2 in t2[r2]) if (Object.prototype.hasOwnProperty.call(t2[r2], n2) && "data" !== n2 && !we(e2[r2][n2], t2[r2][n2])) return false;
	      return true;
	    }
	    function Ee(e2, t2, r2, n2, i2, s2) {
	      e2 = e2 || {}, t2 = t2 || {};
	      for (const o2 in e2) Object.prototype.hasOwnProperty.call(e2, o2) && (we(e2[o2], t2[o2]) || r2.push({ command: s2, args: [n2, o2, t2[o2], i2] }));
	      for (const o2 in t2) Object.prototype.hasOwnProperty.call(t2, o2) && !Object.prototype.hasOwnProperty.call(e2, o2) && (we(e2[o2], t2[o2]) || r2.push({ command: s2, args: [n2, o2, t2[o2], i2] }));
	    }
	    function Me(e2) {
	      return e2.id;
	    }
	    function ke(e2, t2) {
	      return e2[t2.id] = t2, e2;
	    }
	    class Fe {
	      constructor(e2, t2, r2, n2) {
	        this.message = (e2 ? `${e2}: ` : "") + r2, n2 && (this.identifier = n2), null != t2 && t2.__line__ && (this.line = t2.__line__);
	      }
	    }
	    function De(e2, ...t2) {
	      for (const r2 of t2) for (const t3 in r2) e2[t3] = r2[t3];
	      return e2;
	    }
	    class Pe extends Error {
	      constructor(e2, t2) {
	        super(t2), this.message = t2, this.key = e2;
	      }
	    }
	    class Be {
	      constructor(e2, t2 = []) {
	        this.parent = e2, this.bindings = {};
	        for (const [e3, r2] of t2) this.bindings[e3] = r2;
	      }
	      concat(e2) {
	        return new Be(this, e2);
	      }
	      get(e2) {
	        if (this.bindings[e2]) return this.bindings[e2];
	        if (this.parent) return this.parent.get(e2);
	        throw new Error(`${e2} not found in scope.`);
	      }
	      has(e2) {
	        return !!this.bindings[e2] || !!this.parent && this.parent.has(e2);
	      }
	    }
	    const ze = { kind: "null" }, Ve = { kind: "number" }, Ce = { kind: "string" }, Le = { kind: "boolean" }, Oe = { kind: "color" }, Re = { kind: "projectionDefinition" }, Ne = { kind: "object" }, $e = { kind: "value" }, Ue = { kind: "collator" }, qe = { kind: "formatted" }, je = { kind: "padding" }, Ge = { kind: "colorArray" }, Xe = { kind: "numberArray" }, Ye = { kind: "resolvedImage" }, Ze = { kind: "variableAnchorOffsetCollection" };
	    function He(e2, t2) {
	      return { kind: "array", itemType: e2, N: t2 };
	    }
	    function Ke(e2) {
	      if ("array" === e2.kind) {
	        const t2 = Ke(e2.itemType);
	        return "number" == typeof e2.N ? `array<${t2}, ${e2.N}>` : "value" === e2.itemType.kind ? "array" : `array<${t2}>`;
	      }
	      return e2.kind;
	    }
	    const We = [ze, Ve, Ce, Le, Oe, Re, qe, Ne, He($e), je, Xe, Ge, Ye, Ze];
	    function Je(e2, t2) {
	      if ("error" === t2.kind) return null;
	      if ("array" === e2.kind) {
	        if ("array" === t2.kind && (0 === t2.N && "value" === t2.itemType.kind || !Je(e2.itemType, t2.itemType)) && ("number" != typeof e2.N || e2.N === t2.N)) return null;
	      } else {
	        if (e2.kind === t2.kind) return null;
	        if ("value" === e2.kind) {
	          for (const e3 of We) if (!Je(e3, t2)) return null;
	        }
	      }
	      return `Expected ${Ke(e2)} but found ${Ke(t2)} instead.`;
	    }
	    function Qe(e2, t2) {
	      return t2.some((t3) => t3.kind === e2.kind);
	    }
	    function et(e2, t2) {
	      return t2.some((t3) => "null" === t3 ? null === e2 : "array" === t3 ? Array.isArray(e2) : "object" === t3 ? e2 && !Array.isArray(e2) && "object" == typeof e2 : t3 === typeof e2);
	    }
	    function tt(e2, t2) {
	      return "array" === e2.kind && "array" === t2.kind ? e2.itemType.kind === t2.itemType.kind && "number" == typeof e2.N : e2.kind === t2.kind;
	    }
	    const rt = 0.96422, nt = 0.82521, it = 4 / 29, st = 6 / 29, ot = 3 * st * st, at = st * st * st, lt = Math.PI / 180, ut = 180 / Math.PI;
	    function ct(e2) {
	      return (e2 %= 360) < 0 && (e2 += 360), e2;
	    }
	    function ht([e2, t2, r2, n2]) {
	      let i2, s2;
	      const o2 = ft((0.2225045 * (e2 = pt(e2)) + 0.7168786 * (t2 = pt(t2)) + 0.0606169 * (r2 = pt(r2))) / 1);
	      e2 === t2 && t2 === r2 ? i2 = s2 = o2 : (i2 = ft((0.4360747 * e2 + 0.3850649 * t2 + 0.1430804 * r2) / rt), s2 = ft((0.0139322 * e2 + 0.0971045 * t2 + 0.7141733 * r2) / nt));
	      const a2 = 116 * o2 - 16;
	      return [a2 < 0 ? 0 : a2, 500 * (i2 - o2), 200 * (o2 - s2), n2];
	    }
	    function pt(e2) {
	      return e2 <= 0.04045 ? e2 / 12.92 : Math.pow((e2 + 0.055) / 1.055, 2.4);
	    }
	    function ft(e2) {
	      return e2 > at ? Math.pow(e2, 1 / 3) : e2 / ot + it;
	    }
	    function dt([e2, t2, r2, n2]) {
	      let i2 = (e2 + 16) / 116, s2 = isNaN(t2) ? i2 : i2 + t2 / 500, o2 = isNaN(r2) ? i2 : i2 - r2 / 200;
	      return i2 = 1 * mt(i2), s2 = rt * mt(s2), o2 = nt * mt(o2), [yt(3.1338561 * s2 - 1.6168667 * i2 - 0.4906146 * o2), yt(-0.9787684 * s2 + 1.9161415 * i2 + 0.033454 * o2), yt(0.0719453 * s2 - 0.2289914 * i2 + 1.4052427 * o2), n2];
	    }
	    function yt(e2) {
	      return (e2 = e2 <= 304e-5 ? 12.92 * e2 : 1.055 * Math.pow(e2, 1 / 2.4) - 0.055) < 0 ? 0 : e2 > 1 ? 1 : e2;
	    }
	    function mt(e2) {
	      return e2 > st ? e2 * e2 * e2 : ot * (e2 - it);
	    }
	    const gt = Object.hasOwn || function(e2, t2) {
	      return Object.prototype.hasOwnProperty.call(e2, t2);
	    };
	    function xt(e2, t2) {
	      return gt(e2, t2) ? e2[t2] : void 0;
	    }
	    function vt(e2) {
	      return parseInt(e2.padEnd(2, e2), 16) / 255;
	    }
	    function bt(e2, t2) {
	      return wt(t2 ? e2 / 100 : e2, 0, 1);
	    }
	    function wt(e2, t2, r2) {
	      return Math.min(Math.max(t2, e2), r2);
	    }
	    function _t(e2) {
	      return !e2.some(Number.isNaN);
	    }
	    const St = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
	    function At(e2, t2, r2) {
	      return e2 + r2 * (t2 - e2);
	    }
	    function Tt(e2, t2, r2) {
	      return e2.map((e3, n2) => At(e3, t2[n2], r2));
	    }
	    class It {
	      constructor(e2, t2, r2, n2 = 1, i2 = true) {
	        this.r = e2, this.g = t2, this.b = r2, this.a = n2, i2 || (this.r *= n2, this.g *= n2, this.b *= n2, n2 || this.overwriteGetter("rgb", [e2, t2, r2, n2]));
	      }
	      static parse(e2) {
	        if (e2 instanceof It) return e2;
	        if ("string" != typeof e2) return;
	        const t2 = function(e3) {
	          if ("transparent" === (e3 = e3.toLowerCase().trim())) return [0, 0, 0, 0];
	          const t3 = xt(St, e3);
	          if (t3) {
	            const [e4, r3, n2] = t3;
	            return [e4 / 255, r3 / 255, n2 / 255, 1];
	          }
	          if (e3.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(e3)) {
	            const t4 = e3.length < 6 ? 1 : 2;
	            let r3 = 1;
	            return [vt(e3.slice(r3, r3 += t4)), vt(e3.slice(r3, r3 += t4)), vt(e3.slice(r3, r3 += t4)), vt(e3.slice(r3, r3 + t4) || "ff")];
	          }
	          if (e3.startsWith("rgb")) {
	            const t4 = e3.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
	            if (t4) {
	              const [e4, r3, n2, i2, s2, o2, a2, l2, u2, c2, h2, p2] = t4, f2 = [i2 || " ", a2 || " ", c2].join("");
	              if ("  " === f2 || "  /" === f2 || ",," === f2 || ",,," === f2) {
	                const e5 = [n2, o2, u2].join(""), t5 = "%%%" === e5 ? 100 : "" === e5 ? 255 : 0;
	                if (t5) {
	                  const e6 = [wt(+r3 / t5, 0, 1), wt(+s2 / t5, 0, 1), wt(+l2 / t5, 0, 1), h2 ? bt(+h2, p2) : 1];
	                  if (_t(e6)) return e6;
	                }
	              }
	              return;
	            }
	          }
	          const r2 = e3.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
	          if (r2) {
	            const [e4, t4, n2, i2, s2, o2, a2, l2, u2] = r2, c2 = [n2 || " ", s2 || " ", a2].join("");
	            if ("  " === c2 || "  /" === c2 || ",," === c2 || ",,," === c2) {
	              const e5 = [+t4, wt(+i2, 0, 100), wt(+o2, 0, 100), l2 ? bt(+l2, u2) : 1];
	              if (_t(e5)) return function([e6, t5, r3, n3]) {
	                function i3(n4) {
	                  const i4 = (n4 + e6 / 30) % 12, s3 = t5 * Math.min(r3, 1 - r3);
	                  return r3 - s3 * Math.max(-1, Math.min(i4 - 3, 9 - i4, 1));
	                }
	                return e6 = ct(e6), t5 /= 100, r3 /= 100, [i3(0), i3(8), i3(4), n3];
	              }(e5);
	            }
	          }
	        }(e2);
	        return t2 ? new It(...t2, false) : void 0;
	      }
	      get rgb() {
	        const { r: e2, g: t2, b: r2, a: n2 } = this, i2 = n2 || 1 / 0;
	        return this.overwriteGetter("rgb", [e2 / i2, t2 / i2, r2 / i2, n2]);
	      }
	      get hcl() {
	        return this.overwriteGetter("hcl", function(e2) {
	          const [t2, r2, n2, i2] = ht(e2), s2 = Math.sqrt(r2 * r2 + n2 * n2);
	          return [Math.round(1e4 * s2) ? ct(Math.atan2(n2, r2) * ut) : NaN, s2, t2, i2];
	        }(this.rgb));
	      }
	      get lab() {
	        return this.overwriteGetter("lab", ht(this.rgb));
	      }
	      overwriteGetter(e2, t2) {
	        return Object.defineProperty(this, e2, { value: t2 }), t2;
	      }
	      toString() {
	        const [e2, t2, r2, n2] = this.rgb;
	        return `rgba(${[e2, t2, r2].map((e3) => Math.round(255 * e3)).join(",")},${n2})`;
	      }
	      static interpolate(e2, t2, r2, n2 = "rgb") {
	        switch (n2) {
	          case "rgb": {
	            const [n3, i2, s2, o2] = Tt(e2.rgb, t2.rgb, r2);
	            return new It(n3, i2, s2, o2, false);
	          }
	          case "hcl": {
	            const [n3, i2, s2, o2] = e2.hcl, [a2, l2, u2, c2] = t2.hcl;
	            let h2, p2;
	            if (isNaN(n3) || isNaN(a2)) isNaN(n3) ? isNaN(a2) ? h2 = NaN : (h2 = a2, 1 !== s2 && 0 !== s2 || (p2 = l2)) : (h2 = n3, 1 !== u2 && 0 !== u2 || (p2 = i2));
	            else {
	              let e3 = a2 - n3;
	              a2 > n3 && e3 > 180 ? e3 -= 360 : a2 < n3 && n3 - a2 > 180 && (e3 += 360), h2 = n3 + r2 * e3;
	            }
	            const [f2, d2, y2, m2] = function([e3, t3, r3, n4]) {
	              return e3 = isNaN(e3) ? 0 : e3 * lt, dt([r3, Math.cos(e3) * t3, Math.sin(e3) * t3, n4]);
	            }([h2, null != p2 ? p2 : At(i2, l2, r2), At(s2, u2, r2), At(o2, c2, r2)]);
	            return new It(f2, d2, y2, m2, false);
	          }
	          case "lab": {
	            const [n3, i2, s2, o2] = dt(Tt(e2.lab, t2.lab, r2));
	            return new It(n3, i2, s2, o2, false);
	          }
	        }
	      }
	    }
	    It.black = new It(0, 0, 0, 1), It.white = new It(1, 1, 1, 1), It.transparent = new It(0, 0, 0, 0), It.red = new It(1, 0, 0, 1);
	    class Et {
	      constructor(e2, t2, r2) {
	        this.sensitivity = e2 ? t2 ? "variant" : "case" : t2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
	      }
	      compare(e2, t2) {
	        return this.collator.compare(e2, t2);
	      }
	      resolvedLocale() {
	        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
	      }
	    }
	    const Mt = ["bottom", "center", "top"];
	    class kt {
	      constructor(e2, t2, r2, n2, i2, s2) {
	        this.text = e2, this.image = t2, this.scale = r2, this.fontStack = n2, this.textColor = i2, this.verticalAlign = s2;
	      }
	    }
	    class Ft {
	      constructor(e2) {
	        this.sections = e2;
	      }
	      static fromString(e2) {
	        return new Ft([new kt(e2, null, null, null, null, null)]);
	      }
	      isEmpty() {
	        return 0 === this.sections.length || !this.sections.some((e2) => 0 !== e2.text.length || e2.image && 0 !== e2.image.name.length);
	      }
	      static factory(e2) {
	        return e2 instanceof Ft ? e2 : Ft.fromString(e2);
	      }
	      toString() {
	        return 0 === this.sections.length ? "" : this.sections.map((e2) => e2.text).join("");
	      }
	    }
	    class Dt {
	      constructor(e2) {
	        this.values = e2.slice();
	      }
	      static parse(e2) {
	        if (e2 instanceof Dt) return e2;
	        if ("number" == typeof e2) return new Dt([e2, e2, e2, e2]);
	        if (Array.isArray(e2) && !(e2.length < 1 || e2.length > 4)) {
	          for (const t2 of e2) if ("number" != typeof t2) return;
	          switch (e2.length) {
	            case 1:
	              e2 = [e2[0], e2[0], e2[0], e2[0]];
	              break;
	            case 2:
	              e2 = [e2[0], e2[1], e2[0], e2[1]];
	              break;
	            case 3:
	              e2 = [e2[0], e2[1], e2[2], e2[1]];
	          }
	          return new Dt(e2);
	        }
	      }
	      toString() {
	        return JSON.stringify(this.values);
	      }
	      static interpolate(e2, t2, r2) {
	        return new Dt(Tt(e2.values, t2.values, r2));
	      }
	    }
	    class Pt {
	      constructor(e2) {
	        this.values = e2.slice();
	      }
	      static parse(e2) {
	        if (e2 instanceof Pt) return e2;
	        if ("number" == typeof e2) return new Pt([e2]);
	        if (Array.isArray(e2)) {
	          for (const t2 of e2) if ("number" != typeof t2) return;
	          return new Pt(e2);
	        }
	      }
	      toString() {
	        return JSON.stringify(this.values);
	      }
	      static interpolate(e2, t2, r2) {
	        return new Pt(Tt(e2.values, t2.values, r2));
	      }
	    }
	    class Bt {
	      constructor(e2) {
	        this.values = e2.slice();
	      }
	      static parse(e2) {
	        if (e2 instanceof Bt) return e2;
	        if ("string" == typeof e2) {
	          const t3 = It.parse(e2);
	          if (!t3) return;
	          return new Bt([t3]);
	        }
	        if (!Array.isArray(e2)) return;
	        const t2 = [];
	        for (const r2 of e2) {
	          if ("string" != typeof r2) return;
	          const e3 = It.parse(r2);
	          if (!e3) return;
	          t2.push(e3);
	        }
	        return new Bt(t2);
	      }
	      toString() {
	        return JSON.stringify(this.values);
	      }
	      static interpolate(e2, t2, r2, n2 = "rgb") {
	        const i2 = [];
	        if (e2.values.length != t2.values.length) throw new Error(`colorArray: Arrays have mismatched length (${e2.values.length} vs. ${t2.values.length}), cannot interpolate.`);
	        for (let s2 = 0; s2 < e2.values.length; s2++) i2.push(It.interpolate(e2.values[s2], t2.values[s2], r2, n2));
	        return new Bt(i2);
	      }
	    }
	    class zt extends Error {
	      constructor(e2) {
	        super(e2), this.name = "RuntimeError";
	      }
	      toJSON() {
	        return this.message;
	      }
	    }
	    const Vt = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
	    class Ct {
	      constructor(e2) {
	        this.values = e2.slice();
	      }
	      static parse(e2) {
	        if (e2 instanceof Ct) return e2;
	        if (Array.isArray(e2) && !(e2.length < 1) && e2.length % 2 == 0) {
	          for (let t2 = 0; t2 < e2.length; t2 += 2) {
	            const r2 = e2[t2], n2 = e2[t2 + 1];
	            if ("string" != typeof r2 || !Vt.has(r2)) return;
	            if (!Array.isArray(n2) || 2 !== n2.length || "number" != typeof n2[0] || "number" != typeof n2[1]) return;
	          }
	          return new Ct(e2);
	        }
	      }
	      toString() {
	        return JSON.stringify(this.values);
	      }
	      static interpolate(e2, t2, r2) {
	        const n2 = e2.values, i2 = t2.values;
	        if (n2.length !== i2.length) throw new zt(`Cannot interpolate values of different length. from: ${e2.toString()}, to: ${t2.toString()}`);
	        const s2 = [];
	        for (let e3 = 0; e3 < n2.length; e3 += 2) {
	          if (n2[e3] !== i2[e3]) throw new zt(`Cannot interpolate values containing mismatched anchors. from[${e3}]: ${n2[e3]}, to[${e3}]: ${i2[e3]}`);
	          s2.push(n2[e3]);
	          const [t3, o2] = n2[e3 + 1], [a2, l2] = i2[e3 + 1];
	          s2.push([At(t3, a2, r2), At(o2, l2, r2)]);
	        }
	        return new Ct(s2);
	      }
	    }
	    class Lt {
	      constructor(e2) {
	        this.name = e2.name, this.available = e2.available;
	      }
	      toString() {
	        return this.name;
	      }
	      static fromString(e2) {
	        return e2 ? new Lt({ name: e2, available: false }) : null;
	      }
	    }
	    class Ot {
	      constructor(e2, t2, r2) {
	        this.from = e2, this.to = t2, this.transition = r2;
	      }
	      static interpolate(e2, t2, r2) {
	        return new Ot(e2, t2, r2);
	      }
	      static parse(e2) {
	        return e2 instanceof Ot ? e2 : Array.isArray(e2) && 3 === e2.length && "string" == typeof e2[0] && "string" == typeof e2[1] && "number" == typeof e2[2] ? new Ot(e2[0], e2[1], e2[2]) : "object" == typeof e2 && "string" == typeof e2.from && "string" == typeof e2.to && "number" == typeof e2.transition ? new Ot(e2.from, e2.to, e2.transition) : "string" == typeof e2 ? new Ot(e2, e2, 1) : void 0;
	      }
	    }
	    function Rt(e2, t2, r2, n2) {
	      return "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof t2 && t2 >= 0 && t2 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n2 || "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[e2, t2, r2, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n2 ? [e2, t2, r2, n2] : [e2, t2, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
	    }
	    function Nt(e2) {
	      if (null === e2 || "string" == typeof e2 || "boolean" == typeof e2 || "number" == typeof e2 || e2 instanceof Ot || e2 instanceof It || e2 instanceof Et || e2 instanceof Ft || e2 instanceof Dt || e2 instanceof Pt || e2 instanceof Bt || e2 instanceof Ct || e2 instanceof Lt) return true;
	      if (Array.isArray(e2)) {
	        for (const t2 of e2) if (!Nt(t2)) return false;
	        return true;
	      }
	      if ("object" == typeof e2) {
	        for (const t2 in e2) if (!Nt(e2[t2])) return false;
	        return true;
	      }
	      return false;
	    }
	    function $t(e2) {
	      if (null === e2) return ze;
	      if ("string" == typeof e2) return Ce;
	      if ("boolean" == typeof e2) return Le;
	      if ("number" == typeof e2) return Ve;
	      if (e2 instanceof It) return Oe;
	      if (e2 instanceof Ot) return Re;
	      if (e2 instanceof Et) return Ue;
	      if (e2 instanceof Ft) return qe;
	      if (e2 instanceof Dt) return je;
	      if (e2 instanceof Pt) return Xe;
	      if (e2 instanceof Bt) return Ge;
	      if (e2 instanceof Ct) return Ze;
	      if (e2 instanceof Lt) return Ye;
	      if (Array.isArray(e2)) {
	        const t2 = e2.length;
	        let r2;
	        for (const t3 of e2) {
	          const e3 = $t(t3);
	          if (r2) {
	            if (r2 === e3) continue;
	            r2 = $e;
	            break;
	          }
	          r2 = e3;
	        }
	        return He(r2 || $e, t2);
	      }
	      return Ne;
	    }
	    function Ut(e2) {
	      const t2 = typeof e2;
	      return null === e2 ? "" : "string" === t2 || "number" === t2 || "boolean" === t2 ? String(e2) : e2 instanceof It || e2 instanceof Ot || e2 instanceof Ft || e2 instanceof Dt || e2 instanceof Pt || e2 instanceof Bt || e2 instanceof Ct || e2 instanceof Lt ? e2.toString() : JSON.stringify(e2);
	    }
	    class qt {
	      constructor(e2, t2) {
	        this.type = e2, this.value = t2;
	      }
	      static parse(e2, t2) {
	        if (2 !== e2.length) return t2.error(`'literal' expression requires exactly one argument, but found ${e2.length - 1} instead.`);
	        if (!Nt(e2[1])) return t2.error("invalid value");
	        const r2 = e2[1];
	        let n2 = $t(r2);
	        const i2 = t2.expectedType;
	        return "array" !== n2.kind || 0 !== n2.N || !i2 || "array" !== i2.kind || "number" == typeof i2.N && 0 !== i2.N || (n2 = i2), new qt(n2, r2);
	      }
	      evaluate() {
	        return this.value;
	      }
	      eachChild() {
	      }
	      outputDefined() {
	        return true;
	      }
	    }
	    const jt = { string: Ce, number: Ve, boolean: Le, object: Ne };
	    class Gt {
	      constructor(e2, t2) {
	        this.type = e2, this.args = t2;
	      }
	      static parse(e2, t2) {
	        if (e2.length < 2) return t2.error("Expected at least one argument.");
	        let r2, n2 = 1;
	        const i2 = e2[0];
	        if ("array" === i2) {
	          let i3, s3;
	          if (e2.length > 2) {
	            const r3 = e2[1];
	            if ("string" != typeof r3 || !(r3 in jt) || "object" === r3) return t2.error('The item type argument of "array" must be one of string, number, boolean', 1);
	            i3 = jt[r3], n2++;
	          } else i3 = $e;
	          if (e2.length > 3) {
	            if (null !== e2[2] && ("number" != typeof e2[2] || e2[2] < 0 || e2[2] !== Math.floor(e2[2]))) return t2.error('The length argument to "array" must be a positive integer literal', 2);
	            s3 = e2[2], n2++;
	          }
	          r2 = He(i3, s3);
	        } else {
	          if (!jt[i2]) throw new Error(`Types doesn't contain name = ${i2}`);
	          r2 = jt[i2];
	        }
	        const s2 = [];
	        for (; n2 < e2.length; n2++) {
	          const r3 = t2.parse(e2[n2], n2, $e);
	          if (!r3) return null;
	          s2.push(r3);
	        }
	        return new Gt(r2, s2);
	      }
	      evaluate(e2) {
	        for (let t2 = 0; t2 < this.args.length; t2++) {
	          const r2 = this.args[t2].evaluate(e2);
	          if (!Je(this.type, $t(r2))) return r2;
	          if (t2 === this.args.length - 1) throw new zt(`Expected value to be of type ${Ke(this.type)}, but found ${Ke($t(r2))} instead.`);
	        }
	        throw new Error();
	      }
	      eachChild(e2) {
	        this.args.forEach(e2);
	      }
	      outputDefined() {
	        return this.args.every((e2) => e2.outputDefined());
	      }
	    }
	    const Xt = { "to-boolean": Le, "to-color": Oe, "to-number": Ve, "to-string": Ce };
	    class Yt {
	      constructor(e2, t2) {
	        this.type = e2, this.args = t2;
	      }
	      static parse(e2, t2) {
	        if (e2.length < 2) return t2.error("Expected at least one argument.");
	        const r2 = e2[0];
	        if (!Xt[r2]) throw new Error(`Can't parse ${r2} as it is not part of the known types`);
	        if (("to-boolean" === r2 || "to-string" === r2) && 2 !== e2.length) return t2.error("Expected one argument.");
	        const n2 = Xt[r2], i2 = [];
	        for (let r3 = 1; r3 < e2.length; r3++) {
	          const n3 = t2.parse(e2[r3], r3, $e);
	          if (!n3) return null;
	          i2.push(n3);
	        }
	        return new Yt(n2, i2);
	      }
	      evaluate(e2) {
	        switch (this.type.kind) {
	          case "boolean":
	            return Boolean(this.args[0].evaluate(e2));
	          case "color": {
	            let t2, r2;
	            for (const n2 of this.args) {
	              if (t2 = n2.evaluate(e2), r2 = null, t2 instanceof It) return t2;
	              if ("string" == typeof t2) {
	                const r3 = e2.parseColor(t2);
	                if (r3) return r3;
	              } else if (Array.isArray(t2) && (r2 = t2.length < 3 || t2.length > 4 ? `Invalid rgba value ${JSON.stringify(t2)}: expected an array containing either three or four numeric values.` : Rt(t2[0], t2[1], t2[2], t2[3]), !r2)) return new It(t2[0] / 255, t2[1] / 255, t2[2] / 255, t2[3]);
	            }
	            throw new zt(r2 || `Could not parse color from value '${"string" == typeof t2 ? t2 : JSON.stringify(t2)}'`);
	          }
	          case "padding": {
	            let t2;
	            for (const r2 of this.args) {
	              t2 = r2.evaluate(e2);
	              const n2 = Dt.parse(t2);
	              if (n2) return n2;
	            }
	            throw new zt(`Could not parse padding from value '${"string" == typeof t2 ? t2 : JSON.stringify(t2)}'`);
	          }
	          case "numberArray": {
	            let t2;
	            for (const r2 of this.args) {
	              t2 = r2.evaluate(e2);
	              const n2 = Pt.parse(t2);
	              if (n2) return n2;
	            }
	            throw new zt(`Could not parse numberArray from value '${"string" == typeof t2 ? t2 : JSON.stringify(t2)}'`);
	          }
	          case "colorArray": {
	            let t2;
	            for (const r2 of this.args) {
	              t2 = r2.evaluate(e2);
	              const n2 = Bt.parse(t2);
	              if (n2) return n2;
	            }
	            throw new zt(`Could not parse colorArray from value '${"string" == typeof t2 ? t2 : JSON.stringify(t2)}'`);
	          }
	          case "variableAnchorOffsetCollection": {
	            let t2;
	            for (const r2 of this.args) {
	              t2 = r2.evaluate(e2);
	              const n2 = Ct.parse(t2);
	              if (n2) return n2;
	            }
	            throw new zt(`Could not parse variableAnchorOffsetCollection from value '${"string" == typeof t2 ? t2 : JSON.stringify(t2)}'`);
	          }
	          case "number": {
	            let t2 = null;
	            for (const r2 of this.args) {
	              if (t2 = r2.evaluate(e2), null === t2) return 0;
	              const n2 = Number(t2);
	              if (!isNaN(n2)) return n2;
	            }
	            throw new zt(`Could not convert ${JSON.stringify(t2)} to number.`);
	          }
	          case "formatted":
	            return Ft.fromString(Ut(this.args[0].evaluate(e2)));
	          case "resolvedImage":
	            return Lt.fromString(Ut(this.args[0].evaluate(e2)));
	          case "projectionDefinition":
	            return this.args[0].evaluate(e2);
	          default:
	            return Ut(this.args[0].evaluate(e2));
	        }
	      }
	      eachChild(e2) {
	        this.args.forEach(e2);
	      }
	      outputDefined() {
	        return this.args.every((e2) => e2.outputDefined());
	      }
	    }
	    const Zt = ["Unknown", "Point", "LineString", "Polygon"];
	    class Ht {
	      constructor() {
	        this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
	      }
	      id() {
	        return this.feature && "id" in this.feature ? this.feature.id : null;
	      }
	      geometryType() {
	        return this.feature ? "number" == typeof this.feature.type ? Zt[this.feature.type] : this.feature.type : null;
	      }
	      geometry() {
	        return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
	      }
	      canonicalID() {
	        return this.canonical;
	      }
	      properties() {
	        return this.feature && this.feature.properties || {};
	      }
	      parseColor(e2) {
	        let t2 = this._parseColorCache.get(e2);
	        return t2 || (t2 = It.parse(e2), this._parseColorCache.set(e2, t2)), t2;
	      }
	    }
	    class Kt {
	      constructor(e2, t2, r2 = [], n2, i2 = new Be(), s2 = []) {
	        this.registry = e2, this.path = r2, this.key = r2.map((e3) => `[${e3}]`).join(""), this.scope = i2, this.errors = s2, this.expectedType = n2, this._isConstant = t2;
	      }
	      parse(e2, t2, r2, n2, i2 = {}) {
	        return t2 ? this.concat(t2, r2, n2)._parse(e2, i2) : this._parse(e2, i2);
	      }
	      _parse(e2, t2) {
	        function r2(e3, t3, r3) {
	          return "assert" === r3 ? new Gt(t3, [e3]) : "coerce" === r3 ? new Yt(t3, [e3]) : e3;
	        }
	        if (null !== e2 && "string" != typeof e2 && "boolean" != typeof e2 && "number" != typeof e2 || (e2 = ["literal", e2]), Array.isArray(e2)) {
	          if (0 === e2.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
	          const n2 = e2[0];
	          if ("string" != typeof n2) return this.error(`Expression name must be a string, but found ${typeof n2} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
	          const i2 = this.registry[n2];
	          if (i2) {
	            let n3 = i2.parse(e2, this);
	            if (!n3) return null;
	            if (this.expectedType) {
	              const e3 = this.expectedType, i3 = n3.type;
	              if ("string" !== e3.kind && "number" !== e3.kind && "boolean" !== e3.kind && "object" !== e3.kind && "array" !== e3.kind || "value" !== i3.kind) {
	                if ("projectionDefinition" === e3.kind && ["string", "array"].includes(i3.kind) || ["color", "formatted", "resolvedImage"].includes(e3.kind) && ["value", "string"].includes(i3.kind) || ["padding", "numberArray"].includes(e3.kind) && ["value", "number", "array"].includes(i3.kind) || "colorArray" === e3.kind && ["value", "string", "array"].includes(i3.kind) || "variableAnchorOffsetCollection" === e3.kind && ["value", "array"].includes(i3.kind)) n3 = r2(n3, e3, t2.typeAnnotation || "coerce");
	                else if (this.checkSubtype(e3, i3)) return null;
	              } else n3 = r2(n3, e3, t2.typeAnnotation || "assert");
	            }
	            if (!(n3 instanceof qt) && "resolvedImage" !== n3.type.kind && this._isConstant(n3)) {
	              const e3 = new Ht();
	              try {
	                n3 = new qt(n3.type, n3.evaluate(e3));
	              } catch (e4) {
	                return this.error(e4.message), null;
	              }
	            }
	            return n3;
	          }
	          return this.error(`Unknown expression "${n2}". If you wanted a literal array, use ["literal", [...]].`, 0);
	        }
	        return this.error(void 0 === e2 ? "'undefined' value invalid. Use null instead." : "object" == typeof e2 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof e2} instead.`);
	      }
	      concat(e2, t2, r2) {
	        const n2 = "number" == typeof e2 ? this.path.concat(e2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
	        return new Kt(this.registry, this._isConstant, n2, t2 || null, i2, this.errors);
	      }
	      error(e2, ...t2) {
	        const r2 = `${this.key}${t2.map((e3) => `[${e3}]`).join("")}`;
	        this.errors.push(new Pe(r2, e2));
	      }
	      checkSubtype(e2, t2) {
	        const r2 = Je(e2, t2);
	        return r2 && this.error(r2), r2;
	      }
	    }
	    class Wt {
	      constructor(e2, t2) {
	        this.type = t2.type, this.bindings = [].concat(e2), this.result = t2;
	      }
	      evaluate(e2) {
	        return this.result.evaluate(e2);
	      }
	      eachChild(e2) {
	        for (const t2 of this.bindings) e2(t2[1]);
	        e2(this.result);
	      }
	      static parse(e2, t2) {
	        if (e2.length < 4) return t2.error(`Expected at least 3 arguments, but found ${e2.length - 1} instead.`);
	        const r2 = [];
	        for (let n3 = 1; n3 < e2.length - 1; n3 += 2) {
	          const i2 = e2[n3];
	          if ("string" != typeof i2) return t2.error(`Expected string, but found ${typeof i2} instead.`, n3);
	          if (/[^a-zA-Z0-9_]/.test(i2)) return t2.error("Variable names must contain only alphanumeric characters or '_'.", n3);
	          const s2 = t2.parse(e2[n3 + 1], n3 + 1);
	          if (!s2) return null;
	          r2.push([i2, s2]);
	        }
	        const n2 = t2.parse(e2[e2.length - 1], e2.length - 1, t2.expectedType, r2);
	        return n2 ? new Wt(r2, n2) : null;
	      }
	      outputDefined() {
	        return this.result.outputDefined();
	      }
	    }
	    class Jt {
	      constructor(e2, t2) {
	        this.type = t2.type, this.name = e2, this.boundExpression = t2;
	      }
	      static parse(e2, t2) {
	        if (2 !== e2.length || "string" != typeof e2[1]) return t2.error("'var' expression requires exactly one string literal argument.");
	        const r2 = e2[1];
	        return t2.scope.has(r2) ? new Jt(r2, t2.scope.get(r2)) : t2.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
	      }
	      evaluate(e2) {
	        return this.boundExpression.evaluate(e2);
	      }
	      eachChild() {
	      }
	      outputDefined() {
	        return false;
	      }
	    }
	    class Qt {
	      constructor(e2, t2, r2) {
	        this.type = e2, this.index = t2, this.input = r2;
	      }
	      static parse(e2, t2) {
	        if (3 !== e2.length) return t2.error(`Expected 2 arguments, but found ${e2.length - 1} instead.`);
	        const r2 = t2.parse(e2[1], 1, Ve), n2 = t2.parse(e2[2], 2, He(t2.expectedType || $e));
	        return r2 && n2 ? new Qt(n2.type.itemType, r2, n2) : null;
	      }
	      evaluate(e2) {
	        const t2 = this.index.evaluate(e2), r2 = this.input.evaluate(e2);
	        if (t2 < 0) throw new zt(`Array index out of bounds: ${t2} < 0.`);
	        if (t2 >= r2.length) throw new zt(`Array index out of bounds: ${t2} > ${r2.length - 1}.`);
	        if (t2 !== Math.floor(t2)) throw new zt(`Array index must be an integer, but found ${t2} instead.`);
	        return r2[t2];
	      }
	      eachChild(e2) {
	        e2(this.index), e2(this.input);
	      }
	      outputDefined() {
	        return false;
	      }
	    }
	    class er {
	      constructor(e2, t2) {
	        this.type = Le, this.needle = e2, this.haystack = t2;
	      }
	      static parse(e2, t2) {
	        if (3 !== e2.length) return t2.error(`Expected 2 arguments, but found ${e2.length - 1} instead.`);
	        const r2 = t2.parse(e2[1], 1, $e), n2 = t2.parse(e2[2], 2, $e);
	        return r2 && n2 ? Qe(r2.type, [Le, Ce, Ve, ze, $e]) ? new er(r2, n2) : t2.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ke(r2.type)} instead`) : null;
	      }
	      evaluate(e2) {
	        const t2 = this.needle.evaluate(e2), r2 = this.haystack.evaluate(e2);
	        if (!r2) return false;
	        if (!et(t2, ["boolean", "string", "number", "null"])) throw new zt(`Expected first argument to be of type boolean, string, number or null, but found ${Ke($t(t2))} instead.`);
	        if (!et(r2, ["string", "array"])) throw new zt(`Expected second argument to be of type array or string, but found ${Ke($t(r2))} instead.`);
	        return r2.indexOf(t2) >= 0;
	      }
	      eachChild(e2) {
	        e2(this.needle), e2(this.haystack);
	      }
	      outputDefined() {
	        return true;
	      }
	    }
	    class tr {
	      constructor(e2, t2, r2) {
	        this.type = Ve, this.needle = e2, this.haystack = t2, this.fromIndex = r2;
	      }
	      static parse(e2, t2) {
	        if (e2.length <= 2 || e2.length >= 5) return t2.error(`Expected 2 or 3 arguments, but found ${e2.length - 1} instead.`);
	        const r2 = t2.parse(e2[1], 1, $e), n2 = t2.parse(e2[2], 2, $e);
	        if (!r2 || !n2) return null;
	        if (!Qe(r2.type, [Le, Ce, Ve, ze, $e])) return t2.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ke(r2.type)} instead`);
	        if (4 === e2.length) {
	          const i2 = t2.parse(e2[3], 3, Ve);
	          return i2 ? new tr(r2, n2, i2) : null;
	        }
	        return new tr(r2, n2);
	      }
	      evaluate(e2) {
	        const t2 = this.needle.evaluate(e2), r2 = this.haystack.evaluate(e2);
	        if (!et(t2, ["boolean", "string", "number", "null"])) throw new zt(`Expected first argument to be of type boolean, string, number or null, but found ${Ke($t(t2))} instead.`);
	        let n2;
	        if (this.fromIndex && (n2 = this.fromIndex.evaluate(e2)), et(r2, ["string"])) {
	          const e3 = r2.indexOf(t2, n2);
	          return -1 === e3 ? -1 : [...r2.slice(0, e3)].length;
	        }
	        if (et(r2, ["array"])) return r2.indexOf(t2, n2);
	        throw new zt(`Expected second argument to be of type array or string, but found ${Ke($t(r2))} instead.`);
	      }
	      eachChild(e2) {
	        e2(this.needle), e2(this.haystack), this.fromIndex && e2(this.fromIndex);
	      }
	      outputDefined() {
	        return false;
	      }
	    }
	    class rr {
	      constructor(e2, t2, r2, n2, i2, s2) {
	        this.inputType = e2, this.type = t2, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = s2;
	      }
	      static parse(e2, t2) {
	        if (e2.length < 5) return t2.error(`Expected at least 4 arguments, but found only ${e2.length - 1}.`);
	        if (e2.length % 2 != 1) return t2.error("Expected an even number of arguments.");
	        let r2, n2;
	        t2.expectedType && "value" !== t2.expectedType.kind && (n2 = t2.expectedType);
	        const i2 = {}, s2 = [];
	        for (let o3 = 2; o3 < e2.length - 1; o3 += 2) {
	          let a3 = e2[o3];
	          const l2 = e2[o3 + 1];
	          Array.isArray(a3) || (a3 = [a3]);
	          const u2 = t2.concat(o3);
	          if (0 === a3.length) return u2.error("Expected at least one branch label.");
	          for (const e3 of a3) {
	            if ("number" != typeof e3 && "string" != typeof e3) return u2.error("Branch labels must be numbers or strings.");
	            if ("number" == typeof e3 && Math.abs(e3) > Number.MAX_SAFE_INTEGER) return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
	            if ("number" == typeof e3 && Math.floor(e3) !== e3) return u2.error("Numeric branch labels must be integer values.");
	            if (r2) {
	              if (u2.checkSubtype(r2, $t(e3))) return null;
	            } else r2 = $t(e3);
	            if (void 0 !== i2[String(e3)]) return u2.error("Branch labels must be unique.");
	            i2[String(e3)] = s2.length;
	          }
	          const c2 = t2.parse(l2, o3, n2);
	          if (!c2) return null;
	          n2 = n2 || c2.type, s2.push(c2);
	        }
	        const o2 = t2.parse(e2[1], 1, $e);
	        if (!o2) return null;
	        const a2 = t2.parse(e2[e2.length - 1], e2.length - 1, n2);
	        return a2 ? "value" !== o2.type.kind && t2.concat(1).checkSubtype(r2, o2.type) ? null : new rr(r2, n2, o2, i2, s2, a2) : null;
	      }
	      evaluate(e2) {
	        const t2 = this.input.evaluate(e2);
	        return ($t(t2) === this.inputType && this.outputs[this.cases[t2]] || this.otherwise).evaluate(e2);
	      }
	      eachChild(e2) {
	        e2(this.input), this.outputs.forEach(e2), e2(this.otherwise);
	      }
	      outputDefined() {
	        return this.outputs.every((e2) => e2.outputDefined()) && this.otherwise.outputDefined();
	      }
	    }
	    class nr {
	      constructor(e2, t2, r2) {
	        this.type = e2, this.branches = t2, this.otherwise = r2;
	      }
	      static parse(e2, t2) {
	        if (e2.length < 4) return t2.error(`Expected at least 3 arguments, but found only ${e2.length - 1}.`);
	        if (e2.length % 2 != 0) return t2.error("Expected an odd number of arguments.");
	        let r2;
	        t2.expectedType && "value" !== t2.expectedType.kind && (r2 = t2.expectedType);
	        const n2 = [];
	        for (let i3 = 1; i3 < e2.length - 1; i3 += 2) {
	          const s2 = t2.parse(e2[i3], i3, Le);
	          if (!s2) return null;
	          const o2 = t2.parse(e2[i3 + 1], i3 + 1, r2);
	          if (!o2) return null;
	          n2.push([s2, o2]), r2 = r2 || o2.type;
	        }
	        const i2 = t2.parse(e2[e2.length - 1], e2.length - 1, r2);
	        if (!i2) return null;
	        if (!r2) throw new Error("Can't infer output type");
	        return new nr(r2, n2, i2);
	      }
	      evaluate(e2) {
	        for (const [t2, r2] of this.branches) if (t2.evaluate(e2)) return r2.evaluate(e2);
	        return this.otherwise.evaluate(e2);
	      }
	      eachChild(e2) {
	        for (const [t2, r2] of this.branches) e2(t2), e2(r2);
	        e2(this.otherwise);
	      }
	      outputDefined() {
	        return this.branches.every(([e2, t2]) => t2.outputDefined()) && this.otherwise.outputDefined();
	      }
	    }
	    class ir {
	      constructor(e2, t2, r2, n2) {
	        this.type = e2, this.input = t2, this.beginIndex = r2, this.endIndex = n2;
	      }
	      static parse(e2, t2) {
	        if (e2.length <= 2 || e2.length >= 5) return t2.error(`Expected 2 or 3 arguments, but found ${e2.length - 1} instead.`);
	        const r2 = t2.parse(e2[1], 1, $e), n2 = t2.parse(e2[2], 2, Ve);
	        if (!r2 || !n2) return null;
	        if (!Qe(r2.type, [He($e), Ce, $e])) return t2.error(`Expected first argument to be of type array or string, but found ${Ke(r2.type)} instead`);
	        if (4 === e2.length) {
	          const i2 = t2.parse(e2[3], 3, Ve);
	          return i2 ? new ir(r2.type, r2, n2, i2) : null;
	        }
	        return new ir(r2.type, r2, n2);
	      }
	      evaluate(e2) {
	        const t2 = this.input.evaluate(e2), r2 = this.beginIndex.evaluate(e2);
	        let n2;
	        if (this.endIndex && (n2 = this.endIndex.evaluate(e2)), et(t2, ["string"])) return [...t2].slice(r2, n2).join("");
	        if (et(t2, ["array"])) return t2.slice(r2, n2);
	        throw new zt(`Expected first argument to be of type array or string, but found ${Ke($t(t2))} instead.`);
	      }
	      eachChild(e2) {
	        e2(this.input), e2(this.beginIndex), this.endIndex && e2(this.endIndex);
	      }
	      outputDefined() {
	        return false;
	      }
	    }
	    function sr(e2, t2) {
	      const r2 = e2.length - 1;
	      let n2, i2, s2 = 0, o2 = r2, a2 = 0;
	      for (; s2 <= o2; ) if (a2 = Math.floor((s2 + o2) / 2), n2 = e2[a2], i2 = e2[a2 + 1], n2 <= t2) {
	        if (a2 === r2 || t2 < i2) return a2;
	        s2 = a2 + 1;
	      } else {
	        if (!(n2 > t2)) throw new zt("Input is not a number.");
	        o2 = a2 - 1;
	      }
	      return 0;
	    }
	    class or {
	      constructor(e2, t2, r2) {
	        this.type = e2, this.input = t2, this.labels = [], this.outputs = [];
	        for (const [e3, t3] of r2) this.labels.push(e3), this.outputs.push(t3);
	      }
	      static parse(e2, t2) {
	        if (e2.length - 1 < 4) return t2.error(`Expected at least 4 arguments, but found only ${e2.length - 1}.`);
	        if ((e2.length - 1) % 2 != 0) return t2.error("Expected an even number of arguments.");
	        const r2 = t2.parse(e2[1], 1, Ve);
	        if (!r2) return null;
	        const n2 = [];
	        let i2 = null;
	        t2.expectedType && "value" !== t2.expectedType.kind && (i2 = t2.expectedType);
	        for (let r3 = 1; r3 < e2.length; r3 += 2) {
	          const s2 = 1 === r3 ? -1 / 0 : e2[r3], o2 = e2[r3 + 1], a2 = r3, l2 = r3 + 1;
	          if ("number" != typeof s2) return t2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', a2);
	          if (n2.length && n2[n2.length - 1][0] >= s2) return t2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', a2);
	          const u2 = t2.parse(o2, l2, i2);
	          if (!u2) return null;
	          i2 = i2 || u2.type, n2.push([s2, u2]);
	        }
	        return new or(i2, r2, n2);
	      }
	      evaluate(e2) {
	        const t2 = this.labels, r2 = this.outputs;
	        if (1 === t2.length) return r2[0].evaluate(e2);
	        const n2 = this.input.evaluate(e2);
	        if (n2 <= t2[0]) return r2[0].evaluate(e2);
	        const i2 = t2.length;
	        return n2 >= t2[i2 - 1] ? r2[i2 - 1].evaluate(e2) : r2[sr(t2, n2)].evaluate(e2);
	      }
	      eachChild(e2) {
	        e2(this.input);
	        for (const t2 of this.outputs) e2(t2);
	      }
	      outputDefined() {
	        return this.outputs.every((e2) => e2.outputDefined());
	      }
	    }
	    function ar(e2) {
	      return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
	    }
	    var lr, ur, cr = function() {
	      if (ur) return lr;
	      function e2(e3, t2, r2, n2) {
	        this.cx = 3 * e3, this.bx = 3 * (r2 - e3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t2, this.by = 3 * (n2 - t2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e3, this.p1y = t2, this.p2x = r2, this.p2y = n2;
	      }
	      return ur = 1, lr = e2, e2.prototype = { sampleCurveX: function(e3) {
	        return ((this.ax * e3 + this.bx) * e3 + this.cx) * e3;
	      }, sampleCurveY: function(e3) {
	        return ((this.ay * e3 + this.by) * e3 + this.cy) * e3;
	      }, sampleCurveDerivativeX: function(e3) {
	        return (3 * this.ax * e3 + 2 * this.bx) * e3 + this.cx;
	      }, solveCurveX: function(e3, t2) {
	        if (void 0 === t2 && (t2 = 1e-6), e3 < 0) return 0;
	        if (e3 > 1) return 1;
	        for (var r2 = e3, n2 = 0; n2 < 8; n2++) {
	          var i2 = this.sampleCurveX(r2) - e3;
	          if (Math.abs(i2) < t2) return r2;
	          var s2 = this.sampleCurveDerivativeX(r2);
	          if (Math.abs(s2) < 1e-6) break;
	          r2 -= i2 / s2;
	        }
	        var o2 = 0, a2 = 1;
	        for (r2 = e3, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - e3) < t2)); n2++) e3 > i2 ? o2 = r2 : a2 = r2, r2 = 0.5 * (a2 - o2) + o2;
	        return r2;
	      }, solve: function(e3, t2) {
	        return this.sampleCurveY(this.solveCurveX(e3, t2));
	      } }, lr;
	    }(), hr = ar(cr);
	    class pr {
	      constructor(e2, t2, r2, n2, i2) {
	        this.type = e2, this.operator = t2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
	        for (const [e3, t3] of i2) this.labels.push(e3), this.outputs.push(t3);
	      }
	      static interpolationFactor(e2, t2, r2, n2) {
	        let i2 = 0;
	        if ("exponential" === e2.name) i2 = fr(t2, e2.base, r2, n2);
	        else if ("linear" === e2.name) i2 = fr(t2, 1, r2, n2);
	        else if ("cubic-bezier" === e2.name) {
	          const s2 = e2.controlPoints;
	          i2 = new hr(s2[0], s2[1], s2[2], s2[3]).solve(fr(t2, 1, r2, n2));
	        }
	        return i2;
	      }
	      static parse(e2, t2) {
	        let [r2, n2, i2, ...s2] = e2;
	        if (!Array.isArray(n2) || 0 === n2.length) return t2.error("Expected an interpolation type expression.", 1);
	        if ("linear" === n2[0]) n2 = { name: "linear" };
	        else if ("exponential" === n2[0]) {
	          const e3 = n2[1];
	          if ("number" != typeof e3) return t2.error("Exponential interpolation requires a numeric base.", 1, 1);
	          n2 = { name: "exponential", base: e3 };
	        } else {
	          if ("cubic-bezier" !== n2[0]) return t2.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
	          {
	            const e3 = n2.slice(1);
	            if (4 !== e3.length || e3.some((e4) => "number" != typeof e4 || e4 < 0 || e4 > 1)) return t2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
	            n2 = { name: "cubic-bezier", controlPoints: e3 };
	          }
	        }
	        if (e2.length - 1 < 4) return t2.error(`Expected at least 4 arguments, but found only ${e2.length - 1}.`);
	        if ((e2.length - 1) % 2 != 0) return t2.error("Expected an even number of arguments.");
	        if (i2 = t2.parse(i2, 2, Ve), !i2) return null;
	        const o2 = [];
	        let a2 = null;
	        "interpolate-hcl" !== r2 && "interpolate-lab" !== r2 || t2.expectedType == Ge ? t2.expectedType && "value" !== t2.expectedType.kind && (a2 = t2.expectedType) : a2 = Oe;
	        for (let e3 = 0; e3 < s2.length; e3 += 2) {
	          const r3 = s2[e3], n3 = s2[e3 + 1], i3 = e3 + 3, l2 = e3 + 4;
	          if ("number" != typeof r3) return t2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
	          if (o2.length && o2[o2.length - 1][0] >= r3) return t2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
	          const u2 = t2.parse(n3, l2, a2);
	          if (!u2) return null;
	          a2 = a2 || u2.type, o2.push([r3, u2]);
	        }
	        return tt(a2, Ve) || tt(a2, Re) || tt(a2, Oe) || tt(a2, je) || tt(a2, Xe) || tt(a2, Ge) || tt(a2, Ze) || tt(a2, He(Ve)) ? new pr(a2, r2, n2, i2, o2) : t2.error(`Type ${Ke(a2)} is not interpolatable.`);
	      }
	      evaluate(e2) {
	        const t2 = this.labels, r2 = this.outputs;
	        if (1 === t2.length) return r2[0].evaluate(e2);
	        const n2 = this.input.evaluate(e2);
	        if (n2 <= t2[0]) return r2[0].evaluate(e2);
	        const i2 = t2.length;
	        if (n2 >= t2[i2 - 1]) return r2[i2 - 1].evaluate(e2);
	        const s2 = sr(t2, n2), o2 = pr.interpolationFactor(this.interpolation, n2, t2[s2], t2[s2 + 1]), a2 = r2[s2].evaluate(e2), l2 = r2[s2 + 1].evaluate(e2);
	        switch (this.operator) {
	          case "interpolate":
	            switch (this.type.kind) {
	              case "number":
	                return At(a2, l2, o2);
	              case "color":
	                return It.interpolate(a2, l2, o2);
	              case "padding":
	                return Dt.interpolate(a2, l2, o2);
	              case "colorArray":
	                return Bt.interpolate(a2, l2, o2);
	              case "numberArray":
	                return Pt.interpolate(a2, l2, o2);
	              case "variableAnchorOffsetCollection":
	                return Ct.interpolate(a2, l2, o2);
	              case "array":
	                return Tt(a2, l2, o2);
	              case "projectionDefinition":
	                return Ot.interpolate(a2, l2, o2);
	            }
	          case "interpolate-hcl":
	            switch (this.type.kind) {
	              case "color":
	                return It.interpolate(a2, l2, o2, "hcl");
	              case "colorArray":
	                return Bt.interpolate(a2, l2, o2, "hcl");
	            }
	          case "interpolate-lab":
	            switch (this.type.kind) {
	              case "color":
	                return It.interpolate(a2, l2, o2, "lab");
	              case "colorArray":
	                return Bt.interpolate(a2, l2, o2, "lab");
	            }
	        }
	      }
	      eachChild(e2) {
	        e2(this.input);
	        for (const t2 of this.outputs) e2(t2);
	      }
	      outputDefined() {
	        return this.outputs.every((e2) => e2.outputDefined());
	      }
	    }
	    function fr(e2, t2, r2, n2) {
	      const i2 = n2 - r2, s2 = e2 - r2;
	      return 0 === i2 ? 0 : 1 === t2 ? s2 / i2 : (Math.pow(t2, s2) - 1) / (Math.pow(t2, i2) - 1);
	    }
	    const dr = { color: It.interpolate, number: At, padding: Dt.interpolate, numberArray: Pt.interpolate, colorArray: Bt.interpolate, variableAnchorOffsetCollection: Ct.interpolate, array: Tt };
	    class yr {
	      constructor(e2, t2) {
	        this.type = e2, this.args = t2;
	      }
	      static parse(e2, t2) {
	        if (e2.length < 2) return t2.error("Expected at least one argument.");
	        let r2 = null;
	        const n2 = t2.expectedType;
	        n2 && "value" !== n2.kind && (r2 = n2);
	        const i2 = [];
	        for (const n3 of e2.slice(1)) {
	          const e3 = t2.parse(n3, 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
	          if (!e3) return null;
	          r2 = r2 || e3.type, i2.push(e3);
	        }
	        if (!r2) throw new Error("No output type");
	        const s2 = n2 && i2.some((e3) => Je(n2, e3.type));
	        return new yr(s2 ? $e : r2, i2);
	      }
	      evaluate(e2) {
	        let t2, r2 = null, n2 = 0;
	        for (const i2 of this.args) if (n2++, r2 = i2.evaluate(e2), r2 && r2 instanceof Lt && !r2.available && (t2 || (t2 = r2.name), r2 = null, n2 === this.args.length && (r2 = t2)), null !== r2) break;
	        return r2;
	      }
	      eachChild(e2) {
	        this.args.forEach(e2);
	      }
	      outputDefined() {
	        return this.args.every((e2) => e2.outputDefined());
	      }
	    }
	    function mr(e2, t2) {
	      return "==" === e2 || "!=" === e2 ? "boolean" === t2.kind || "string" === t2.kind || "number" === t2.kind || "null" === t2.kind || "value" === t2.kind : "string" === t2.kind || "number" === t2.kind || "value" === t2.kind;
	    }
	    function gr(e2, t2, r2, n2) {
	      return 0 === n2.compare(t2, r2);
	    }
	    function xr(e2, t2, r2) {
	      const n2 = "==" !== e2 && "!=" !== e2;
	      return class i2 {
	        constructor(e3, t3, r3) {
	          this.type = Le, this.lhs = e3, this.rhs = t3, this.collator = r3, this.hasUntypedArgument = "value" === e3.type.kind || "value" === t3.type.kind;
	        }
	        static parse(e3, t3) {
	          if (3 !== e3.length && 4 !== e3.length) return t3.error("Expected two or three arguments.");
	          const r3 = e3[0];
	          let s2 = t3.parse(e3[1], 1, $e);
	          if (!s2) return null;
	          if (!mr(r3, s2.type)) return t3.concat(1).error(`"${r3}" comparisons are not supported for type '${Ke(s2.type)}'.`);
	          let o2 = t3.parse(e3[2], 2, $e);
	          if (!o2) return null;
	          if (!mr(r3, o2.type)) return t3.concat(2).error(`"${r3}" comparisons are not supported for type '${Ke(o2.type)}'.`);
	          if (s2.type.kind !== o2.type.kind && "value" !== s2.type.kind && "value" !== o2.type.kind) return t3.error(`Cannot compare types '${Ke(s2.type)}' and '${Ke(o2.type)}'.`);
	          n2 && ("value" === s2.type.kind && "value" !== o2.type.kind ? s2 = new Gt(o2.type, [s2]) : "value" !== s2.type.kind && "value" === o2.type.kind && (o2 = new Gt(s2.type, [o2])));
	          let a2 = null;
	          if (4 === e3.length) {
	            if ("string" !== s2.type.kind && "string" !== o2.type.kind && "value" !== s2.type.kind && "value" !== o2.type.kind) return t3.error("Cannot use collator to compare non-string types.");
	            if (a2 = t3.parse(e3[3], 3, Ue), !a2) return null;
	          }
	          return new i2(s2, o2, a2);
	        }
	        evaluate(i3) {
	          const s2 = this.lhs.evaluate(i3), o2 = this.rhs.evaluate(i3);
	          if (n2 && this.hasUntypedArgument) {
	            const t3 = $t(s2), r3 = $t(o2);
	            if (t3.kind !== r3.kind || "string" !== t3.kind && "number" !== t3.kind) throw new zt(`Expected arguments for "${e2}" to be (string, string) or (number, number), but found (${t3.kind}, ${r3.kind}) instead.`);
	          }
	          if (this.collator && !n2 && this.hasUntypedArgument) {
	            const e3 = $t(s2), r3 = $t(o2);
	            if ("string" !== e3.kind || "string" !== r3.kind) return t2(i3, s2, o2);
	          }
	          return this.collator ? r2(i3, s2, o2, this.collator.evaluate(i3)) : t2(i3, s2, o2);
	        }
	        eachChild(e3) {
	          e3(this.lhs), e3(this.rhs), this.collator && e3(this.collator);
	        }
	        outputDefined() {
	          return true;
	        }
	      };
	    }
	    const vr = xr("==", function(e2, t2, r2) {
	      return t2 === r2;
	    }, gr), br = xr("!=", function(e2, t2, r2) {
	      return t2 !== r2;
	    }, function(e2, t2, r2, n2) {
	      return !gr(0, t2, r2, n2);
	    }), wr = xr("<", function(e2, t2, r2) {
	      return t2 < r2;
	    }, function(e2, t2, r2, n2) {
	      return n2.compare(t2, r2) < 0;
	    }), _r = xr(">", function(e2, t2, r2) {
	      return t2 > r2;
	    }, function(e2, t2, r2, n2) {
	      return n2.compare(t2, r2) > 0;
	    }), Sr = xr("<=", function(e2, t2, r2) {
	      return t2 <= r2;
	    }, function(e2, t2, r2, n2) {
	      return n2.compare(t2, r2) <= 0;
	    }), Ar = xr(">=", function(e2, t2, r2) {
	      return t2 >= r2;
	    }, function(e2, t2, r2, n2) {
	      return n2.compare(t2, r2) >= 0;
	    });
	    class Tr {
	      constructor(e2, t2, r2) {
	        this.type = Ue, this.locale = r2, this.caseSensitive = e2, this.diacriticSensitive = t2;
	      }
	      static parse(e2, t2) {
	        if (2 !== e2.length) return t2.error("Expected one argument.");
	        const r2 = e2[1];
	        if ("object" != typeof r2 || Array.isArray(r2)) return t2.error("Collator options argument must be an object.");
	        const n2 = t2.parse(void 0 !== r2["case-sensitive"] && r2["case-sensitive"], 1, Le);
	        if (!n2) return null;
	        const i2 = t2.parse(void 0 !== r2["diacritic-sensitive"] && r2["diacritic-sensitive"], 1, Le);
	        if (!i2) return null;
	        let s2 = null;
	        return r2.locale && (s2 = t2.parse(r2.locale, 1, Ce), !s2) ? null : new Tr(n2, i2, s2);
	      }
	      evaluate(e2) {
	        return new Et(this.caseSensitive.evaluate(e2), this.diacriticSensitive.evaluate(e2), this.locale ? this.locale.evaluate(e2) : null);
	      }
	      eachChild(e2) {
	        e2(this.caseSensitive), e2(this.diacriticSensitive), this.locale && e2(this.locale);
	      }
	      outputDefined() {
	        return false;
	      }
	    }
	    class Ir {
	      constructor(e2, t2, r2, n2, i2) {
	        this.type = Ce, this.number = e2, this.locale = t2, this.currency = r2, this.minFractionDigits = n2, this.maxFractionDigits = i2;
	      }
	      static parse(e2, t2) {
	        if (3 !== e2.length) return t2.error("Expected two arguments.");
	        const r2 = t2.parse(e2[1], 1, Ve);
	        if (!r2) return null;
	        const n2 = e2[2];
	        if ("object" != typeof n2 || Array.isArray(n2)) return t2.error("NumberFormat options argument must be an object.");
	        let i2 = null;
	        if (n2.locale && (i2 = t2.parse(n2.locale, 1, Ce), !i2)) return null;
	        let s2 = null;
	        if (n2.currency && (s2 = t2.parse(n2.currency, 1, Ce), !s2)) return null;
	        let o2 = null;
	        if (n2["min-fraction-digits"] && (o2 = t2.parse(n2["min-fraction-digits"], 1, Ve), !o2)) return null;
	        let a2 = null;
	        return n2["max-fraction-digits"] && (a2 = t2.parse(n2["max-fraction-digits"], 1, Ve), !a2) ? null : new Ir(r2, i2, s2, o2, a2);
	      }
	      evaluate(e2) {
	        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e2) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(e2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e2) : void 0 }).format(this.number.evaluate(e2));
	      }
	      eachChild(e2) {
	        e2(this.number), this.locale && e2(this.locale), this.currency && e2(this.currency), this.minFractionDigits && e2(this.minFractionDigits), this.maxFractionDigits && e2(this.maxFractionDigits);
	      }
	      outputDefined() {
	        return false;
	      }
	    }
	    class Er {
	      constructor(e2) {
	        this.type = qe, this.sections = e2;
	      }
	      static parse(e2, t2) {
	        if (e2.length < 2) return t2.error("Expected at least one argument.");
	        const r2 = e2[1];
	        if (!Array.isArray(r2) && "object" == typeof r2) return t2.error("First argument must be an image or text section.");
	        const n2 = [];
	        let i2 = false;
	        for (let r3 = 1; r3 <= e2.length - 1; ++r3) {
	          const s2 = e2[r3];
	          if (i2 && "object" == typeof s2 && !Array.isArray(s2)) {
	            i2 = false;
	            let e3 = null;
	            if (s2["font-scale"] && (e3 = t2.parse(s2["font-scale"], 1, Ve), !e3)) return null;
	            let r4 = null;
	            if (s2["text-font"] && (r4 = t2.parse(s2["text-font"], 1, He(Ce)), !r4)) return null;
	            let o2 = null;
	            if (s2["text-color"] && (o2 = t2.parse(s2["text-color"], 1, Oe), !o2)) return null;
	            let a2 = null;
	            if (s2["vertical-align"]) {
	              if ("string" == typeof s2["vertical-align"] && !Mt.includes(s2["vertical-align"])) return t2.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${s2["vertical-align"]}' instead.`);
	              if (a2 = t2.parse(s2["vertical-align"], 1, Ce), !a2) return null;
	            }
	            const l2 = n2[n2.length - 1];
	            l2.scale = e3, l2.font = r4, l2.textColor = o2, l2.verticalAlign = a2;
	          } else {
	            const s3 = t2.parse(e2[r3], 1, $e);
	            if (!s3) return null;
	            const o2 = s3.type.kind;
	            if ("string" !== o2 && "value" !== o2 && "null" !== o2 && "resolvedImage" !== o2) return t2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
	            i2 = true, n2.push({ content: s3, scale: null, font: null, textColor: null, verticalAlign: null });
	          }
	        }
	        return new Er(n2);
	      }
	      evaluate(e2) {
	        return new Ft(this.sections.map((t2) => {
	          const r2 = t2.content.evaluate(e2);
	          return $t(r2) === Ye ? new kt("", r2, null, null, null, t2.verticalAlign ? t2.verticalAlign.evaluate(e2) : null) : new kt(Ut(r2), null, t2.scale ? t2.scale.evaluate(e2) : null, t2.font ? t2.font.evaluate(e2).join(",") : null, t2.textColor ? t2.textColor.evaluate(e2) : null, t2.verticalAlign ? t2.verticalAlign.evaluate(e2) : null);
	        }));
	      }
	      eachChild(e2) {
	        for (const t2 of this.sections) e2(t2.content), t2.scale && e2(t2.scale), t2.font && e2(t2.font), t2.textColor && e2(t2.textColor), t2.verticalAlign && e2(t2.verticalAlign);
	      }
	      outputDefined() {
	        return false;
	      }
	    }
	    class Mr {
	      constructor(e2) {
	        this.type = Ye, this.input = e2;
	      }
	      static parse(e2, t2) {
	        if (2 !== e2.length) return t2.error("Expected two arguments.");
	        const r2 = t2.parse(e2[1], 1, Ce);
	        return r2 ? new Mr(r2) : t2.error("No image name provided.");
	      }
	      evaluate(e2) {
	        const t2 = this.input.evaluate(e2), r2 = Lt.fromString(t2);
	        return r2 && e2.availableImages && (r2.available = e2.availableImages.indexOf(t2) > -1), r2;
	      }
	      eachChild(e2) {
	        e2(this.input);
	      }
	      outputDefined() {
	        return false;
	      }
	    }
	    class kr {
	      constructor(e2) {
	        this.type = Ve, this.input = e2;
	      }
	      static parse(e2, t2) {
	        if (2 !== e2.length) return t2.error(`Expected 1 argument, but found ${e2.length - 1} instead.`);
	        const r2 = t2.parse(e2[1], 1);
	        return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? t2.error(`Expected argument of type string or array, but found ${Ke(r2.type)} instead.`) : new kr(r2) : null;
	      }
	      evaluate(e2) {
	        const t2 = this.input.evaluate(e2);
	        if ("string" == typeof t2) return [...t2].length;
	        if (Array.isArray(t2)) return t2.length;
	        throw new zt(`Expected value to be of type string or array, but found ${Ke($t(t2))} instead.`);
	      }
	      eachChild(e2) {
	        e2(this.input);
	      }
	      outputDefined() {
	        return false;
	      }
	    }
	    const Fr = 8192;
	    function Dr(e2, t2) {
	      const r2 = (180 + e2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, t2.z);
	      return [Math.round(r2 * i2 * Fr), Math.round(n2 * i2 * Fr)];
	    }
	    function Pr(e2, t2) {
	      const r2 = Math.pow(2, t2.z);
	      return [(i2 = (e2[0] / Fr + t2.x) / r2, 360 * i2 - 180), (n2 = (e2[1] / Fr + t2.y) / r2, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n2) * Math.PI / 180)) - 90)];
	      var n2, i2;
	    }
	    function Br(e2, t2) {
	      e2[0] = Math.min(e2[0], t2[0]), e2[1] = Math.min(e2[1], t2[1]), e2[2] = Math.max(e2[2], t2[0]), e2[3] = Math.max(e2[3], t2[1]);
	    }
	    function zr(e2, t2) {
	      return !(e2[0] <= t2[0] || e2[2] >= t2[2] || e2[1] <= t2[1] || e2[3] >= t2[3]);
	    }
	    function Vr(e2, t2, r2) {
	      const n2 = e2[0] - t2[0], i2 = e2[1] - t2[1], s2 = e2[0] - r2[0], o2 = e2[1] - r2[1];
	      return n2 * o2 - s2 * i2 == 0 && n2 * s2 <= 0 && i2 * o2 <= 0;
	    }
	    function Cr(e2, t2, r2, n2) {
	      return 0 != (i2 = [n2[0] - r2[0], n2[1] - r2[1]])[0] * (s2 = [t2[0] - e2[0], t2[1] - e2[1]])[1] - i2[1] * s2[0] && !(!Ur(e2, t2, r2, n2) || !Ur(r2, n2, e2, t2));
	      var i2, s2;
	    }
	    function Lr(e2, t2, r2) {
	      for (const n2 of r2) for (let r3 = 0; r3 < n2.length - 1; ++r3) if (Cr(e2, t2, n2[r3], n2[r3 + 1])) return true;
	      return false;
	    }
	    function Or(e2, t2, r2 = false) {
	      let n2 = false;
	      for (const a2 of t2) for (let t3 = 0; t3 < a2.length - 1; t3++) {
	        if (Vr(e2, a2[t3], a2[t3 + 1])) return r2;
	        (s2 = a2[t3])[1] > (i2 = e2)[1] != (o2 = a2[t3 + 1])[1] > i2[1] && i2[0] < (o2[0] - s2[0]) * (i2[1] - s2[1]) / (o2[1] - s2[1]) + s2[0] && (n2 = !n2);
	      }
	      var i2, s2, o2;
	      return n2;
	    }
	    function Rr(e2, t2) {
	      for (const r2 of t2) if (Or(e2, r2)) return true;
	      return false;
	    }
	    function Nr(e2, t2) {
	      for (const r2 of e2) if (!Or(r2, t2)) return false;
	      for (let r2 = 0; r2 < e2.length - 1; ++r2) if (Lr(e2[r2], e2[r2 + 1], t2)) return false;
	      return true;
	    }
	    function $r(e2, t2) {
	      for (const r2 of t2) if (Nr(e2, r2)) return true;
	      return false;
	    }
	    function Ur(e2, t2, r2, n2) {
	      const i2 = n2[0] - r2[0], s2 = n2[1] - r2[1], o2 = (e2[0] - r2[0]) * s2 - i2 * (e2[1] - r2[1]), a2 = (t2[0] - r2[0]) * s2 - i2 * (t2[1] - r2[1]);
	      return o2 > 0 && a2 < 0 || o2 < 0 && a2 > 0;
	    }
	    function qr(e2, t2, r2) {
	      const n2 = [];
	      for (let i2 = 0; i2 < e2.length; i2++) {
	        const s2 = [];
	        for (let n3 = 0; n3 < e2[i2].length; n3++) {
	          const o2 = Dr(e2[i2][n3], r2);
	          Br(t2, o2), s2.push(o2);
	        }
	        n2.push(s2);
	      }
	      return n2;
	    }
	    function jr(e2, t2, r2) {
	      const n2 = [];
	      for (let i2 = 0; i2 < e2.length; i2++) {
	        const s2 = qr(e2[i2], t2, r2);
	        n2.push(s2);
	      }
	      return n2;
	    }
	    function Gr(e2, t2, r2, n2) {
	      if (e2[0] < r2[0] || e2[0] > r2[2]) {
	        const t3 = 0.5 * n2;
	        let i2 = e2[0] - r2[0] > t3 ? -n2 : r2[0] - e2[0] > t3 ? n2 : 0;
	        0 === i2 && (i2 = e2[0] - r2[2] > t3 ? -n2 : r2[2] - e2[0] > t3 ? n2 : 0), e2[0] += i2;
	      }
	      Br(t2, e2);
	    }
	    function Xr(e2, t2, r2, n2) {
	      const i2 = Math.pow(2, n2.z) * Fr, s2 = [n2.x * Fr, n2.y * Fr], o2 = [];
	      for (const n3 of e2) for (const e3 of n3) {
	        const n4 = [e3.x + s2[0], e3.y + s2[1]];
	        Gr(n4, t2, r2, i2), o2.push(n4);
	      }
	      return o2;
	    }
	    function Yr(e2, t2, r2, n2) {
	      const i2 = Math.pow(2, n2.z) * Fr, s2 = [n2.x * Fr, n2.y * Fr], o2 = [];
	      for (const r3 of e2) {
	        const e3 = [];
	        for (const n3 of r3) {
	          const r4 = [n3.x + s2[0], n3.y + s2[1]];
	          Br(t2, r4), e3.push(r4);
	        }
	        o2.push(e3);
	      }
	      if (t2[2] - t2[0] <= i2 / 2) {
	        (a2 = t2)[0] = a2[1] = 1 / 0, a2[2] = a2[3] = -1 / 0;
	        for (const e3 of o2) for (const n3 of e3) Gr(n3, t2, r2, i2);
	      }
	      var a2;
	      return o2;
	    }
	    class Zr {
	      constructor(e2, t2) {
	        this.type = Le, this.geojson = e2, this.geometries = t2;
	      }
	      static parse(e2, t2) {
	        if (2 !== e2.length) return t2.error(`'within' expression requires exactly one argument, but found ${e2.length - 1} instead.`);
	        if (Nt(e2[1])) {
	          const t3 = e2[1];
	          if ("FeatureCollection" === t3.type) {
	            const e3 = [];
	            for (const r2 of t3.features) {
	              const { type: t4, coordinates: n2 } = r2.geometry;
	              "Polygon" === t4 && e3.push(n2), "MultiPolygon" === t4 && e3.push(...n2);
	            }
	            if (e3.length) return new Zr(t3, { type: "MultiPolygon", coordinates: e3 });
	          } else if ("Feature" === t3.type) {
	            const e3 = t3.geometry.type;
	            if ("Polygon" === e3 || "MultiPolygon" === e3) return new Zr(t3, t3.geometry);
	          } else if ("Polygon" === t3.type || "MultiPolygon" === t3.type) return new Zr(t3, t3);
	        }
	        return t2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
	      }
	      evaluate(e2) {
	        if (null != e2.geometry() && null != e2.canonicalID()) {
	          if ("Point" === e2.geometryType()) return function(e3, t2) {
	            const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = e3.canonicalID();
	            if ("Polygon" === t2.type) {
	              const s2 = qr(t2.coordinates, n2, i2), o2 = Xr(e3.geometry(), r2, n2, i2);
	              if (!zr(r2, n2)) return false;
	              for (const e4 of o2) if (!Or(e4, s2)) return false;
	            }
	            if ("MultiPolygon" === t2.type) {
	              const s2 = jr(t2.coordinates, n2, i2), o2 = Xr(e3.geometry(), r2, n2, i2);
	              if (!zr(r2, n2)) return false;
	              for (const e4 of o2) if (!Rr(e4, s2)) return false;
	            }
	            return true;
	          }(e2, this.geometries);
	          if ("LineString" === e2.geometryType()) return function(e3, t2) {
	            const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = e3.canonicalID();
	            if ("Polygon" === t2.type) {
	              const s2 = qr(t2.coordinates, n2, i2), o2 = Yr(e3.geometry(), r2, n2, i2);
	              if (!zr(r2, n2)) return false;
	              for (const e4 of o2) if (!Nr(e4, s2)) return false;
	            }
	            if ("MultiPolygon" === t2.type) {
	              const s2 = jr(t2.coordinates, n2, i2), o2 = Yr(e3.geometry(), r2, n2, i2);
	              if (!zr(r2, n2)) return false;
	              for (const e4 of o2) if (!$r(e4, s2)) return false;
	            }
	            return true;
	          }(e2, this.geometries);
	        }
	        return false;
	      }
	      eachChild() {
	      }
	      outputDefined() {
	        return true;
	      }
	    }
	    let Hr = class {
	      constructor(e2 = [], t2 = (e3, t3) => e3 < t3 ? -1 : e3 > t3 ? 1 : 0) {
	        if (this.data = e2, this.length = this.data.length, this.compare = t2, this.length > 0) for (let e3 = (this.length >> 1) - 1; e3 >= 0; e3--) this._down(e3);
	      }
	      push(e2) {
	        this.data.push(e2), this._up(this.length++);
	      }
	      pop() {
	        if (0 === this.length) return;
	        const e2 = this.data[0], t2 = this.data.pop();
	        return --this.length > 0 && (this.data[0] = t2, this._down(0)), e2;
	      }
	      peek() {
	        return this.data[0];
	      }
	      _up(e2) {
	        const { data: t2, compare: r2 } = this, n2 = t2[e2];
	        for (; e2 > 0; ) {
	          const i2 = e2 - 1 >> 1, s2 = t2[i2];
	          if (r2(n2, s2) >= 0) break;
	          t2[e2] = s2, e2 = i2;
	        }
	        t2[e2] = n2;
	      }
	      _down(e2) {
	        const { data: t2, compare: r2 } = this, n2 = this.length >> 1, i2 = t2[e2];
	        for (; e2 < n2; ) {
	          let n3 = 1 + (e2 << 1);
	          const s2 = n3 + 1;
	          if (s2 < this.length && r2(t2[s2], t2[n3]) < 0 && (n3 = s2), r2(t2[n3], i2) >= 0) break;
	          t2[e2] = t2[n3], e2 = n3;
	        }
	        t2[e2] = i2;
	      }
	    };
	    function Kr(e2, t2, r2 = 0, n2 = e2.length - 1, i2 = Jr) {
	      for (; n2 > r2; ) {
	        if (n2 - r2 > 600) {
	          const s3 = n2 - r2 + 1, o3 = t2 - r2 + 1, a3 = Math.log(s3), l2 = 0.5 * Math.exp(2 * a3 / 3), u2 = 0.5 * Math.sqrt(a3 * l2 * (s3 - l2) / s3) * (o3 - s3 / 2 < 0 ? -1 : 1);
	          Kr(e2, t2, Math.max(r2, Math.floor(t2 - o3 * l2 / s3 + u2)), Math.min(n2, Math.floor(t2 + (s3 - o3) * l2 / s3 + u2)), i2);
	        }
	        const s2 = e2[t2];
	        let o2 = r2, a2 = n2;
	        for (Wr(e2, r2, t2), i2(e2[n2], s2) > 0 && Wr(e2, r2, n2); o2 < a2; ) {
	          for (Wr(e2, o2, a2), o2++, a2--; i2(e2[o2], s2) < 0; ) o2++;
	          for (; i2(e2[a2], s2) > 0; ) a2--;
	        }
	        0 === i2(e2[r2], s2) ? Wr(e2, r2, a2) : (a2++, Wr(e2, a2, n2)), a2 <= t2 && (r2 = a2 + 1), t2 <= a2 && (n2 = a2 - 1);
	      }
	    }
	    function Wr(e2, t2, r2) {
	      const n2 = e2[t2];
	      e2[t2] = e2[r2], e2[r2] = n2;
	    }
	    function Jr(e2, t2) {
	      return e2 < t2 ? -1 : e2 > t2 ? 1 : 0;
	    }
	    function Qr(e2, t2) {
	      if (e2.length <= 1) return [e2];
	      const r2 = [];
	      let n2, i2;
	      for (const t3 of e2) {
	        const e3 = tn(t3);
	        0 !== e3 && (t3.area = Math.abs(e3), void 0 === i2 && (i2 = e3 < 0), i2 === e3 < 0 ? (n2 && r2.push(n2), n2 = [t3]) : n2.push(t3));
	      }
	      if (n2 && r2.push(n2), t2 > 1) for (let e3 = 0; e3 < r2.length; e3++) r2[e3].length <= t2 || (Kr(r2[e3], t2, 1, r2[e3].length - 1, en), r2[e3] = r2[e3].slice(0, t2));
	      return r2;
	    }
	    function en(e2, t2) {
	      return t2.area - e2.area;
	    }
	    function tn(e2) {
	      let t2 = 0;
	      for (let r2, n2, i2 = 0, s2 = e2.length, o2 = s2 - 1; i2 < s2; o2 = i2++) r2 = e2[i2], n2 = e2[o2], t2 += (n2.x - r2.x) * (r2.y + n2.y);
	      return t2;
	    }
	    const rn = 1 / 298.257223563, nn = rn * (2 - rn), sn = Math.PI / 180;
	    class on {
	      constructor(e2) {
	        const t2 = 6378.137 * sn * 1e3, r2 = Math.cos(e2 * sn), n2 = 1 / (1 - nn * (1 - r2 * r2)), i2 = Math.sqrt(n2);
	        this.kx = t2 * i2 * r2, this.ky = t2 * i2 * n2 * (1 - nn);
	      }
	      distance(e2, t2) {
	        const r2 = this.wrap(e2[0] - t2[0]) * this.kx, n2 = (e2[1] - t2[1]) * this.ky;
	        return Math.sqrt(r2 * r2 + n2 * n2);
	      }
	      pointOnLine(e2, t2) {
	        let r2, n2, i2, s2, o2 = 1 / 0;
	        for (let a2 = 0; a2 < e2.length - 1; a2++) {
	          let l2 = e2[a2][0], u2 = e2[a2][1], c2 = this.wrap(e2[a2 + 1][0] - l2) * this.kx, h2 = (e2[a2 + 1][1] - u2) * this.ky, p2 = 0;
	          0 === c2 && 0 === h2 || (p2 = (this.wrap(t2[0] - l2) * this.kx * c2 + (t2[1] - u2) * this.ky * h2) / (c2 * c2 + h2 * h2), p2 > 1 ? (l2 = e2[a2 + 1][0], u2 = e2[a2 + 1][1]) : p2 > 0 && (l2 += c2 / this.kx * p2, u2 += h2 / this.ky * p2)), c2 = this.wrap(t2[0] - l2) * this.kx, h2 = (t2[1] - u2) * this.ky;
	          const f2 = c2 * c2 + h2 * h2;
	          f2 < o2 && (o2 = f2, r2 = l2, n2 = u2, i2 = a2, s2 = p2);
	        }
	        return { point: [r2, n2], index: i2, t: Math.max(0, Math.min(1, s2)) };
	      }
	      wrap(e2) {
	        for (; e2 < -180; ) e2 += 360;
	        for (; e2 > 180; ) e2 -= 360;
	        return e2;
	      }
	    }
	    function an(e2, t2) {
	      return t2[0] - e2[0];
	    }
	    function ln(e2) {
	      return e2[1] - e2[0] + 1;
	    }
	    function un(e2, t2) {
	      return e2[1] >= e2[0] && e2[1] < t2;
	    }
	    function cn(e2, t2) {
	      if (e2[0] > e2[1]) return [null, null];
	      const r2 = ln(e2);
	      if (t2) {
	        if (2 === r2) return [e2, null];
	        const t3 = Math.floor(r2 / 2);
	        return [[e2[0], e2[0] + t3], [e2[0] + t3, e2[1]]];
	      }
	      if (1 === r2) return [e2, null];
	      const n2 = Math.floor(r2 / 2) - 1;
	      return [[e2[0], e2[0] + n2], [e2[0] + n2 + 1, e2[1]]];
	    }
	    function hn(e2, t2) {
	      if (!un(t2, e2.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
	      const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
	      for (let n2 = t2[0]; n2 <= t2[1]; ++n2) Br(r2, e2[n2]);
	      return r2;
	    }
	    function pn(e2) {
	      const t2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
	      for (const r2 of e2) for (const e3 of r2) Br(t2, e3);
	      return t2;
	    }
	    function fn(e2) {
	      return e2[0] !== -1 / 0 && e2[1] !== -1 / 0 && e2[2] !== 1 / 0 && e2[3] !== 1 / 0;
	    }
	    function dn(e2, t2, r2) {
	      if (!fn(e2) || !fn(t2)) return NaN;
	      let n2 = 0, i2 = 0;
	      return e2[2] < t2[0] && (n2 = t2[0] - e2[2]), e2[0] > t2[2] && (n2 = e2[0] - t2[2]), e2[1] > t2[3] && (i2 = e2[1] - t2[3]), e2[3] < t2[1] && (i2 = t2[1] - e2[3]), r2.distance([0, 0], [n2, i2]);
	    }
	    function yn(e2, t2, r2) {
	      const n2 = r2.pointOnLine(t2, e2);
	      return r2.distance(e2, n2.point);
	    }
	    function mn(e2, t2, r2, n2, i2) {
	      const s2 = Math.min(yn(e2, [r2, n2], i2), yn(t2, [r2, n2], i2)), o2 = Math.min(yn(r2, [e2, t2], i2), yn(n2, [e2, t2], i2));
	      return Math.min(s2, o2);
	    }
	    function gn(e2, t2, r2, n2, i2) {
	      if (!un(t2, e2.length) || !un(n2, r2.length)) return 1 / 0;
	      let s2 = 1 / 0;
	      for (let o2 = t2[0]; o2 < t2[1]; ++o2) {
	        const t3 = e2[o2], a2 = e2[o2 + 1];
	        for (let e3 = n2[0]; e3 < n2[1]; ++e3) {
	          const n3 = r2[e3], o3 = r2[e3 + 1];
	          if (Cr(t3, a2, n3, o3)) return 0;
	          s2 = Math.min(s2, mn(t3, a2, n3, o3, i2));
	        }
	      }
	      return s2;
	    }
	    function xn(e2, t2, r2, n2, i2) {
	      if (!un(t2, e2.length) || !un(n2, r2.length)) return NaN;
	      let s2 = 1 / 0;
	      for (let o2 = t2[0]; o2 <= t2[1]; ++o2) for (let t3 = n2[0]; t3 <= n2[1]; ++t3) if (s2 = Math.min(s2, i2.distance(e2[o2], r2[t3])), 0 === s2) return s2;
	      return s2;
	    }
	    function vn(e2, t2, r2) {
	      if (Or(e2, t2, true)) return 0;
	      let n2 = 1 / 0;
	      for (const i2 of t2) {
	        const t3 = i2[0], s2 = i2[i2.length - 1];
	        if (t3 !== s2 && (n2 = Math.min(n2, yn(e2, [s2, t3], r2)), 0 === n2)) return n2;
	        const o2 = r2.pointOnLine(i2, e2);
	        if (n2 = Math.min(n2, r2.distance(e2, o2.point)), 0 === n2) return n2;
	      }
	      return n2;
	    }
	    function bn(e2, t2, r2, n2) {
	      if (!un(t2, e2.length)) return NaN;
	      for (let n3 = t2[0]; n3 <= t2[1]; ++n3) if (Or(e2[n3], r2, true)) return 0;
	      let i2 = 1 / 0;
	      for (let s2 = t2[0]; s2 < t2[1]; ++s2) {
	        const t3 = e2[s2], o2 = e2[s2 + 1];
	        for (const e3 of r2) for (let r3 = 0, s3 = e3.length, a2 = s3 - 1; r3 < s3; a2 = r3++) {
	          const s4 = e3[a2], l2 = e3[r3];
	          if (Cr(t3, o2, s4, l2)) return 0;
	          i2 = Math.min(i2, mn(t3, o2, s4, l2, n2));
	        }
	      }
	      return i2;
	    }
	    function wn(e2, t2) {
	      for (const r2 of e2) for (const e3 of r2) if (Or(e3, t2, true)) return true;
	      return false;
	    }
	    function _n(e2, t2, r2, n2 = 1 / 0) {
	      const i2 = pn(e2), s2 = pn(t2);
	      if (n2 !== 1 / 0 && dn(i2, s2, r2) >= n2) return n2;
	      if (zr(i2, s2)) {
	        if (wn(e2, t2)) return 0;
	      } else if (wn(t2, e2)) return 0;
	      let o2 = 1 / 0;
	      for (const n3 of e2) for (let e3 = 0, i3 = n3.length, s3 = i3 - 1; e3 < i3; s3 = e3++) {
	        const i4 = n3[s3], a2 = n3[e3];
	        for (const e4 of t2) for (let t3 = 0, n4 = e4.length, s4 = n4 - 1; t3 < n4; s4 = t3++) {
	          const n5 = e4[s4], l2 = e4[t3];
	          if (Cr(i4, a2, n5, l2)) return 0;
	          o2 = Math.min(o2, mn(i4, a2, n5, l2, r2));
	        }
	      }
	      return o2;
	    }
	    function Sn(e2, t2, r2, n2, i2, s2) {
	      if (!s2) return;
	      const o2 = dn(hn(n2, s2), i2, r2);
	      o2 < t2 && e2.push([o2, s2, [0, 0]]);
	    }
	    function An(e2, t2, r2, n2, i2, s2, o2) {
	      if (!s2 || !o2) return;
	      const a2 = dn(hn(n2, s2), hn(i2, o2), r2);
	      a2 < t2 && e2.push([a2, s2, o2]);
	    }
	    function Tn(e2, t2, r2, n2, i2 = 1 / 0) {
	      let s2 = Math.min(n2.distance(e2[0], r2[0][0]), i2);
	      if (0 === s2) return s2;
	      const o2 = new Hr([[0, [0, e2.length - 1], [0, 0]]], an), a2 = pn(r2);
	      for (; o2.length > 0; ) {
	        const i3 = o2.pop();
	        if (i3[0] >= s2) continue;
	        const l2 = i3[1], u2 = t2 ? 50 : 100;
	        if (ln(l2) <= u2) {
	          if (!un(l2, e2.length)) return NaN;
	          if (t2) {
	            const t3 = bn(e2, l2, r2, n2);
	            if (isNaN(t3) || 0 === t3) return t3;
	            s2 = Math.min(s2, t3);
	          } else for (let t3 = l2[0]; t3 <= l2[1]; ++t3) {
	            const i4 = vn(e2[t3], r2, n2);
	            if (s2 = Math.min(s2, i4), 0 === s2) return 0;
	          }
	        } else {
	          const r3 = cn(l2, t2);
	          Sn(o2, s2, n2, e2, a2, r3[0]), Sn(o2, s2, n2, e2, a2, r3[1]);
	        }
	      }
	      return s2;
	    }
	    function In(e2, t2, r2, n2, i2, s2 = 1 / 0) {
	      let o2 = Math.min(s2, i2.distance(e2[0], r2[0]));
	      if (0 === o2) return o2;
	      const a2 = new Hr([[0, [0, e2.length - 1], [0, r2.length - 1]]], an);
	      for (; a2.length > 0; ) {
	        const s3 = a2.pop();
	        if (s3[0] >= o2) continue;
	        const l2 = s3[1], u2 = s3[2], c2 = t2 ? 50 : 100, h2 = n2 ? 50 : 100;
	        if (ln(l2) <= c2 && ln(u2) <= h2) {
	          if (!un(l2, e2.length) && un(u2, r2.length)) return NaN;
	          let s4;
	          if (t2 && n2) s4 = gn(e2, l2, r2, u2, i2), o2 = Math.min(o2, s4);
	          else if (t2 && !n2) {
	            const t3 = e2.slice(l2[0], l2[1] + 1);
	            for (let e3 = u2[0]; e3 <= u2[1]; ++e3) if (s4 = yn(r2[e3], t3, i2), o2 = Math.min(o2, s4), 0 === o2) return o2;
	          } else if (!t2 && n2) {
	            const t3 = r2.slice(u2[0], u2[1] + 1);
	            for (let r3 = l2[0]; r3 <= l2[1]; ++r3) if (s4 = yn(e2[r3], t3, i2), o2 = Math.min(o2, s4), 0 === o2) return o2;
	          } else s4 = xn(e2, l2, r2, u2, i2), o2 = Math.min(o2, s4);
	        } else {
	          const s4 = cn(l2, t2), c3 = cn(u2, n2);
	          An(a2, o2, i2, e2, r2, s4[0], c3[0]), An(a2, o2, i2, e2, r2, s4[0], c3[1]), An(a2, o2, i2, e2, r2, s4[1], c3[0]), An(a2, o2, i2, e2, r2, s4[1], c3[1]);
	        }
	      }
	      return o2;
	    }
	    function En(e2) {
	      return "MultiPolygon" === e2.type ? e2.coordinates.map((e3) => ({ type: "Polygon", coordinates: e3 })) : "MultiLineString" === e2.type ? e2.coordinates.map((e3) => ({ type: "LineString", coordinates: e3 })) : "MultiPoint" === e2.type ? e2.coordinates.map((e3) => ({ type: "Point", coordinates: e3 })) : [e2];
	    }
	    class Mn {
	      constructor(e2, t2) {
	        this.type = Ve, this.geojson = e2, this.geometries = t2;
	      }
	      static parse(e2, t2) {
	        if (2 !== e2.length) return t2.error(`'distance' expression requires exactly one argument, but found ${e2.length - 1} instead.`);
	        if (Nt(e2[1])) {
	          const t3 = e2[1];
	          if ("FeatureCollection" === t3.type) return new Mn(t3, t3.features.map((e3) => En(e3.geometry)).flat());
	          if ("Feature" === t3.type) return new Mn(t3, En(t3.geometry));
	          if ("type" in t3 && "coordinates" in t3) return new Mn(t3, En(t3));
	        }
	        return t2.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
	      }
	      evaluate(e2) {
	        if (null != e2.geometry() && null != e2.canonicalID()) {
	          if ("Point" === e2.geometryType()) return function(e3, t2) {
	            const r2 = e3.geometry(), n2 = r2.flat().map((t3) => Pr([t3.x, t3.y], e3.canonical));
	            if (0 === r2.length) return NaN;
	            const i2 = new on(n2[0][1]);
	            let s2 = 1 / 0;
	            for (const e4 of t2) {
	              switch (e4.type) {
	                case "Point":
	                  s2 = Math.min(s2, In(n2, false, [e4.coordinates], false, i2, s2));
	                  break;
	                case "LineString":
	                  s2 = Math.min(s2, In(n2, false, e4.coordinates, true, i2, s2));
	                  break;
	                case "Polygon":
	                  s2 = Math.min(s2, Tn(n2, false, e4.coordinates, i2, s2));
	              }
	              if (0 === s2) return s2;
	            }
	            return s2;
	          }(e2, this.geometries);
	          if ("LineString" === e2.geometryType()) return function(e3, t2) {
	            const r2 = e3.geometry(), n2 = r2.flat().map((t3) => Pr([t3.x, t3.y], e3.canonical));
	            if (0 === r2.length) return NaN;
	            const i2 = new on(n2[0][1]);
	            let s2 = 1 / 0;
	            for (const e4 of t2) {
	              switch (e4.type) {
	                case "Point":
	                  s2 = Math.min(s2, In(n2, true, [e4.coordinates], false, i2, s2));
	                  break;
	                case "LineString":
	                  s2 = Math.min(s2, In(n2, true, e4.coordinates, true, i2, s2));
	                  break;
	                case "Polygon":
	                  s2 = Math.min(s2, Tn(n2, true, e4.coordinates, i2, s2));
	              }
	              if (0 === s2) return s2;
	            }
	            return s2;
	          }(e2, this.geometries);
	          if ("Polygon" === e2.geometryType()) return function(e3, t2) {
	            const r2 = e3.geometry();
	            if (0 === r2.length || 0 === r2[0].length) return NaN;
	            const n2 = Qr(r2, 0).map((t3) => t3.map((t4) => t4.map((t5) => Pr([t5.x, t5.y], e3.canonical)))), i2 = new on(n2[0][0][0][1]);
	            let s2 = 1 / 0;
	            for (const e4 of t2) for (const t3 of n2) {
	              switch (e4.type) {
	                case "Point":
	                  s2 = Math.min(s2, Tn([e4.coordinates], false, t3, i2, s2));
	                  break;
	                case "LineString":
	                  s2 = Math.min(s2, Tn(e4.coordinates, true, t3, i2, s2));
	                  break;
	                case "Polygon":
	                  s2 = Math.min(s2, _n(t3, e4.coordinates, i2, s2));
	              }
	              if (0 === s2) return s2;
	            }
	            return s2;
	          }(e2, this.geometries);
	        }
	        return NaN;
	      }
	      eachChild() {
	      }
	      outputDefined() {
	        return true;
	      }
	    }
	    class kn {
	      constructor(e2) {
	        this.type = $e, this.key = e2;
	      }
	      static parse(e2, t2) {
	        if (2 !== e2.length) return t2.error(`Expected 1 argument, but found ${e2.length - 1} instead.`);
	        const r2 = e2[1];
	        return null == r2 ? t2.error("Global state property must be defined.") : "string" != typeof r2 ? t2.error(`Global state property must be string, but found ${typeof e2[1]} instead.`) : new kn(r2);
	      }
	      evaluate(e2) {
	        var t2;
	        const r2 = null === (t2 = e2.globals) || void 0 === t2 ? void 0 : t2.globalState;
	        return r2 && 0 !== Object.keys(r2).length ? xt(r2, this.key) : null;
	      }
	      eachChild() {
	      }
	      outputDefined() {
	        return false;
	      }
	    }
	    const Fn = { "==": vr, "!=": br, ">": _r, "<": wr, ">=": Ar, "<=": Sr, array: Gt, at: Qt, boolean: Gt, case: nr, coalesce: yr, collator: Tr, format: Er, image: Mr, in: er, "index-of": tr, interpolate: pr, "interpolate-hcl": pr, "interpolate-lab": pr, length: kr, let: Wt, literal: qt, match: rr, number: Gt, "number-format": Ir, object: Gt, slice: ir, step: or, string: Gt, "to-boolean": Yt, "to-color": Yt, "to-number": Yt, "to-string": Yt, var: Jt, within: Zr, distance: Mn, "global-state": kn };
	    class Dn {
	      constructor(e2, t2, r2, n2) {
	        this.name = e2, this.type = t2, this._evaluate = r2, this.args = n2;
	      }
	      evaluate(e2) {
	        return this._evaluate(e2, this.args);
	      }
	      eachChild(e2) {
	        this.args.forEach(e2);
	      }
	      outputDefined() {
	        return false;
	      }
	      static parse(e2, t2) {
	        const r2 = e2[0], n2 = Dn.definitions[r2];
	        if (!n2) return t2.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
	        const i2 = Array.isArray(n2) ? n2[0] : n2.type, s2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, o2 = s2.filter(([t3]) => !Array.isArray(t3) || t3.length === e2.length - 1);
	        let a2 = null;
	        for (const [n3, s3] of o2) {
	          a2 = new Kt(t2.registry, Cn, t2.path, null, t2.scope);
	          const o3 = [];
	          let l2 = false;
	          for (let t3 = 1; t3 < e2.length; t3++) {
	            const r3 = e2[t3], i3 = Array.isArray(n3) ? n3[t3 - 1] : n3.type, s4 = a2.parse(r3, 1 + o3.length, i3);
	            if (!s4) {
	              l2 = true;
	              break;
	            }
	            o3.push(s4);
	          }
	          if (!l2) if (Array.isArray(n3) && n3.length !== o3.length) a2.error(`Expected ${n3.length} arguments, but found ${o3.length} instead.`);
	          else {
	            for (let e3 = 0; e3 < o3.length; e3++) {
	              const t3 = Array.isArray(n3) ? n3[e3] : n3.type, r3 = o3[e3];
	              a2.concat(e3 + 1).checkSubtype(t3, r3.type);
	            }
	            if (0 === a2.errors.length) return new Dn(r2, i2, s3, o3);
	          }
	        }
	        if (1 === o2.length) t2.errors.push(...a2.errors);
	        else {
	          const r3 = (o2.length ? o2 : s2).map(([e3]) => {
	            return t3 = e3, Array.isArray(t3) ? `(${t3.map(Ke).join(", ")})` : `(${Ke(t3.type)}...)`;
	            var t3;
	          }).join(" | "), n3 = [];
	          for (let r4 = 1; r4 < e2.length; r4++) {
	            const i3 = t2.parse(e2[r4], 1 + n3.length);
	            if (!i3) return null;
	            n3.push(Ke(i3.type));
	          }
	          t2.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
	        }
	        return null;
	      }
	      static register(e2, t2) {
	        Dn.definitions = t2;
	        for (const r2 in t2) e2[r2] = Dn;
	      }
	    }
	    function Pn(e2, [t2, r2, n2, i2]) {
	      t2 = t2.evaluate(e2), r2 = r2.evaluate(e2), n2 = n2.evaluate(e2);
	      const s2 = i2 ? i2.evaluate(e2) : 1, o2 = Rt(t2, r2, n2, s2);
	      if (o2) throw new zt(o2);
	      return new It(t2 / 255, r2 / 255, n2 / 255, s2, false);
	    }
	    function Bn(e2, t2) {
	      return e2 in t2;
	    }
	    function zn(e2, t2) {
	      const r2 = t2[e2];
	      return void 0 === r2 ? null : r2;
	    }
	    function Vn(e2) {
	      return { type: e2 };
	    }
	    function Cn(e2) {
	      if (e2 instanceof Jt) return Cn(e2.boundExpression);
	      if (e2 instanceof Dn && "error" === e2.name) return false;
	      if (e2 instanceof Tr) return false;
	      if (e2 instanceof Zr) return false;
	      if (e2 instanceof Mn) return false;
	      if (e2 instanceof kn) return false;
	      const t2 = e2 instanceof Yt || e2 instanceof Gt;
	      let r2 = true;
	      return e2.eachChild((e3) => {
	        r2 = t2 ? r2 && Cn(e3) : r2 && e3 instanceof qt;
	      }), !!r2 && Ln(e2) && Rn(e2, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]);
	    }
	    function Ln(e2) {
	      if (e2 instanceof Dn) {
	        if ("get" === e2.name && 1 === e2.args.length) return false;
	        if ("feature-state" === e2.name) return false;
	        if ("has" === e2.name && 1 === e2.args.length) return false;
	        if ("properties" === e2.name || "geometry-type" === e2.name || "id" === e2.name) return false;
	        if (/^filter-/.test(e2.name)) return false;
	      }
	      if (e2 instanceof Zr) return false;
	      if (e2 instanceof Mn) return false;
	      let t2 = true;
	      return e2.eachChild((e3) => {
	        t2 && !Ln(e3) && (t2 = false);
	      }), t2;
	    }
	    function On(e2) {
	      if (e2 instanceof Dn && "feature-state" === e2.name) return false;
	      let t2 = true;
	      return e2.eachChild((e3) => {
	        t2 && !On(e3) && (t2 = false);
	      }), t2;
	    }
	    function Rn(e2, t2) {
	      if (e2 instanceof Dn && t2.indexOf(e2.name) >= 0) return false;
	      let r2 = true;
	      return e2.eachChild((e3) => {
	        r2 && !Rn(e3, t2) && (r2 = false);
	      }), r2;
	    }
	    function Nn(e2) {
	      return { result: "success", value: e2 };
	    }
	    function $n(e2) {
	      return { result: "error", value: e2 };
	    }
	    function Un(e2) {
	      return "data-driven" === e2["property-type"] || "cross-faded-data-driven" === e2["property-type"];
	    }
	    function qn(e2) {
	      return !!e2.expression && e2.expression.parameters.indexOf("zoom") > -1;
	    }
	    function jn(e2) {
	      return !!e2.expression && e2.expression.interpolated;
	    }
	    function Gn(e2) {
	      return e2 instanceof Number ? "number" : e2 instanceof String ? "string" : e2 instanceof Boolean ? "boolean" : Array.isArray(e2) ? "array" : null === e2 ? "null" : typeof e2;
	    }
	    function Xn(e2) {
	      return "object" == typeof e2 && null !== e2 && !Array.isArray(e2) && $t(e2) === Ne;
	    }
	    function Yn(e2) {
	      return e2;
	    }
	    function Zn(e2, t2) {
	      const r2 = e2.stops && "object" == typeof e2.stops[0][0], n2 = r2 || !(r2 || void 0 !== e2.property), i2 = e2.type || (jn(t2) ? "exponential" : "interval"), s2 = function(e3) {
	        switch (e3.type) {
	          case "color":
	            return It.parse;
	          case "padding":
	            return Dt.parse;
	          case "numberArray":
	            return Pt.parse;
	          case "colorArray":
	            return Bt.parse;
	          default:
	            return null;
	        }
	      }(t2);
	      if (s2 && ((e2 = De({}, e2)).stops && (e2.stops = e2.stops.map((e3) => [e3[0], s2(e3[1])])), e2.default = s2(e2.default ? e2.default : t2.default)), e2.colorSpace && "rgb" !== (o2 = e2.colorSpace) && "hcl" !== o2 && "lab" !== o2) throw new Error(`Unknown color space: "${e2.colorSpace}"`);
	      var o2;
	      const a2 = function(e3) {
	        switch (e3) {
	          case "exponential":
	            return Jn;
	          case "interval":
	            return Wn;
	          case "categorical":
	            return Kn;
	          case "identity":
	            return Qn;
	          default:
	            throw new Error(`Unknown function type "${e3}"`);
	        }
	      }(i2);
	      let l2, u2;
	      if ("categorical" === i2) {
	        l2 = /* @__PURE__ */ Object.create(null);
	        for (const t3 of e2.stops) l2[t3[0]] = t3[1];
	        u2 = typeof e2.stops[0][0];
	      }
	      if (r2) {
	        const r3 = {}, n3 = [];
	        for (let t3 = 0; t3 < e2.stops.length; t3++) {
	          const i4 = e2.stops[t3], s4 = i4[0].zoom;
	          void 0 === r3[s4] && (r3[s4] = { zoom: s4, type: e2.type, property: e2.property, default: e2.default, stops: [] }, n3.push(s4)), r3[s4].stops.push([i4[0].value, i4[1]]);
	        }
	        const i3 = [];
	        for (const e3 of n3) i3.push([r3[e3].zoom, Zn(r3[e3], t2)]);
	        const s3 = { name: "linear" };
	        return { kind: "composite", interpolationType: s3, interpolationFactor: pr.interpolationFactor.bind(void 0, s3), zoomStops: i3.map((e3) => e3[0]), evaluate: ({ zoom: r4 }, n4) => Jn({ stops: i3, base: e2.base }, t2, r4).evaluate(r4, n4) };
	      }
	      if (n2) {
	        const r3 = "exponential" === i2 ? { name: "exponential", base: void 0 !== e2.base ? e2.base : 1 } : null;
	        return { kind: "camera", interpolationType: r3, interpolationFactor: pr.interpolationFactor.bind(void 0, r3), zoomStops: e2.stops.map((e3) => e3[0]), evaluate: ({ zoom: r4 }) => a2(e2, t2, r4, l2, u2) };
	      }
	      return { kind: "source", evaluate(r3, n3) {
	        const i3 = n3 && n3.properties ? n3.properties[e2.property] : void 0;
	        return void 0 === i3 ? Hn(e2.default, t2.default) : a2(e2, t2, i3, l2, u2);
	      } };
	    }
	    function Hn(e2, t2, r2) {
	      return void 0 !== e2 ? e2 : void 0 !== t2 ? t2 : void 0 !== r2 ? r2 : void 0;
	    }
	    function Kn(e2, t2, r2, n2, i2) {
	      return Hn(typeof r2 === i2 ? n2[r2] : void 0, e2.default, t2.default);
	    }
	    function Wn(e2, t2, r2) {
	      if ("number" !== Gn(r2)) return Hn(e2.default, t2.default);
	      const n2 = e2.stops.length;
	      if (1 === n2) return e2.stops[0][1];
	      if (r2 <= e2.stops[0][0]) return e2.stops[0][1];
	      if (r2 >= e2.stops[n2 - 1][0]) return e2.stops[n2 - 1][1];
	      const i2 = sr(e2.stops.map((e3) => e3[0]), r2);
	      return e2.stops[i2][1];
	    }
	    function Jn(e2, t2, r2) {
	      const n2 = void 0 !== e2.base ? e2.base : 1;
	      if ("number" !== Gn(r2)) return Hn(e2.default, t2.default);
	      const i2 = e2.stops.length;
	      if (1 === i2) return e2.stops[0][1];
	      if (r2 <= e2.stops[0][0]) return e2.stops[0][1];
	      if (r2 >= e2.stops[i2 - 1][0]) return e2.stops[i2 - 1][1];
	      const s2 = sr(e2.stops.map((e3) => e3[0]), r2), o2 = function(e3, t3, r3, n3) {
	        const i3 = n3 - r3, s3 = e3 - r3;
	        return 0 === i3 ? 0 : 1 === t3 ? s3 / i3 : (Math.pow(t3, s3) - 1) / (Math.pow(t3, i3) - 1);
	      }(r2, n2, e2.stops[s2][0], e2.stops[s2 + 1][0]), a2 = e2.stops[s2][1], l2 = e2.stops[s2 + 1][1], u2 = dr[t2.type] || Yn;
	      return "function" == typeof a2.evaluate ? { evaluate(...t3) {
	        const r3 = a2.evaluate.apply(void 0, t3), n3 = l2.evaluate.apply(void 0, t3);
	        if (void 0 !== r3 && void 0 !== n3) return u2(r3, n3, o2, e2.colorSpace);
	      } } : u2(a2, l2, o2, e2.colorSpace);
	    }
	    function Qn(e2, t2, r2) {
	      switch (t2.type) {
	        case "color":
	          r2 = It.parse(r2);
	          break;
	        case "formatted":
	          r2 = Ft.fromString(r2.toString());
	          break;
	        case "resolvedImage":
	          r2 = Lt.fromString(r2.toString());
	          break;
	        case "padding":
	          r2 = Dt.parse(r2);
	          break;
	        case "colorArray":
	          r2 = Bt.parse(r2);
	          break;
	        case "numberArray":
	          r2 = Pt.parse(r2);
	          break;
	        default:
	          Gn(r2) === t2.type || "enum" === t2.type && t2.values[r2] || (r2 = void 0);
	      }
	      return Hn(r2, e2.default, t2.default);
	    }
	    Dn.register(Fn, { error: [{ kind: "error" }, [Ce], (e2, [t2]) => {
	      throw new zt(t2.evaluate(e2));
	    }], typeof: [Ce, [$e], (e2, [t2]) => Ke($t(t2.evaluate(e2)))], "to-rgba": [He(Ve, 4), [Oe], (e2, [t2]) => {
	      const [r2, n2, i2, s2] = t2.evaluate(e2).rgb;
	      return [255 * r2, 255 * n2, 255 * i2, s2];
	    }], rgb: [Oe, [Ve, Ve, Ve], Pn], rgba: [Oe, [Ve, Ve, Ve, Ve], Pn], has: { type: Le, overloads: [[[Ce], (e2, [t2]) => Bn(t2.evaluate(e2), e2.properties())], [[Ce, Ne], (e2, [t2, r2]) => Bn(t2.evaluate(e2), r2.evaluate(e2))]] }, get: { type: $e, overloads: [[[Ce], (e2, [t2]) => zn(t2.evaluate(e2), e2.properties())], [[Ce, Ne], (e2, [t2, r2]) => zn(t2.evaluate(e2), r2.evaluate(e2))]] }, "feature-state": [$e, [Ce], (e2, [t2]) => zn(t2.evaluate(e2), e2.featureState || {})], properties: [Ne, [], (e2) => e2.properties()], "geometry-type": [Ce, [], (e2) => e2.geometryType()], id: [$e, [], (e2) => e2.id()], zoom: [Ve, [], (e2) => e2.globals.zoom], "heatmap-density": [Ve, [], (e2) => e2.globals.heatmapDensity || 0], elevation: [Ve, [], (e2) => e2.globals.elevation || 0], "line-progress": [Ve, [], (e2) => e2.globals.lineProgress || 0], accumulated: [$e, [], (e2) => void 0 === e2.globals.accumulated ? null : e2.globals.accumulated], "+": [Ve, Vn(Ve), (e2, t2) => {
	      let r2 = 0;
	      for (const n2 of t2) r2 += n2.evaluate(e2);
	      return r2;
	    }], "*": [Ve, Vn(Ve), (e2, t2) => {
	      let r2 = 1;
	      for (const n2 of t2) r2 *= n2.evaluate(e2);
	      return r2;
	    }], "-": { type: Ve, overloads: [[[Ve, Ve], (e2, [t2, r2]) => t2.evaluate(e2) - r2.evaluate(e2)], [[Ve], (e2, [t2]) => -t2.evaluate(e2)]] }, "/": [Ve, [Ve, Ve], (e2, [t2, r2]) => t2.evaluate(e2) / r2.evaluate(e2)], "%": [Ve, [Ve, Ve], (e2, [t2, r2]) => t2.evaluate(e2) % r2.evaluate(e2)], ln2: [Ve, [], () => Math.LN2], pi: [Ve, [], () => Math.PI], e: [Ve, [], () => Math.E], "^": [Ve, [Ve, Ve], (e2, [t2, r2]) => Math.pow(t2.evaluate(e2), r2.evaluate(e2))], sqrt: [Ve, [Ve], (e2, [t2]) => Math.sqrt(t2.evaluate(e2))], log10: [Ve, [Ve], (e2, [t2]) => Math.log(t2.evaluate(e2)) / Math.LN10], ln: [Ve, [Ve], (e2, [t2]) => Math.log(t2.evaluate(e2))], log2: [Ve, [Ve], (e2, [t2]) => Math.log(t2.evaluate(e2)) / Math.LN2], sin: [Ve, [Ve], (e2, [t2]) => Math.sin(t2.evaluate(e2))], cos: [Ve, [Ve], (e2, [t2]) => Math.cos(t2.evaluate(e2))], tan: [Ve, [Ve], (e2, [t2]) => Math.tan(t2.evaluate(e2))], asin: [Ve, [Ve], (e2, [t2]) => Math.asin(t2.evaluate(e2))], acos: [Ve, [Ve], (e2, [t2]) => Math.acos(t2.evaluate(e2))], atan: [Ve, [Ve], (e2, [t2]) => Math.atan(t2.evaluate(e2))], min: [Ve, Vn(Ve), (e2, t2) => Math.min(...t2.map((t3) => t3.evaluate(e2)))], max: [Ve, Vn(Ve), (e2, t2) => Math.max(...t2.map((t3) => t3.evaluate(e2)))], abs: [Ve, [Ve], (e2, [t2]) => Math.abs(t2.evaluate(e2))], round: [Ve, [Ve], (e2, [t2]) => {
	      const r2 = t2.evaluate(e2);
	      return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
	    }], floor: [Ve, [Ve], (e2, [t2]) => Math.floor(t2.evaluate(e2))], ceil: [Ve, [Ve], (e2, [t2]) => Math.ceil(t2.evaluate(e2))], "filter-==": [Le, [Ce, $e], (e2, [t2, r2]) => e2.properties()[t2.value] === r2.value], "filter-id-==": [Le, [$e], (e2, [t2]) => e2.id() === t2.value], "filter-type-==": [Le, [Ce], (e2, [t2]) => e2.geometryType() === t2.value], "filter-<": [Le, [Ce, $e], (e2, [t2, r2]) => {
	      const n2 = e2.properties()[t2.value], i2 = r2.value;
	      return typeof n2 == typeof i2 && n2 < i2;
	    }], "filter-id-<": [Le, [$e], (e2, [t2]) => {
	      const r2 = e2.id(), n2 = t2.value;
	      return typeof r2 == typeof n2 && r2 < n2;
	    }], "filter->": [Le, [Ce, $e], (e2, [t2, r2]) => {
	      const n2 = e2.properties()[t2.value], i2 = r2.value;
	      return typeof n2 == typeof i2 && n2 > i2;
	    }], "filter-id->": [Le, [$e], (e2, [t2]) => {
	      const r2 = e2.id(), n2 = t2.value;
	      return typeof r2 == typeof n2 && r2 > n2;
	    }], "filter-<=": [Le, [Ce, $e], (e2, [t2, r2]) => {
	      const n2 = e2.properties()[t2.value], i2 = r2.value;
	      return typeof n2 == typeof i2 && n2 <= i2;
	    }], "filter-id-<=": [Le, [$e], (e2, [t2]) => {
	      const r2 = e2.id(), n2 = t2.value;
	      return typeof r2 == typeof n2 && r2 <= n2;
	    }], "filter->=": [Le, [Ce, $e], (e2, [t2, r2]) => {
	      const n2 = e2.properties()[t2.value], i2 = r2.value;
	      return typeof n2 == typeof i2 && n2 >= i2;
	    }], "filter-id->=": [Le, [$e], (e2, [t2]) => {
	      const r2 = e2.id(), n2 = t2.value;
	      return typeof r2 == typeof n2 && r2 >= n2;
	    }], "filter-has": [Le, [$e], (e2, [t2]) => t2.value in e2.properties()], "filter-has-id": [Le, [], (e2) => null !== e2.id() && void 0 !== e2.id()], "filter-type-in": [Le, [He(Ce)], (e2, [t2]) => t2.value.indexOf(e2.geometryType()) >= 0], "filter-id-in": [Le, [He($e)], (e2, [t2]) => t2.value.indexOf(e2.id()) >= 0], "filter-in-small": [Le, [Ce, He($e)], (e2, [t2, r2]) => r2.value.indexOf(e2.properties()[t2.value]) >= 0], "filter-in-large": [Le, [Ce, He($e)], (e2, [t2, r2]) => function(e3, t3, r3, n2) {
	      for (; r3 <= n2; ) {
	        const i2 = r3 + n2 >> 1;
	        if (t3[i2] === e3) return true;
	        t3[i2] > e3 ? n2 = i2 - 1 : r3 = i2 + 1;
	      }
	      return false;
	    }(e2.properties()[t2.value], r2.value, 0, r2.value.length - 1)], all: { type: Le, overloads: [[[Le, Le], (e2, [t2, r2]) => t2.evaluate(e2) && r2.evaluate(e2)], [Vn(Le), (e2, t2) => {
	      for (const r2 of t2) if (!r2.evaluate(e2)) return false;
	      return true;
	    }]] }, any: { type: Le, overloads: [[[Le, Le], (e2, [t2, r2]) => t2.evaluate(e2) || r2.evaluate(e2)], [Vn(Le), (e2, t2) => {
	      for (const r2 of t2) if (r2.evaluate(e2)) return true;
	      return false;
	    }]] }, "!": [Le, [Le], (e2, [t2]) => !t2.evaluate(e2)], "is-supported-script": [Le, [Ce], (e2, [t2]) => {
	      const r2 = e2.globals && e2.globals.isSupportedScript;
	      return !r2 || r2(t2.evaluate(e2));
	    }], upcase: [Ce, [Ce], (e2, [t2]) => t2.evaluate(e2).toUpperCase()], downcase: [Ce, [Ce], (e2, [t2]) => t2.evaluate(e2).toLowerCase()], concat: [Ce, Vn($e), (e2, t2) => t2.map((t3) => Ut(t3.evaluate(e2))).join("")], "resolved-locale": [Ce, [Ue], (e2, [t2]) => t2.evaluate(e2).resolvedLocale()] });
	    class ei {
	      constructor(e2, t2, r2) {
	        this.expression = e2, this._warningHistory = {}, this._evaluator = new Ht(), this._defaultValue = t2 ? function(e3) {
	          if ("color" === e3.type && Xn(e3.default)) return new It(0, 0, 0, 0);
	          switch (e3.type) {
	            case "color":
	              return It.parse(e3.default) || null;
	            case "padding":
	              return Dt.parse(e3.default) || null;
	            case "numberArray":
	              return Pt.parse(e3.default) || null;
	            case "colorArray":
	              return Bt.parse(e3.default) || null;
	            case "variableAnchorOffsetCollection":
	              return Ct.parse(e3.default) || null;
	            case "projectionDefinition":
	              return Ot.parse(e3.default) || null;
	            default:
	              return void 0 === e3.default ? null : e3.default;
	          }
	        }(t2) : null, this._enumValues = t2 && "enum" === t2.type ? t2.values : null, this._globalState = r2;
	      }
	      evaluateWithoutErrorHandling(e2, t2, r2, n2, i2, s2) {
	        return this._globalState && (e2 = ui(e2, this._globalState)), this._evaluator.globals = e2, this._evaluator.feature = t2, this._evaluator.featureState = r2, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this.expression.evaluate(this._evaluator);
	      }
	      evaluate(e2, t2, r2, n2, i2, s2) {
	        this._globalState && (e2 = ui(e2, this._globalState)), this._evaluator.globals = e2, this._evaluator.feature = t2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null;
	        try {
	          const e3 = this.expression.evaluate(this._evaluator);
	          if (null == e3 || "number" == typeof e3 && e3 != e3) return this._defaultValue;
	          if (this._enumValues && !(e3 in this._enumValues)) throw new zt(`Expected value to be one of ${Object.keys(this._enumValues).map((e4) => JSON.stringify(e4)).join(", ")}, but found ${JSON.stringify(e3)} instead.`);
	          return e3;
	        } catch (e3) {
	          return this._warningHistory[e3.message] || (this._warningHistory[e3.message] = true, "undefined" != typeof console && console.warn(e3.message)), this._defaultValue;
	        }
	      }
	    }
	    function ti(e2) {
	      return Array.isArray(e2) && e2.length > 0 && "string" == typeof e2[0] && e2[0] in Fn;
	    }
	    function ri(e2, t2, r2) {
	      const n2 = new Kt(Fn, Cn, [], t2 ? function(e3) {
	        const t3 = { color: Oe, string: Ce, number: Ve, enum: Ce, boolean: Le, formatted: qe, padding: je, numberArray: Xe, colorArray: Ge, projectionDefinition: Re, resolvedImage: Ye, variableAnchorOffsetCollection: Ze };
	        return "array" === e3.type ? He(t3[e3.value] || $e, e3.length) : t3[e3.type];
	      }(t2) : void 0), i2 = n2.parse(e2, void 0, void 0, void 0, t2 && "string" === t2.type ? { typeAnnotation: "coerce" } : void 0);
	      return i2 ? Nn(new ei(i2, t2, r2)) : $n(n2.errors);
	    }
	    class ni {
	      constructor(e2, t2, r2) {
	        this.kind = e2, this._styleExpression = t2, this.isStateDependent = "constant" !== e2 && !On(t2.expression), this.globalStateRefs = li(t2.expression), this._globalState = r2;
	      }
	      evaluateWithoutErrorHandling(e2, t2, r2, n2, i2, s2) {
	        return this._globalState && (e2 = ui(e2, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e2, t2, r2, n2, i2, s2);
	      }
	      evaluate(e2, t2, r2, n2, i2, s2) {
	        return this._globalState && (e2 = ui(e2, this._globalState)), this._styleExpression.evaluate(e2, t2, r2, n2, i2, s2);
	      }
	    }
	    class ii {
	      constructor(e2, t2, r2, n2, i2) {
	        this.kind = e2, this.zoomStops = r2, this._styleExpression = t2, this.isStateDependent = "camera" !== e2 && !On(t2.expression), this.globalStateRefs = li(t2.expression), this.interpolationType = n2, this._globalState = i2;
	      }
	      evaluateWithoutErrorHandling(e2, t2, r2, n2, i2, s2) {
	        return this._globalState && (e2 = ui(e2, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e2, t2, r2, n2, i2, s2);
	      }
	      evaluate(e2, t2, r2, n2, i2, s2) {
	        return this._globalState && (e2 = ui(e2, this._globalState)), this._styleExpression.evaluate(e2, t2, r2, n2, i2, s2);
	      }
	      interpolationFactor(e2, t2, r2) {
	        return this.interpolationType ? pr.interpolationFactor(this.interpolationType, e2, t2, r2) : 0;
	      }
	    }
	    function si(e2, t2, r2) {
	      const n2 = ri(e2, t2, r2);
	      if ("error" === n2.result) return n2;
	      const i2 = n2.value.expression, s2 = Ln(i2);
	      if (!s2 && !Un(t2)) return $n([new Pe("", "data expressions not supported")]);
	      const o2 = Rn(i2, ["zoom"]);
	      if (!o2 && !qn(t2)) return $n([new Pe("", "zoom expressions not supported")]);
	      const a2 = ai(i2);
	      return a2 || o2 ? a2 instanceof Pe ? $n([a2]) : a2 instanceof pr && !jn(t2) ? $n([new Pe("", '"interpolate" expressions cannot be used with this property')]) : Nn(a2 ? new ii(s2 ? "camera" : "composite", n2.value, a2.labels, a2 instanceof pr ? a2.interpolation : void 0, r2) : new ni(s2 ? "constant" : "source", n2.value, r2)) : $n([new Pe("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
	    }
	    class oi {
	      constructor(e2, t2) {
	        this._parameters = e2, this._specification = t2, De(this, Zn(this._parameters, this._specification));
	      }
	      static deserialize(e2) {
	        return new oi(e2._parameters, e2._specification);
	      }
	      static serialize(e2) {
	        return { _parameters: e2._parameters, _specification: e2._specification };
	      }
	    }
	    function ai(e2) {
	      let t2 = null;
	      if (e2 instanceof Wt) t2 = ai(e2.result);
	      else if (e2 instanceof yr) {
	        for (const r2 of e2.args) if (t2 = ai(r2), t2) break;
	      } else (e2 instanceof or || e2 instanceof pr) && e2.input instanceof Dn && "zoom" === e2.input.name && (t2 = e2);
	      return t2 instanceof Pe || e2.eachChild((e3) => {
	        const r2 = ai(e3);
	        r2 instanceof Pe ? t2 = r2 : !t2 && r2 ? t2 = new Pe("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t2 && r2 && t2 !== r2 && (t2 = new Pe("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
	      }), t2;
	    }
	    function li(e2, t2 = /* @__PURE__ */ new Set()) {
	      return e2 instanceof kn && t2.add(e2.key), e2.eachChild((e3) => {
	        li(e3, t2);
	      }), t2;
	    }
	    function ui(e2, t2) {
	      const { zoom: r2, heatmapDensity: n2, elevation: i2, lineProgress: s2, isSupportedScript: o2, accumulated: a2 } = null != e2 ? e2 : {};
	      return { zoom: r2, heatmapDensity: n2, elevation: i2, lineProgress: s2, isSupportedScript: o2, accumulated: a2, globalState: t2 };
	    }
	    function ci(e2) {
	      if (true === e2 || false === e2) return true;
	      if (!Array.isArray(e2) || 0 === e2.length) return false;
	      switch (e2[0]) {
	        case "has":
	          return e2.length >= 2 && "$id" !== e2[1] && "$type" !== e2[1];
	        case "in":
	          return e2.length >= 3 && ("string" != typeof e2[1] || Array.isArray(e2[2]));
	        case "!in":
	        case "!has":
	        case "none":
	          return false;
	        case "==":
	        case "!=":
	        case ">":
	        case ">=":
	        case "<":
	        case "<=":
	          return 3 !== e2.length || Array.isArray(e2[1]) || Array.isArray(e2[2]);
	        case "any":
	        case "all":
	          for (const t2 of e2.slice(1)) if (!ci(t2) && "boolean" != typeof t2) return false;
	          return true;
	        default:
	          return true;
	      }
	    }
	    const hi = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
	    function pi(e2, t2) {
	      if (null == e2) return { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
	      ci(e2) || (e2 = yi(e2));
	      const r2 = ri(e2, hi, t2);
	      if ("error" === r2.result) throw new Error(r2.value.map((e3) => `${e3.key}: ${e3.message}`).join(", "));
	      return { filter: (e3, t3, n2) => r2.value.evaluate(e3, t3, {}, n2), needGeometry: di(e2), getGlobalStateRefs: () => li(r2.value.expression) };
	    }
	    function fi(e2, t2) {
	      return e2 < t2 ? -1 : e2 > t2 ? 1 : 0;
	    }
	    function di(e2) {
	      if (!Array.isArray(e2)) return false;
	      if ("within" === e2[0] || "distance" === e2[0]) return true;
	      for (let t2 = 1; t2 < e2.length; t2++) if (di(e2[t2])) return true;
	      return false;
	    }
	    function yi(e2) {
	      if (!e2) return true;
	      const t2 = e2[0];
	      return e2.length <= 1 ? "any" !== t2 : "==" === t2 ? mi(e2[1], e2[2], "==") : "!=" === t2 ? vi(mi(e2[1], e2[2], "==")) : "<" === t2 || ">" === t2 || "<=" === t2 || ">=" === t2 ? mi(e2[1], e2[2], t2) : "any" === t2 ? (r2 = e2.slice(1), ["any"].concat(r2.map(yi))) : "all" === t2 ? ["all"].concat(e2.slice(1).map(yi)) : "none" === t2 ? ["all"].concat(e2.slice(1).map(yi).map(vi)) : "in" === t2 ? gi(e2[1], e2.slice(2)) : "!in" === t2 ? vi(gi(e2[1], e2.slice(2))) : "has" === t2 ? xi(e2[1]) : "!has" !== t2 || vi(xi(e2[1]));
	      var r2;
	    }
	    function mi(e2, t2, r2) {
	      switch (e2) {
	        case "$type":
	          return [`filter-type-${r2}`, t2];
	        case "$id":
	          return [`filter-id-${r2}`, t2];
	        default:
	          return [`filter-${r2}`, e2, t2];
	      }
	    }
	    function gi(e2, t2) {
	      if (0 === t2.length) return false;
	      switch (e2) {
	        case "$type":
	          return ["filter-type-in", ["literal", t2]];
	        case "$id":
	          return ["filter-id-in", ["literal", t2]];
	        default:
	          return t2.length > 200 && !t2.some((e3) => typeof e3 != typeof t2[0]) ? ["filter-in-large", e2, ["literal", t2.sort(fi)]] : ["filter-in-small", e2, ["literal", t2]];
	      }
	    }
	    function xi(e2) {
	      switch (e2) {
	        case "$type":
	          return true;
	        case "$id":
	          return ["filter-has-id"];
	        default:
	          return ["filter-has", e2];
	      }
	    }
	    function vi(e2) {
	      return ["!", e2];
	    }
	    function bi(e2) {
	      const t2 = typeof e2;
	      if ("number" === t2 || "boolean" === t2 || "string" === t2 || null == e2) return JSON.stringify(e2);
	      if (Array.isArray(e2)) {
	        let t3 = "[";
	        for (const r3 of e2) t3 += `${bi(r3)},`;
	        return `${t3}]`;
	      }
	      const r2 = Object.keys(e2).sort();
	      let n2 = "{";
	      for (let t3 = 0; t3 < r2.length; t3++) n2 += `${JSON.stringify(r2[t3])}:${bi(e2[r2[t3]])},`;
	      return `${n2}}`;
	    }
	    function wi(e2) {
	      let t2 = "";
	      for (const r2 of ve) t2 += `/${bi(e2[r2])}`;
	      return t2;
	    }
	    function _i(e2) {
	      const t2 = e2.value;
	      return t2 ? [new Fe(e2.key, t2, "constants have been deprecated as of v8")] : [];
	    }
	    function Si(e2) {
	      return e2 instanceof Number || e2 instanceof String || e2 instanceof Boolean ? e2.valueOf() : e2;
	    }
	    function Ai(e2) {
	      if (Array.isArray(e2)) return e2.map(Ai);
	      if (e2 instanceof Object && !(e2 instanceof Number || e2 instanceof String || e2 instanceof Boolean)) {
	        const t2 = {};
	        for (const r2 in e2) t2[r2] = Ai(e2[r2]);
	        return t2;
	      }
	      return Si(e2);
	    }
	    function Ti(e2) {
	      const t2 = e2.key, r2 = e2.value, n2 = e2.valueSpec || {}, i2 = e2.objectElementValidators || {}, s2 = e2.style, o2 = e2.styleSpec, a2 = e2.validateSpec;
	      let l2 = [];
	      const u2 = Gn(r2);
	      if ("object" !== u2) return [new Fe(t2, r2, `object expected, ${u2} found`)];
	      for (const e3 in r2) {
	        const u3 = e3.split(".")[0], c2 = xt(n2, u3) || n2["*"];
	        let h2;
	        if (xt(i2, u3)) h2 = i2[u3];
	        else if (xt(n2, u3)) h2 = a2;
	        else if (i2["*"]) h2 = i2["*"];
	        else {
	          if (!n2["*"]) {
	            l2.push(new Fe(t2, r2[e3], `unknown property "${e3}"`));
	            continue;
	          }
	          h2 = a2;
	        }
	        l2 = l2.concat(h2({ key: (t2 ? `${t2}.` : t2) + e3, value: r2[e3], valueSpec: c2, style: s2, styleSpec: o2, object: r2, objectKey: e3, validateSpec: a2 }, r2));
	      }
	      for (const e3 in n2) i2[e3] || n2[e3].required && void 0 === n2[e3].default && void 0 === r2[e3] && l2.push(new Fe(t2, r2, `missing required property "${e3}"`));
	      return l2;
	    }
	    function Ii(e2) {
	      const t2 = e2.value, r2 = e2.valueSpec, n2 = e2.style, i2 = e2.styleSpec, s2 = e2.key, o2 = e2.arrayElementValidator || e2.validateSpec;
	      if ("array" !== Gn(t2)) return [new Fe(s2, t2, `array expected, ${Gn(t2)} found`)];
	      if (r2.length && t2.length !== r2.length) return [new Fe(s2, t2, `array length ${r2.length} expected, length ${t2.length} found`)];
	      if (r2["min-length"] && t2.length < r2["min-length"]) return [new Fe(s2, t2, `array length at least ${r2["min-length"]} expected, length ${t2.length} found`)];
	      let a2 = { type: r2.value, values: r2.values };
	      i2.$version < 7 && (a2.function = r2.function), "object" === Gn(r2.value) && (a2 = r2.value);
	      let l2 = [];
	      for (let r3 = 0; r3 < t2.length; r3++) l2 = l2.concat(o2({ array: t2, arrayIndex: r3, value: t2[r3], valueSpec: a2, validateSpec: e2.validateSpec, style: n2, styleSpec: i2, key: `${s2}[${r3}]` }));
	      return l2;
	    }
	    function Ei(e2) {
	      const t2 = e2.key, r2 = e2.value, n2 = e2.valueSpec;
	      let i2 = Gn(r2);
	      return "number" === i2 && r2 != r2 && (i2 = "NaN"), "number" !== i2 ? [new Fe(t2, r2, `number expected, ${i2} found`)] : "minimum" in n2 && r2 < n2.minimum ? [new Fe(t2, r2, `${r2} is less than the minimum value ${n2.minimum}`)] : "maximum" in n2 && r2 > n2.maximum ? [new Fe(t2, r2, `${r2} is greater than the maximum value ${n2.maximum}`)] : [];
	    }
	    function Mi(e2) {
	      const t2 = e2.valueSpec, r2 = Si(e2.value.type);
	      let n2, i2, s2, o2 = {};
	      const a2 = "categorical" !== r2 && void 0 === e2.value.property, l2 = !a2, u2 = "array" === Gn(e2.value.stops) && "array" === Gn(e2.value.stops[0]) && "object" === Gn(e2.value.stops[0][0]), c2 = Ti({ key: e2.key, value: e2.value, valueSpec: e2.styleSpec.function, validateSpec: e2.validateSpec, style: e2.style, styleSpec: e2.styleSpec, objectElementValidators: { stops: function(e3) {
	        if ("identity" === r2) return [new Fe(e3.key, e3.value, 'identity function may not have a "stops" property')];
	        let t3 = [];
	        const n3 = e3.value;
	        return t3 = t3.concat(Ii({ key: e3.key, value: n3, valueSpec: e3.valueSpec, validateSpec: e3.validateSpec, style: e3.style, styleSpec: e3.styleSpec, arrayElementValidator: h2 })), "array" === Gn(n3) && 0 === n3.length && t3.push(new Fe(e3.key, n3, "array must have at least one stop")), t3;
	      }, default: function(e3) {
	        return e3.validateSpec({ key: e3.key, value: e3.value, valueSpec: t2, validateSpec: e3.validateSpec, style: e3.style, styleSpec: e3.styleSpec });
	      } } });
	      return "identity" === r2 && a2 && c2.push(new Fe(e2.key, e2.value, 'missing required property "property"')), "identity" === r2 || e2.value.stops || c2.push(new Fe(e2.key, e2.value, 'missing required property "stops"')), "exponential" === r2 && e2.valueSpec.expression && !jn(e2.valueSpec) && c2.push(new Fe(e2.key, e2.value, "exponential functions not supported")), e2.styleSpec.$version >= 8 && (l2 && !Un(e2.valueSpec) ? c2.push(new Fe(e2.key, e2.value, "property functions not supported")) : a2 && !qn(e2.valueSpec) && c2.push(new Fe(e2.key, e2.value, "zoom functions not supported"))), "categorical" !== r2 && !u2 || void 0 !== e2.value.property || c2.push(new Fe(e2.key, e2.value, '"property" property is required')), c2;
	      function h2(e3) {
	        let r3 = [];
	        const n3 = e3.value, a3 = e3.key;
	        if ("array" !== Gn(n3)) return [new Fe(a3, n3, `array expected, ${Gn(n3)} found`)];
	        if (2 !== n3.length) return [new Fe(a3, n3, `array length 2 expected, length ${n3.length} found`)];
	        if (u2) {
	          if ("object" !== Gn(n3[0])) return [new Fe(a3, n3, `object expected, ${Gn(n3[0])} found`)];
	          if (void 0 === n3[0].zoom) return [new Fe(a3, n3, "object stop key must have zoom")];
	          if (void 0 === n3[0].value) return [new Fe(a3, n3, "object stop key must have value")];
	          if (s2 && s2 > Si(n3[0].zoom)) return [new Fe(a3, n3[0].zoom, "stop zoom values must appear in ascending order")];
	          Si(n3[0].zoom) !== s2 && (s2 = Si(n3[0].zoom), i2 = void 0, o2 = {}), r3 = r3.concat(Ti({ key: `${a3}[0]`, value: n3[0], valueSpec: { zoom: {} }, validateSpec: e3.validateSpec, style: e3.style, styleSpec: e3.styleSpec, objectElementValidators: { zoom: Ei, value: p2 } }));
	        } else r3 = r3.concat(p2({ key: `${a3}[0]`, value: n3[0], validateSpec: e3.validateSpec, style: e3.style, styleSpec: e3.styleSpec }, n3));
	        return ti(Ai(n3[1])) ? r3.concat([new Fe(`${a3}[1]`, n3[1], "expressions are not allowed in function stops.")]) : r3.concat(e3.validateSpec({ key: `${a3}[1]`, value: n3[1], valueSpec: t2, validateSpec: e3.validateSpec, style: e3.style, styleSpec: e3.styleSpec }));
	      }
	      function p2(e3, s3) {
	        const a3 = Gn(e3.value), l3 = Si(e3.value), u3 = null !== e3.value ? e3.value : s3;
	        if (n2) {
	          if (a3 !== n2) return [new Fe(e3.key, u3, `${a3} stop domain type must match previous stop domain type ${n2}`)];
	        } else n2 = a3;
	        if ("number" !== a3 && "string" !== a3 && "boolean" !== a3) return [new Fe(e3.key, u3, "stop domain value must be a number, string, or boolean")];
	        if ("number" !== a3 && "categorical" !== r2) {
	          let n3 = `number expected, ${a3} found`;
	          return Un(t2) && void 0 === r2 && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Fe(e3.key, u3, n3)];
	        }
	        return "categorical" !== r2 || "number" !== a3 || isFinite(l3) && Math.floor(l3) === l3 ? "categorical" !== r2 && "number" === a3 && void 0 !== i2 && l3 < i2 ? [new Fe(e3.key, u3, "stop domain values must appear in ascending order")] : (i2 = l3, "categorical" === r2 && l3 in o2 ? [new Fe(e3.key, u3, "stop domain values must be unique")] : (o2[l3] = true, [])) : [new Fe(e3.key, u3, `integer expected, found ${l3}`)];
	      }
	    }
	    function ki(e2) {
	      const t2 = ("property" === e2.expressionContext ? si : ri)(Ai(e2.value), e2.valueSpec);
	      if ("error" === t2.result) return t2.value.map((t3) => new Fe(`${e2.key}${t3.key}`, e2.value, t3.message));
	      const r2 = t2.value.expression || t2.value._styleExpression.expression;
	      if ("property" === e2.expressionContext && "text-font" === e2.propertyKey && !r2.outputDefined()) return [new Fe(e2.key, e2.value, `Invalid data expression for "${e2.propertyKey}". Output values must be contained as literals within the expression.`)];
	      if ("property" === e2.expressionContext && "layout" === e2.propertyType && !On(r2)) return [new Fe(e2.key, e2.value, '"feature-state" data expressions are not supported with layout properties.')];
	      if ("filter" === e2.expressionContext && !On(r2)) return [new Fe(e2.key, e2.value, '"feature-state" data expressions are not supported with filters.')];
	      if (e2.expressionContext && 0 === e2.expressionContext.indexOf("cluster")) {
	        if (!Rn(r2, ["zoom", "feature-state"])) return [new Fe(e2.key, e2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
	        if ("cluster-initial" === e2.expressionContext && !Ln(r2)) return [new Fe(e2.key, e2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
	      }
	      return [];
	    }
	    function Fi(e2) {
	      const t2 = e2.key, r2 = e2.value, n2 = Gn(r2);
	      return "string" !== n2 ? [new Fe(t2, r2, `color expected, ${n2} found`)] : It.parse(String(r2)) ? [] : [new Fe(t2, r2, `color expected, "${r2}" found`)];
	    }
	    function Di(e2) {
	      const t2 = e2.key, r2 = e2.value, n2 = e2.valueSpec, i2 = [];
	      return Array.isArray(n2.values) ? -1 === n2.values.indexOf(Si(r2)) && i2.push(new Fe(t2, r2, `expected one of [${n2.values.join(", ")}], ${JSON.stringify(r2)} found`)) : -1 === Object.keys(n2.values).indexOf(Si(r2)) && i2.push(new Fe(t2, r2, `expected one of [${Object.keys(n2.values).join(", ")}], ${JSON.stringify(r2)} found`)), i2;
	    }
	    function Pi(e2) {
	      return ci(Ai(e2.value)) ? ki(De({}, e2, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Bi(e2);
	    }
	    function Bi(e2) {
	      const t2 = e2.value, r2 = e2.key;
	      if ("array" !== Gn(t2)) return [new Fe(r2, t2, `array expected, ${Gn(t2)} found`)];
	      const n2 = e2.styleSpec;
	      let i2, s2 = [];
	      if (t2.length < 1) return [new Fe(r2, t2, "filter array must have at least 1 element")];
	      switch (s2 = s2.concat(Di({ key: `${r2}[0]`, value: t2[0], valueSpec: n2.filter_operator, style: e2.style, styleSpec: e2.styleSpec })), Si(t2[0])) {
	        case "<":
	        case "<=":
	        case ">":
	        case ">=":
	          t2.length >= 2 && "$type" === Si(t2[1]) && s2.push(new Fe(r2, t2, `"$type" cannot be use with operator "${t2[0]}"`));
	        case "==":
	        case "!=":
	          3 !== t2.length && s2.push(new Fe(r2, t2, `filter array for operator "${t2[0]}" must have 3 elements`));
	        case "in":
	        case "!in":
	          t2.length >= 2 && (i2 = Gn(t2[1]), "string" !== i2 && s2.push(new Fe(`${r2}[1]`, t2[1], `string expected, ${i2} found`)));
	          for (let o2 = 2; o2 < t2.length; o2++) i2 = Gn(t2[o2]), "$type" === Si(t2[1]) ? s2 = s2.concat(Di({ key: `${r2}[${o2}]`, value: t2[o2], valueSpec: n2.geometry_type, style: e2.style, styleSpec: e2.styleSpec })) : "string" !== i2 && "number" !== i2 && "boolean" !== i2 && s2.push(new Fe(`${r2}[${o2}]`, t2[o2], `string, number, or boolean expected, ${i2} found`));
	          break;
	        case "any":
	        case "all":
	        case "none":
	          for (let n3 = 1; n3 < t2.length; n3++) s2 = s2.concat(Bi({ key: `${r2}[${n3}]`, value: t2[n3], style: e2.style, styleSpec: e2.styleSpec }));
	          break;
	        case "has":
	        case "!has":
	          i2 = Gn(t2[1]), 2 !== t2.length ? s2.push(new Fe(r2, t2, `filter array for "${t2[0]}" operator must have 2 elements`)) : "string" !== i2 && s2.push(new Fe(`${r2}[1]`, t2[1], `string expected, ${i2} found`));
	      }
	      return s2;
	    }
	    function zi(e2, t2) {
	      const r2 = e2.key, n2 = e2.validateSpec, i2 = e2.style, s2 = e2.styleSpec, o2 = e2.value, a2 = e2.objectKey, l2 = s2[`${t2}_${e2.layerType}`];
	      if (!l2) return [];
	      const u2 = a2.match(/^(.*)-transition$/);
	      if ("paint" === t2 && u2 && l2[u2[1]] && l2[u2[1]].transition) return n2({ key: r2, value: o2, valueSpec: s2.transition, style: i2, styleSpec: s2 });
	      const c2 = e2.valueSpec || l2[a2];
	      if (!c2) return [new Fe(r2, o2, `unknown property "${a2}"`)];
	      let h2;
	      if ("string" === Gn(o2) && Un(c2) && !c2.tokens && (h2 = /^{([^}]+)}$/.exec(o2))) return [new Fe(r2, o2, `"${a2}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h2[1])} }\`.`)];
	      const p2 = [];
	      return "symbol" === e2.layerType && "text-font" === a2 && Xn(Ai(o2)) && "identity" === Si(o2.type) && p2.push(new Fe(r2, o2, '"text-font" does not support identity functions')), p2.concat(n2({ key: e2.key, value: o2, valueSpec: c2, style: i2, styleSpec: s2, expressionContext: "property", propertyType: t2, propertyKey: a2 }));
	    }
	    function Vi(e2) {
	      return zi(e2, "paint");
	    }
	    function Ci(e2) {
	      return zi(e2, "layout");
	    }
	    function Li(e2) {
	      let t2 = [];
	      const r2 = e2.value, n2 = e2.key, i2 = e2.style, s2 = e2.styleSpec;
	      if ("object" !== Gn(r2)) return [new Fe(n2, r2, `object expected, ${Gn(r2)} found`)];
	      r2.type || r2.ref || t2.push(new Fe(n2, r2, 'either "type" or "ref" is required'));
	      let o2 = Si(r2.type);
	      const a2 = Si(r2.ref);
	      if (r2.id) {
	        const s3 = Si(r2.id);
	        for (let o3 = 0; o3 < e2.arrayIndex; o3++) {
	          const e3 = i2.layers[o3];
	          Si(e3.id) === s3 && t2.push(new Fe(n2, r2.id, `duplicate layer id "${r2.id}", previously used at line ${e3.id.__line__}`));
	        }
	      }
	      if ("ref" in r2) {
	        let e3;
	        ["type", "source", "source-layer", "filter", "layout"].forEach((e4) => {
	          e4 in r2 && t2.push(new Fe(n2, r2[e4], `"${e4}" is prohibited for ref layers`));
	        }), i2.layers.forEach((t3) => {
	          Si(t3.id) === a2 && (e3 = t3);
	        }), e3 ? e3.ref ? t2.push(new Fe(n2, r2.ref, "ref cannot reference another ref layer")) : o2 = Si(e3.type) : t2.push(new Fe(n2, r2.ref, `ref layer "${a2}" not found`));
	      } else if ("background" !== o2) if (r2.source) {
	        const e3 = i2.sources && i2.sources[r2.source], s3 = e3 && Si(e3.type);
	        e3 ? "vector" === s3 && "raster" === o2 ? t2.push(new Fe(n2, r2.source, `layer "${r2.id}" requires a raster source`)) : "raster-dem" !== s3 && "hillshade" === o2 || "raster-dem" !== s3 && "color-relief" === o2 ? t2.push(new Fe(n2, r2.source, `layer "${r2.id}" requires a raster-dem source`)) : "raster" === s3 && "raster" !== o2 ? t2.push(new Fe(n2, r2.source, `layer "${r2.id}" requires a vector source`)) : "vector" !== s3 || r2["source-layer"] ? "raster-dem" === s3 && "hillshade" !== o2 && "color-relief" !== o2 ? t2.push(new Fe(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : "line" !== o2 || !r2.paint || !r2.paint["line-gradient"] || "geojson" === s3 && e3.lineMetrics || t2.push(new Fe(n2, r2, `layer "${r2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t2.push(new Fe(n2, r2, `layer "${r2.id}" must specify a "source-layer"`)) : t2.push(new Fe(n2, r2.source, `source "${r2.source}" not found`));
	      } else t2.push(new Fe(n2, r2, 'missing required property "source"'));
	      return t2 = t2.concat(Ti({ key: n2, value: r2, valueSpec: s2.layer, style: e2.style, styleSpec: e2.styleSpec, validateSpec: e2.validateSpec, objectElementValidators: { "*": () => [], type: () => e2.validateSpec({ key: `${n2}.type`, value: r2.type, valueSpec: s2.layer.type, style: e2.style, styleSpec: e2.styleSpec, validateSpec: e2.validateSpec, object: r2, objectKey: "type" }), filter: Pi, layout: (e3) => Ti({ layer: r2, key: e3.key, value: e3.value, style: e3.style, styleSpec: e3.styleSpec, validateSpec: e3.validateSpec, objectElementValidators: { "*": (e4) => Ci(De({ layerType: o2 }, e4)) } }), paint: (e3) => Ti({ layer: r2, key: e3.key, value: e3.value, style: e3.style, styleSpec: e3.styleSpec, validateSpec: e3.validateSpec, objectElementValidators: { "*": (e4) => Vi(De({ layerType: o2 }, e4)) } }) } })), t2;
	    }
	    function Oi(e2) {
	      const t2 = e2.value, r2 = e2.key, n2 = Gn(t2);
	      return "string" !== n2 ? [new Fe(r2, t2, `string expected, ${n2} found`)] : [];
	    }
	    const Ri = { promoteId: function({ key: e2, value: t2 }) {
	      if ("string" === Gn(t2)) return Oi({ key: e2, value: t2 });
	      {
	        const r2 = [];
	        for (const n2 in t2) r2.push(...Oi({ key: `${e2}.${n2}`, value: t2[n2] }));
	        return r2;
	      }
	    } };
	    function Ni(e2) {
	      const t2 = e2.value, r2 = e2.key, n2 = e2.styleSpec, i2 = e2.style, s2 = e2.validateSpec;
	      if (!t2.type) return [new Fe(r2, t2, '"type" is required')];
	      const o2 = Si(t2.type);
	      let a2;
	      switch (o2) {
	        case "vector":
	        case "raster":
	          return a2 = Ti({ key: r2, value: t2, valueSpec: n2[`source_${o2.replace("-", "_")}`], style: e2.style, styleSpec: n2, objectElementValidators: Ri, validateSpec: s2 }), a2;
	        case "raster-dem":
	          return a2 = function(e3) {
	            var t3;
	            const r3 = null !== (t3 = e3.sourceName) && void 0 !== t3 ? t3 : "", n3 = e3.value, i3 = e3.styleSpec, s3 = i3.source_raster_dem, o3 = e3.style;
	            let a3 = [];
	            const l2 = Gn(n3);
	            if (void 0 === n3) return a3;
	            if ("object" !== l2) return a3.push(new Fe("source_raster_dem", n3, `object expected, ${l2} found`)), a3;
	            const u2 = "custom" === Si(n3.encoding), c2 = ["redFactor", "greenFactor", "blueFactor", "baseShift"], h2 = e3.value.encoding ? `"${e3.value.encoding}"` : "Default";
	            for (const t4 in n3) !u2 && c2.includes(t4) ? a3.push(new Fe(t4, n3[t4], `In "${r3}": "${t4}" is only valid when "encoding" is set to "custom". ${h2} encoding found`)) : s3[t4] ? a3 = a3.concat(e3.validateSpec({ key: t4, value: n3[t4], valueSpec: s3[t4], validateSpec: e3.validateSpec, style: o3, styleSpec: i3 })) : a3.push(new Fe(t4, n3[t4], `unknown property "${t4}"`));
	            return a3;
	          }({ sourceName: r2, value: t2, style: e2.style, styleSpec: n2, validateSpec: s2 }), a2;
	        case "geojson":
	          if (a2 = Ti({ key: r2, value: t2, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, validateSpec: s2, objectElementValidators: Ri }), t2.cluster) for (const e3 in t2.clusterProperties) {
	            const [n3, i3] = t2.clusterProperties[e3], s3 = "string" == typeof n3 ? [n3, ["accumulated"], ["get", e3]] : n3;
	            a2.push(...ki({ key: `${r2}.${e3}.map`, value: i3, expressionContext: "cluster-map" })), a2.push(...ki({ key: `${r2}.${e3}.reduce`, value: s3, expressionContext: "cluster-reduce" }));
	          }
	          return a2;
	        case "video":
	          return Ti({ key: r2, value: t2, valueSpec: n2.source_video, style: i2, validateSpec: s2, styleSpec: n2 });
	        case "image":
	          return Ti({ key: r2, value: t2, valueSpec: n2.source_image, style: i2, validateSpec: s2, styleSpec: n2 });
	        case "canvas":
	          return [new Fe(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
	        default:
	          return Di({ key: `${r2}.type`, value: t2.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
	      }
	    }
	    function $i(e2) {
	      const t2 = e2.value, r2 = e2.styleSpec, n2 = r2.light, i2 = e2.style;
	      let s2 = [];
	      const o2 = Gn(t2);
	      if (void 0 === t2) return s2;
	      if ("object" !== o2) return s2 = s2.concat([new Fe("light", t2, `object expected, ${o2} found`)]), s2;
	      for (const o3 in t2) {
	        const a2 = o3.match(/^(.*)-transition$/);
	        s2 = s2.concat(a2 && n2[a2[1]] && n2[a2[1]].transition ? e2.validateSpec({ key: o3, value: t2[o3], valueSpec: r2.transition, validateSpec: e2.validateSpec, style: i2, styleSpec: r2 }) : n2[o3] ? e2.validateSpec({ key: o3, value: t2[o3], valueSpec: n2[o3], validateSpec: e2.validateSpec, style: i2, styleSpec: r2 }) : [new Fe(o3, t2[o3], `unknown property "${o3}"`)]);
	      }
	      return s2;
	    }
	    function Ui(e2) {
	      const t2 = e2.value, r2 = e2.styleSpec, n2 = r2.sky, i2 = e2.style, s2 = Gn(t2);
	      if (void 0 === t2) return [];
	      if ("object" !== s2) return [new Fe("sky", t2, `object expected, ${s2} found`)];
	      let o2 = [];
	      for (const s3 in t2) o2 = o2.concat(n2[s3] ? e2.validateSpec({ key: s3, value: t2[s3], valueSpec: n2[s3], style: i2, styleSpec: r2 }) : [new Fe(s3, t2[s3], `unknown property "${s3}"`)]);
	      return o2;
	    }
	    function qi(e2) {
	      const t2 = e2.value, r2 = e2.styleSpec, n2 = r2.terrain, i2 = e2.style;
	      let s2 = [];
	      const o2 = Gn(t2);
	      if (void 0 === t2) return s2;
	      if ("object" !== o2) return s2 = s2.concat([new Fe("terrain", t2, `object expected, ${o2} found`)]), s2;
	      for (const o3 in t2) s2 = s2.concat(n2[o3] ? e2.validateSpec({ key: o3, value: t2[o3], valueSpec: n2[o3], validateSpec: e2.validateSpec, style: i2, styleSpec: r2 }) : [new Fe(o3, t2[o3], `unknown property "${o3}"`)]);
	      return s2;
	    }
	    function ji(e2) {
	      let t2 = [];
	      const r2 = e2.value, n2 = e2.key;
	      if (Array.isArray(r2)) {
	        const i2 = [], s2 = [];
	        for (const o2 in r2) r2[o2].id && i2.includes(r2[o2].id) && t2.push(new Fe(n2, r2, `all the sprites' ids must be unique, but ${r2[o2].id} is duplicated`)), i2.push(r2[o2].id), r2[o2].url && s2.includes(r2[o2].url) && t2.push(new Fe(n2, r2, `all the sprites' URLs must be unique, but ${r2[o2].url} is duplicated`)), s2.push(r2[o2].url), t2 = t2.concat(Ti({ key: `${n2}[${o2}]`, value: r2[o2], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: e2.validateSpec }));
	        return t2;
	      }
	      return Oi({ key: n2, value: r2 });
	    }
	    function Gi(e2) {
	      return t2 = e2.value, Boolean(t2) && t2.constructor === Object ? [] : [new Fe(e2.key, e2.value, `object expected, ${Gn(e2.value)} found`)];
	      var t2;
	    }
	    const Xi = { "*": () => [], array: Ii, boolean: function(e2) {
	      const t2 = e2.value, r2 = e2.key, n2 = Gn(t2);
	      return "boolean" !== n2 ? [new Fe(r2, t2, `boolean expected, ${n2} found`)] : [];
	    }, number: Ei, color: Fi, constants: _i, enum: Di, filter: Pi, function: Mi, layer: Li, object: Ti, source: Ni, light: $i, sky: Ui, terrain: qi, projection: function(e2) {
	      const t2 = e2.value, r2 = e2.styleSpec, n2 = r2.projection, i2 = e2.style, s2 = Gn(t2);
	      if (void 0 === t2) return [];
	      if ("object" !== s2) return [new Fe("projection", t2, `object expected, ${s2} found`)];
	      let o2 = [];
	      for (const s3 in t2) o2 = o2.concat(n2[s3] ? e2.validateSpec({ key: s3, value: t2[s3], valueSpec: n2[s3], style: i2, styleSpec: r2 }) : [new Fe(s3, t2[s3], `unknown property "${s3}"`)]);
	      return o2;
	    }, projectionDefinition: function(e2) {
	      const t2 = e2.key;
	      let r2 = e2.value;
	      r2 = r2 instanceof String ? r2.valueOf() : r2;
	      const n2 = Gn(r2);
	      return "array" !== n2 || function(e3) {
	        return Array.isArray(e3) && 3 === e3.length && "string" == typeof e3[0] && "string" == typeof e3[1] && "number" == typeof e3[2];
	      }(r2) || function(e3) {
	        return !!["interpolate", "step", "literal"].includes(e3[0]);
	      }(r2) ? ["array", "string"].includes(n2) ? [] : [new Fe(t2, r2, `projection expected, invalid type "${n2}" found`)] : [new Fe(t2, r2, `projection expected, invalid array ${JSON.stringify(r2)} found`)];
	    }, string: Oi, formatted: function(e2) {
	      return 0 === Oi(e2).length ? [] : ki(e2);
	    }, resolvedImage: function(e2) {
	      return 0 === Oi(e2).length ? [] : ki(e2);
	    }, padding: function(e2) {
	      const t2 = e2.key, r2 = e2.value;
	      if ("array" === Gn(r2)) {
	        if (r2.length < 1 || r2.length > 4) return [new Fe(t2, r2, `padding requires 1 to 4 values; ${r2.length} values found`)];
	        const n2 = { type: "number" };
	        let i2 = [];
	        for (let s2 = 0; s2 < r2.length; s2++) i2 = i2.concat(e2.validateSpec({ key: `${t2}[${s2}]`, value: r2[s2], validateSpec: e2.validateSpec, valueSpec: n2 }));
	        return i2;
	      }
	      return Ei({ key: t2, value: r2, valueSpec: {} });
	    }, numberArray: function(e2) {
	      const t2 = e2.key, r2 = e2.value;
	      if ("array" === Gn(r2)) {
	        const n2 = { type: "number" };
	        if (r2.length < 1) return [new Fe(t2, r2, "array length at least 1 expected, length 0 found")];
	        let i2 = [];
	        for (let s2 = 0; s2 < r2.length; s2++) i2 = i2.concat(e2.validateSpec({ key: `${t2}[${s2}]`, value: r2[s2], validateSpec: e2.validateSpec, valueSpec: n2 }));
	        return i2;
	      }
	      return Ei({ key: t2, value: r2, valueSpec: {} });
	    }, colorArray: function(e2) {
	      const t2 = e2.key, r2 = e2.value;
	      if ("array" === Gn(r2)) {
	        if (r2.length < 1) return [new Fe(t2, r2, "array length at least 1 expected, length 0 found")];
	        let e3 = [];
	        for (let n2 = 0; n2 < r2.length; n2++) e3 = e3.concat(Fi({ key: `${t2}[${n2}]`, value: r2[n2] }));
	        return e3;
	      }
	      return Fi({ key: t2, value: r2 });
	    }, variableAnchorOffsetCollection: function(e2) {
	      const t2 = e2.key, r2 = e2.value, n2 = Gn(r2), i2 = e2.styleSpec;
	      if ("array" !== n2 || r2.length < 1 || r2.length % 2 != 0) return [new Fe(t2, r2, "variableAnchorOffsetCollection requires a non-empty array of even length")];
	      let s2 = [];
	      for (let n3 = 0; n3 < r2.length; n3 += 2) s2 = s2.concat(Di({ key: `${t2}[${n3}]`, value: r2[n3], valueSpec: i2.layout_symbol["text-anchor"] })), s2 = s2.concat(Ii({ key: `${t2}[${n3 + 1}]`, value: r2[n3 + 1], valueSpec: { length: 2, value: "number" }, validateSpec: e2.validateSpec, style: e2.style, styleSpec: i2 }));
	      return s2;
	    }, sprite: ji, state: Gi };
	    function Yi(e2) {
	      const t2 = e2.value, r2 = e2.valueSpec, n2 = e2.styleSpec;
	      return e2.validateSpec = Yi, r2.expression && Xn(Si(t2)) ? Mi(e2) : r2.expression && ti(Ai(t2)) ? ki(e2) : r2.type && Xi[r2.type] ? Xi[r2.type](e2) : Ti(De({}, e2, { valueSpec: r2.type ? n2[r2.type] : r2 }));
	    }
	    function Zi(e2) {
	      const t2 = e2.value, r2 = e2.key, n2 = Oi(e2);
	      return n2.length || (-1 === t2.indexOf("{fontstack}") && n2.push(new Fe(r2, t2, '"glyphs" url must include a "{fontstack}" token')), -1 === t2.indexOf("{range}") && n2.push(new Fe(r2, t2, '"glyphs" url must include a "{range}" token'))), n2;
	    }
	    function Hi(e2, t2 = xe) {
	      let r2 = [];
	      return r2 = r2.concat(Yi({ key: "", value: e2, valueSpec: t2.$root, styleSpec: t2, style: e2, validateSpec: Yi, objectElementValidators: { glyphs: Zi, "*": () => [] } })), e2.constants && (r2 = r2.concat(_i({ key: "constants", value: e2.constants }))), Wi(r2);
	    }
	    function Ki(e2) {
	      return function(t2) {
	        return e2(Object.assign({}, t2, { validateSpec: Yi }));
	      };
	    }
	    function Wi(e2) {
	      return [].concat(e2).sort((e3, t2) => e3.line - t2.line);
	    }
	    function Ji(e2) {
	      return function(...t2) {
	        return Wi(e2.apply(this, t2));
	      };
	    }
	    Hi.source = Ji(Ki(Ni)), Hi.sprite = Ji(Ki(ji)), Hi.glyphs = Ji(Ki(Zi)), Hi.light = Ji(Ki($i)), Hi.sky = Ji(Ki(Ui)), Hi.terrain = Ji(Ki(qi)), Hi.state = Ji(Ki(Gi)), Hi.layer = Ji(Ki(Li)), Hi.filter = Ji(Ki(Pi)), Hi.paintProperty = Ji(Ki(Vi)), Hi.layoutProperty = Ji(Ki(Ci));
	    const Qi = xe, es = Hi, ts = es.light, rs = es.sky, ns = es.paintProperty, is = es.layoutProperty;
	    function ss(e2, t2) {
	      let r2 = false;
	      if (t2 && t2.length) for (const n2 of t2) e2.fire(new me(new Error(n2.message))), r2 = true;
	      return r2;
	    }
	    class os {
	      constructor(e2, t2, r2) {
	        const n2 = this.cells = [];
	        if (e2 instanceof ArrayBuffer) {
	          this.arrayBuffer = e2;
	          const i3 = new Int32Array(this.arrayBuffer);
	          e2 = i3[0], this.d = (t2 = i3[1]) + 2 * (r2 = i3[2]);
	          for (let e3 = 0; e3 < this.d * this.d; e3++) {
	            const t3 = i3[3 + e3], r3 = i3[3 + e3 + 1];
	            n2.push(t3 === r3 ? null : i3.subarray(t3, r3));
	          }
	          const s2 = i3[3 + n2.length + 1];
	          this.keys = i3.subarray(i3[3 + n2.length], s2), this.bboxes = i3.subarray(s2), this.insert = this._insertReadonly;
	        } else {
	          this.d = t2 + 2 * r2;
	          for (let e3 = 0; e3 < this.d * this.d; e3++) n2.push([]);
	          this.keys = [], this.bboxes = [];
	        }
	        this.n = t2, this.extent = e2, this.padding = r2, this.scale = t2 / e2, this.uid = 0;
	        const i2 = r2 / t2 * e2;
	        this.min = -i2, this.max = e2 + i2;
	      }
	      insert(e2, t2, r2, n2, i2) {
	        this._forEachCell(t2, r2, n2, i2, this._insertCell, this.uid++, void 0, void 0), this.keys.push(e2), this.bboxes.push(t2), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
	      }
	      _insertReadonly() {
	        throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
	      }
	      _insertCell(e2, t2, r2, n2, i2, s2) {
	        this.cells[i2].push(s2);
	      }
	      query(e2, t2, r2, n2, i2) {
	        const s2 = this.min, o2 = this.max;
	        if (e2 <= s2 && t2 <= s2 && o2 <= r2 && o2 <= n2 && !i2) return Array.prototype.slice.call(this.keys);
	        {
	          const s3 = [];
	          return this._forEachCell(e2, t2, r2, n2, this._queryCell, s3, {}, i2), s3;
	        }
	      }
	      _queryCell(e2, t2, r2, n2, i2, s2, o2, a2) {
	        const l2 = this.cells[i2];
	        if (null !== l2) {
	          const i3 = this.keys, u2 = this.bboxes;
	          for (let c2 = 0; c2 < l2.length; c2++) {
	            const h2 = l2[c2];
	            if (void 0 === o2[h2]) {
	              const l3 = 4 * h2;
	              (a2 ? a2(u2[l3 + 0], u2[l3 + 1], u2[l3 + 2], u2[l3 + 3]) : e2 <= u2[l3 + 2] && t2 <= u2[l3 + 3] && r2 >= u2[l3 + 0] && n2 >= u2[l3 + 1]) ? (o2[h2] = true, s2.push(i3[h2])) : o2[h2] = false;
	            }
	          }
	        }
	      }
	      _forEachCell(e2, t2, r2, n2, i2, s2, o2, a2) {
	        const l2 = this._convertToCellCoord(e2), u2 = this._convertToCellCoord(t2), c2 = this._convertToCellCoord(r2), h2 = this._convertToCellCoord(n2);
	        for (let p2 = l2; p2 <= c2; p2++) for (let l3 = u2; l3 <= h2; l3++) {
	          const u3 = this.d * l3 + p2;
	          if ((!a2 || a2(this._convertFromCellCoord(p2), this._convertFromCellCoord(l3), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(l3 + 1))) && i2.call(this, e2, t2, r2, n2, u3, s2, o2, a2)) return;
	        }
	      }
	      _convertFromCellCoord(e2) {
	        return (e2 - this.padding) / this.scale;
	      }
	      _convertToCellCoord(e2) {
	        return Math.max(0, Math.min(this.d - 1, Math.floor(e2 * this.scale) + this.padding));
	      }
	      toArrayBuffer() {
	        if (this.arrayBuffer) return this.arrayBuffer;
	        const e2 = this.cells, t2 = 3 + this.cells.length + 1 + 1;
	        let r2 = 0;
	        for (let e3 = 0; e3 < this.cells.length; e3++) r2 += this.cells[e3].length;
	        const n2 = new Int32Array(t2 + r2 + this.keys.length + this.bboxes.length);
	        n2[0] = this.extent, n2[1] = this.n, n2[2] = this.padding;
	        let i2 = t2;
	        for (let t3 = 0; t3 < e2.length; t3++) {
	          const r3 = e2[t3];
	          n2[3 + t3] = i2, n2.set(r3, i2), i2 += r3.length;
	        }
	        return n2[3 + e2.length] = i2, n2.set(this.keys, i2), i2 += this.keys.length, n2[3 + e2.length + 1] = i2, n2.set(this.bboxes, i2), i2 += this.bboxes.length, n2.buffer;
	      }
	      static serialize(e2, t2) {
	        const r2 = e2.toArrayBuffer();
	        return t2 && t2.push(r2), { buffer: r2 };
	      }
	      static deserialize(e2) {
	        return new os(e2.buffer);
	      }
	    }
	    const as = {};
	    function ls(e2, t2, r2 = {}) {
	      if (as[e2]) throw new Error(`${e2} is already registered.`);
	      Object.defineProperty(t2, "_classRegistryKey", { value: e2, writeable: false }), as[e2] = { klass: t2, omit: r2.omit || [], shallow: r2.shallow || [] };
	    }
	    ls("Object", Object), ls("Set", Set), ls("TransferableGridIndex", os), ls("Color", It), ls("Error", Error), ls("AJAXError", ue), ls("ResolvedImage", Lt), ls("StylePropertyFunction", oi), ls("StyleExpression", ei, { omit: ["_evaluator"] }), ls("ZoomDependentExpression", ii), ls("ZoomConstantExpression", ni), ls("CompoundExpression", Dn, { omit: ["_evaluate"] });
	    for (const e2 in Fn) Fn[e2]._classRegistryKey || ls(`Expression_${e2}`, Fn[e2]);
	    function us(e2) {
	      return e2 && "undefined" != typeof ArrayBuffer && (e2 instanceof ArrayBuffer || e2.constructor && "ArrayBuffer" === e2.constructor.name);
	    }
	    function cs(e2) {
	      return e2.$name || e2.constructor._classRegistryKey;
	    }
	    function hs(e2) {
	      return !function(e3) {
	        if (null === e3 || "object" != typeof e3) return false;
	        const t2 = cs(e3);
	        return !(!t2 || "Object" === t2);
	      }(e2) && (null == e2 || "boolean" == typeof e2 || "number" == typeof e2 || "string" == typeof e2 || e2 instanceof Boolean || e2 instanceof Number || e2 instanceof String || e2 instanceof Date || e2 instanceof RegExp || e2 instanceof Blob || e2 instanceof Error || us(e2) || Z(e2) || ArrayBuffer.isView(e2) || e2 instanceof ImageData);
	    }
	    function ps(e2, t2) {
	      if (hs(e2)) return (us(e2) || Z(e2)) && t2 && t2.push(e2), ArrayBuffer.isView(e2) && t2 && t2.push(e2.buffer), e2 instanceof ImageData && t2 && t2.push(e2.data.buffer), e2;
	      if (Array.isArray(e2)) {
	        const r3 = [];
	        for (const n3 of e2) r3.push(ps(n3, t2));
	        return r3;
	      }
	      if ("object" != typeof e2) throw new Error("can't serialize object of type " + typeof e2);
	      const r2 = cs(e2);
	      if (!r2) throw new Error(`can't serialize object of unregistered class ${e2.constructor.name}`);
	      if (!as[r2]) throw new Error(`${r2} is not registered.`);
	      const { klass: n2 } = as[r2], i2 = n2.serialize ? n2.serialize(e2, t2) : {};
	      if (n2.serialize) {
	        if (t2 && i2 === t2[t2.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
	      } else {
	        for (const n3 in e2) {
	          if (!e2.hasOwnProperty(n3)) continue;
	          if (as[r2].omit.indexOf(n3) >= 0) continue;
	          const s2 = e2[n3];
	          i2[n3] = as[r2].shallow.indexOf(n3) >= 0 ? s2 : ps(s2, t2);
	        }
	        e2 instanceof Error && (i2.message = e2.message);
	      }
	      if (i2.$name) throw new Error("$name property is reserved for worker serialization logic.");
	      return "Object" !== r2 && (i2.$name = r2), i2;
	    }
	    function fs(e2) {
	      if (hs(e2)) return e2;
	      if (Array.isArray(e2)) return e2.map(fs);
	      if ("object" != typeof e2) throw new Error("can't deserialize object of type " + typeof e2);
	      const t2 = cs(e2) || "Object";
	      if (!as[t2]) throw new Error(`can't deserialize unregistered class ${t2}`);
	      const { klass: r2 } = as[t2];
	      if (!r2) throw new Error(`can't deserialize unregistered class ${t2}`);
	      if (r2.deserialize) return r2.deserialize(e2);
	      const n2 = Object.create(r2.prototype);
	      for (const r3 of Object.keys(e2)) {
	        if ("$name" === r3) continue;
	        const i2 = e2[r3];
	        n2[r3] = as[t2].shallow.indexOf(r3) >= 0 ? i2 : fs(i2);
	      }
	      return n2;
	    }
	    class ds {
	      constructor() {
	        this.first = true;
	      }
	      update(e2, t2) {
	        const r2 = Math.floor(e2);
	        return this.first ? (this.first = false, this.lastIntegerZoom = r2, this.lastIntegerZoomTime = 0, this.lastZoom = e2, this.lastFloorZoom = r2, true) : (this.lastFloorZoom > r2 ? (this.lastIntegerZoom = r2 + 1, this.lastIntegerZoomTime = t2) : this.lastFloorZoom < r2 && (this.lastIntegerZoom = r2, this.lastIntegerZoomTime = t2), e2 !== this.lastZoom && (this.lastZoom = e2, this.lastFloorZoom = r2, true));
	      }
	    }
	    function ys(e2) {
	      return /[\u02EA\u02EB\u2E80-\u2FDF\u2FF0-\u303F\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FD-\u30FF\u3105-\u312F\u31A0-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE4F\uFF00-\uFFEF]|\uD81B[\uDFE0-\uDFFF]|[\uD81C-\uD822\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFFF]|\uD82C[\uDC00-\uDEFB]|\uD83C[\uDE00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(e2));
	    }
	    function ms(e2) {
	      return /[\u02EA\u02EB\u1100-\u11FF\u1400-\u167F\u18B0-\u18F5\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u3007\u3012\u3013\u3020-\u302F\u3031-\u303F\u3041-\u3096\u309D-\u30FB\u30FD-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE48\uFE50-\uFE57\uFE5F-\uFE62\uFE67-\uFE6F\uFF00-\uFF07\uFF0A-\uFF0C\uFF0E-\uFF19\uFF1F-\uFF3A\uFF3C\uFF3E\uFF40-\uFF5A\uFFE0-\uFFE2\uFFE4-\uFFE7]|\uD802[\uDD80-\uDD9F]|\uD805[\uDD80-\uDDFF]|\uD806[\uDE00-\uDEBF]|\uD811[\uDC00-\uDE7F]|\uD81B[\uDFE0-\uDFE4\uDFF0-\uDFF6]|[\uD81C-\uD822\uD83D\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD30-\uDEFB]|\uD833[\uDEC0-\uDFCF]|\uD834[\uDC00-\uDDFF\uDEE0-\uDF7F]|\uD836[\uDC00-\uDEAF]|\uD83C[\uDC00-\uDE00\uDF00-\uDFFF]|\uD83E[\uDD00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(e2));
	    }
	    function gs(e2) {
	      return /\s/u.test(String.fromCodePoint(e2));
	    }
	    function xs(e2) {
	      for (const t2 of e2) if (ms(t2.codePointAt(0))) return true;
	      return false;
	    }
	    function vs(e2) {
	      for (const t2 of e2) if (!_s(t2.codePointAt(0))) return false;
	      return true;
	    }
	    function bs(e2) {
	      const t2 = e2.map((e3) => {
	        try {
	          return new RegExp(`\\p{sc=${e3}}`, "u").source;
	        } catch (e4) {
	          return null;
	        }
	      }).filter((e3) => e3);
	      return new RegExp(t2.join("|"), "u");
	    }
	    const ws = bs(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
	    function _s(e2) {
	      return !ws.test(String.fromCodePoint(e2));
	    }
	    function Ss(e2) {
	      return !(ms(e2) || (t2 = e2, /[\xA7\xA9\xAE\xB1\xBC-\xBE\xD7\xF7\u2016\u2020\u2021\u2030\u2031\u203B\u203C\u2042\u2047-\u2049\u2051\u2100-\u218F\u221E\u2234\u2235\u2300-\u2307\u230C-\u231F\u2324-\u2328\u232B\u237D-\u239A\u23BE-\u23CD\u23CF\u23D1-\u23DB\u23E2-\u2422\u2424-\u24FF\u25A0-\u2619\u2620-\u2767\u2776-\u2793\u2B12-\u2B2F\u2B50-\u2B59\u2BB8-\u2BEB\u3000-\u303F\u30A0-\u30FF\uE000-\uF8FF\uFE30-\uFE6F\uFF00-\uFFEF\uFFFC\uFFFD]|[\uDB80-\uDBFF][\uDC00-\uDFFF]/gim.test(String.fromCodePoint(t2))));
	      var t2;
	    }
	    const As = bs(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
	    function Ts(e2) {
	      return As.test(String.fromCodePoint(e2));
	    }
	    function Is(e2, t2) {
	      return !(!t2 && Ts(e2) || /[\u0900-\u0DFF\u0F00-\u109F\u1780-\u17FF]/gim.test(String.fromCodePoint(e2)));
	    }
	    function Es(e2) {
	      for (const t2 of e2) if (Ts(t2.codePointAt(0))) return true;
	      return false;
	    }
	    const Ms = new class {
	      constructor() {
	        this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
	        };
	      }
	      setState(e2) {
	        this.pluginStatus = e2.pluginStatus, this.pluginURL = e2.pluginURL;
	      }
	      getState() {
	        return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
	      }
	      setMethods(e2) {
	        if (Ms.isParsed()) throw new Error("RTL text plugin already registered.");
	        this.applyArabicShaping = e2.applyArabicShaping, this.processBidirectionalText = e2.processBidirectionalText, this.processStyledBidirectionalText = e2.processStyledBidirectionalText, this.loadScriptResolve();
	      }
	      isParsed() {
	        return null != this.applyArabicShaping && null != this.processBidirectionalText && null != this.processStyledBidirectionalText;
	      }
	      getRTLTextPluginStatus() {
	        return this.pluginStatus;
	      }
	      syncState(e2, r2) {
	        return t(this, void 0, void 0, function* () {
	          if (this.isParsed()) return this.getState();
	          if ("loading" !== e2.pluginStatus) return this.setState(e2), e2;
	          const t2 = e2.pluginURL, n2 = new Promise((e3) => {
	            this.loadScriptResolve = e3;
	          });
	          r2(t2);
	          const i2 = new Promise((e3) => setTimeout(() => e3(), this.TIMEOUT));
	          if (yield Promise.race([n2, i2]), this.isParsed()) {
	            const e3 = { pluginStatus: "loaded", pluginURL: t2 };
	            return this.setState(e3), e3;
	          }
	          throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${t2}`);
	        });
	      }
	    }();
	    class ks {
	      constructor(e2, t2) {
	        this.isSupportedScript = Fs, this.zoom = e2, t2 ? (this.now = t2.now || 0, this.fadeDuration = t2.fadeDuration || 0, this.zoomHistory = t2.zoomHistory || new ds(), this.transition = t2.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new ds(), this.transition = {});
	      }
	      crossFadingFactor() {
	        return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
	      }
	      getCrossfadeParameters() {
	        const e2 = this.zoom, t2 = e2 - Math.floor(e2), r2 = this.crossFadingFactor();
	        return e2 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: t2 + (1 - t2) * r2 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r2) * t2 };
	      }
	    }
	    function Fs(e2) {
	      return function(e3, t2) {
	        for (const r2 of e3) if (!Is(r2.codePointAt(0), t2)) return false;
	        return true;
	      }(e2, "loaded" === Ms.getRTLTextPluginStatus());
	    }
	    const Ds = "-transition";
	    class Ps {
	      constructor(e2, t2, r2) {
	        this.property = e2, this.value = t2, this.expression = function(e3, t3, r3) {
	          if (Xn(e3)) return new oi(e3, t3);
	          if (ti(e3)) {
	            const n2 = si(e3, t3, r3);
	            if ("error" === n2.result) throw new Error(n2.value.map((e4) => `${e4.key}: ${e4.message}`).join(", "));
	            return n2.value;
	          }
	          {
	            let r4 = e3;
	            return "color" === t3.type && "string" == typeof e3 ? r4 = It.parse(e3) : "padding" !== t3.type || "number" != typeof e3 && !Array.isArray(e3) ? "numberArray" !== t3.type || "number" != typeof e3 && !Array.isArray(e3) ? "colorArray" !== t3.type || "string" != typeof e3 && !Array.isArray(e3) ? "variableAnchorOffsetCollection" === t3.type && Array.isArray(e3) ? r4 = Ct.parse(e3) : "projectionDefinition" === t3.type && "string" == typeof e3 && (r4 = Ot.parse(e3)) : r4 = Bt.parse(e3) : r4 = Pt.parse(e3) : r4 = Dt.parse(e3), { globalStateRefs: /* @__PURE__ */ new Set(), _globalState: null, kind: "constant", evaluate: () => r4 };
	          }
	        }(void 0 === t2 ? e2.specification.default : t2, e2.specification, r2);
	      }
	      isDataDriven() {
	        return "source" === this.expression.kind || "composite" === this.expression.kind;
	      }
	      getGlobalStateRefs() {
	        return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
	      }
	      possiblyEvaluate(e2, t2, r2) {
	        return this.property.possiblyEvaluate(this, e2, t2, r2);
	      }
	    }
	    class Bs {
	      constructor(e2, t2) {
	        this.property = e2, this.value = new Ps(e2, void 0, t2);
	      }
	      transitioned(e2, t2) {
	        return new Vs(this.property, this.value, t2, O({}, e2.transition, this.transition), e2.now);
	      }
	      untransitioned() {
	        return new Vs(this.property, this.value, null, {}, 0);
	      }
	    }
	    class zs {
	      constructor(e2, t2) {
	        this._properties = e2, this._values = Object.create(e2.defaultTransitionablePropertyValues), this._globalState = t2;
	      }
	      getValue(e2) {
	        return U(this._values[e2].value.value);
	      }
	      setValue(e2, t2) {
	        Object.prototype.hasOwnProperty.call(this._values, e2) || (this._values[e2] = new Bs(this._values[e2].property, this._globalState)), this._values[e2].value = new Ps(this._values[e2].property, null === t2 ? void 0 : U(t2), this._globalState);
	      }
	      getTransition(e2) {
	        return U(this._values[e2].transition);
	      }
	      setTransition(e2, t2) {
	        Object.prototype.hasOwnProperty.call(this._values, e2) || (this._values[e2] = new Bs(this._values[e2].property, this._globalState)), this._values[e2].transition = U(t2) || void 0;
	      }
	      serialize() {
	        const e2 = {};
	        for (const t2 of Object.keys(this._values)) {
	          const r2 = this.getValue(t2);
	          void 0 !== r2 && (e2[t2] = r2);
	          const n2 = this.getTransition(t2);
	          void 0 !== n2 && (e2[`${t2}${Ds}`] = n2);
	        }
	        return e2;
	      }
	      transitioned(e2, t2) {
	        const r2 = new Cs(this._properties);
	        for (const n2 of Object.keys(this._values)) r2._values[n2] = this._values[n2].transitioned(e2, t2._values[n2]);
	        return r2;
	      }
	      untransitioned() {
	        const e2 = new Cs(this._properties);
	        for (const t2 of Object.keys(this._values)) e2._values[t2] = this._values[t2].untransitioned();
	        return e2;
	      }
	    }
	    class Vs {
	      constructor(e2, t2, r2, n2, i2) {
	        this.property = e2, this.value = t2, this.begin = i2 + n2.delay || 0, this.end = this.begin + n2.duration || 0, e2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
	      }
	      possiblyEvaluate(e2, t2, r2) {
	        const n2 = e2.now || 0, i2 = this.value.possiblyEvaluate(e2, t2, r2), s2 = this.prior;
	        if (s2) {
	          if (n2 > this.end) return this.prior = null, i2;
	          if (this.value.isDataDriven()) return this.prior = null, i2;
	          if (n2 < this.begin) return s2.possiblyEvaluate(e2, t2, r2);
	          {
	            const o2 = (n2 - this.begin) / (this.end - this.begin);
	            return this.property.interpolate(s2.possiblyEvaluate(e2, t2, r2), i2, B(o2));
	          }
	        }
	        return i2;
	      }
	    }
	    class Cs {
	      constructor(e2) {
	        this._properties = e2, this._values = Object.create(e2.defaultTransitioningPropertyValues);
	      }
	      possiblyEvaluate(e2, t2, r2) {
	        const n2 = new Rs(this._properties);
	        for (const i2 of Object.keys(this._values)) n2._values[i2] = this._values[i2].possiblyEvaluate(e2, t2, r2);
	        return n2;
	      }
	      hasTransition() {
	        for (const e2 of Object.keys(this._values)) if (this._values[e2].prior) return true;
	        return false;
	      }
	    }
	    class Ls {
	      constructor(e2, t2) {
	        this._properties = e2, this._values = Object.create(e2.defaultPropertyValues), this._globalState = t2;
	      }
	      hasValue(e2) {
	        return void 0 !== this._values[e2].value;
	      }
	      getValue(e2) {
	        return U(this._values[e2].value);
	      }
	      setValue(e2, t2) {
	        this._values[e2] = new Ps(this._values[e2].property, null === t2 ? void 0 : U(t2), this._globalState);
	      }
	      serialize() {
	        const e2 = {};
	        for (const t2 of Object.keys(this._values)) {
	          const r2 = this.getValue(t2);
	          void 0 !== r2 && (e2[t2] = r2);
	        }
	        return e2;
	      }
	      possiblyEvaluate(e2, t2, r2) {
	        const n2 = new Rs(this._properties);
	        for (const i2 of Object.keys(this._values)) n2._values[i2] = this._values[i2].possiblyEvaluate(e2, t2, r2);
	        return n2;
	      }
	    }
	    class Os {
	      constructor(e2, t2, r2) {
	        this.property = e2, this.value = t2, this.parameters = r2;
	      }
	      isConstant() {
	        return "constant" === this.value.kind;
	      }
	      constantOr(e2) {
	        return "constant" === this.value.kind ? this.value.value : e2;
	      }
	      evaluate(e2, t2, r2, n2) {
	        return this.property.evaluate(this.value, this.parameters, e2, t2, r2, n2);
	      }
	    }
	    class Rs {
	      constructor(e2) {
	        this._properties = e2, this._values = Object.create(e2.defaultPossiblyEvaluatedValues);
	      }
	      get(e2) {
	        return this._values[e2];
	      }
	    }
	    class Ns {
	      constructor(e2) {
	        this.specification = e2;
	      }
	      possiblyEvaluate(e2, t2) {
	        if (e2.isDataDriven()) throw new Error("Value should not be data driven");
	        return e2.expression.evaluate(t2);
	      }
	      interpolate(e2, t2, r2) {
	        const n2 = dr[this.specification.type];
	        return n2 ? n2(e2, t2, r2) : e2;
	      }
	    }
	    class $s {
	      constructor(e2, t2) {
	        this.specification = e2, this.overrides = t2;
	      }
	      possiblyEvaluate(e2, t2, r2, n2) {
	        return new Os(this, "constant" === e2.expression.kind || "camera" === e2.expression.kind ? { kind: "constant", value: e2.expression.evaluate(t2, null, {}, r2, n2) } : e2.expression, t2);
	      }
	      interpolate(e2, t2, r2) {
	        if ("constant" !== e2.value.kind || "constant" !== t2.value.kind) return e2;
	        if (void 0 === e2.value.value || void 0 === t2.value.value) return new Os(this, { kind: "constant", value: void 0 }, e2.parameters);
	        const n2 = dr[this.specification.type];
	        if (n2) {
	          const i2 = n2(e2.value.value, t2.value.value, r2);
	          return new Os(this, { kind: "constant", value: i2 }, e2.parameters);
	        }
	        return e2;
	      }
	      evaluate(e2, t2, r2, n2, i2, s2) {
	        return "constant" === e2.kind ? e2.value : e2.evaluate(t2, r2, n2, i2, s2);
	      }
	    }
	    class Us extends $s {
	      possiblyEvaluate(e2, t2, r2, n2) {
	        if (void 0 === e2.value) return new Os(this, { kind: "constant", value: void 0 }, t2);
	        if ("constant" === e2.expression.kind) {
	          const i2 = e2.expression.evaluate(t2, null, {}, r2, n2), s2 = "resolvedImage" === e2.property.specification.type && "string" != typeof i2 ? i2.name : i2, o2 = this._calculate(s2, s2, s2, t2);
	          return new Os(this, { kind: "constant", value: o2 }, t2);
	        }
	        if ("camera" === e2.expression.kind) {
	          const r3 = this._calculate(e2.expression.evaluate({ zoom: t2.zoom - 1 }), e2.expression.evaluate({ zoom: t2.zoom }), e2.expression.evaluate({ zoom: t2.zoom + 1 }), t2);
	          return new Os(this, { kind: "constant", value: r3 }, t2);
	        }
	        return new Os(this, e2.expression, t2);
	      }
	      evaluate(e2, t2, r2, n2, i2, s2) {
	        if ("source" === e2.kind) {
	          const o2 = e2.evaluate(t2, r2, n2, i2, s2);
	          return this._calculate(o2, o2, o2, t2);
	        }
	        return "composite" === e2.kind ? this._calculate(e2.evaluate({ zoom: Math.floor(t2.zoom) - 1 }, r2, n2), e2.evaluate({ zoom: Math.floor(t2.zoom) }, r2, n2), e2.evaluate({ zoom: Math.floor(t2.zoom) + 1 }, r2, n2), t2) : e2.value;
	      }
	      _calculate(e2, t2, r2, n2) {
	        return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: e2, to: t2 } : { from: r2, to: t2 };
	      }
	      interpolate(e2) {
	        return e2;
	      }
	    }
	    class qs {
	      constructor(e2) {
	        this.specification = e2;
	      }
	      possiblyEvaluate(e2, t2, r2, n2) {
	        if (void 0 !== e2.value) {
	          if ("constant" === e2.expression.kind) {
	            const i2 = e2.expression.evaluate(t2, null, {}, r2, n2);
	            return this._calculate(i2, i2, i2, t2);
	          }
	          return this._calculate(e2.expression.evaluate(new ks(Math.floor(t2.zoom - 1), t2)), e2.expression.evaluate(new ks(Math.floor(t2.zoom), t2)), e2.expression.evaluate(new ks(Math.floor(t2.zoom + 1), t2)), t2);
	        }
	      }
	      _calculate(e2, t2, r2, n2) {
	        return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: e2, to: t2 } : { from: r2, to: t2 };
	      }
	      interpolate(e2) {
	        return e2;
	      }
	    }
	    class js {
	      constructor(e2) {
	        this.specification = e2;
	      }
	      possiblyEvaluate(e2, t2, r2, n2) {
	        return !!e2.expression.evaluate(t2, null, {}, r2, n2);
	      }
	      interpolate() {
	        return false;
	      }
	    }
	    class Gs {
	      constructor(e2) {
	        this.properties = e2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
	        for (const t2 in e2) {
	          const r2 = e2[t2];
	          r2.specification.overridable && this.overridableProperties.push(t2);
	          const n2 = this.defaultPropertyValues[t2] = new Ps(r2, void 0, void 0), i2 = this.defaultTransitionablePropertyValues[t2] = new Bs(r2, void 0);
	          this.defaultTransitioningPropertyValues[t2] = i2.untransitioned(), this.defaultPossiblyEvaluatedValues[t2] = n2.possiblyEvaluate({});
	        }
	      }
	    }
	    ls("DataDrivenProperty", $s), ls("DataConstantProperty", Ns), ls("CrossFadedDataDrivenProperty", Us), ls("CrossFadedProperty", qs), ls("ColorRampProperty", js);
	    class Xs extends ge {
	      constructor(e2, t2, r2) {
	        if (super(), this.id = e2.id, this.type = e2.type, this._globalState = r2, this._featureFilter = { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() }, "custom" !== e2.type && (this.metadata = e2.metadata, this.minzoom = e2.minzoom, this.maxzoom = e2.maxzoom, "background" !== e2.type && (this.source = e2.source, this.sourceLayer = e2["source-layer"], this.filter = e2.filter, this._featureFilter = pi(e2.filter, r2)), t2.layout && (this._unevaluatedLayout = new Ls(t2.layout, r2)), t2.paint)) {
	          this._transitionablePaint = new zs(t2.paint, r2);
	          for (const t3 in e2.paint) this.setPaintProperty(t3, e2.paint[t3], { validate: false });
	          for (const t3 in e2.layout) this.setLayoutProperty(t3, e2.layout[t3], { validate: false });
	          this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Rs(t2.paint);
	        }
	      }
	      setFilter(e2) {
	        this.filter = e2, this._featureFilter = pi(e2, this._globalState);
	      }
	      getCrossfadeParameters() {
	        return this._crossfadeParameters;
	      }
	      getLayoutProperty(e2) {
	        return "visibility" === e2 ? this.visibility : this._unevaluatedLayout.getValue(e2);
	      }
	      getLayoutAffectingGlobalStateRefs() {
	        const e2 = /* @__PURE__ */ new Set();
	        if (this._unevaluatedLayout) for (const t2 in this._unevaluatedLayout._values) {
	          const r2 = this._unevaluatedLayout._values[t2];
	          for (const t3 of r2.getGlobalStateRefs()) e2.add(t3);
	        }
	        for (const t2 of this._featureFilter.getGlobalStateRefs()) e2.add(t2);
	        return e2;
	      }
	      getPaintAffectingGlobalStateRefs() {
	        var e2;
	        const t2 = new globalThis.Map();
	        if (this._transitionablePaint) for (const r2 in this._transitionablePaint._values) {
	          const n2 = this._transitionablePaint._values[r2].value;
	          for (const i2 of n2.getGlobalStateRefs()) {
	            const s2 = null !== (e2 = t2.get(i2)) && void 0 !== e2 ? e2 : [];
	            s2.push({ name: r2, value: n2.value }), t2.set(i2, s2);
	          }
	        }
	        return t2;
	      }
	      setLayoutProperty(e2, t2, r2 = {}) {
	        null != t2 && this._validate(is, `layers.${this.id}.layout.${e2}`, e2, t2, r2) || ("visibility" !== e2 ? this._unevaluatedLayout.setValue(e2, t2) : this.visibility = t2);
	      }
	      getPaintProperty(e2) {
	        return e2.endsWith(Ds) ? this._transitionablePaint.getTransition(e2.slice(0, -11)) : this._transitionablePaint.getValue(e2);
	      }
	      setPaintProperty(e2, t2, r2 = {}) {
	        if (null != t2 && this._validate(ns, `layers.${this.id}.paint.${e2}`, e2, t2, r2)) return false;
	        if (e2.endsWith(Ds)) return this._transitionablePaint.setTransition(e2.slice(0, -11), t2 || void 0), false;
	        {
	          const r3 = this._transitionablePaint._values[e2], n2 = "cross-faded-data-driven" === r3.property.specification["property-type"], i2 = r3.value.isDataDriven(), s2 = r3.value;
	          this._transitionablePaint.setValue(e2, t2), this._handleSpecialPaintPropertyUpdate(e2);
	          const o2 = this._transitionablePaint._values[e2].value;
	          return o2.isDataDriven() || i2 || n2 || this._handleOverridablePaintPropertyUpdate(e2, s2, o2);
	        }
	      }
	      _handleSpecialPaintPropertyUpdate(e2) {
	      }
	      _handleOverridablePaintPropertyUpdate(e2, t2, r2) {
	        return false;
	      }
	      isHidden(e2, t2 = false) {
	        return !!(this.minzoom && e2 < (t2 ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && e2 >= this.maxzoom) || "none" === this.visibility;
	      }
	      updateTransitions(e2) {
	        this._transitioningPaint = this._transitionablePaint.transitioned(e2, this._transitioningPaint);
	      }
	      hasTransition() {
	        return this._transitioningPaint.hasTransition();
	      }
	      recalculate(e2, t2) {
	        e2.getCrossfadeParameters && (this._crossfadeParameters = e2.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e2, void 0, t2)), this.paint = this._transitioningPaint.possiblyEvaluate(e2, void 0, t2);
	      }
	      serialize() {
	        const e2 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
	        return this.visibility && (e2.layout = e2.layout || {}, e2.layout.visibility = this.visibility), $(e2, (e3, t2) => !(void 0 === e3 || "layout" === t2 && !Object.keys(e3).length || "paint" === t2 && !Object.keys(e3).length));
	      }
	      _validate(e2, t2, r2, n2, i2 = {}) {
	        return (!i2 || false !== i2.validate) && ss(this, e2.call(es, { key: t2, layerType: this.type, objectKey: r2, value: n2, styleSpec: xe, style: { glyphs: true, sprite: true } }));
	      }
	      is3D() {
	        return false;
	      }
	      isTileClipped() {
	        return false;
	      }
	      hasOffscreenPass() {
	        return false;
	      }
	      resize() {
	      }
	      isStateDependent() {
	        for (const e2 in this.paint._values) {
	          const t2 = this.paint.get(e2);
	          if (t2 instanceof Os && Un(t2.property.specification) && ("source" === t2.value.kind || "composite" === t2.value.kind) && t2.value.isStateDependent) return true;
	        }
	        return false;
	      }
	    }
	    let Ys;
	    var Zs = { get paint() {
	      return Ys = Ys || new Gs({ "raster-opacity": new Ns(xe.paint_raster["raster-opacity"]), "raster-hue-rotate": new Ns(xe.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Ns(xe.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Ns(xe.paint_raster["raster-brightness-max"]), "raster-saturation": new Ns(xe.paint_raster["raster-saturation"]), "raster-contrast": new Ns(xe.paint_raster["raster-contrast"]), "raster-resampling": new Ns(xe.paint_raster["raster-resampling"]), "raster-fade-duration": new Ns(xe.paint_raster["raster-fade-duration"]) });
	    } };
	    class Hs extends Xs {
	      constructor(e2, t2) {
	        super(e2, Zs, t2);
	      }
	    }
	    const Ks = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
	    class Ws {
	      constructor(e2, t2) {
	        this._structArray = e2, this._pos1 = t2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
	      }
	    }
	    class Js {
	      constructor() {
	        this.isTransferred = false, this.capacity = -1, this.resize(0);
	      }
	      static serialize(e2, t2) {
	        return e2._trim(), t2 && (e2.isTransferred = true, t2.push(e2.arrayBuffer)), { length: e2.length, arrayBuffer: e2.arrayBuffer };
	      }
	      static deserialize(e2) {
	        const t2 = Object.create(this.prototype);
	        return t2.arrayBuffer = e2.arrayBuffer, t2.length = e2.length, t2.capacity = e2.arrayBuffer.byteLength / t2.bytesPerElement, t2._refreshViews(), t2;
	      }
	      _trim() {
	        this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
	      }
	      clear() {
	        this.length = 0;
	      }
	      resize(e2) {
	        this.reserve(e2), this.length = e2;
	      }
	      reserve(e2) {
	        if (e2 > this.capacity) {
	          this.capacity = Math.max(e2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
	          const t2 = this.uint8;
	          this._refreshViews(), t2 && this.uint8.set(t2);
	        }
	      }
	      _refreshViews() {
	        throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
	      }
	    }
	    function Qs(e2, t2 = 1) {
	      let r2 = 0, n2 = 0;
	      return { members: e2.map((e3) => {
	        const i2 = Ks[e3.type].BYTES_PER_ELEMENT, s2 = r2 = eo(r2, Math.max(t2, i2)), o2 = e3.components || 1;
	        return n2 = Math.max(n2, i2), r2 += i2 * o2, { name: e3.name, type: e3.type, components: o2, offset: s2 };
	      }), size: eo(r2, Math.max(n2, t2)), alignment: t2 };
	    }
	    function eo(e2, t2) {
	      return Math.ceil(e2 / t2) * t2;
	    }
	    class to extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2) {
	        const r2 = this.length;
	        return this.resize(r2 + 1), this.emplace(r2, e2, t2);
	      }
	      emplace(e2, t2, r2) {
	        const n2 = 2 * e2;
	        return this.int16[n2 + 0] = t2, this.int16[n2 + 1] = r2, e2;
	      }
	    }
	    to.prototype.bytesPerElement = 4, ls("StructArrayLayout2i4", to);
	    class ro extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2, r2) {
	        const n2 = this.length;
	        return this.resize(n2 + 1), this.emplace(n2, e2, t2, r2);
	      }
	      emplace(e2, t2, r2, n2) {
	        const i2 = 3 * e2;
	        return this.int16[i2 + 0] = t2, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, e2;
	      }
	    }
	    ro.prototype.bytesPerElement = 6, ls("StructArrayLayout3i6", ro);
	    class no extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2, r2, n2) {
	        const i2 = this.length;
	        return this.resize(i2 + 1), this.emplace(i2, e2, t2, r2, n2);
	      }
	      emplace(e2, t2, r2, n2, i2) {
	        const s2 = 4 * e2;
	        return this.int16[s2 + 0] = t2, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, e2;
	      }
	    }
	    no.prototype.bytesPerElement = 8, ls("StructArrayLayout4i8", no);
	    class io extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2, r2, n2, i2, s2) {
	        const o2 = this.length;
	        return this.resize(o2 + 1), this.emplace(o2, e2, t2, r2, n2, i2, s2);
	      }
	      emplace(e2, t2, r2, n2, i2, s2, o2) {
	        const a2 = 6 * e2;
	        return this.int16[a2 + 0] = t2, this.int16[a2 + 1] = r2, this.int16[a2 + 2] = n2, this.int16[a2 + 3] = i2, this.int16[a2 + 4] = s2, this.int16[a2 + 5] = o2, e2;
	      }
	    }
	    io.prototype.bytesPerElement = 12, ls("StructArrayLayout2i4i12", io);
	    class so extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2, r2, n2, i2, s2) {
	        const o2 = this.length;
	        return this.resize(o2 + 1), this.emplace(o2, e2, t2, r2, n2, i2, s2);
	      }
	      emplace(e2, t2, r2, n2, i2, s2, o2) {
	        const a2 = 4 * e2, l2 = 8 * e2;
	        return this.int16[a2 + 0] = t2, this.int16[a2 + 1] = r2, this.uint8[l2 + 4] = n2, this.uint8[l2 + 5] = i2, this.uint8[l2 + 6] = s2, this.uint8[l2 + 7] = o2, e2;
	      }
	    }
	    so.prototype.bytesPerElement = 8, ls("StructArrayLayout2i4ub8", so);
	    class oo extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2) {
	        const r2 = this.length;
	        return this.resize(r2 + 1), this.emplace(r2, e2, t2);
	      }
	      emplace(e2, t2, r2) {
	        const n2 = 2 * e2;
	        return this.float32[n2 + 0] = t2, this.float32[n2 + 1] = r2, e2;
	      }
	    }
	    oo.prototype.bytesPerElement = 8, ls("StructArrayLayout2f8", oo);
	    class ao extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2, r2, n2, i2, s2, o2, a2, l2, u2) {
	        const c2 = this.length;
	        return this.resize(c2 + 1), this.emplace(c2, e2, t2, r2, n2, i2, s2, o2, a2, l2, u2);
	      }
	      emplace(e2, t2, r2, n2, i2, s2, o2, a2, l2, u2, c2) {
	        const h2 = 10 * e2;
	        return this.uint16[h2 + 0] = t2, this.uint16[h2 + 1] = r2, this.uint16[h2 + 2] = n2, this.uint16[h2 + 3] = i2, this.uint16[h2 + 4] = s2, this.uint16[h2 + 5] = o2, this.uint16[h2 + 6] = a2, this.uint16[h2 + 7] = l2, this.uint16[h2 + 8] = u2, this.uint16[h2 + 9] = c2, e2;
	      }
	    }
	    ao.prototype.bytesPerElement = 20, ls("StructArrayLayout10ui20", ao);
	    class lo extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2, r2, n2, i2, s2, o2, a2) {
	        const l2 = this.length;
	        return this.resize(l2 + 1), this.emplace(l2, e2, t2, r2, n2, i2, s2, o2, a2);
	      }
	      emplace(e2, t2, r2, n2, i2, s2, o2, a2, l2) {
	        const u2 = 8 * e2;
	        return this.uint16[u2 + 0] = t2, this.uint16[u2 + 1] = r2, this.uint16[u2 + 2] = n2, this.uint16[u2 + 3] = i2, this.uint16[u2 + 4] = s2, this.uint16[u2 + 5] = o2, this.uint16[u2 + 6] = a2, this.uint16[u2 + 7] = l2, e2;
	      }
	    }
	    lo.prototype.bytesPerElement = 16, ls("StructArrayLayout8ui16", lo);
	    class uo extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2, r2, n2, i2, s2, o2, a2, l2, u2, c2, h2) {
	        const p2 = this.length;
	        return this.resize(p2 + 1), this.emplace(p2, e2, t2, r2, n2, i2, s2, o2, a2, l2, u2, c2, h2);
	      }
	      emplace(e2, t2, r2, n2, i2, s2, o2, a2, l2, u2, c2, h2, p2) {
	        const f2 = 12 * e2;
	        return this.int16[f2 + 0] = t2, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = s2, this.uint16[f2 + 5] = o2, this.uint16[f2 + 6] = a2, this.uint16[f2 + 7] = l2, this.int16[f2 + 8] = u2, this.int16[f2 + 9] = c2, this.int16[f2 + 10] = h2, this.int16[f2 + 11] = p2, e2;
	      }
	    }
	    uo.prototype.bytesPerElement = 24, ls("StructArrayLayout4i4ui4i24", uo);
	    class co extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2, r2) {
	        const n2 = this.length;
	        return this.resize(n2 + 1), this.emplace(n2, e2, t2, r2);
	      }
	      emplace(e2, t2, r2, n2) {
	        const i2 = 3 * e2;
	        return this.float32[i2 + 0] = t2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, e2;
	      }
	    }
	    co.prototype.bytesPerElement = 12, ls("StructArrayLayout3f12", co);
	    class ho extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
	      }
	      emplaceBack(e2) {
	        const t2 = this.length;
	        return this.resize(t2 + 1), this.emplace(t2, e2);
	      }
	      emplace(e2, t2) {
	        return this.uint32[1 * e2 + 0] = t2, e2;
	      }
	    }
	    ho.prototype.bytesPerElement = 4, ls("StructArrayLayout1ul4", ho);
	    class po extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2, r2, n2, i2, s2, o2, a2, l2) {
	        const u2 = this.length;
	        return this.resize(u2 + 1), this.emplace(u2, e2, t2, r2, n2, i2, s2, o2, a2, l2);
	      }
	      emplace(e2, t2, r2, n2, i2, s2, o2, a2, l2, u2) {
	        const c2 = 10 * e2, h2 = 5 * e2;
	        return this.int16[c2 + 0] = t2, this.int16[c2 + 1] = r2, this.int16[c2 + 2] = n2, this.int16[c2 + 3] = i2, this.int16[c2 + 4] = s2, this.int16[c2 + 5] = o2, this.uint32[h2 + 3] = a2, this.uint16[c2 + 8] = l2, this.uint16[c2 + 9] = u2, e2;
	      }
	    }
	    po.prototype.bytesPerElement = 20, ls("StructArrayLayout6i1ul2ui20", po);
	    class fo extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2, r2, n2, i2, s2) {
	        const o2 = this.length;
	        return this.resize(o2 + 1), this.emplace(o2, e2, t2, r2, n2, i2, s2);
	      }
	      emplace(e2, t2, r2, n2, i2, s2, o2) {
	        const a2 = 6 * e2;
	        return this.int16[a2 + 0] = t2, this.int16[a2 + 1] = r2, this.int16[a2 + 2] = n2, this.int16[a2 + 3] = i2, this.int16[a2 + 4] = s2, this.int16[a2 + 5] = o2, e2;
	      }
	    }
	    fo.prototype.bytesPerElement = 12, ls("StructArrayLayout2i2i2i12", fo);
	    class yo extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2, r2, n2, i2) {
	        const s2 = this.length;
	        return this.resize(s2 + 1), this.emplace(s2, e2, t2, r2, n2, i2);
	      }
	      emplace(e2, t2, r2, n2, i2, s2) {
	        const o2 = 4 * e2, a2 = 8 * e2;
	        return this.float32[o2 + 0] = t2, this.float32[o2 + 1] = r2, this.float32[o2 + 2] = n2, this.int16[a2 + 6] = i2, this.int16[a2 + 7] = s2, e2;
	      }
	    }
	    yo.prototype.bytesPerElement = 16, ls("StructArrayLayout2f1f2i16", yo);
	    class mo extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2, r2, n2, i2, s2) {
	        const o2 = this.length;
	        return this.resize(o2 + 1), this.emplace(o2, e2, t2, r2, n2, i2, s2);
	      }
	      emplace(e2, t2, r2, n2, i2, s2, o2) {
	        const a2 = 16 * e2, l2 = 4 * e2, u2 = 8 * e2;
	        return this.uint8[a2 + 0] = t2, this.uint8[a2 + 1] = r2, this.float32[l2 + 1] = n2, this.float32[l2 + 2] = i2, this.int16[u2 + 6] = s2, this.int16[u2 + 7] = o2, e2;
	      }
	    }
	    mo.prototype.bytesPerElement = 16, ls("StructArrayLayout2ub2f2i16", mo);
	    class go extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2, r2) {
	        const n2 = this.length;
	        return this.resize(n2 + 1), this.emplace(n2, e2, t2, r2);
	      }
	      emplace(e2, t2, r2, n2) {
	        const i2 = 3 * e2;
	        return this.uint16[i2 + 0] = t2, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, e2;
	      }
	    }
	    go.prototype.bytesPerElement = 6, ls("StructArrayLayout3ui6", go);
	    class xo extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2, r2, n2, i2, s2, o2, a2, l2, u2, c2, h2, p2, f2, d2, y2, m2) {
	        const g2 = this.length;
	        return this.resize(g2 + 1), this.emplace(g2, e2, t2, r2, n2, i2, s2, o2, a2, l2, u2, c2, h2, p2, f2, d2, y2, m2);
	      }
	      emplace(e2, t2, r2, n2, i2, s2, o2, a2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2) {
	        const x2 = 24 * e2, v2 = 12 * e2, b2 = 48 * e2;
	        return this.int16[x2 + 0] = t2, this.int16[x2 + 1] = r2, this.uint16[x2 + 2] = n2, this.uint16[x2 + 3] = i2, this.uint32[v2 + 2] = s2, this.uint32[v2 + 3] = o2, this.uint32[v2 + 4] = a2, this.uint16[x2 + 10] = l2, this.uint16[x2 + 11] = u2, this.uint16[x2 + 12] = c2, this.float32[v2 + 7] = h2, this.float32[v2 + 8] = p2, this.uint8[b2 + 36] = f2, this.uint8[b2 + 37] = d2, this.uint8[b2 + 38] = y2, this.uint32[v2 + 10] = m2, this.int16[x2 + 22] = g2, e2;
	      }
	    }
	    xo.prototype.bytesPerElement = 48, ls("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", xo);
	    class vo extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2, r2, n2, i2, s2, o2, a2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, S2, A2, T2, I2, E2) {
	        const M2 = this.length;
	        return this.resize(M2 + 1), this.emplace(M2, e2, t2, r2, n2, i2, s2, o2, a2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, S2, A2, T2, I2, E2);
	      }
	      emplace(e2, t2, r2, n2, i2, s2, o2, a2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, S2, A2, T2, I2, E2, M2) {
	        const k2 = 32 * e2, F2 = 16 * e2;
	        return this.int16[k2 + 0] = t2, this.int16[k2 + 1] = r2, this.int16[k2 + 2] = n2, this.int16[k2 + 3] = i2, this.int16[k2 + 4] = s2, this.int16[k2 + 5] = o2, this.int16[k2 + 6] = a2, this.int16[k2 + 7] = l2, this.uint16[k2 + 8] = u2, this.uint16[k2 + 9] = c2, this.uint16[k2 + 10] = h2, this.uint16[k2 + 11] = p2, this.uint16[k2 + 12] = f2, this.uint16[k2 + 13] = d2, this.uint16[k2 + 14] = y2, this.uint16[k2 + 15] = m2, this.uint16[k2 + 16] = g2, this.uint16[k2 + 17] = x2, this.uint16[k2 + 18] = v2, this.uint16[k2 + 19] = b2, this.uint16[k2 + 20] = w2, this.uint16[k2 + 21] = _2, this.uint16[k2 + 22] = S2, this.uint32[F2 + 12] = A2, this.float32[F2 + 13] = T2, this.float32[F2 + 14] = I2, this.uint16[k2 + 30] = E2, this.uint16[k2 + 31] = M2, e2;
	      }
	    }
	    vo.prototype.bytesPerElement = 64, ls("StructArrayLayout8i15ui1ul2f2ui64", vo);
	    class bo extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
	      }
	      emplaceBack(e2) {
	        const t2 = this.length;
	        return this.resize(t2 + 1), this.emplace(t2, e2);
	      }
	      emplace(e2, t2) {
	        return this.float32[1 * e2 + 0] = t2, e2;
	      }
	    }
	    bo.prototype.bytesPerElement = 4, ls("StructArrayLayout1f4", bo);
	    class wo extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2, r2) {
	        const n2 = this.length;
	        return this.resize(n2 + 1), this.emplace(n2, e2, t2, r2);
	      }
	      emplace(e2, t2, r2, n2) {
	        const i2 = 3 * e2;
	        return this.uint16[6 * e2 + 0] = t2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, e2;
	      }
	    }
	    wo.prototype.bytesPerElement = 12, ls("StructArrayLayout1ui2f12", wo);
	    class _o extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2, r2) {
	        const n2 = this.length;
	        return this.resize(n2 + 1), this.emplace(n2, e2, t2, r2);
	      }
	      emplace(e2, t2, r2, n2) {
	        const i2 = 4 * e2;
	        return this.uint32[2 * e2 + 0] = t2, this.uint16[i2 + 2] = r2, this.uint16[i2 + 3] = n2, e2;
	      }
	    }
	    _o.prototype.bytesPerElement = 8, ls("StructArrayLayout1ul2ui8", _o);
	    class So extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2) {
	        const r2 = this.length;
	        return this.resize(r2 + 1), this.emplace(r2, e2, t2);
	      }
	      emplace(e2, t2, r2) {
	        const n2 = 2 * e2;
	        return this.uint16[n2 + 0] = t2, this.uint16[n2 + 1] = r2, e2;
	      }
	    }
	    So.prototype.bytesPerElement = 4, ls("StructArrayLayout2ui4", So);
	    class Ao extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
	      }
	      emplaceBack(e2) {
	        const t2 = this.length;
	        return this.resize(t2 + 1), this.emplace(t2, e2);
	      }
	      emplace(e2, t2) {
	        return this.uint16[1 * e2 + 0] = t2, e2;
	      }
	    }
	    Ao.prototype.bytesPerElement = 2, ls("StructArrayLayout1ui2", Ao);
	    class To extends Js {
	      _refreshViews() {
	        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
	      }
	      emplaceBack(e2, t2, r2, n2) {
	        const i2 = this.length;
	        return this.resize(i2 + 1), this.emplace(i2, e2, t2, r2, n2);
	      }
	      emplace(e2, t2, r2, n2, i2) {
	        const s2 = 4 * e2;
	        return this.float32[s2 + 0] = t2, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.float32[s2 + 3] = i2, e2;
	      }
	    }
	    To.prototype.bytesPerElement = 16, ls("StructArrayLayout4f16", To);
	    class Io extends Ws {
	      get anchorPointX() {
	        return this._structArray.int16[this._pos2 + 0];
	      }
	      get anchorPointY() {
	        return this._structArray.int16[this._pos2 + 1];
	      }
	      get x1() {
	        return this._structArray.int16[this._pos2 + 2];
	      }
	      get y1() {
	        return this._structArray.int16[this._pos2 + 3];
	      }
	      get x2() {
	        return this._structArray.int16[this._pos2 + 4];
	      }
	      get y2() {
	        return this._structArray.int16[this._pos2 + 5];
	      }
	      get featureIndex() {
	        return this._structArray.uint32[this._pos4 + 3];
	      }
	      get sourceLayerIndex() {
	        return this._structArray.uint16[this._pos2 + 8];
	      }
	      get bucketIndex() {
	        return this._structArray.uint16[this._pos2 + 9];
	      }
	      get anchorPoint() {
	        return new r(this.anchorPointX, this.anchorPointY);
	      }
	    }
	    Io.prototype.size = 20;
	    class Eo extends po {
	      get(e2) {
	        return new Io(this, e2);
	      }
	    }
	    ls("CollisionBoxArray", Eo);
	    class Mo extends Ws {
	      get anchorX() {
	        return this._structArray.int16[this._pos2 + 0];
	      }
	      get anchorY() {
	        return this._structArray.int16[this._pos2 + 1];
	      }
	      get glyphStartIndex() {
	        return this._structArray.uint16[this._pos2 + 2];
	      }
	      get numGlyphs() {
	        return this._structArray.uint16[this._pos2 + 3];
	      }
	      get vertexStartIndex() {
	        return this._structArray.uint32[this._pos4 + 2];
	      }
	      get lineStartIndex() {
	        return this._structArray.uint32[this._pos4 + 3];
	      }
	      get lineLength() {
	        return this._structArray.uint32[this._pos4 + 4];
	      }
	      get segment() {
	        return this._structArray.uint16[this._pos2 + 10];
	      }
	      get lowerSize() {
	        return this._structArray.uint16[this._pos2 + 11];
	      }
	      get upperSize() {
	        return this._structArray.uint16[this._pos2 + 12];
	      }
	      get lineOffsetX() {
	        return this._structArray.float32[this._pos4 + 7];
	      }
	      get lineOffsetY() {
	        return this._structArray.float32[this._pos4 + 8];
	      }
	      get writingMode() {
	        return this._structArray.uint8[this._pos1 + 36];
	      }
	      get placedOrientation() {
	        return this._structArray.uint8[this._pos1 + 37];
	      }
	      set placedOrientation(e2) {
	        this._structArray.uint8[this._pos1 + 37] = e2;
	      }
	      get hidden() {
	        return this._structArray.uint8[this._pos1 + 38];
	      }
	      set hidden(e2) {
	        this._structArray.uint8[this._pos1 + 38] = e2;
	      }
	      get crossTileID() {
	        return this._structArray.uint32[this._pos4 + 10];
	      }
	      set crossTileID(e2) {
	        this._structArray.uint32[this._pos4 + 10] = e2;
	      }
	      get associatedIconIndex() {
	        return this._structArray.int16[this._pos2 + 22];
	      }
	    }
	    Mo.prototype.size = 48;
	    class ko extends xo {
	      get(e2) {
	        return new Mo(this, e2);
	      }
	    }
	    ls("PlacedSymbolArray", ko);
	    class Fo extends Ws {
	      get anchorX() {
	        return this._structArray.int16[this._pos2 + 0];
	      }
	      get anchorY() {
	        return this._structArray.int16[this._pos2 + 1];
	      }
	      get rightJustifiedTextSymbolIndex() {
	        return this._structArray.int16[this._pos2 + 2];
	      }
	      get centerJustifiedTextSymbolIndex() {
	        return this._structArray.int16[this._pos2 + 3];
	      }
	      get leftJustifiedTextSymbolIndex() {
	        return this._structArray.int16[this._pos2 + 4];
	      }
	      get verticalPlacedTextSymbolIndex() {
	        return this._structArray.int16[this._pos2 + 5];
	      }
	      get placedIconSymbolIndex() {
	        return this._structArray.int16[this._pos2 + 6];
	      }
	      get verticalPlacedIconSymbolIndex() {
	        return this._structArray.int16[this._pos2 + 7];
	      }
	      get key() {
	        return this._structArray.uint16[this._pos2 + 8];
	      }
	      get textBoxStartIndex() {
	        return this._structArray.uint16[this._pos2 + 9];
	      }
	      get textBoxEndIndex() {
	        return this._structArray.uint16[this._pos2 + 10];
	      }
	      get verticalTextBoxStartIndex() {
	        return this._structArray.uint16[this._pos2 + 11];
	      }
	      get verticalTextBoxEndIndex() {
	        return this._structArray.uint16[this._pos2 + 12];
	      }
	      get iconBoxStartIndex() {
	        return this._structArray.uint16[this._pos2 + 13];
	      }
	      get iconBoxEndIndex() {
	        return this._structArray.uint16[this._pos2 + 14];
	      }
	      get verticalIconBoxStartIndex() {
	        return this._structArray.uint16[this._pos2 + 15];
	      }
	      get verticalIconBoxEndIndex() {
	        return this._structArray.uint16[this._pos2 + 16];
	      }
	      get featureIndex() {
	        return this._structArray.uint16[this._pos2 + 17];
	      }
	      get numHorizontalGlyphVertices() {
	        return this._structArray.uint16[this._pos2 + 18];
	      }
	      get numVerticalGlyphVertices() {
	        return this._structArray.uint16[this._pos2 + 19];
	      }
	      get numIconVertices() {
	        return this._structArray.uint16[this._pos2 + 20];
	      }
	      get numVerticalIconVertices() {
	        return this._structArray.uint16[this._pos2 + 21];
	      }
	      get useRuntimeCollisionCircles() {
	        return this._structArray.uint16[this._pos2 + 22];
	      }
	      get crossTileID() {
	        return this._structArray.uint32[this._pos4 + 12];
	      }
	      set crossTileID(e2) {
	        this._structArray.uint32[this._pos4 + 12] = e2;
	      }
	      get textBoxScale() {
	        return this._structArray.float32[this._pos4 + 13];
	      }
	      get collisionCircleDiameter() {
	        return this._structArray.float32[this._pos4 + 14];
	      }
	      get textAnchorOffsetStartIndex() {
	        return this._structArray.uint16[this._pos2 + 30];
	      }
	      get textAnchorOffsetEndIndex() {
	        return this._structArray.uint16[this._pos2 + 31];
	      }
	    }
	    Fo.prototype.size = 64;
	    class Do extends vo {
	      get(e2) {
	        return new Fo(this, e2);
	      }
	    }
	    ls("SymbolInstanceArray", Do);
	    class Po extends bo {
	      getoffsetX(e2) {
	        return this.float32[1 * e2 + 0];
	      }
	    }
	    ls("GlyphOffsetArray", Po);
	    class Bo extends ro {
	      getx(e2) {
	        return this.int16[3 * e2 + 0];
	      }
	      gety(e2) {
	        return this.int16[3 * e2 + 1];
	      }
	      gettileUnitDistanceFromAnchor(e2) {
	        return this.int16[3 * e2 + 2];
	      }
	    }
	    ls("SymbolLineVertexArray", Bo);
	    class zo extends Ws {
	      get textAnchor() {
	        return this._structArray.uint16[this._pos2 + 0];
	      }
	      get textOffset0() {
	        return this._structArray.float32[this._pos4 + 1];
	      }
	      get textOffset1() {
	        return this._structArray.float32[this._pos4 + 2];
	      }
	    }
	    zo.prototype.size = 12;
	    class Vo extends wo {
	      get(e2) {
	        return new zo(this, e2);
	      }
	    }
	    ls("TextAnchorOffsetArray", Vo);
	    class Co extends Ws {
	      get featureIndex() {
	        return this._structArray.uint32[this._pos4 + 0];
	      }
	      get sourceLayerIndex() {
	        return this._structArray.uint16[this._pos2 + 2];
	      }
	      get bucketIndex() {
	        return this._structArray.uint16[this._pos2 + 3];
	      }
	    }
	    Co.prototype.size = 8;
	    class Lo extends _o {
	      get(e2) {
	        return new Co(this, e2);
	      }
	    }
	    ls("FeatureIndexArray", Lo);
	    class Oo extends to {
	    }
	    class Ro extends to {
	    }
	    class No extends to {
	    }
	    class $o extends io {
	    }
	    class Uo extends so {
	    }
	    class qo extends oo {
	    }
	    class jo extends ao {
	    }
	    class Go extends lo {
	    }
	    class Xo extends uo {
	    }
	    class Yo extends co {
	    }
	    class Zo extends ho {
	    }
	    class Ho extends fo {
	    }
	    class Ko extends mo {
	    }
	    class Wo extends go {
	    }
	    class Jo extends So {
	    }
	    const Qo = Qs([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: ea } = Qo;
	    class ta {
	      constructor(e2 = []) {
	        this._forceNewSegmentOnNextPrepare = false, this.segments = e2;
	      }
	      prepareSegment(e2, t2, r2, n2) {
	        const i2 = this.segments[this.segments.length - 1];
	        return e2 > ta.MAX_VERTEX_ARRAY_LENGTH && j(`Max vertices per segment is ${ta.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e2}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${ta.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !i2 || i2.vertexLength + e2 > ta.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2 ? this.createNewSegment(t2, r2, n2) : i2;
	      }
	      createNewSegment(e2, t2, r2) {
	        const n2 = { vertexOffset: e2.length, primitiveOffset: t2.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
	        return void 0 !== r2 && (n2.sortKey = r2), this._forceNewSegmentOnNextPrepare = false, this.segments.push(n2), n2;
	      }
	      getOrCreateLatestSegment(e2, t2, r2) {
	        return this.prepareSegment(0, e2, t2, r2);
	      }
	      forceNewSegmentOnNextPrepare() {
	        this._forceNewSegmentOnNextPrepare = true;
	      }
	      get() {
	        return this.segments;
	      }
	      destroy() {
	        for (const e2 of this.segments) for (const t2 in e2.vaos) e2.vaos[t2].destroy();
	      }
	      static simpleSegment(e2, t2, r2, n2) {
	        return new ta([{ vertexOffset: e2, primitiveOffset: t2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
	      }
	    }
	    function ra(e2, t2) {
	      return 256 * (e2 = C(Math.floor(e2), 0, 255)) + C(Math.floor(t2), 0, 255);
	    }
	    ta.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, ls("SegmentVector", ta);
	    const na = Qs([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), ia = Qs([{ name: "a_dasharray_from", components: 4, type: "Uint16" }, { name: "a_dasharray_to", components: 4, type: "Uint16" }]);
	    var sa, oa, aa, la = { exports: {} }, ua = { exports: {} }, ca = { exports: {} }, ha = function() {
	      if (aa) return la.exports;
	      aa = 1;
	      var e2 = (sa || (sa = 1, ua.exports = function(e3, t3) {
	        var r2, n2, i2, s2, o2, a2, l2, u2;
	        for (n2 = e3.length - (r2 = 3 & e3.length), i2 = t3, o2 = 3432918353, a2 = 461845907, u2 = 0; u2 < n2; ) l2 = 255 & e3.charCodeAt(u2) | (255 & e3.charCodeAt(++u2)) << 8 | (255 & e3.charCodeAt(++u2)) << 16 | (255 & e3.charCodeAt(++u2)) << 24, ++u2, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
	        switch (l2 = 0, r2) {
	          case 3:
	            l2 ^= (255 & e3.charCodeAt(u2 + 2)) << 16;
	          case 2:
	            l2 ^= (255 & e3.charCodeAt(u2 + 1)) << 8;
	          case 1:
	            i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & e3.charCodeAt(u2))) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295;
	        }
	        return i2 ^= e3.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
	      }), ua.exports), t2 = (oa || (oa = 1, ca.exports = function(e3, t3) {
	        for (var r2, n2 = e3.length, i2 = t3 ^ n2, s2 = 0; n2 >= 4; ) r2 = 1540483477 * (65535 & (r2 = 255 & e3.charCodeAt(s2) | (255 & e3.charCodeAt(++s2)) << 8 | (255 & e3.charCodeAt(++s2)) << 16 | (255 & e3.charCodeAt(++s2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++s2;
	        switch (n2) {
	          case 3:
	            i2 ^= (255 & e3.charCodeAt(s2 + 2)) << 16;
	          case 2:
	            i2 ^= (255 & e3.charCodeAt(s2 + 1)) << 8;
	          case 1:
	            i2 = 1540483477 * (65535 & (i2 ^= 255 & e3.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
	        }
	        return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
	      }), ca.exports);
	      return la.exports = e2, la.exports.murmur3 = e2, la.exports.murmur2 = t2, la.exports;
	    }(), pa = n(ha);
	    class fa {
	      constructor() {
	        this.ids = [], this.positions = [], this.indexed = false;
	      }
	      add(e2, t2, r2, n2) {
	        this.ids.push(da(e2)), this.positions.push(t2, r2, n2);
	      }
	      getPositions(e2) {
	        if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
	        const t2 = da(e2);
	        let r2 = 0, n2 = this.ids.length - 1;
	        for (; r2 < n2; ) {
	          const e3 = r2 + n2 >> 1;
	          this.ids[e3] >= t2 ? n2 = e3 : r2 = e3 + 1;
	        }
	        const i2 = [];
	        for (; this.ids[r2] === t2; ) i2.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
	        return i2;
	      }
	      static serialize(e2, t2) {
	        const r2 = new Float64Array(e2.ids), n2 = new Uint32Array(e2.positions);
	        return ya(r2, n2, 0, r2.length - 1), t2 && t2.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
	      }
	      static deserialize(e2) {
	        const t2 = new fa();
	        return t2.ids = e2.ids, t2.positions = e2.positions, t2.indexed = true, t2;
	      }
	    }
	    function da(e2) {
	      const t2 = +e2;
	      return !isNaN(t2) && t2 <= Number.MAX_SAFE_INTEGER ? t2 : pa(String(e2));
	    }
	    function ya(e2, t2, r2, n2) {
	      for (; r2 < n2; ) {
	        const i2 = e2[r2 + n2 >> 1];
	        let s2 = r2 - 1, o2 = n2 + 1;
	        for (; ; ) {
	          do {
	            s2++;
	          } while (e2[s2] < i2);
	          do {
	            o2--;
	          } while (e2[o2] > i2);
	          if (s2 >= o2) break;
	          ma(e2, s2, o2), ma(t2, 3 * s2, 3 * o2), ma(t2, 3 * s2 + 1, 3 * o2 + 1), ma(t2, 3 * s2 + 2, 3 * o2 + 2);
	        }
	        o2 - r2 < n2 - o2 ? (ya(e2, t2, r2, o2), r2 = o2 + 1) : (ya(e2, t2, o2 + 1, n2), n2 = o2);
	      }
	    }
	    function ma(e2, t2, r2) {
	      const n2 = e2[t2];
	      e2[t2] = e2[r2], e2[r2] = n2;
	    }
	    ls("FeaturePositionMap", fa);
	    class ga {
	      constructor(e2, t2) {
	        this.gl = e2.gl, this.location = t2;
	      }
	    }
	    class xa extends ga {
	      constructor(e2, t2) {
	        super(e2, t2), this.current = 0;
	      }
	      set(e2) {
	        this.current !== e2 && (this.current = e2, this.gl.uniform1f(this.location, e2));
	      }
	    }
	    class va extends ga {
	      constructor(e2, t2) {
	        super(e2, t2), this.current = [0, 0, 0, 0];
	      }
	      set(e2) {
	        e2[0] === this.current[0] && e2[1] === this.current[1] && e2[2] === this.current[2] && e2[3] === this.current[3] || (this.current = e2, this.gl.uniform4f(this.location, e2[0], e2[1], e2[2], e2[3]));
	      }
	    }
	    class ba extends ga {
	      constructor(e2, t2) {
	        super(e2, t2), this.current = It.transparent;
	      }
	      set(e2) {
	        e2.r === this.current.r && e2.g === this.current.g && e2.b === this.current.b && e2.a === this.current.a || (this.current = e2, this.gl.uniform4f(this.location, e2.r, e2.g, e2.b, e2.a));
	      }
	    }
	    const wa = new Float32Array(16);
	    function _a(e2) {
	      return [ra(255 * e2.r, 255 * e2.g), ra(255 * e2.b, 255 * e2.a)];
	    }
	    class Sa {
	      constructor(e2, t2, r2) {
	        this.value = e2, this.uniformNames = t2.map((e3) => `u_${e3}`), this.type = r2;
	      }
	      setUniform(e2, t2, r2) {
	        e2.set(r2.constantOr(this.value));
	      }
	      getBinding(e2, t2, r2) {
	        return "color" === this.type ? new ba(e2, t2) : new xa(e2, t2);
	      }
	    }
	    class Aa {
	      constructor(e2, t2) {
	        this.uniformNames = t2.map((e3) => `u_${e3}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
	      }
	      setConstantPatternPositions(e2, t2) {
	        this.pixelRatioFrom = t2.pixelRatio, this.pixelRatioTo = e2.pixelRatio, this.patternFrom = t2.tlbr, this.patternTo = e2.tlbr;
	      }
	      setConstantDashPositions(e2, t2) {
	        this.dashTo = [0, e2.y, e2.height, e2.width], this.dashFrom = [0, t2.y, t2.height, t2.width];
	      }
	      setUniform(e2, t2, r2, n2) {
	        let i2 = null;
	        "u_pattern_to" === n2 ? i2 = this.patternTo : "u_pattern_from" === n2 ? i2 = this.patternFrom : "u_dasharray_to" === n2 ? i2 = this.dashTo : "u_dasharray_from" === n2 ? i2 = this.dashFrom : "u_pixel_ratio_to" === n2 ? i2 = this.pixelRatioTo : "u_pixel_ratio_from" === n2 && (i2 = this.pixelRatioFrom), null !== i2 && e2.set(i2);
	      }
	      getBinding(e2, t2, r2) {
	        return "u_pattern" === r2.substr(0, 9) || "u_dasharray_" === r2.substr(0, 12) ? new va(e2, t2) : new xa(e2, t2);
	      }
	    }
	    class Ta {
	      constructor(e2, t2, r2, n2) {
	        this.expression = e2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = t2.map((e3) => ({ name: `a_${e3}`, type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2();
	      }
	      populatePaintArray(e2, t2, r2) {
	        const n2 = this.paintVertexArray.length, i2 = this.expression.evaluate(new ks(0, r2), t2, {}, r2.canonical, [], r2.formattedSection);
	        this.paintVertexArray.resize(e2), this._setPaintValue(n2, e2, i2);
	      }
	      updatePaintArray(e2, t2, r2, n2, i2) {
	        const s2 = this.expression.evaluate(new ks(0, i2), r2, n2);
	        this._setPaintValue(e2, t2, s2);
	      }
	      _setPaintValue(e2, t2, r2) {
	        if ("color" === this.type) {
	          const n2 = _a(r2);
	          for (let r3 = e2; r3 < t2; r3++) this.paintVertexArray.emplace(r3, n2[0], n2[1]);
	        } else {
	          for (let n2 = e2; n2 < t2; n2++) this.paintVertexArray.emplace(n2, r2);
	          this.maxValue = Math.max(this.maxValue, Math.abs(r2));
	        }
	      }
	      upload(e2) {
	        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
	      }
	      destroy() {
	        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
	      }
	    }
	    class Ia {
	      constructor(e2, t2, r2, n2, i2, s2) {
	        this.expression = e2, this.uniformNames = t2.map((e3) => `u_${e3}_t`), this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = t2.map((e3) => ({ name: `a_${e3}`, type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2();
	      }
	      populatePaintArray(e2, t2, r2) {
	        const n2 = this.expression.evaluate(new ks(this.zoom, r2), t2, {}, r2.canonical, [], r2.formattedSection), i2 = this.expression.evaluate(new ks(this.zoom + 1, r2), t2, {}, r2.canonical, [], r2.formattedSection), s2 = this.paintVertexArray.length;
	        this.paintVertexArray.resize(e2), this._setPaintValue(s2, e2, n2, i2);
	      }
	      updatePaintArray(e2, t2, r2, n2, i2) {
	        const s2 = this.expression.evaluate(new ks(this.zoom, i2), r2, n2), o2 = this.expression.evaluate(new ks(this.zoom + 1, i2), r2, n2);
	        this._setPaintValue(e2, t2, s2, o2);
	      }
	      _setPaintValue(e2, t2, r2, n2) {
	        if ("color" === this.type) {
	          const i2 = _a(r2), s2 = _a(n2);
	          for (let r3 = e2; r3 < t2; r3++) this.paintVertexArray.emplace(r3, i2[0], i2[1], s2[0], s2[1]);
	        } else {
	          for (let i2 = e2; i2 < t2; i2++) this.paintVertexArray.emplace(i2, r2, n2);
	          this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
	        }
	      }
	      upload(e2) {
	        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
	      }
	      destroy() {
	        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
	      }
	      setUniform(e2, t2) {
	        const r2 = this.useIntegerZoom ? Math.floor(t2.zoom) : t2.zoom, n2 = C(this.expression.interpolationFactor(r2, this.zoom, this.zoom + 1), 0, 1);
	        e2.set(n2);
	      }
	      getBinding(e2, t2, r2) {
	        return new xa(e2, t2);
	      }
	    }
	    class Ea {
	      constructor(e2, t2, r2, n2, i2, s2) {
	        this.expression = e2, this.type = t2, this.useIntegerZoom = r2, this.zoom = n2, this.layerId = s2, this.zoomInPaintVertexArray = new i2(), this.zoomOutPaintVertexArray = new i2();
	      }
	      populatePaintArray(e2, t2, r2) {
	        const n2 = this.zoomInPaintVertexArray.length;
	        this.zoomInPaintVertexArray.resize(e2), this.zoomOutPaintVertexArray.resize(e2), this._setPaintValues(n2, e2, this.getPositionIds(t2), r2);
	      }
	      updatePaintArray(e2, t2, r2, n2, i2) {
	        this._setPaintValues(e2, t2, this.getPositionIds(r2), i2);
	      }
	      _setPaintValues(e2, t2, r2, n2) {
	        const i2 = this.getPositions(n2);
	        if (!i2 || !r2) return;
	        const s2 = i2[r2.min], o2 = i2[r2.mid], a2 = i2[r2.max];
	        if (s2 && o2 && a2) for (let r3 = e2; r3 < t2; r3++) this.emplace(this.zoomInPaintVertexArray, r3, o2, s2), this.emplace(this.zoomOutPaintVertexArray, r3, o2, a2);
	      }
	      upload(e2) {
	        if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
	          const t2 = this.getVertexAttributes();
	          this.zoomInPaintVertexBuffer = e2.createVertexBuffer(this.zoomInPaintVertexArray, t2, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = e2.createVertexBuffer(this.zoomOutPaintVertexArray, t2, this.expression.isStateDependent);
	        }
	      }
	      destroy() {
	        this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
	      }
	    }
	    class Ma extends Ea {
	      getPositions(e2) {
	        return e2.imagePositions;
	      }
	      getPositionIds(e2) {
	        return e2.patterns && e2.patterns[this.layerId];
	      }
	      getVertexAttributes() {
	        return na.members;
	      }
	      emplace(e2, t2, r2, n2) {
	        e2.emplace(t2, r2.tlbr[0], r2.tlbr[1], r2.tlbr[2], r2.tlbr[3], n2.tlbr[0], n2.tlbr[1], n2.tlbr[2], n2.tlbr[3], r2.pixelRatio, n2.pixelRatio);
	      }
	    }
	    class ka extends Ea {
	      getPositions(e2) {
	        return e2.dashPositions;
	      }
	      getPositionIds(e2) {
	        return e2.dashes && e2.dashes[this.layerId];
	      }
	      getVertexAttributes() {
	        return ia.members;
	      }
	      emplace(e2, t2, r2, n2) {
	        e2.emplace(t2, 0, r2.y, r2.height, r2.width, 0, n2.y, n2.height, n2.width);
	      }
	    }
	    class Fa {
	      constructor(e2, t2, r2) {
	        this.binders = {}, this._buffers = [];
	        const n2 = [];
	        for (const i2 in e2.paint._values) {
	          if (!r2(i2)) continue;
	          const s2 = e2.paint.get(i2);
	          if (!(s2 instanceof Os && Un(s2.property.specification))) continue;
	          const o2 = Pa(i2, e2.type), a2 = s2.value, l2 = s2.property.specification.type, u2 = s2.property.useIntegerZoom, c2 = s2.property.specification["property-type"], h2 = "cross-faded" === c2 || "cross-faded-data-driven" === c2;
	          if ("constant" === a2.kind) this.binders[i2] = h2 ? new Aa(a2.value, o2) : new Sa(a2.value, o2, l2), n2.push(`/u_${i2}`);
	          else if ("source" === a2.kind || h2) {
	            const r3 = Ba(i2, l2, "source");
	            this.binders[i2] = h2 ? "line-dasharray" === i2 ? new ka(a2, l2, u2, t2, r3, e2.id) : new Ma(a2, l2, u2, t2, r3, e2.id) : new Ta(a2, o2, l2, r3), n2.push(`/a_${i2}`);
	          } else {
	            const e3 = Ba(i2, l2, "composite");
	            this.binders[i2] = new Ia(a2, o2, l2, u2, t2, e3), n2.push(`/z_${i2}`);
	          }
	        }
	        this.cacheKey = n2.sort().join("");
	      }
	      getMaxValue(e2) {
	        const t2 = this.binders[e2];
	        return t2 instanceof Ta || t2 instanceof Ia ? t2.maxValue : 0;
	      }
	      populatePaintArrays(e2, t2, r2) {
	        for (const n2 in this.binders) {
	          const i2 = this.binders[n2];
	          (i2 instanceof Ta || i2 instanceof Ia || i2 instanceof Ea) && i2.populatePaintArray(e2, t2, r2);
	        }
	      }
	      setConstantPatternPositions(e2, t2) {
	        for (const r2 in this.binders) {
	          const n2 = this.binders[r2];
	          n2 instanceof Aa && n2.setConstantPatternPositions(e2, t2);
	        }
	      }
	      setConstantDashPositions(e2, t2) {
	        for (const r2 in this.binders) {
	          const n2 = this.binders[r2];
	          n2 instanceof Aa && n2.setConstantDashPositions(e2, t2);
	        }
	      }
	      updatePaintArrays(e2, t2, r2, n2, i2) {
	        let s2 = false;
	        for (const o2 in e2) {
	          const a2 = t2.getPositions(o2);
	          for (const t3 of a2) {
	            const a3 = r2.feature(t3.index);
	            for (const r3 in this.binders) {
	              const l2 = this.binders[r3];
	              if ((l2 instanceof Ta || l2 instanceof Ia || l2 instanceof Ea) && true === l2.expression.isStateDependent) {
	                const u2 = n2.paint.get(r3);
	                l2.expression = u2.value, l2.updatePaintArray(t3.start, t3.end, a3, e2[o2], i2), s2 = true;
	              }
	            }
	          }
	        }
	        return s2;
	      }
	      defines() {
	        const e2 = [];
	        for (const t2 in this.binders) {
	          const r2 = this.binders[t2];
	          (r2 instanceof Sa || r2 instanceof Aa) && e2.push(...r2.uniformNames.map((e3) => `#define HAS_UNIFORM_${e3}`));
	        }
	        return e2;
	      }
	      getBinderAttributes() {
	        const e2 = [];
	        for (const t2 in this.binders) {
	          const r2 = this.binders[t2];
	          if (r2 instanceof Ta || r2 instanceof Ia) for (let t3 = 0; t3 < r2.paintVertexAttributes.length; t3++) e2.push(r2.paintVertexAttributes[t3].name);
	          else if (r2 instanceof Ea) {
	            const t3 = r2.getVertexAttributes();
	            for (const r3 of t3) e2.push(r3.name);
	          }
	        }
	        return e2;
	      }
	      getBinderUniforms() {
	        const e2 = [];
	        for (const t2 in this.binders) {
	          const r2 = this.binders[t2];
	          if (r2 instanceof Sa || r2 instanceof Aa || r2 instanceof Ia) for (const t3 of r2.uniformNames) e2.push(t3);
	        }
	        return e2;
	      }
	      getPaintVertexBuffers() {
	        return this._buffers;
	      }
	      getUniforms(e2, t2) {
	        const r2 = [];
	        for (const n2 in this.binders) {
	          const i2 = this.binders[n2];
	          if (i2 instanceof Sa || i2 instanceof Aa || i2 instanceof Ia) {
	            for (const s2 of i2.uniformNames) if (t2[s2]) {
	              const o2 = i2.getBinding(e2, t2[s2], s2);
	              r2.push({ name: s2, property: n2, binding: o2 });
	            }
	          }
	        }
	        return r2;
	      }
	      setUniforms(e2, t2, r2, n2) {
	        for (const { name: e3, property: i2, binding: s2 } of t2) this.binders[i2].setUniform(s2, n2, r2.get(i2), e3);
	      }
	      updatePaintBuffers(e2) {
	        this._buffers = [];
	        for (const t2 in this.binders) {
	          const r2 = this.binders[t2];
	          if (e2 && r2 instanceof Ea) {
	            const t3 = 2 === e2.fromScale ? r2.zoomInPaintVertexBuffer : r2.zoomOutPaintVertexBuffer;
	            t3 && this._buffers.push(t3);
	          } else (r2 instanceof Ta || r2 instanceof Ia) && r2.paintVertexBuffer && this._buffers.push(r2.paintVertexBuffer);
	        }
	      }
	      upload(e2) {
	        for (const t2 in this.binders) {
	          const r2 = this.binders[t2];
	          (r2 instanceof Ta || r2 instanceof Ia || r2 instanceof Ea) && r2.upload(e2);
	        }
	        this.updatePaintBuffers();
	      }
	      destroy() {
	        for (const e2 in this.binders) {
	          const t2 = this.binders[e2];
	          (t2 instanceof Ta || t2 instanceof Ia || t2 instanceof Ea) && t2.destroy();
	        }
	      }
	    }
	    class Da {
	      constructor(e2, t2, r2 = () => true) {
	        this.programConfigurations = {};
	        for (const n2 of e2) this.programConfigurations[n2.id] = new Fa(n2, t2, r2);
	        this.needsUpload = false, this._featureMap = new fa(), this._bufferOffset = 0;
	      }
	      populatePaintArrays(e2, t2, r2, n2) {
	        for (const r3 in this.programConfigurations) this.programConfigurations[r3].populatePaintArrays(e2, t2, n2);
	        void 0 !== t2.id && this._featureMap.add(t2.id, r2, this._bufferOffset, e2), this._bufferOffset = e2, this.needsUpload = true;
	      }
	      updatePaintArrays(e2, t2, r2, n2) {
	        for (const i2 of r2) this.needsUpload = this.programConfigurations[i2.id].updatePaintArrays(e2, this._featureMap, t2, i2, n2) || this.needsUpload;
	      }
	      get(e2) {
	        return this.programConfigurations[e2];
	      }
	      upload(e2) {
	        if (this.needsUpload) {
	          for (const t2 in this.programConfigurations) this.programConfigurations[t2].upload(e2);
	          this.needsUpload = false;
	        }
	      }
	      destroy() {
	        for (const e2 in this.programConfigurations) this.programConfigurations[e2].destroy();
	      }
	    }
	    function Pa(e2, t2) {
	      return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-dasharray": ["dasharray_to", "dasharray_from"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[e2] || [e2.replace(`${t2}-`, "").replace(/-/g, "_")];
	    }
	    function Ba(e2, t2, r2) {
	      const n2 = { color: { source: oo, composite: To }, number: { source: bo, composite: oo } }, i2 = function(e3) {
	        return { "line-pattern": { source: jo, composite: jo }, "fill-pattern": { source: jo, composite: jo }, "fill-extrusion-pattern": { source: jo, composite: jo }, "line-dasharray": { source: Go, composite: Go } }[e3];
	      }(e2);
	      return i2 && i2[r2] || n2[t2][r2];
	    }
	    ls("ConstantBinder", Sa), ls("CrossFadedConstantBinder", Aa), ls("SourceExpressionBinder", Ta), ls("CrossFadedPatternBinder", Ma), ls("CrossFadedDasharrayBinder", ka), ls("CompositeExpressionBinder", Ia), ls("ProgramConfiguration", Fa, { omit: ["_buffers"] }), ls("ProgramConfigurationSet", Da);
	    const za = Math.pow(2, 14) - 1, Va = -za - 1;
	    function Ca(e2) {
	      const t2 = k / e2.extent, r2 = e2.loadGeometry();
	      for (let e3 = 0; e3 < r2.length; e3++) {
	        const n2 = r2[e3];
	        for (let e4 = 0; e4 < n2.length; e4++) {
	          const r3 = n2[e4], i2 = Math.round(r3.x * t2), s2 = Math.round(r3.y * t2);
	          r3.x = C(i2, Va, za), r3.y = C(s2, Va, za), (i2 < r3.x || i2 > r3.x + 1 || s2 < r3.y || s2 > r3.y + 1) && j("Geometry exceeds allowed extent, reduce your vector tile buffer size");
	        }
	      }
	      return r2;
	    }
	    function La(e2, t2) {
	      return { type: e2.type, id: e2.id, properties: e2.properties, geometry: t2 ? Ca(e2) : [] };
	    }
	    const Oa = -32768;
	    function Ra(e2, t2, r2, n2, i2) {
	      e2.emplaceBack(Oa + 8 * t2 + n2, Oa + 8 * r2 + i2);
	    }
	    class Na {
	      constructor(e2) {
	        this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((e3) => e3.id), this.index = e2.index, this.hasDependencies = false, this.layoutVertexArray = new Ro(), this.indexArray = new Wo(), this.segments = new ta(), this.programConfigurations = new Da(e2.layers, e2.zoom), this.stateDependentLayerIds = this.layers.filter((e3) => e3.isStateDependent()).map((e3) => e3.id);
	      }
	      populate(e2, t2, r2) {
	        const n2 = this.layers[0], i2 = [];
	        let s2 = null, o2 = false, a2 = "heatmap" === n2.type;
	        if ("circle" === n2.type) {
	          const e3 = n2;
	          s2 = e3.layout.get("circle-sort-key"), o2 = !s2.isConstant(), a2 = a2 || "map" === e3.paint.get("circle-pitch-alignment");
	        }
	        const l2 = a2 ? t2.subdivisionGranularity.circle : 1;
	        for (const { feature: t3, id: n3, index: a3, sourceLayerIndex: l3 } of e2) {
	          const e3 = this.layers[0]._featureFilter.needGeometry, u2 = La(t3, e3);
	          if (!this.layers[0]._featureFilter.filter(new ks(this.zoom), u2, r2)) continue;
	          const c2 = o2 ? s2.evaluate(u2, {}, r2) : void 0, h2 = { id: n3, properties: t3.properties, type: t3.type, sourceLayerIndex: l3, index: a3, geometry: e3 ? u2.geometry : Ca(t3), patterns: {}, sortKey: c2 };
	          i2.push(h2);
	        }
	        o2 && i2.sort((e3, t3) => e3.sortKey - t3.sortKey);
	        for (const n3 of i2) {
	          const { geometry: i3, index: s3, sourceLayerIndex: o3 } = n3, a3 = e2[s3].feature;
	          this.addFeature(n3, i3, s3, r2, l2), t2.featureIndex.insert(a3, i3, s3, o3, this.index);
	        }
	      }
	      update(e2, t2, r2) {
	        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e2, t2, this.stateDependentLayers, { imagePositions: r2 });
	      }
	      isEmpty() {
	        return 0 === this.layoutVertexArray.length;
	      }
	      uploadPending() {
	        return !this.uploaded || this.programConfigurations.needsUpload;
	      }
	      upload(e2) {
	        this.uploaded || (this.layoutVertexBuffer = e2.createVertexBuffer(this.layoutVertexArray, ea), this.indexBuffer = e2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e2), this.uploaded = true;
	      }
	      destroy() {
	        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
	      }
	      addFeature(e2, t2, r2, n2, i2 = 1) {
	        let s2;
	        switch (i2) {
	          case 1:
	            s2 = [0, 7];
	            break;
	          case 3:
	            s2 = [0, 2, 5, 7];
	            break;
	          case 5:
	            s2 = [0, 1, 3, 4, 6, 7];
	            break;
	          case 7:
	            s2 = [0, 1, 2, 3, 4, 5, 6, 7];
	            break;
	          default:
	            throw new Error(`Invalid circle bucket granularity: ${i2}; valid values are 1, 3, 5, 7.`);
	        }
	        const o2 = s2.length;
	        for (const r3 of t2) for (const t3 of r3) {
	          const r4 = t3.x, n3 = t3.y;
	          if (r4 < 0 || r4 >= k || n3 < 0 || n3 >= k) continue;
	          const i3 = this.segments.prepareSegment(o2 * o2, this.layoutVertexArray, this.indexArray, e2.sortKey), a2 = i3.vertexLength;
	          for (let e3 = 0; e3 < o2; e3++) for (let t4 = 0; t4 < o2; t4++) Ra(this.layoutVertexArray, r4, n3, s2[t4], s2[e3]);
	          for (let e3 = 0; e3 < o2 - 1; e3++) for (let t4 = 0; t4 < o2 - 1; t4++) {
	            const r5 = a2 + e3 * o2 + t4, n4 = a2 + (e3 + 1) * o2 + t4;
	            this.indexArray.emplaceBack(r5, n4 + 1, r5 + 1), this.indexArray.emplaceBack(r5, n4, n4 + 1);
	          }
	          i3.vertexLength += o2 * o2, i3.primitiveLength += (o2 - 1) * (o2 - 1) * 2;
	        }
	        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e2, r2, { imagePositions: {}, canonical: n2 });
	      }
	    }
	    function $a(e2, t2) {
	      for (let r2 = 0; r2 < e2.length; r2++) if (Ka(t2, e2[r2])) return true;
	      for (let r2 = 0; r2 < t2.length; r2++) if (Ka(e2, t2[r2])) return true;
	      return !!Ga(e2, t2);
	    }
	    function Ua(e2, t2, r2) {
	      return !!Ka(e2, t2) || !!Ya(t2, e2, r2);
	    }
	    function qa(e2, t2) {
	      if (1 === e2.length) return Ha(t2, e2[0]);
	      for (let r2 = 0; r2 < t2.length; r2++) {
	        const n2 = t2[r2];
	        for (let t3 = 0; t3 < n2.length; t3++) if (Ka(e2, n2[t3])) return true;
	      }
	      for (let r2 = 0; r2 < e2.length; r2++) if (Ha(t2, e2[r2])) return true;
	      for (let r2 = 0; r2 < t2.length; r2++) if (Ga(e2, t2[r2])) return true;
	      return false;
	    }
	    function ja(e2, t2, r2) {
	      if (e2.length > 1) {
	        if (Ga(e2, t2)) return true;
	        for (let n2 = 0; n2 < t2.length; n2++) if (Ya(t2[n2], e2, r2)) return true;
	      }
	      for (let n2 = 0; n2 < e2.length; n2++) if (Ya(e2[n2], t2, r2)) return true;
	      return false;
	    }
	    function Ga(e2, t2) {
	      if (0 === e2.length || 0 === t2.length) return false;
	      for (let r2 = 0; r2 < e2.length - 1; r2++) {
	        const n2 = e2[r2], i2 = e2[r2 + 1];
	        for (let e3 = 0; e3 < t2.length - 1; e3++) if (Xa(n2, i2, t2[e3], t2[e3 + 1])) return true;
	      }
	      return false;
	    }
	    function Xa(e2, t2, r2, n2) {
	      return G(e2, r2, n2) !== G(t2, r2, n2) && G(e2, t2, r2) !== G(e2, t2, n2);
	    }
	    function Ya(e2, t2, r2) {
	      const n2 = r2 * r2;
	      if (1 === t2.length) return e2.distSqr(t2[0]) < n2;
	      for (let r3 = 1; r3 < t2.length; r3++) if (Za(e2, t2[r3 - 1], t2[r3]) < n2) return true;
	      return false;
	    }
	    function Za(e2, t2, r2) {
	      const n2 = t2.distSqr(r2);
	      if (0 === n2) return e2.distSqr(t2);
	      const i2 = ((e2.x - t2.x) * (r2.x - t2.x) + (e2.y - t2.y) * (r2.y - t2.y)) / n2;
	      return e2.distSqr(i2 < 0 ? t2 : i2 > 1 ? r2 : r2.sub(t2)._mult(i2)._add(t2));
	    }
	    function Ha(e2, t2) {
	      let r2, n2, i2, s2 = false;
	      for (let o2 = 0; o2 < e2.length; o2++) {
	        r2 = e2[o2];
	        for (let e3 = 0, o3 = r2.length - 1; e3 < r2.length; o3 = e3++) n2 = r2[e3], i2 = r2[o3], n2.y > t2.y != i2.y > t2.y && t2.x < (i2.x - n2.x) * (t2.y - n2.y) / (i2.y - n2.y) + n2.x && (s2 = !s2);
	      }
	      return s2;
	    }
	    function Ka(e2, t2) {
	      let r2 = false;
	      for (let n2 = 0, i2 = e2.length - 1; n2 < e2.length; i2 = n2++) {
	        const s2 = e2[n2], o2 = e2[i2];
	        s2.y > t2.y != o2.y > t2.y && t2.x < (o2.x - s2.x) * (t2.y - s2.y) / (o2.y - s2.y) + s2.x && (r2 = !r2);
	      }
	      return r2;
	    }
	    function Wa(e2, t2, r2) {
	      const n2 = r2[0], i2 = r2[2];
	      if (e2.x < n2.x && t2.x < n2.x || e2.x > i2.x && t2.x > i2.x || e2.y < n2.y && t2.y < n2.y || e2.y > i2.y && t2.y > i2.y) return false;
	      const s2 = G(e2, t2, r2[0]);
	      return s2 !== G(e2, t2, r2[1]) || s2 !== G(e2, t2, r2[2]) || s2 !== G(e2, t2, r2[3]);
	    }
	    function Ja(e2, t2, r2) {
	      const n2 = t2.paint.get(e2).value;
	      return "constant" === n2.kind ? n2.value : r2.programConfigurations.get(t2.id).getMaxValue(e2);
	    }
	    function Qa(e2) {
	      return Math.sqrt(e2[0] * e2[0] + e2[1] * e2[1]);
	    }
	    function el(e2, t2, n2, i2, s2) {
	      if (!t2[0] && !t2[1]) return e2;
	      const o2 = r.convert(t2)._mult(s2);
	      "viewport" === n2 && o2._rotate(-i2);
	      const a2 = [];
	      for (let t3 = 0; t3 < e2.length; t3++) a2.push(e2[t3].sub(o2));
	      return a2;
	    }
	    function tl({ queryGeometry: e2, size: t2 }, r2) {
	      return Ua(e2, r2, t2);
	    }
	    function rl({ queryGeometry: e2, size: t2, transform: r2, unwrappedTileID: n2, getElevation: i2 }, s2) {
	      return Ua(e2, s2, t2 * (r2.projectTileCoordinates(s2.x, s2.y, n2, i2).signedDistanceFromCamera / r2.cameraToCenterDistance));
	    }
	    function nl({ queryGeometry: e2, size: t2, transform: r2, unwrappedTileID: n2, getElevation: i2 }, s2) {
	      const o2 = r2.projectTileCoordinates(s2.x, s2.y, n2, i2).signedDistanceFromCamera, a2 = t2 * (r2.cameraToCenterDistance / o2);
	      return Ua(e2, ol(s2, r2, n2, i2), a2);
	    }
	    function il({ queryGeometry: e2, size: t2, transform: r2, unwrappedTileID: n2, getElevation: i2 }, s2) {
	      return Ua(e2, ol(s2, r2, n2, i2), t2);
	    }
	    function sl({ queryGeometry: e2, size: t2, transform: r2, unwrappedTileID: n2, getElevation: i2, pitchAlignment: s2 = "map", pitchScale: o2 = "map" }, a2) {
	      const l2 = "map" === s2 ? "map" === o2 ? tl : rl : "map" === o2 ? nl : il, u2 = { queryGeometry: e2, size: t2, transform: r2, unwrappedTileID: n2, getElevation: i2 };
	      for (const e3 of a2) for (const t3 of e3) if (l2(u2, t3)) return true;
	      return false;
	    }
	    function ol(e2, t2, n2, i2) {
	      const s2 = t2.projectTileCoordinates(e2.x, e2.y, n2, i2).point;
	      return new r((0.5 * s2.x + 0.5) * t2.width, (0.5 * -s2.y + 0.5) * t2.height);
	    }
	    let al, ll;
	    ls("CircleBucket", Na, { omit: ["layers"] });
	    var ul = { get paint() {
	      return ll = ll || new Gs({ "circle-radius": new $s(xe.paint_circle["circle-radius"]), "circle-color": new $s(xe.paint_circle["circle-color"]), "circle-blur": new $s(xe.paint_circle["circle-blur"]), "circle-opacity": new $s(xe.paint_circle["circle-opacity"]), "circle-translate": new Ns(xe.paint_circle["circle-translate"]), "circle-translate-anchor": new Ns(xe.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Ns(xe.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Ns(xe.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new $s(xe.paint_circle["circle-stroke-width"]), "circle-stroke-color": new $s(xe.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new $s(xe.paint_circle["circle-stroke-opacity"]) });
	    }, get layout() {
	      return al = al || new Gs({ "circle-sort-key": new $s(xe.layout_circle["circle-sort-key"]) });
	    } };
	    class cl extends Xs {
	      constructor(e2, t2) {
	        super(e2, ul, t2);
	      }
	      createBucket(e2) {
	        return new Na(e2);
	      }
	      queryRadius(e2) {
	        const t2 = e2;
	        return Ja("circle-radius", this, t2) + Ja("circle-stroke-width", this, t2) + Qa(this.paint.get("circle-translate"));
	      }
	      queryIntersectsFeature({ queryGeometry: e2, feature: t2, featureState: r2, geometry: n2, transform: i2, pixelsToTileUnits: s2, unwrappedTileID: o2, getElevation: a2 }) {
	        const l2 = el(e2, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -i2.bearingInRadians, s2), u2 = this.paint.get("circle-radius").evaluate(t2, r2) + this.paint.get("circle-stroke-width").evaluate(t2, r2), c2 = this.paint.get("circle-pitch-scale"), h2 = this.paint.get("circle-pitch-alignment");
	        let p2, f2;
	        return "map" === h2 ? (p2 = l2, f2 = u2 * s2) : (p2 = function(e3, t3, r3, n3) {
	          return e3.map((e4) => ol(e4, t3, r3, n3));
	        }(l2, i2, o2, a2), f2 = u2), sl({ queryGeometry: p2, size: f2, transform: i2, unwrappedTileID: o2, getElevation: a2, pitchAlignment: h2, pitchScale: c2 }, n2);
	      }
	    }
	    class hl extends Na {
	    }
	    let pl;
	    ls("HeatmapBucket", hl, { omit: ["layers"] });
	    var fl = { get paint() {
	      return pl = pl || new Gs({ "heatmap-radius": new $s(xe.paint_heatmap["heatmap-radius"]), "heatmap-weight": new $s(xe.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Ns(xe.paint_heatmap["heatmap-intensity"]), "heatmap-color": new js(xe.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Ns(xe.paint_heatmap["heatmap-opacity"]) });
	    } };
	    function dl(e2, { width: t2, height: r2 }, n2, i2) {
	      if (i2) {
	        if (i2 instanceof Uint8ClampedArray) i2 = new Uint8Array(i2.buffer);
	        else if (i2.length !== t2 * r2 * n2) throw new RangeError(`mismatched image size. expected: ${i2.length} but got: ${t2 * r2 * n2}`);
	      } else i2 = new Uint8Array(t2 * r2 * n2);
	      return e2.width = t2, e2.height = r2, e2.data = i2, e2;
	    }
	    function yl(e2, { width: t2, height: r2 }, n2) {
	      if (t2 === e2.width && r2 === e2.height) return;
	      const i2 = dl({}, { width: t2, height: r2 }, n2);
	      ml(e2, i2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(e2.width, t2), height: Math.min(e2.height, r2) }, n2), e2.width = t2, e2.height = r2, e2.data = i2.data;
	    }
	    function ml(e2, t2, r2, n2, i2, s2) {
	      if (0 === i2.width || 0 === i2.height) return t2;
	      if (i2.width > e2.width || i2.height > e2.height || r2.x > e2.width - i2.width || r2.y > e2.height - i2.height) throw new RangeError("out of range source coordinates for image copy");
	      if (i2.width > t2.width || i2.height > t2.height || n2.x > t2.width - i2.width || n2.y > t2.height - i2.height) throw new RangeError("out of range destination coordinates for image copy");
	      const o2 = e2.data, a2 = t2.data;
	      if (o2 === a2) throw new Error("srcData equals dstData, so image is already copied");
	      for (let l2 = 0; l2 < i2.height; l2++) {
	        const u2 = ((r2.y + l2) * e2.width + r2.x) * s2, c2 = ((n2.y + l2) * t2.width + n2.x) * s2;
	        for (let e3 = 0; e3 < i2.width * s2; e3++) a2[c2 + e3] = o2[u2 + e3];
	      }
	      return t2;
	    }
	    class gl {
	      constructor(e2, t2) {
	        dl(this, e2, 1, t2);
	      }
	      resize(e2) {
	        yl(this, e2, 1);
	      }
	      clone() {
	        return new gl({ width: this.width, height: this.height }, new Uint8Array(this.data));
	      }
	      static copy(e2, t2, r2, n2, i2) {
	        ml(e2, t2, r2, n2, i2, 1);
	      }
	    }
	    class xl {
	      constructor(e2, t2) {
	        dl(this, e2, 4, t2);
	      }
	      resize(e2) {
	        yl(this, e2, 4);
	      }
	      replace(e2, t2) {
	        t2 ? this.data.set(e2) : this.data = e2 instanceof Uint8ClampedArray ? new Uint8Array(e2.buffer) : e2;
	      }
	      clone() {
	        return new xl({ width: this.width, height: this.height }, new Uint8Array(this.data));
	      }
	      static copy(e2, t2, r2, n2, i2) {
	        ml(e2, t2, r2, n2, i2, 4);
	      }
	      setPixel(e2, t2, r2) {
	        const n2 = 4 * (e2 * this.width + t2);
	        this.data[n2 + 0] = Math.round(255 * r2.r / r2.a), this.data[n2 + 1] = Math.round(255 * r2.g / r2.a), this.data[n2 + 2] = Math.round(255 * r2.b / r2.a), this.data[n2 + 3] = Math.round(255 * r2.a);
	      }
	    }
	    function vl(e2) {
	      const t2 = {}, r2 = e2.resolution || 256, n2 = e2.clips ? e2.clips.length : 1, i2 = e2.image || new xl({ width: r2, height: n2 });
	      if (Math.log(r2) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r2}`);
	      const s2 = (n3, s3, o2) => {
	        t2[e2.evaluationKey] = o2;
	        const a2 = e2.expression.evaluate(t2);
	        i2.setPixel(n3 / 4 / r2, s3 / 4, a2);
	      };
	      if (e2.clips) for (let t3 = 0, i3 = 0; t3 < n2; ++t3, i3 += 4 * r2) for (let n3 = 0, o2 = 0; n3 < r2; n3++, o2 += 4) {
	        const a2 = n3 / (r2 - 1), { start: l2, end: u2 } = e2.clips[t3];
	        s2(i3, o2, l2 * (1 - a2) + u2 * a2);
	      }
	      else for (let e3 = 0, t3 = 0; e3 < r2; e3++, t3 += 4) s2(0, t3, e3 / (r2 - 1));
	      return i2;
	    }
	    ls("AlphaImage", gl), ls("RGBAImage", xl);
	    const bl = "big-fb";
	    class wl extends Xs {
	      createBucket(e2) {
	        return new hl(e2);
	      }
	      constructor(e2, t2) {
	        super(e2, fl, t2), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
	      }
	      _handleSpecialPaintPropertyUpdate(e2) {
	        "heatmap-color" === e2 && this._updateColorRamp();
	      }
	      _updateColorRamp() {
	        this.colorRamp = vl({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
	      }
	      resize() {
	        this.heatmapFbos.has(bl) && this.heatmapFbos.delete(bl);
	      }
	      queryRadius(e2) {
	        return Ja("heatmap-radius", this, e2);
	      }
	      queryIntersectsFeature({ queryGeometry: e2, feature: t2, featureState: r2, geometry: n2, transform: i2, pixelsToTileUnits: s2, unwrappedTileID: o2, getElevation: a2 }) {
	        return sl({ queryGeometry: e2, size: this.paint.get("heatmap-radius").evaluate(t2, r2) * s2, transform: i2, unwrappedTileID: o2, getElevation: a2 }, n2);
	      }
	      hasOffscreenPass() {
	        return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
	      }
	    }
	    let _l;
	    var Sl = { get paint() {
	      return _l = _l || new Gs({ "hillshade-illumination-direction": new Ns(xe.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new Ns(xe.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new Ns(xe.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Ns(xe.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Ns(xe.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Ns(xe.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Ns(xe.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new Ns(xe.paint_hillshade["hillshade-method"]) });
	    } };
	    class Al extends Xs {
	      constructor(e2, t2) {
	        super(e2, Sl, t2), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
	      }
	      getIlluminationProperties() {
	        let e2 = this.paint.get("hillshade-illumination-direction").values, t2 = this.paint.get("hillshade-illumination-altitude").values, r2 = this.paint.get("hillshade-highlight-color").values, n2 = this.paint.get("hillshade-shadow-color").values;
	        const i2 = Math.max(e2.length, t2.length, r2.length, n2.length);
	        e2 = e2.concat(Array(i2 - e2.length).fill(e2.at(-1))), t2 = t2.concat(Array(i2 - t2.length).fill(t2.at(-1))), r2 = r2.concat(Array(i2 - r2.length).fill(r2.at(-1))), n2 = n2.concat(Array(i2 - n2.length).fill(n2.at(-1)));
	        const s2 = t2.map(ee);
	        return { directionRadians: e2.map(ee), altitudeRadians: s2, shadowColor: n2, highlightColor: r2 };
	      }
	      hasOffscreenPass() {
	        return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
	      }
	    }
	    let Tl;
	    var Il = { get paint() {
	      return Tl = Tl || new Gs({ "color-relief-opacity": new Ns(xe["paint_color-relief"]["color-relief-opacity"]), "color-relief-color": new js(xe["paint_color-relief"]["color-relief-color"]) });
	    } };
	    class El {
	      constructor(e2, t2, r2, n2) {
	        this.context = e2, this.format = r2, this.texture = e2.gl.createTexture(), this.update(t2, n2);
	      }
	      update(e2, t2, r2) {
	        const { width: n2, height: i2 } = e2, s2 = !(this.size && this.size[0] === n2 && this.size[1] === i2 || r2), { context: o2 } = this, { gl: a2 } = o2;
	        if (this.useMipmap = Boolean(t2 && t2.useMipmap), a2.bindTexture(a2.TEXTURE_2D, this.texture), o2.pixelStoreUnpackFlipY.set(false), o2.pixelStoreUnpack.set(1), o2.pixelStoreUnpackPremultiplyAlpha.set(this.format === a2.RGBA && (!t2 || false !== t2.premultiply)), s2) this.size = [n2, i2], e2 instanceof HTMLImageElement || e2 instanceof HTMLCanvasElement || e2 instanceof HTMLVideoElement || e2 instanceof ImageData || Z(e2) ? a2.texImage2D(a2.TEXTURE_2D, 0, this.format, this.format, a2.UNSIGNED_BYTE, e2) : a2.texImage2D(a2.TEXTURE_2D, 0, this.format, n2, i2, 0, this.format, a2.UNSIGNED_BYTE, e2.data);
	        else {
	          const { x: t3, y: s3 } = r2 || { x: 0, y: 0 };
	          e2 instanceof HTMLImageElement || e2 instanceof HTMLCanvasElement || e2 instanceof HTMLVideoElement || e2 instanceof ImageData || Z(e2) ? a2.texSubImage2D(a2.TEXTURE_2D, 0, t3, s3, a2.RGBA, a2.UNSIGNED_BYTE, e2) : a2.texSubImage2D(a2.TEXTURE_2D, 0, t3, s3, n2, i2, a2.RGBA, a2.UNSIGNED_BYTE, e2.data);
	        }
	        this.useMipmap && this.isSizePowerOfTwo() && a2.generateMipmap(a2.TEXTURE_2D), o2.pixelStoreUnpackFlipY.setDefault(), o2.pixelStoreUnpack.setDefault(), o2.pixelStoreUnpackPremultiplyAlpha.setDefault();
	      }
	      bind(e2, t2, r2) {
	        const { context: n2 } = this, { gl: i2 } = n2;
	        i2.bindTexture(i2.TEXTURE_2D, this.texture), r2 !== i2.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (r2 = i2.LINEAR), e2 !== this.filter && (i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MAG_FILTER, e2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MIN_FILTER, r2 || e2), this.filter = e2), t2 !== this.wrap && (i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_S, t2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_T, t2), this.wrap = t2);
	      }
	      isSizePowerOfTwo() {
	        return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
	      }
	      destroy() {
	        const { gl: e2 } = this.context;
	        e2.deleteTexture(this.texture), this.texture = null;
	      }
	    }
	    class Ml {
	      constructor(e2, t2, r2, n2 = 1, i2 = 1, s2 = 1, o2 = 0) {
	        if (this.uid = e2, t2.height !== t2.width) throw new RangeError("DEM tiles must be square");
	        if (r2 && !["mapbox", "terrarium", "custom"].includes(r2)) return void j(`"${r2}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
	        this.stride = t2.height;
	        const a2 = this.dim = t2.height - 2;
	        switch (this.data = new Uint32Array(t2.data.buffer), r2) {
	          case "terrarium":
	            this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
	            break;
	          case "custom":
	            this.redFactor = n2, this.greenFactor = i2, this.blueFactor = s2, this.baseShift = o2;
	            break;
	          default:
	            this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
	        }
	        for (let e3 = 0; e3 < a2; e3++) this.data[this._idx(-1, e3)] = this.data[this._idx(0, e3)], this.data[this._idx(a2, e3)] = this.data[this._idx(a2 - 1, e3)], this.data[this._idx(e3, -1)] = this.data[this._idx(e3, 0)], this.data[this._idx(e3, a2)] = this.data[this._idx(e3, a2 - 1)];
	        this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(a2, -1)] = this.data[this._idx(a2 - 1, 0)], this.data[this._idx(-1, a2)] = this.data[this._idx(0, a2 - 1)], this.data[this._idx(a2, a2)] = this.data[this._idx(a2 - 1, a2 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
	        for (let e3 = 0; e3 < a2; e3++) for (let t3 = 0; t3 < a2; t3++) {
	          const r3 = this.get(e3, t3);
	          r3 > this.max && (this.max = r3), r3 < this.min && (this.min = r3);
	        }
	      }
	      get(e2, t2) {
	        const r2 = new Uint8Array(this.data.buffer), n2 = 4 * this._idx(e2, t2);
	        return this.unpack(r2[n2], r2[n2 + 1], r2[n2 + 2]);
	      }
	      getUnpackVector() {
	        return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
	      }
	      _idx(e2, t2) {
	        if (e2 < -1 || e2 >= this.dim + 1 || t2 < -1 || t2 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
	        return (t2 + 1) * this.stride + (e2 + 1);
	      }
	      unpack(e2, t2, r2) {
	        return e2 * this.redFactor + t2 * this.greenFactor + r2 * this.blueFactor - this.baseShift;
	      }
	      pack(e2) {
	        return kl(e2, this.getUnpackVector());
	      }
	      getPixels() {
	        return new xl({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
	      }
	      backfillBorder(e2, t2, r2) {
	        if (this.dim !== e2.dim) throw new Error("dem dimension mismatch");
	        let n2 = t2 * this.dim, i2 = t2 * this.dim + this.dim, s2 = r2 * this.dim, o2 = r2 * this.dim + this.dim;
	        switch (t2) {
	          case -1:
	            n2 = i2 - 1;
	            break;
	          case 1:
	            i2 = n2 + 1;
	        }
	        switch (r2) {
	          case -1:
	            s2 = o2 - 1;
	            break;
	          case 1:
	            o2 = s2 + 1;
	        }
	        const a2 = -t2 * this.dim, l2 = -r2 * this.dim;
	        for (let t3 = s2; t3 < o2; t3++) for (let r3 = n2; r3 < i2; r3++) this.data[this._idx(r3, t3)] = e2.data[this._idx(r3 + a2, t3 + l2)];
	      }
	    }
	    function kl(e2, t2) {
	      const r2 = t2[0], n2 = t2[1], i2 = t2[2], s2 = t2[3], o2 = Math.min(r2, n2, i2), a2 = Math.round((e2 + s2) / o2);
	      return { r: Math.floor(a2 * o2 / r2) % 256, g: Math.floor(a2 * o2 / n2) % 256, b: Math.floor(a2 * o2 / i2) % 256 };
	    }
	    ls("DEMData", Ml);
	    class Fl extends Xs {
	      constructor(e2, t2) {
	        super(e2, Il, t2);
	      }
	      _createColorRamp(e2) {
	        const t2 = { elevationStops: [], colorStops: [] }, r2 = this._transitionablePaint._values["color-relief-color"].value.expression;
	        if (r2 instanceof ni && r2._styleExpression.expression instanceof pr) {
	          this.colorRampExpression = r2;
	          const e3 = r2._styleExpression.expression;
	          t2.elevationStops = e3.labels, t2.colorStops = [];
	          for (const r3 of t2.elevationStops) t2.colorStops.push(e3.evaluate({ globals: { elevation: r3 } }));
	        }
	        if (t2.elevationStops.length < 1 && (t2.elevationStops = [0], t2.colorStops = [It.transparent]), t2.elevationStops.length < 2 && (t2.elevationStops.push(t2.elevationStops[0] + 1), t2.colorStops.push(t2.colorStops[0])), t2.elevationStops.length <= e2) return t2;
	        const n2 = { elevationStops: [], colorStops: [] }, i2 = (t2.elevationStops.length - 1) / (e2 - 1);
	        for (let e3 = 0; e3 < t2.elevationStops.length - 0.5; e3 += i2) n2.elevationStops.push(t2.elevationStops[Math.round(e3)]), n2.colorStops.push(t2.colorStops[Math.round(e3)]);
	        return j(`Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${e2}, provided: ${t2.elevationStops.length}`), n2;
	      }
	      _colorRampChanged() {
	        return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
	      }
	      getColorRampTextures(e2, t2, r2) {
	        if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
	        const n2 = this._createColorRamp(t2), i2 = new xl({ width: n2.colorStops.length, height: 1 }), s2 = new xl({ width: n2.colorStops.length, height: 1 });
	        for (let e3 = 0; e3 < n2.elevationStops.length; e3++) {
	          const t3 = kl(n2.elevationStops[e3], r2);
	          s2.setPixel(0, e3, new It(t3.r / 255, t3.g / 255, t3.b / 255, 1)), i2.setPixel(0, e3, n2.colorStops[e3]);
	        }
	        return this.colorRampTextures = { elevationTexture: new El(e2, s2, e2.gl.RGBA), colorTexture: new El(e2, i2, e2.gl.RGBA) }, this.colorRampTextures;
	      }
	      hasOffscreenPass() {
	        return "none" !== this.visibility && !!this.colorRampTextures;
	      }
	    }
	    const Dl = Qs([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Pl } = Dl;
	    function Bl(e2, t2, r2) {
	      const n2 = r2.patternDependencies;
	      let i2 = false;
	      for (const r3 of t2) {
	        const t3 = r3.paint.get(`${e2}-pattern`);
	        t3.isConstant() || (i2 = true);
	        const s2 = t3.constantOr(null);
	        s2 && (i2 = true, n2[s2.to] = true, n2[s2.from] = true);
	      }
	      return i2;
	    }
	    function zl(e2, t2, r2, n2, i2) {
	      const { zoom: s2 } = n2, o2 = i2.patternDependencies;
	      for (const n3 of t2) {
	        const t3 = n3.paint.get(`${e2}-pattern`).value;
	        if ("constant" !== t3.kind) {
	          let e3 = t3.evaluate({ zoom: s2 - 1 }, r2, {}, i2.availableImages), a2 = t3.evaluate({ zoom: s2 }, r2, {}, i2.availableImages), l2 = t3.evaluate({ zoom: s2 + 1 }, r2, {}, i2.availableImages);
	          e3 = e3 && e3.name ? e3.name : e3, a2 = a2 && a2.name ? a2.name : a2, l2 = l2 && l2.name ? l2.name : l2, o2[e3] = true, o2[a2] = true, o2[l2] = true, r2.patterns[n3.id] = { min: e3, mid: a2, max: l2 };
	        }
	      }
	      return r2;
	    }
	    function Vl(e2, t2, r2, n2, i2) {
	      let s2;
	      if (i2 === function(e3, t3, r3, n3) {
	        let i3 = 0;
	        for (let s3 = t3, o2 = r3 - n3; s3 < r3; s3 += n3) i3 += (e3[o2] - e3[s3]) * (e3[s3 + 1] + e3[o2 + 1]), o2 = s3;
	        return i3;
	      }(e2, t2, r2, n2) > 0) for (let i3 = t2; i3 < r2; i3 += n2) s2 = nu(i3 / n2 | 0, e2[i3], e2[i3 + 1], s2);
	      else for (let i3 = r2 - n2; i3 >= t2; i3 -= n2) s2 = nu(i3 / n2 | 0, e2[i3], e2[i3 + 1], s2);
	      return s2 && Wl(s2, s2.next) && (iu(s2), s2 = s2.next), s2;
	    }
	    function Cl(e2, t2) {
	      if (!e2) return e2;
	      t2 || (t2 = e2);
	      let r2, n2 = e2;
	      do {
	        if (r2 = false, n2.steiner || !Wl(n2, n2.next) && 0 !== Kl(n2.prev, n2, n2.next)) n2 = n2.next;
	        else {
	          if (iu(n2), n2 = t2 = n2.prev, n2 === n2.next) break;
	          r2 = true;
	        }
	      } while (r2 || n2 !== t2);
	      return t2;
	    }
	    function Ll(e2, t2, r2, n2, i2, s2, o2) {
	      if (!e2) return;
	      !o2 && s2 && function(e3, t3, r3, n3) {
	        let i3 = e3;
	        do {
	          0 === i3.z && (i3.z = Gl(i3.x, i3.y, t3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
	        } while (i3 !== e3);
	        i3.prevZ.nextZ = null, i3.prevZ = null, function(e4) {
	          let t4, r4 = 1;
	          do {
	            let n4, i4 = e4;
	            e4 = null;
	            let s3 = null;
	            for (t4 = 0; i4; ) {
	              t4++;
	              let o3 = i4, a3 = 0;
	              for (let e5 = 0; e5 < r4 && (a3++, o3 = o3.nextZ, o3); e5++) ;
	              let l2 = r4;
	              for (; a3 > 0 || l2 > 0 && o3; ) 0 !== a3 && (0 === l2 || !o3 || i4.z <= o3.z) ? (n4 = i4, i4 = i4.nextZ, a3--) : (n4 = o3, o3 = o3.nextZ, l2--), s3 ? s3.nextZ = n4 : e4 = n4, n4.prevZ = s3, s3 = n4;
	              i4 = o3;
	            }
	            s3.nextZ = null, r4 *= 2;
	          } while (t4 > 1);
	        }(i3);
	      }(e2, n2, i2, s2);
	      let a2 = e2;
	      for (; e2.prev !== e2.next; ) {
	        const l2 = e2.prev, u2 = e2.next;
	        if (s2 ? Rl(e2, n2, i2, s2) : Ol(e2)) t2.push(l2.i, e2.i, u2.i), iu(e2), e2 = u2.next, a2 = u2.next;
	        else if ((e2 = u2) === a2) {
	          o2 ? 1 === o2 ? Ll(e2 = Nl(Cl(e2), t2), t2, r2, n2, i2, s2, 2) : 2 === o2 && $l(e2, t2, r2, n2, i2, s2) : Ll(Cl(e2), t2, r2, n2, i2, s2, 1);
	          break;
	        }
	      }
	    }
	    function Ol(e2) {
	      const t2 = e2.prev, r2 = e2, n2 = e2.next;
	      if (Kl(t2, r2, n2) >= 0) return false;
	      const i2 = t2.x, s2 = r2.x, o2 = n2.x, a2 = t2.y, l2 = r2.y, u2 = n2.y, c2 = Math.min(i2, s2, o2), h2 = Math.min(a2, l2, u2), p2 = Math.max(i2, s2, o2), f2 = Math.max(a2, l2, u2);
	      let d2 = n2.next;
	      for (; d2 !== t2; ) {
	        if (d2.x >= c2 && d2.x <= p2 && d2.y >= h2 && d2.y <= f2 && Zl(i2, a2, s2, l2, o2, u2, d2.x, d2.y) && Kl(d2.prev, d2, d2.next) >= 0) return false;
	        d2 = d2.next;
	      }
	      return true;
	    }
	    function Rl(e2, t2, r2, n2) {
	      const i2 = e2.prev, s2 = e2, o2 = e2.next;
	      if (Kl(i2, s2, o2) >= 0) return false;
	      const a2 = i2.x, l2 = s2.x, u2 = o2.x, c2 = i2.y, h2 = s2.y, p2 = o2.y, f2 = Math.min(a2, l2, u2), d2 = Math.min(c2, h2, p2), y2 = Math.max(a2, l2, u2), m2 = Math.max(c2, h2, p2), g2 = Gl(f2, d2, t2, r2, n2), x2 = Gl(y2, m2, t2, r2, n2);
	      let v2 = e2.prevZ, b2 = e2.nextZ;
	      for (; v2 && v2.z >= g2 && b2 && b2.z <= x2; ) {
	        if (v2.x >= f2 && v2.x <= y2 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== o2 && Zl(a2, c2, l2, h2, u2, p2, v2.x, v2.y) && Kl(v2.prev, v2, v2.next) >= 0) return false;
	        if (v2 = v2.prevZ, b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== o2 && Zl(a2, c2, l2, h2, u2, p2, b2.x, b2.y) && Kl(b2.prev, b2, b2.next) >= 0) return false;
	        b2 = b2.nextZ;
	      }
	      for (; v2 && v2.z >= g2; ) {
	        if (v2.x >= f2 && v2.x <= y2 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== o2 && Zl(a2, c2, l2, h2, u2, p2, v2.x, v2.y) && Kl(v2.prev, v2, v2.next) >= 0) return false;
	        v2 = v2.prevZ;
	      }
	      for (; b2 && b2.z <= x2; ) {
	        if (b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== o2 && Zl(a2, c2, l2, h2, u2, p2, b2.x, b2.y) && Kl(b2.prev, b2, b2.next) >= 0) return false;
	        b2 = b2.nextZ;
	      }
	      return true;
	    }
	    function Nl(e2, t2) {
	      let r2 = e2;
	      do {
	        const n2 = r2.prev, i2 = r2.next.next;
	        !Wl(n2, i2) && Jl(n2, r2, r2.next, i2) && tu(n2, i2) && tu(i2, n2) && (t2.push(n2.i, r2.i, i2.i), iu(r2), iu(r2.next), r2 = e2 = i2), r2 = r2.next;
	      } while (r2 !== e2);
	      return Cl(r2);
	    }
	    function $l(e2, t2, r2, n2, i2, s2) {
	      let o2 = e2;
	      do {
	        let e3 = o2.next.next;
	        for (; e3 !== o2.prev; ) {
	          if (o2.i !== e3.i && Hl(o2, e3)) {
	            let a2 = ru(o2, e3);
	            return o2 = Cl(o2, o2.next), a2 = Cl(a2, a2.next), Ll(o2, t2, r2, n2, i2, s2, 0), void Ll(a2, t2, r2, n2, i2, s2, 0);
	          }
	          e3 = e3.next;
	        }
	        o2 = o2.next;
	      } while (o2 !== e2);
	    }
	    function Ul(e2, t2) {
	      let r2 = e2.x - t2.x;
	      return 0 === r2 && (r2 = e2.y - t2.y, 0 === r2) && (r2 = (e2.next.y - e2.y) / (e2.next.x - e2.x) - (t2.next.y - t2.y) / (t2.next.x - t2.x)), r2;
	    }
	    function ql(e2, t2) {
	      const r2 = function(e3, t3) {
	        let r3 = t3;
	        const n3 = e3.x, i2 = e3.y;
	        let s2, o2 = -1 / 0;
	        if (Wl(e3, r3)) return r3;
	        do {
	          if (Wl(e3, r3.next)) return r3.next;
	          if (i2 <= r3.y && i2 >= r3.next.y && r3.next.y !== r3.y) {
	            const e4 = r3.x + (i2 - r3.y) * (r3.next.x - r3.x) / (r3.next.y - r3.y);
	            if (e4 <= n3 && e4 > o2 && (o2 = e4, s2 = r3.x < r3.next.x ? r3 : r3.next, e4 === n3)) return s2;
	          }
	          r3 = r3.next;
	        } while (r3 !== t3);
	        if (!s2) return null;
	        const a2 = s2, l2 = s2.x, u2 = s2.y;
	        let c2 = 1 / 0;
	        r3 = s2;
	        do {
	          if (n3 >= r3.x && r3.x >= l2 && n3 !== r3.x && Yl(i2 < u2 ? n3 : o2, i2, l2, u2, i2 < u2 ? o2 : n3, i2, r3.x, r3.y)) {
	            const t4 = Math.abs(i2 - r3.y) / (n3 - r3.x);
	            tu(r3, e3) && (t4 < c2 || t4 === c2 && (r3.x > s2.x || r3.x === s2.x && jl(s2, r3))) && (s2 = r3, c2 = t4);
	          }
	          r3 = r3.next;
	        } while (r3 !== a2);
	        return s2;
	      }(e2, t2);
	      if (!r2) return t2;
	      const n2 = ru(r2, e2);
	      return Cl(n2, n2.next), Cl(r2, r2.next);
	    }
	    function jl(e2, t2) {
	      return Kl(e2.prev, e2, t2.prev) < 0 && Kl(t2.next, e2, e2.next) < 0;
	    }
	    function Gl(e2, t2, r2, n2, i2) {
	      return (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - r2) * i2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) | (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - n2) * i2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) << 1;
	    }
	    function Xl(e2) {
	      let t2 = e2, r2 = e2;
	      do {
	        (t2.x < r2.x || t2.x === r2.x && t2.y < r2.y) && (r2 = t2), t2 = t2.next;
	      } while (t2 !== e2);
	      return r2;
	    }
	    function Yl(e2, t2, r2, n2, i2, s2, o2, a2) {
	      return (i2 - o2) * (t2 - a2) >= (e2 - o2) * (s2 - a2) && (e2 - o2) * (n2 - a2) >= (r2 - o2) * (t2 - a2) && (r2 - o2) * (s2 - a2) >= (i2 - o2) * (n2 - a2);
	    }
	    function Zl(e2, t2, r2, n2, i2, s2, o2, a2) {
	      return !(e2 === o2 && t2 === a2) && Yl(e2, t2, r2, n2, i2, s2, o2, a2);
	    }
	    function Hl(e2, t2) {
	      return e2.next.i !== t2.i && e2.prev.i !== t2.i && !function(e3, t3) {
	        let r2 = e3;
	        do {
	          if (r2.i !== e3.i && r2.next.i !== e3.i && r2.i !== t3.i && r2.next.i !== t3.i && Jl(r2, r2.next, e3, t3)) return true;
	          r2 = r2.next;
	        } while (r2 !== e3);
	        return false;
	      }(e2, t2) && (tu(e2, t2) && tu(t2, e2) && function(e3, t3) {
	        let r2 = e3, n2 = false;
	        const i2 = (e3.x + t3.x) / 2, s2 = (e3.y + t3.y) / 2;
	        do {
	          r2.y > s2 != r2.next.y > s2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (s2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
	        } while (r2 !== e3);
	        return n2;
	      }(e2, t2) && (Kl(e2.prev, e2, t2.prev) || Kl(e2, t2.prev, t2)) || Wl(e2, t2) && Kl(e2.prev, e2, e2.next) > 0 && Kl(t2.prev, t2, t2.next) > 0);
	    }
	    function Kl(e2, t2, r2) {
	      return (t2.y - e2.y) * (r2.x - t2.x) - (t2.x - e2.x) * (r2.y - t2.y);
	    }
	    function Wl(e2, t2) {
	      return e2.x === t2.x && e2.y === t2.y;
	    }
	    function Jl(e2, t2, r2, n2) {
	      const i2 = eu(Kl(e2, t2, r2)), s2 = eu(Kl(e2, t2, n2)), o2 = eu(Kl(r2, n2, e2)), a2 = eu(Kl(r2, n2, t2));
	      return i2 !== s2 && o2 !== a2 || !(0 !== i2 || !Ql(e2, r2, t2)) || !(0 !== s2 || !Ql(e2, n2, t2)) || !(0 !== o2 || !Ql(r2, e2, n2)) || !(0 !== a2 || !Ql(r2, t2, n2));
	    }
	    function Ql(e2, t2, r2) {
	      return t2.x <= Math.max(e2.x, r2.x) && t2.x >= Math.min(e2.x, r2.x) && t2.y <= Math.max(e2.y, r2.y) && t2.y >= Math.min(e2.y, r2.y);
	    }
	    function eu(e2) {
	      return e2 > 0 ? 1 : e2 < 0 ? -1 : 0;
	    }
	    function tu(e2, t2) {
	      return Kl(e2.prev, e2, e2.next) < 0 ? Kl(e2, t2, e2.next) >= 0 && Kl(e2, e2.prev, t2) >= 0 : Kl(e2, t2, e2.prev) < 0 || Kl(e2, e2.next, t2) < 0;
	    }
	    function ru(e2, t2) {
	      const r2 = su(e2.i, e2.x, e2.y), n2 = su(t2.i, t2.x, t2.y), i2 = e2.next, s2 = t2.prev;
	      return e2.next = t2, t2.prev = e2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, s2.next = n2, n2.prev = s2, n2;
	    }
	    function nu(e2, t2, r2, n2) {
	      const i2 = su(e2, t2, r2);
	      return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
	    }
	    function iu(e2) {
	      e2.next.prev = e2.prev, e2.prev.next = e2.next, e2.prevZ && (e2.prevZ.nextZ = e2.nextZ), e2.nextZ && (e2.nextZ.prevZ = e2.prevZ);
	    }
	    function su(e2, t2, r2) {
	      return { i: e2, x: t2, y: r2, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
	    }
	    class ou {
	      constructor(e2, t2) {
	        if (t2 > e2) throw new Error("Min granularity must not be greater than base granularity.");
	        this._baseZoomGranularity = e2, this._minGranularity = t2;
	      }
	      getGranularityForZoomLevel(e2) {
	        return Math.max(Math.floor(this._baseZoomGranularity / (1 << e2)), this._minGranularity, 1);
	      }
	    }
	    class au {
	      constructor(e2) {
	        this.fill = e2.fill, this.line = e2.line, this.tile = e2.tile, this.stencil = e2.stencil, this.circle = e2.circle;
	      }
	    }
	    au.noSubdivision = new au({ fill: new ou(0, 0), line: new ou(0, 0), tile: new ou(0, 0), stencil: new ou(0, 0), circle: 1 }), ls("SubdivisionGranularityExpression", ou), ls("SubdivisionGranularitySetting", au);
	    const lu = -32768, uu = 32767;
	    class cu {
	      constructor(e2, t2) {
	        this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = false, this._granularity = e2, this._granularityCellSize = k / e2, this._canonical = t2;
	      }
	      _getKey(e2, t2) {
	        return (e2 += 32768) << 16 | t2 + 32768;
	      }
	      _vertexToIndex(e2, t2) {
	        if (e2 < -32768 || t2 < -32768 || e2 > 32767 || t2 > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
	        const r2 = 0 | Math.round(e2), n2 = 0 | Math.round(t2), i2 = this._getKey(r2, n2);
	        if (this._vertexDictionary.has(i2)) return this._vertexDictionary.get(i2);
	        const s2 = this._vertexBuffer.length / 2;
	        return this._vertexDictionary.set(i2, s2), this._vertexBuffer.push(r2, n2), s2;
	      }
	      _subdivideTrianglesScanline(e2) {
	        if (this._granularity < 2) return function(e3, t3) {
	          const r3 = [];
	          for (let n2 = 0; n2 < t3.length; n2 += 3) {
	            const i2 = t3[n2], s2 = t3[n2 + 1], o2 = t3[n2 + 2], a2 = e3[2 * i2], l2 = e3[2 * i2 + 1];
	            (e3[2 * s2] - a2) * (e3[2 * o2 + 1] - l2) - (e3[2 * s2 + 1] - l2) * (e3[2 * o2] - a2) > 0 ? (r3.push(i2), r3.push(o2), r3.push(s2)) : (r3.push(i2), r3.push(s2), r3.push(o2));
	          }
	          return r3;
	        }(this._vertexBuffer, e2);
	        const t2 = [], r2 = e2.length;
	        for (let n2 = 0; n2 < r2; n2 += 3) {
	          const r3 = [e2[n2 + 0], e2[n2 + 1], e2[n2 + 2]], i2 = [this._vertexBuffer[2 * e2[n2 + 0] + 0], this._vertexBuffer[2 * e2[n2 + 0] + 1], this._vertexBuffer[2 * e2[n2 + 1] + 0], this._vertexBuffer[2 * e2[n2 + 1] + 1], this._vertexBuffer[2 * e2[n2 + 2] + 0], this._vertexBuffer[2 * e2[n2 + 2] + 1]];
	          let s2 = 1 / 0, o2 = 1 / 0, a2 = -1 / 0, l2 = -1 / 0;
	          for (let e3 = 0; e3 < 3; e3++) {
	            const t3 = i2[2 * e3], r4 = i2[2 * e3 + 1];
	            s2 = Math.min(s2, t3), a2 = Math.max(a2, t3), o2 = Math.min(o2, r4), l2 = Math.max(l2, r4);
	          }
	          if (s2 === a2 || o2 === l2) continue;
	          const u2 = Math.floor(s2 / this._granularityCellSize), c2 = Math.ceil(a2 / this._granularityCellSize), h2 = Math.floor(o2 / this._granularityCellSize), p2 = Math.ceil(l2 / this._granularityCellSize);
	          if (u2 !== c2 || h2 !== p2) for (let e3 = h2; e3 < p2; e3++) {
	            const n3 = this._scanlineGenerateVertexRingForCellRow(e3, i2, r3);
	            fu(this._vertexBuffer, n3, t2);
	          }
	          else t2.push(...r3);
	        }
	        return t2;
	      }
	      _scanlineGenerateVertexRingForCellRow(e2, t2, r2) {
	        const n2 = e2 * this._granularityCellSize, i2 = n2 + this._granularityCellSize, s2 = [];
	        for (let e3 = 0; e3 < 3; e3++) {
	          const o2 = t2[2 * e3], a2 = t2[2 * e3 + 1], l2 = t2[2 * (e3 + 1) % 6], u2 = t2[(2 * (e3 + 1) + 1) % 6], c2 = t2[2 * (e3 + 2) % 6], h2 = t2[(2 * (e3 + 2) + 1) % 6], p2 = l2 - o2, f2 = u2 - a2, d2 = 0 === p2, y2 = 0 === f2, m2 = (n2 - a2) / f2, g2 = (i2 - a2) / f2, x2 = Math.min(m2, g2), v2 = Math.max(m2, g2);
	          if (!y2 && (x2 >= 1 || v2 <= 0) || y2 && (a2 < n2 || a2 > i2)) {
	            u2 >= n2 && u2 <= i2 && s2.push(r2[(e3 + 1) % 3]);
	            continue;
	          }
	          !y2 && x2 > 0 && s2.push(this._vertexToIndex(o2 + p2 * x2, a2 + f2 * x2));
	          const b2 = o2 + p2 * Math.max(x2, 0), w2 = o2 + p2 * Math.min(v2, 1);
	          d2 || this._generateIntraEdgeVertices(s2, o2, a2, l2, u2, b2, w2), !y2 && v2 < 1 && s2.push(this._vertexToIndex(o2 + p2 * v2, a2 + f2 * v2)), (y2 || u2 >= n2 && u2 <= i2) && s2.push(r2[(e3 + 1) % 3]), !y2 && (u2 <= n2 || u2 >= i2) && this._generateInterEdgeVertices(s2, o2, a2, l2, u2, c2, h2, w2, n2, i2);
	        }
	        return s2;
	      }
	      _generateIntraEdgeVertices(e2, t2, r2, n2, i2, s2, o2) {
	        const a2 = n2 - t2, l2 = i2 - r2, u2 = 0 === l2, c2 = u2 ? Math.min(t2, n2) : Math.min(s2, o2), h2 = u2 ? Math.max(t2, n2) : Math.max(s2, o2), p2 = Math.floor(c2 / this._granularityCellSize) + 1, f2 = Math.ceil(h2 / this._granularityCellSize) - 1;
	        if (u2 ? t2 < n2 : s2 < o2) for (let n3 = p2; n3 <= f2; n3++) {
	          const i3 = n3 * this._granularityCellSize;
	          e2.push(this._vertexToIndex(i3, r2 + l2 * (i3 - t2) / a2));
	        }
	        else for (let n3 = f2; n3 >= p2; n3--) {
	          const i3 = n3 * this._granularityCellSize;
	          e2.push(this._vertexToIndex(i3, r2 + l2 * (i3 - t2) / a2));
	        }
	      }
	      _generateInterEdgeVertices(e2, t2, r2, n2, i2, s2, o2, a2, l2, u2) {
	        const c2 = i2 - r2, h2 = s2 - n2, p2 = o2 - i2, f2 = (l2 - i2) / p2, d2 = (u2 - i2) / p2, y2 = Math.min(f2, d2), m2 = Math.max(f2, d2), g2 = n2 + h2 * y2;
	        let x2 = Math.floor(Math.min(g2, a2) / this._granularityCellSize) + 1, v2 = Math.ceil(Math.max(g2, a2) / this._granularityCellSize) - 1, b2 = a2 < g2;
	        const w2 = 0 === p2;
	        if (w2 && (o2 === l2 || o2 === u2)) return;
	        if (w2 || y2 >= 1 || m2 <= 0) {
	          const e3 = r2 - o2, n3 = s2 + (t2 - s2) * Math.min((l2 - o2) / e3, (u2 - o2) / e3);
	          x2 = Math.floor(Math.min(n3, a2) / this._granularityCellSize) + 1, v2 = Math.ceil(Math.max(n3, a2) / this._granularityCellSize) - 1, b2 = a2 < n3;
	        }
	        const _2 = c2 > 0 ? u2 : l2;
	        if (b2) for (let t3 = x2; t3 <= v2; t3++) e2.push(this._vertexToIndex(t3 * this._granularityCellSize, _2));
	        else for (let t3 = v2; t3 >= x2; t3--) e2.push(this._vertexToIndex(t3 * this._granularityCellSize, _2));
	      }
	      _generateOutline(e2) {
	        const t2 = [];
	        for (const r2 of e2) {
	          const e3 = pu(r2, this._granularity, true), n2 = this._pointArrayToIndices(e3), i2 = [];
	          for (let e4 = 1; e4 < n2.length; e4++) i2.push(n2[e4 - 1]), i2.push(n2[e4]);
	          t2.push(i2);
	        }
	        return t2;
	      }
	      _handlePoles(e2) {
	        let t2 = false, r2 = false;
	        this._canonical && (0 === this._canonical.y && (t2 = true), this._canonical.y === (1 << this._canonical.z) - 1 && (r2 = true)), (t2 || r2) && this._fillPoles(e2, t2, r2);
	      }
	      _ensureNoPoleVertices() {
	        const e2 = this._vertexBuffer;
	        for (let t2 = 0; t2 < e2.length; t2 += 2) {
	          const r2 = e2[t2 + 1];
	          r2 === lu && (e2[t2 + 1] = -32767), r2 === uu && (e2[t2 + 1] = 32766);
	        }
	      }
	      _generatePoleQuad(e2, t2, r2, n2, i2, s2) {
	        n2 > i2 != (s2 === lu) ? (e2.push(t2), e2.push(r2), e2.push(this._vertexToIndex(n2, s2)), e2.push(r2), e2.push(this._vertexToIndex(i2, s2)), e2.push(this._vertexToIndex(n2, s2))) : (e2.push(r2), e2.push(t2), e2.push(this._vertexToIndex(n2, s2)), e2.push(this._vertexToIndex(i2, s2)), e2.push(r2), e2.push(this._vertexToIndex(n2, s2)));
	      }
	      _fillPoles(e2, t2, r2) {
	        const n2 = this._vertexBuffer, i2 = k, s2 = e2.length;
	        for (let o2 = 2; o2 < s2; o2 += 3) {
	          const s3 = e2[o2 - 2], a2 = e2[o2 - 1], l2 = e2[o2], u2 = n2[2 * s3], c2 = n2[2 * s3 + 1], h2 = n2[2 * a2], p2 = n2[2 * a2 + 1], f2 = n2[2 * l2], d2 = n2[2 * l2 + 1];
	          t2 && (0 === c2 && 0 === p2 && this._generatePoleQuad(e2, s3, a2, u2, h2, lu), 0 === p2 && 0 === d2 && this._generatePoleQuad(e2, a2, l2, h2, f2, lu), 0 === d2 && 0 === c2 && this._generatePoleQuad(e2, l2, s3, f2, u2, lu)), r2 && (c2 === i2 && p2 === i2 && this._generatePoleQuad(e2, s3, a2, u2, h2, uu), p2 === i2 && d2 === i2 && this._generatePoleQuad(e2, a2, l2, h2, f2, uu), d2 === i2 && c2 === i2 && this._generatePoleQuad(e2, l2, s3, f2, u2, uu));
	        }
	      }
	      _initializeVertices(e2) {
	        for (let t2 = 0; t2 < e2.length; t2 += 2) this._vertexToIndex(e2[t2], e2[t2 + 1]);
	      }
	      subdividePolygonInternal(e2, t2) {
	        if (this._used) throw new Error("Subdivision: multiple use not allowed.");
	        this._used = true;
	        const { flattened: r2, holeIndices: n2 } = function(e3) {
	          const t3 = [], r3 = [];
	          for (const n3 of e3) if (0 !== n3.length) {
	            n3 !== e3[0] && t3.push(r3.length / 2);
	            for (let e4 = 0; e4 < n3.length; e4++) r3.push(n3[e4].x), r3.push(n3[e4].y);
	          }
	          return { flattened: r3, holeIndices: t3 };
	        }(e2);
	        let i2;
	        this._initializeVertices(r2);
	        try {
	          const e3 = function(e4, t4, r3 = 2) {
	            const n3 = t4 && t4.length, i3 = n3 ? t4[0] * r3 : e4.length;
	            let s3 = Vl(e4, 0, i3, r3, true);
	            const o2 = [];
	            if (!s3 || s3.next === s3.prev) return o2;
	            let a2, l2, u2;
	            if (n3 && (s3 = function(e5, t5, r4, n4) {
	              const i4 = [];
	              for (let r5 = 0, s4 = t5.length; r5 < s4; r5++) {
	                const o3 = Vl(e5, t5[r5] * n4, r5 < s4 - 1 ? t5[r5 + 1] * n4 : e5.length, n4, false);
	                o3 === o3.next && (o3.steiner = true), i4.push(Xl(o3));
	              }
	              i4.sort(Ul);
	              for (let e6 = 0; e6 < i4.length; e6++) r4 = ql(i4[e6], r4);
	              return r4;
	            }(e4, t4, s3, r3)), e4.length > 80 * r3) {
	              a2 = e4[0], l2 = e4[1];
	              let t5 = a2, n4 = l2;
	              for (let s4 = r3; s4 < i3; s4 += r3) {
	                const r4 = e4[s4], i4 = e4[s4 + 1];
	                r4 < a2 && (a2 = r4), i4 < l2 && (l2 = i4), r4 > t5 && (t5 = r4), i4 > n4 && (n4 = i4);
	              }
	              u2 = Math.max(t5 - a2, n4 - l2), u2 = 0 !== u2 ? 32767 / u2 : 0;
	            }
	            return Ll(s3, o2, r3, a2, l2, u2, 0), o2;
	          }(r2, n2), t3 = this._convertIndices(r2, e3);
	          i2 = this._subdivideTrianglesScanline(t3);
	        } catch (e3) {
	          console.error(e3);
	        }
	        let s2 = [];
	        return t2 && (s2 = this._generateOutline(e2)), this._ensureNoPoleVertices(), this._handlePoles(i2), { verticesFlattened: this._vertexBuffer, indicesTriangles: i2, indicesLineList: s2 };
	      }
	      _convertIndices(e2, t2) {
	        const r2 = [];
	        for (let n2 = 0; n2 < t2.length; n2++) r2.push(this._vertexToIndex(e2[2 * t2[n2]], e2[2 * t2[n2] + 1]));
	        return r2;
	      }
	      _pointArrayToIndices(e2) {
	        const t2 = [];
	        for (let r2 = 0; r2 < e2.length; r2++) {
	          const n2 = e2[r2];
	          t2.push(this._vertexToIndex(n2.x, n2.y));
	        }
	        return t2;
	      }
	    }
	    function hu(e2, t2, r2, n2 = true) {
	      return new cu(r2, t2).subdividePolygonInternal(e2, n2);
	    }
	    function pu(e2, t2, n2 = false) {
	      if (!e2 || e2.length < 1) return [];
	      if (e2.length < 2) return [];
	      const i2 = e2[0], s2 = e2[e2.length - 1], o2 = n2 && (i2.x !== s2.x || i2.y !== s2.y);
	      if (t2 < 2) return o2 ? [...e2, e2[0]] : [...e2];
	      const a2 = Math.floor(k / t2), l2 = [];
	      l2.push(new r(e2[0].x, e2[0].y));
	      const u2 = e2.length, c2 = o2 ? u2 : u2 - 1;
	      for (let t3 = 0; t3 < c2; t3++) {
	        const n3 = e2[t3], i3 = t3 < u2 - 1 ? e2[t3 + 1] : e2[0], s3 = n3.x, o3 = n3.y, c3 = i3.x, h2 = i3.y, p2 = s3 !== c3, f2 = o3 !== h2;
	        if (!p2 && !f2) continue;
	        const d2 = c3 - s3, y2 = h2 - o3, m2 = Math.abs(d2), g2 = Math.abs(y2);
	        let x2 = s3, v2 = o3;
	        for (; ; ) {
	          const e3 = d2 > 0 ? (Math.floor(x2 / a2) + 1) * a2 : (Math.ceil(x2 / a2) - 1) * a2, t4 = y2 > 0 ? (Math.floor(v2 / a2) + 1) * a2 : (Math.ceil(v2 / a2) - 1) * a2, n4 = Math.abs(x2 - e3), i4 = Math.abs(v2 - t4), s4 = Math.abs(x2 - c3), o4 = Math.abs(v2 - h2), u3 = p2 ? n4 / m2 : Number.POSITIVE_INFINITY, b3 = f2 ? i4 / g2 : Number.POSITIVE_INFINITY;
	          if ((s4 <= n4 || !p2) && (o4 <= i4 || !f2)) break;
	          if (u3 < b3 && p2 || !f2) {
	            x2 = e3, v2 += y2 * u3;
	            const t5 = new r(x2, Math.round(v2));
	            l2[l2.length - 1].x === t5.x && l2[l2.length - 1].y === t5.y || l2.push(t5);
	          } else {
	            x2 += d2 * b3, v2 = t4;
	            const e4 = new r(Math.round(x2), v2);
	            l2[l2.length - 1].x === e4.x && l2[l2.length - 1].y === e4.y || l2.push(e4);
	          }
	        }
	        const b2 = new r(c3, h2);
	        l2[l2.length - 1].x === b2.x && l2[l2.length - 1].y === b2.y || l2.push(b2);
	      }
	      return l2;
	    }
	    function fu(e2, t2, r2) {
	      if (0 === t2.length) throw new Error("Subdivision vertex ring is empty.");
	      let n2 = 0, i2 = e2[2 * t2[0]];
	      for (let r3 = 1; r3 < t2.length; r3++) {
	        const s3 = e2[2 * t2[r3]];
	        s3 < i2 && (i2 = s3, n2 = r3);
	      }
	      const s2 = t2.length;
	      let o2 = n2, a2 = (o2 + 1) % s2;
	      for (; ; ) {
	        const n3 = o2 - 1 >= 0 ? o2 - 1 : s2 - 1, i3 = (a2 + 1) % s2, l2 = e2[2 * t2[n3]], u2 = e2[2 * t2[i3]], c2 = e2[2 * t2[o2]], h2 = e2[2 * t2[o2] + 1], p2 = e2[2 * t2[a2] + 1];
	        let f2 = false;
	        if (l2 < u2) f2 = true;
	        else if (l2 > u2) f2 = false;
	        else {
	          const r3 = p2 - h2, s3 = -(e2[2 * t2[a2]] - c2), o3 = h2 < p2 ? 1 : -1;
	          ((l2 - c2) * r3 + (e2[2 * t2[n3] + 1] - h2) * s3) * o3 > ((u2 - c2) * r3 + (e2[2 * t2[i3] + 1] - h2) * s3) * o3 && (f2 = true);
	        }
	        if (f2) {
	          const e3 = t2[n3], i4 = t2[o2], l3 = t2[a2];
	          e3 !== i4 && e3 !== l3 && i4 !== l3 && r2.push(l3, i4, e3), o2--, o2 < 0 && (o2 = s2 - 1);
	        } else {
	          const e3 = t2[i3], n4 = t2[o2], l3 = t2[a2];
	          e3 !== n4 && e3 !== l3 && n4 !== l3 && r2.push(l3, n4, e3), a2++, a2 >= s2 && (a2 = 0);
	        }
	        if (n3 === i3) break;
	      }
	    }
	    function du(e2, t2, r2, n2, i2, s2, o2, a2, l2) {
	      const u2 = i2.length / 2, c2 = o2 && a2 && l2;
	      if (u2 < ta.MAX_VERTEX_ARRAY_LENGTH) {
	        const h2 = t2.prepareSegment(u2, r2, n2), p2 = h2.vertexLength;
	        for (let e3 = 0; e3 < s2.length; e3 += 3) n2.emplaceBack(p2 + s2[e3], p2 + s2[e3 + 1], p2 + s2[e3 + 2]);
	        let f2, d2;
	        h2.vertexLength += u2, h2.primitiveLength += s2.length / 3, c2 && (d2 = o2.prepareSegment(u2, r2, a2), f2 = d2.vertexLength, d2.vertexLength += u2);
	        for (let t3 = 0; t3 < i2.length; t3 += 2) e2(i2[t3], i2[t3 + 1]);
	        if (c2) for (let e3 = 0; e3 < l2.length; e3++) {
	          const t3 = l2[e3];
	          for (let e4 = 1; e4 < t3.length; e4 += 2) a2.emplaceBack(f2 + t3[e4 - 1], f2 + t3[e4]);
	          d2.primitiveLength += t3.length / 2;
	        }
	      } else !function(e3, t3, r3, n3, i3, s3) {
	        const o3 = [];
	        for (let e4 = 0; e4 < n3.length / 2; e4++) o3.push(-1);
	        const a3 = { count: 0 };
	        let l3 = 0, u3 = e3.getOrCreateLatestSegment(t3, r3), c3 = u3.vertexLength;
	        for (let h2 = 2; h2 < i3.length; h2 += 3) {
	          const p2 = i3[h2 - 2], f2 = i3[h2 - 1], d2 = i3[h2];
	          let y2 = o3[p2] < l3, m2 = o3[f2] < l3, g2 = o3[d2] < l3;
	          u3.vertexLength + ((y2 ? 1 : 0) + (m2 ? 1 : 0) + (g2 ? 1 : 0)) > ta.MAX_VERTEX_ARRAY_LENGTH && (u3 = e3.createNewSegment(t3, r3), l3 = a3.count, y2 = true, m2 = true, g2 = true, c3 = 0);
	          const x2 = yu(o3, n3, s3, a3, p2, y2, u3), v2 = yu(o3, n3, s3, a3, f2, m2, u3), b2 = yu(o3, n3, s3, a3, d2, g2, u3);
	          r3.emplaceBack(c3 + x2 - l3, c3 + v2 - l3, c3 + b2 - l3), u3.primitiveLength++;
	        }
	      }(t2, r2, n2, i2, s2, e2), c2 && function(e3, t3, r3, n3, i3, s3) {
	        const o3 = [];
	        for (let e4 = 0; e4 < n3.length / 2; e4++) o3.push(-1);
	        const a3 = { count: 0 };
	        let l3 = 0, u3 = e3.getOrCreateLatestSegment(t3, r3), c3 = u3.vertexLength;
	        for (let h2 = 0; h2 < i3.length; h2++) {
	          const p2 = i3[h2];
	          for (let f2 = 1; f2 < i3[h2].length; f2 += 2) {
	            const i4 = p2[f2 - 1], h3 = p2[f2];
	            let d2 = o3[i4] < l3, y2 = o3[h3] < l3;
	            u3.vertexLength + ((d2 ? 1 : 0) + (y2 ? 1 : 0)) > ta.MAX_VERTEX_ARRAY_LENGTH && (u3 = e3.createNewSegment(t3, r3), l3 = a3.count, d2 = true, y2 = true, c3 = 0);
	            const m2 = yu(o3, n3, s3, a3, i4, d2, u3), g2 = yu(o3, n3, s3, a3, h3, y2, u3);
	            r3.emplaceBack(c3 + m2 - l3, c3 + g2 - l3), u3.primitiveLength++;
	          }
	        }
	      }(o2, r2, a2, i2, l2, e2), t2.forceNewSegmentOnNextPrepare(), null == o2 || o2.forceNewSegmentOnNextPrepare();
	    }
	    function yu(e2, t2, r2, n2, i2, s2, o2) {
	      if (s2) {
	        const s3 = n2.count;
	        return r2(t2[2 * i2], t2[2 * i2 + 1]), e2[i2] = n2.count, n2.count++, o2.vertexLength++, s3;
	      }
	      return e2[i2];
	    }
	    class mu {
	      constructor(e2) {
	        this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((e3) => e3.id), this.index = e2.index, this.hasDependencies = false, this.patternFeatures = [], this.layoutVertexArray = new No(), this.indexArray = new Wo(), this.indexArray2 = new Jo(), this.programConfigurations = new Da(e2.layers, e2.zoom), this.segments = new ta(), this.segments2 = new ta(), this.stateDependentLayerIds = this.layers.filter((e3) => e3.isStateDependent()).map((e3) => e3.id);
	      }
	      populate(e2, t2, r2) {
	        this.hasDependencies = Bl("fill", this.layers, t2);
	        const n2 = this.layers[0].layout.get("fill-sort-key"), i2 = !n2.isConstant(), s2 = [];
	        for (const { feature: o2, id: a2, index: l2, sourceLayerIndex: u2 } of e2) {
	          const e3 = this.layers[0]._featureFilter.needGeometry, c2 = La(o2, e3);
	          if (!this.layers[0]._featureFilter.filter(new ks(this.zoom), c2, r2)) continue;
	          const h2 = i2 ? n2.evaluate(c2, {}, r2, t2.availableImages) : void 0, p2 = { id: a2, properties: o2.properties, type: o2.type, sourceLayerIndex: u2, index: l2, geometry: e3 ? c2.geometry : Ca(o2), patterns: {}, sortKey: h2 };
	          s2.push(p2);
	        }
	        i2 && s2.sort((e3, t3) => e3.sortKey - t3.sortKey);
	        for (const n3 of s2) {
	          const { geometry: i3, index: s3, sourceLayerIndex: o2 } = n3;
	          if (this.hasDependencies) {
	            const e3 = zl("fill", this.layers, n3, { zoom: this.zoom }, t2);
	            this.patternFeatures.push(e3);
	          } else this.addFeature(n3, i3, s3, r2, {}, t2.subdivisionGranularity);
	          t2.featureIndex.insert(e2[s3].feature, i3, s3, o2, this.index);
	        }
	      }
	      update(e2, t2, r2) {
	        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e2, t2, this.stateDependentLayers, { imagePositions: r2 });
	      }
	      addFeatures(e2, t2, r2) {
	        for (const n2 of this.patternFeatures) this.addFeature(n2, n2.geometry, n2.index, t2, r2, e2.subdivisionGranularity);
	      }
	      isEmpty() {
	        return 0 === this.layoutVertexArray.length;
	      }
	      uploadPending() {
	        return !this.uploaded || this.programConfigurations.needsUpload;
	      }
	      upload(e2) {
	        this.uploaded || (this.layoutVertexBuffer = e2.createVertexBuffer(this.layoutVertexArray, Pl), this.indexBuffer = e2.createIndexBuffer(this.indexArray), this.indexBuffer2 = e2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e2), this.uploaded = true;
	      }
	      destroy() {
	        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
	      }
	      addFeature(e2, t2, r2, n2, i2, s2) {
	        for (const e3 of Qr(t2, 500)) {
	          const t3 = hu(e3, n2, s2.fill.getGranularityForZoomLevel(n2.z)), r3 = this.layoutVertexArray;
	          du((e4, t4) => {
	            r3.emplaceBack(e4, t4);
	          }, this.segments, this.layoutVertexArray, this.indexArray, t3.verticesFlattened, t3.indicesTriangles, this.segments2, this.indexArray2, t3.indicesLineList);
	        }
	        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e2, r2, { imagePositions: i2, canonical: n2 });
	      }
	    }
	    let gu, xu;
	    ls("FillBucket", mu, { omit: ["layers", "patternFeatures"] });
	    var vu = { get paint() {
	      return xu = xu || new Gs({ "fill-antialias": new Ns(xe.paint_fill["fill-antialias"]), "fill-opacity": new $s(xe.paint_fill["fill-opacity"]), "fill-color": new $s(xe.paint_fill["fill-color"]), "fill-outline-color": new $s(xe.paint_fill["fill-outline-color"]), "fill-translate": new Ns(xe.paint_fill["fill-translate"]), "fill-translate-anchor": new Ns(xe.paint_fill["fill-translate-anchor"]), "fill-pattern": new Us(xe.paint_fill["fill-pattern"]) });
	    }, get layout() {
	      return gu = gu || new Gs({ "fill-sort-key": new $s(xe.layout_fill["fill-sort-key"]) });
	    } };
	    class bu extends Xs {
	      constructor(e2, t2) {
	        super(e2, vu, t2);
	      }
	      recalculate(e2, t2) {
	        super.recalculate(e2, t2);
	        const r2 = this.paint._values["fill-outline-color"];
	        "constant" === r2.value.kind && void 0 === r2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
	      }
	      createBucket(e2) {
	        return new mu(e2);
	      }
	      queryRadius() {
	        return Qa(this.paint.get("fill-translate"));
	      }
	      queryIntersectsFeature({ queryGeometry: e2, geometry: t2, transform: r2, pixelsToTileUnits: n2 }) {
	        return qa(el(e2, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -r2.bearingInRadians, n2), t2);
	      }
	      isTileClipped() {
	        return true;
	      }
	    }
	    const wu = Qs([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), _u = Qs([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: Su } = wu;
	    class Au {
	      constructor(e2, t2, r2, n2, i2) {
	        this.properties = {}, this.extent = r2, this.type = 0, this.id = void 0, this._pbf = e2, this._geometry = -1, this._keys = n2, this._values = i2, e2.readFields(Tu, this, t2);
	      }
	      loadGeometry() {
	        const e2 = this._pbf;
	        e2.pos = this._geometry;
	        const t2 = e2.readVarint() + e2.pos, n2 = [];
	        let i2, s2 = 1, o2 = 0, a2 = 0, l2 = 0;
	        for (; e2.pos < t2; ) {
	          if (o2 <= 0) {
	            const t3 = e2.readVarint();
	            s2 = 7 & t3, o2 = t3 >> 3;
	          }
	          if (o2--, 1 === s2 || 2 === s2) a2 += e2.readSVarint(), l2 += e2.readSVarint(), 1 === s2 && (i2 && n2.push(i2), i2 = []), i2 && i2.push(new r(a2, l2));
	          else {
	            if (7 !== s2) throw new Error(`unknown command ${s2}`);
	            i2 && i2.push(i2[0].clone());
	          }
	        }
	        return i2 && n2.push(i2), n2;
	      }
	      bbox() {
	        const e2 = this._pbf;
	        e2.pos = this._geometry;
	        const t2 = e2.readVarint() + e2.pos;
	        let r2 = 1, n2 = 0, i2 = 0, s2 = 0, o2 = 1 / 0, a2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0;
	        for (; e2.pos < t2; ) {
	          if (n2 <= 0) {
	            const t3 = e2.readVarint();
	            r2 = 7 & t3, n2 = t3 >> 3;
	          }
	          if (n2--, 1 === r2 || 2 === r2) i2 += e2.readSVarint(), s2 += e2.readSVarint(), i2 < o2 && (o2 = i2), i2 > a2 && (a2 = i2), s2 < l2 && (l2 = s2), s2 > u2 && (u2 = s2);
	          else if (7 !== r2) throw new Error(`unknown command ${r2}`);
	        }
	        return [o2, l2, a2, u2];
	      }
	      toGeoJSON(e2, t2, r2) {
	        const n2 = this.extent * Math.pow(2, r2), i2 = this.extent * e2, s2 = this.extent * t2, o2 = this.loadGeometry();
	        function a2(e3) {
	          return [360 * (e3.x + i2) / n2 - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (e3.y + s2) / n2) * Math.PI)) - 90];
	        }
	        function l2(e3) {
	          return e3.map(a2);
	        }
	        let u2;
	        if (1 === this.type) {
	          const e3 = [];
	          for (const t4 of o2) e3.push(t4[0]);
	          const t3 = l2(e3);
	          u2 = 1 === e3.length ? { type: "Point", coordinates: t3[0] } : { type: "MultiPoint", coordinates: t3 };
	        } else if (2 === this.type) {
	          const e3 = o2.map(l2);
	          u2 = 1 === e3.length ? { type: "LineString", coordinates: e3[0] } : { type: "MultiLineString", coordinates: e3 };
	        } else {
	          if (3 !== this.type) throw new Error("unknown feature type");
	          {
	            const e3 = function(e4) {
	              const t4 = e4.length;
	              if (t4 <= 1) return [e4];
	              const r3 = [];
	              let n3, i3;
	              for (let s3 = 0; s3 < t4; s3++) {
	                const t5 = Iu(e4[s3]);
	                0 !== t5 && (void 0 === i3 && (i3 = t5 < 0), i3 === t5 < 0 ? (n3 && r3.push(n3), n3 = [e4[s3]]) : n3 && n3.push(e4[s3]));
	              }
	              return n3 && r3.push(n3), r3;
	            }(o2), t3 = [];
	            for (const r3 of e3) t3.push(r3.map(l2));
	            u2 = 1 === t3.length ? { type: "Polygon", coordinates: t3[0] } : { type: "MultiPolygon", coordinates: t3 };
	          }
	        }
	        const c2 = { type: "Feature", geometry: u2, properties: this.properties };
	        return null != this.id && (c2.id = this.id), c2;
	      }
	    }
	    function Tu(e2, t2, r2) {
	      1 === e2 ? t2.id = r2.readVarint() : 2 === e2 ? function(e3, t3) {
	        const r3 = e3.readVarint() + e3.pos;
	        for (; e3.pos < r3; ) {
	          const r4 = t3._keys[e3.readVarint()], n2 = t3._values[e3.readVarint()];
	          t3.properties[r4] = n2;
	        }
	      }(r2, t2) : 3 === e2 ? t2.type = r2.readVarint() : 4 === e2 && (t2._geometry = r2.pos);
	    }
	    function Iu(e2) {
	      let t2 = 0;
	      for (let r2, n2, i2 = 0, s2 = e2.length, o2 = s2 - 1; i2 < s2; o2 = i2++) r2 = e2[i2], n2 = e2[o2], t2 += (n2.x - r2.x) * (r2.y + n2.y);
	      return t2;
	    }
	    Au.types = ["Unknown", "Point", "LineString", "Polygon"];
	    class Eu {
	      constructor(e2, t2) {
	        this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = e2, this._keys = [], this._values = [], this._features = [], e2.readFields(Mu, this, t2), this.length = this._features.length;
	      }
	      feature(e2) {
	        if (e2 < 0 || e2 >= this._features.length) throw new Error("feature index out of bounds");
	        this._pbf.pos = this._features[e2];
	        const t2 = this._pbf.readVarint() + this._pbf.pos;
	        return new Au(this._pbf, t2, this.extent, this._keys, this._values);
	      }
	    }
	    function Mu(e2, t2, r2) {
	      15 === e2 ? t2.version = r2.readVarint() : 1 === e2 ? t2.name = r2.readString() : 5 === e2 ? t2.extent = r2.readVarint() : 2 === e2 ? t2._features.push(r2.pos) : 3 === e2 ? t2._keys.push(r2.readString()) : 4 === e2 && t2._values.push(function(e3) {
	        let t3 = null;
	        const r3 = e3.readVarint() + e3.pos;
	        for (; e3.pos < r3; ) {
	          const r4 = e3.readVarint() >> 3;
	          t3 = 1 === r4 ? e3.readString() : 2 === r4 ? e3.readFloat() : 3 === r4 ? e3.readDouble() : 4 === r4 ? e3.readVarint64() : 5 === r4 ? e3.readVarint() : 6 === r4 ? e3.readSVarint() : 7 === r4 ? e3.readBoolean() : null;
	        }
	        if (null == t3) throw new Error("unknown feature value");
	        return t3;
	      }(r2));
	    }
	    class ku {
	      constructor(e2, t2) {
	        this.layers = e2.readFields(Fu, {}, t2);
	      }
	    }
	    function Fu(e2, t2, r2) {
	      if (3 === e2) {
	        const e3 = new Eu(r2, r2.readVarint() + r2.pos);
	        e3.length && (t2[e3.name] = e3);
	      }
	    }
	    const Du = Math.pow(2, 13);
	    function Pu(e2, t2, r2, n2, i2, s2, o2, a2) {
	      e2.emplaceBack(t2, r2, 2 * Math.floor(n2 * Du) + o2, i2 * Du * 2, s2 * Du * 2, Math.round(a2));
	    }
	    class Bu {
	      constructor(e2) {
	        this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((e3) => e3.id), this.index = e2.index, this.hasDependencies = false, this.layoutVertexArray = new $o(), this.centroidVertexArray = new Oo(), this.indexArray = new Wo(), this.programConfigurations = new Da(e2.layers, e2.zoom), this.segments = new ta(), this.stateDependentLayerIds = this.layers.filter((e3) => e3.isStateDependent()).map((e3) => e3.id);
	      }
	      populate(e2, t2, r2) {
	        this.features = [], this.hasDependencies = Bl("fill-extrusion", this.layers, t2);
	        for (const { feature: n2, id: i2, index: s2, sourceLayerIndex: o2 } of e2) {
	          const e3 = this.layers[0]._featureFilter.needGeometry, a2 = La(n2, e3);
	          if (!this.layers[0]._featureFilter.filter(new ks(this.zoom), a2, r2)) continue;
	          const l2 = { id: i2, sourceLayerIndex: o2, index: s2, geometry: e3 ? a2.geometry : Ca(n2), properties: n2.properties, type: n2.type, patterns: {} };
	          this.hasDependencies ? this.features.push(zl("fill-extrusion", this.layers, l2, { zoom: this.zoom }, t2)) : this.addFeature(l2, l2.geometry, s2, r2, {}, t2.subdivisionGranularity), t2.featureIndex.insert(n2, l2.geometry, s2, o2, this.index, true);
	        }
	      }
	      addFeatures(e2, t2, r2) {
	        for (const n2 of this.features) {
	          const { geometry: i2 } = n2;
	          this.addFeature(n2, i2, n2.index, t2, r2, e2.subdivisionGranularity);
	        }
	      }
	      update(e2, t2, r2) {
	        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e2, t2, this.stateDependentLayers, { imagePositions: r2 });
	      }
	      isEmpty() {
	        return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
	      }
	      uploadPending() {
	        return !this.uploaded || this.programConfigurations.needsUpload;
	      }
	      upload(e2) {
	        this.uploaded || (this.layoutVertexBuffer = e2.createVertexBuffer(this.layoutVertexArray, Su), this.centroidVertexBuffer = e2.createVertexBuffer(this.centroidVertexArray, _u.members, true), this.indexBuffer = e2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e2), this.uploaded = true;
	      }
	      destroy() {
	        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
	      }
	      addFeature(e2, t2, r2, n2, i2, s2) {
	        for (const r3 of Qr(t2, 500)) {
	          const t3 = { x: 0, y: 0, sampleCount: 0 }, i3 = this.layoutVertexArray.length;
	          this.processPolygon(t3, n2, e2, r3, s2);
	          const o2 = this.layoutVertexArray.length - i3, a2 = Math.floor(t3.x / t3.sampleCount), l2 = Math.floor(t3.y / t3.sampleCount);
	          for (let e3 = 0; e3 < o2; e3++) this.centroidVertexArray.emplaceBack(a2, l2);
	        }
	        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e2, r2, { imagePositions: i2, canonical: n2 });
	      }
	      processPolygon(e2, t2, r2, n2, i2) {
	        if (n2.length < 1) return;
	        if (Cu(n2[0])) return;
	        for (const t3 of n2) 0 !== t3.length && zu(e2, t3);
	        const s2 = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, o2 = i2.fill.getGranularityForZoomLevel(t2.z), a2 = "Polygon" === Au.types[r2.type];
	        for (const e3 of n2) {
	          if (0 === e3.length) continue;
	          if (Cu(e3)) continue;
	          const t3 = pu(e3, o2, a2);
	          this._generateSideFaces(t3, s2);
	        }
	        if (!a2) return;
	        const l2 = hu(n2, t2, o2, false), u2 = this.layoutVertexArray;
	        du((e3, t3) => {
	          Pu(u2, e3, t3, 0, 0, 1, 1, 0);
	        }, this.segments, this.layoutVertexArray, this.indexArray, l2.verticesFlattened, l2.indicesTriangles);
	      }
	      _generateSideFaces(e2, t2) {
	        let r2 = 0;
	        for (let n2 = 1; n2 < e2.length; n2++) {
	          const i2 = e2[n2], s2 = e2[n2 - 1];
	          if (Vu(i2, s2)) continue;
	          t2.segment.vertexLength + 4 > ta.MAX_VERTEX_ARRAY_LENGTH && (t2.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
	          const o2 = i2.sub(s2)._perp()._unit(), a2 = s2.dist(i2);
	          r2 + a2 > 32768 && (r2 = 0), Pu(this.layoutVertexArray, i2.x, i2.y, o2.x, o2.y, 0, 0, r2), Pu(this.layoutVertexArray, i2.x, i2.y, o2.x, o2.y, 0, 1, r2), r2 += a2, Pu(this.layoutVertexArray, s2.x, s2.y, o2.x, o2.y, 0, 0, r2), Pu(this.layoutVertexArray, s2.x, s2.y, o2.x, o2.y, 0, 1, r2);
	          const l2 = t2.segment.vertexLength;
	          this.indexArray.emplaceBack(l2, l2 + 2, l2 + 1), this.indexArray.emplaceBack(l2 + 1, l2 + 2, l2 + 3), t2.segment.vertexLength += 4, t2.segment.primitiveLength += 2;
	        }
	      }
	    }
	    function zu(e2, t2) {
	      for (let r2 = 0; r2 < t2.length; r2++) {
	        const n2 = t2[r2];
	        r2 === t2.length - 1 && t2[0].x === n2.x && t2[0].y === n2.y || (e2.x += n2.x, e2.y += n2.y, e2.sampleCount++);
	      }
	    }
	    function Vu(e2, t2) {
	      return e2.x === t2.x && (e2.x < 0 || e2.x > k) || e2.y === t2.y && (e2.y < 0 || e2.y > k);
	    }
	    function Cu(e2) {
	      return e2.every((e3) => e3.x < 0) || e2.every((e3) => e3.x > k) || e2.every((e3) => e3.y < 0) || e2.every((e3) => e3.y > k);
	    }
	    let Lu;
	    ls("FillExtrusionBucket", Bu, { omit: ["layers", "features"] });
	    var Ou = { get paint() {
	      return Lu = Lu || new Gs({ "fill-extrusion-opacity": new Ns(xe["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new $s(xe["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Ns(xe["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Ns(xe["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Us(xe["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new $s(xe["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new $s(xe["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Ns(xe["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
	    } };
	    class Ru extends Xs {
	      constructor(e2, t2) {
	        super(e2, Ou, t2);
	      }
	      createBucket(e2) {
	        return new Bu(e2);
	      }
	      queryRadius() {
	        return Qa(this.paint.get("fill-extrusion-translate"));
	      }
	      is3D() {
	        return true;
	      }
	      queryIntersectsFeature({ queryGeometry: e2, feature: t2, featureState: n2, geometry: i2, transform: s2, pixelsToTileUnits: o2, pixelPosMatrix: a2 }) {
	        const l2 = el(e2, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -s2.bearingInRadians, o2), u2 = this.paint.get("fill-extrusion-height").evaluate(t2, n2), c2 = this.paint.get("fill-extrusion-base").evaluate(t2, n2), h2 = function(e3, t3) {
	          const n3 = [];
	          for (const i3 of e3) {
	            const e4 = [i3.x, i3.y, 0, 1];
	            A(e4, e4, t3), n3.push(new r(e4[0] / e4[3], e4[1] / e4[3]));
	          }
	          return n3;
	        }(l2, a2), p2 = function(e3, t3, n3, i3) {
	          const s3 = [], o3 = [], a3 = i3[8] * t3, l3 = i3[9] * t3, u3 = i3[10] * t3, c3 = i3[11] * t3, h3 = i3[8] * n3, p3 = i3[9] * n3, f2 = i3[10] * n3, d2 = i3[11] * n3;
	          for (const t4 of e3) {
	            const e4 = [], n4 = [];
	            for (const s4 of t4) {
	              const t5 = s4.x, o4 = s4.y, y2 = i3[0] * t5 + i3[4] * o4 + i3[12], m2 = i3[1] * t5 + i3[5] * o4 + i3[13], g2 = i3[2] * t5 + i3[6] * o4 + i3[14], x2 = i3[3] * t5 + i3[7] * o4 + i3[15], v2 = g2 + u3, b2 = x2 + c3, w2 = y2 + h3, _2 = m2 + p3, S2 = g2 + f2, A2 = x2 + d2, T2 = new r((y2 + a3) / b2, (m2 + l3) / b2);
	              T2.z = v2 / b2, e4.push(T2);
	              const I2 = new r(w2 / A2, _2 / A2);
	              I2.z = S2 / A2, n4.push(I2);
	            }
	            s3.push(e4), o3.push(n4);
	          }
	          return [s3, o3];
	        }(i2, c2, u2, a2);
	        return function(e3, t3, r2) {
	          let n3 = 1 / 0;
	          qa(r2, t3) && (n3 = $u(r2, t3[0]));
	          for (let i3 = 0; i3 < t3.length; i3++) {
	            const s3 = t3[i3], o3 = e3[i3];
	            for (let e4 = 0; e4 < s3.length - 1; e4++) {
	              const t4 = s3[e4], i4 = [t4, s3[e4 + 1], o3[e4 + 1], o3[e4], t4];
	              $a(r2, i4) && (n3 = Math.min(n3, $u(r2, i4)));
	            }
	          }
	          return n3 !== 1 / 0 && n3;
	        }(p2[0], p2[1], h2);
	      }
	    }
	    function Nu(e2, t2) {
	      return e2.x * t2.x + e2.y * t2.y;
	    }
	    function $u(e2, t2) {
	      if (1 === e2.length) {
	        let r2 = 0;
	        const n2 = t2[r2++];
	        let i2;
	        for (; !i2 || n2.equals(i2); ) if (i2 = t2[r2++], !i2) return 1 / 0;
	        for (; r2 < t2.length; r2++) {
	          const s2 = t2[r2], o2 = e2[0], a2 = i2.sub(n2), l2 = s2.sub(n2), u2 = o2.sub(n2), c2 = Nu(a2, a2), h2 = Nu(a2, l2), p2 = Nu(l2, l2), f2 = Nu(u2, a2), d2 = Nu(u2, l2), y2 = c2 * p2 - h2 * h2, m2 = (p2 * f2 - h2 * d2) / y2, g2 = (c2 * d2 - h2 * f2) / y2, x2 = n2.z * (1 - m2 - g2) + i2.z * m2 + s2.z * g2;
	          if (isFinite(x2)) return x2;
	        }
	        return 1 / 0;
	      }
	      {
	        let e3 = 1 / 0;
	        for (const r2 of t2) e3 = Math.min(e3, r2.z);
	        return e3;
	      }
	    }
	    const Uu = Qs([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: qu } = Uu, ju = Qs([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: Gu } = ju, Xu = Math.cos(Math.PI / 180 * 37.5), Yu = Math.pow(2, 14) / 0.5;
	    class Zu {
	      constructor(e2) {
	        this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((e3) => e3.id), this.index = e2.index, this.hasDependencies = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((e3) => {
	          this.gradients[e3.id] = {};
	        }), this.layoutVertexArray = new Uo(), this.layoutVertexArray2 = new qo(), this.indexArray = new Wo(), this.programConfigurations = new Da(e2.layers, e2.zoom), this.segments = new ta(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((e3) => e3.isStateDependent()).map((e3) => e3.id);
	      }
	      populate(e2, t2, r2) {
	        this.hasDependencies = Bl("line", this.layers, t2) || this.hasLineDasharray(this.layers);
	        const n2 = this.layers[0].layout.get("line-sort-key"), i2 = !n2.isConstant(), s2 = [];
	        for (const { feature: t3, id: o2, index: a2, sourceLayerIndex: l2 } of e2) {
	          const e3 = this.layers[0]._featureFilter.needGeometry, u2 = La(t3, e3);
	          if (!this.layers[0]._featureFilter.filter(new ks(this.zoom), u2, r2)) continue;
	          const c2 = i2 ? n2.evaluate(u2, {}, r2) : void 0, h2 = { id: o2, properties: t3.properties, type: t3.type, sourceLayerIndex: l2, index: a2, geometry: e3 ? u2.geometry : Ca(t3), patterns: {}, dashes: {}, sortKey: c2 };
	          s2.push(h2);
	        }
	        i2 && s2.sort((e3, t3) => e3.sortKey - t3.sortKey);
	        for (const n3 of s2) {
	          const { geometry: i3, index: s3, sourceLayerIndex: o2 } = n3;
	          this.hasDependencies ? (Bl("line", this.layers, t2) ? zl("line", this.layers, n3, { zoom: this.zoom }, t2) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, n3, this.zoom, t2), this.patternFeatures.push(n3)) : this.addFeature(n3, i3, s3, r2, {}, {}, t2.subdivisionGranularity), t2.featureIndex.insert(e2[s3].feature, i3, s3, o2, this.index);
	        }
	      }
	      update(e2, t2, r2, n2) {
	        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e2, t2, this.stateDependentLayers, { imagePositions: r2, dashPositions: n2 });
	      }
	      addFeatures(e2, t2, r2, n2) {
	        for (const i2 of this.patternFeatures) this.addFeature(i2, i2.geometry, i2.index, t2, r2, n2, e2.subdivisionGranularity);
	      }
	      isEmpty() {
	        return 0 === this.layoutVertexArray.length;
	      }
	      uploadPending() {
	        return !this.uploaded || this.programConfigurations.needsUpload;
	      }
	      upload(e2) {
	        this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = e2.createVertexBuffer(this.layoutVertexArray2, Gu)), this.layoutVertexBuffer = e2.createVertexBuffer(this.layoutVertexArray, qu), this.indexBuffer = e2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e2), this.uploaded = true;
	      }
	      destroy() {
	        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
	      }
	      lineFeatureClips(e2) {
	        if (e2.properties && Object.prototype.hasOwnProperty.call(e2.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(e2.properties, "mapbox_clip_end")) return { start: +e2.properties.mapbox_clip_start, end: +e2.properties.mapbox_clip_end };
	      }
	      addFeature(e2, t2, r2, n2, i2, s2, o2) {
	        const a2 = this.layers[0].layout, l2 = a2.get("line-join").evaluate(e2, {}), u2 = a2.get("line-cap"), c2 = a2.get("line-miter-limit"), h2 = a2.get("line-round-limit");
	        this.lineClips = this.lineFeatureClips(e2);
	        for (const r3 of t2) this.addLine(r3, e2, l2, u2, c2, h2, n2, o2);
	        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e2, r2, { imagePositions: i2, dashPositions: s2, canonical: n2 });
	      }
	      addLine(e2, t2, r2, n2, i2, s2, o2, a2) {
	        if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, e2 = pu(e2, o2 ? a2.line.getGranularityForZoomLevel(o2.z) : 1), this.lineClips) {
	          this.lineClipsArray.push(this.lineClips);
	          for (let t3 = 0; t3 < e2.length - 1; t3++) this.totalDistance += e2[t3].dist(e2[t3 + 1]);
	          this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
	        }
	        const l2 = "Polygon" === Au.types[t2.type];
	        let u2 = e2.length;
	        for (; u2 >= 2 && e2[u2 - 1].equals(e2[u2 - 2]); ) u2--;
	        let c2 = 0;
	        for (; c2 < u2 - 1 && e2[c2].equals(e2[c2 + 1]); ) c2++;
	        if (u2 < (l2 ? 3 : 2)) return;
	        "bevel" === r2 && (i2 = 1.05);
	        const h2 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, p2 = this.segments.prepareSegment(10 * u2, this.layoutVertexArray, this.indexArray);
	        let f2, d2, y2, m2, g2;
	        this.e1 = this.e2 = -1, l2 && (f2 = e2[u2 - 2], g2 = e2[c2].sub(f2)._unit()._perp());
	        for (let t3 = c2; t3 < u2; t3++) {
	          if (y2 = t3 === u2 - 1 ? l2 ? e2[c2 + 1] : void 0 : e2[t3 + 1], y2 && e2[t3].equals(y2)) continue;
	          g2 && (m2 = g2), f2 && (d2 = f2), f2 = e2[t3], g2 = y2 ? y2.sub(f2)._unit()._perp() : m2, m2 = m2 || g2;
	          let o3 = m2.add(g2);
	          0 === o3.x && 0 === o3.y || o3._unit();
	          const a3 = m2.x * g2.x + m2.y * g2.y, x2 = o3.x * g2.x + o3.y * g2.y, v2 = 0 !== x2 ? 1 / x2 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x2), w2 = x2 < Xu && d2 && y2, _2 = m2.x * g2.y - m2.y * g2.x > 0;
	          if (w2 && t3 > c2) {
	            const e3 = f2.dist(d2);
	            if (e3 > 2 * h2) {
	              const t4 = f2.sub(f2.sub(d2)._mult(h2 / e3)._round());
	              this.updateDistance(d2, t4), this.addCurrentVertex(t4, m2, 0, 0, p2), d2 = t4;
	            }
	          }
	          const S2 = d2 && y2;
	          let A2 = S2 ? r2 : l2 ? "butt" : n2;
	          if (S2 && "round" === A2 && (v2 < s2 ? A2 = "miter" : v2 <= 2 && (A2 = "fakeround")), "miter" === A2 && v2 > i2 && (A2 = "bevel"), "bevel" === A2 && (v2 > 2 && (A2 = "flipbevel"), v2 < i2 && (A2 = "miter")), d2 && this.updateDistance(d2, f2), "miter" === A2) o3._mult(v2), this.addCurrentVertex(f2, o3, 0, 0, p2);
	          else if ("flipbevel" === A2) {
	            if (v2 > 100) o3 = g2.mult(-1);
	            else {
	              const e3 = v2 * m2.add(g2).mag() / m2.sub(g2).mag();
	              o3._perp()._mult(e3 * (_2 ? -1 : 1));
	            }
	            this.addCurrentVertex(f2, o3, 0, 0, p2), this.addCurrentVertex(f2, o3.mult(-1), 0, 0, p2);
	          } else if ("bevel" === A2 || "fakeround" === A2) {
	            const e3 = -Math.sqrt(v2 * v2 - 1), t4 = _2 ? e3 : 0, r3 = _2 ? 0 : e3;
	            if (d2 && this.addCurrentVertex(f2, m2, t4, r3, p2), "fakeround" === A2) {
	              const e4 = Math.round(180 * b2 / Math.PI / 20);
	              for (let t5 = 1; t5 < e4; t5++) {
	                let r4 = t5 / e4;
	                if (0.5 !== r4) {
	                  const e5 = r4 - 0.5;
	                  r4 += r4 * e5 * (r4 - 1) * ((1.0904 + a3 * (a3 * (3.55645 - 1.43519 * a3) - 3.2452)) * e5 * e5 + (0.848013 + a3 * (0.215638 * a3 - 1.06021)));
	                }
	                const n3 = g2.sub(m2)._mult(r4)._add(m2)._unit()._mult(_2 ? -1 : 1);
	                this.addHalfVertex(f2, n3.x, n3.y, false, _2, 0, p2);
	              }
	            }
	            y2 && this.addCurrentVertex(f2, g2, -t4, -r3, p2);
	          } else if ("butt" === A2) this.addCurrentVertex(f2, o3, 0, 0, p2);
	          else if ("square" === A2) {
	            const e3 = d2 ? 1 : -1;
	            this.addCurrentVertex(f2, o3, e3, e3, p2);
	          } else "round" === A2 && (d2 && (this.addCurrentVertex(f2, m2, 0, 0, p2), this.addCurrentVertex(f2, m2, 1, 1, p2, true)), y2 && (this.addCurrentVertex(f2, g2, -1, -1, p2, true), this.addCurrentVertex(f2, g2, 0, 0, p2)));
	          if (w2 && t3 < u2 - 1) {
	            const e3 = f2.dist(y2);
	            if (e3 > 2 * h2) {
	              const t4 = f2.add(y2.sub(f2)._mult(h2 / e3)._round());
	              this.updateDistance(f2, t4), this.addCurrentVertex(t4, g2, 0, 0, p2), f2 = t4;
	            }
	          }
	        }
	      }
	      addCurrentVertex(e2, t2, r2, n2, i2, s2 = false) {
	        const o2 = t2.y * n2 - t2.x, a2 = -t2.y - t2.x * n2;
	        this.addHalfVertex(e2, t2.x + t2.y * r2, t2.y - t2.x * r2, s2, false, r2, i2), this.addHalfVertex(e2, o2, a2, s2, true, -n2, i2), this.distance > Yu / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(e2, t2, r2, n2, i2, s2));
	      }
	      addHalfVertex({ x: e2, y: t2 }, r2, n2, i2, s2, o2, a2) {
	        const l2 = 0.5 * (this.lineClips ? this.scaledDistance * (Yu - 1) : this.scaledDistance);
	        this.layoutVertexArray.emplaceBack((e2 << 1) + (i2 ? 1 : 0), (t2 << 1) + (s2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (0 === o2 ? 0 : o2 < 0 ? -1 : 1) | (63 & l2) << 2, l2 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
	        const u2 = a2.vertexLength++;
	        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, u2, this.e2), a2.primitiveLength++), s2 ? this.e2 = u2 : this.e1 = u2;
	      }
	      updateScaledDistance() {
	        this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
	      }
	      updateDistance(e2, t2) {
	        this.distance += e2.dist(t2), this.updateScaledDistance();
	      }
	      hasLineDasharray(e2) {
	        for (const t2 of e2) {
	          const e3 = t2.paint.get("line-dasharray");
	          if (e3 && !e3.isConstant()) return true;
	        }
	        return false;
	      }
	      addLineDashDependencies(e2, t2, r2, n2) {
	        for (const i2 of e2) {
	          const e3 = i2.paint.get("line-dasharray");
	          if (!e3 || "constant" === e3.value.kind) continue;
	          const s2 = "round" === i2.layout.get("line-cap"), o2 = { dasharray: e3.value.evaluate({ zoom: r2 - 1 }, t2, {}), round: s2 }, a2 = { dasharray: e3.value.evaluate({ zoom: r2 }, t2, {}), round: s2 }, l2 = { dasharray: e3.value.evaluate({ zoom: r2 + 1 }, t2, {}), round: s2 }, u2 = `${o2.dasharray.join(",")},${o2.round}`, c2 = `${a2.dasharray.join(",")},${a2.round}`, h2 = `${l2.dasharray.join(",")},${l2.round}`;
	          n2.dashDependencies[u2] = o2, n2.dashDependencies[c2] = a2, n2.dashDependencies[h2] = l2, t2.dashes[i2.id] = { min: u2, mid: c2, max: h2 };
	        }
	      }
	    }
	    let Hu, Ku;
	    ls("LineBucket", Zu, { omit: ["layers", "patternFeatures"] });
	    var Wu = { get paint() {
	      return Ku = Ku || new Gs({ "line-opacity": new $s(xe.paint_line["line-opacity"]), "line-color": new $s(xe.paint_line["line-color"]), "line-translate": new Ns(xe.paint_line["line-translate"]), "line-translate-anchor": new Ns(xe.paint_line["line-translate-anchor"]), "line-width": new $s(xe.paint_line["line-width"]), "line-gap-width": new $s(xe.paint_line["line-gap-width"]), "line-offset": new $s(xe.paint_line["line-offset"]), "line-blur": new $s(xe.paint_line["line-blur"]), "line-dasharray": new Us(xe.paint_line["line-dasharray"]), "line-pattern": new Us(xe.paint_line["line-pattern"]), "line-gradient": new js(xe.paint_line["line-gradient"]) });
	    }, get layout() {
	      return Hu = Hu || new Gs({ "line-cap": new Ns(xe.layout_line["line-cap"]), "line-join": new $s(xe.layout_line["line-join"]), "line-miter-limit": new Ns(xe.layout_line["line-miter-limit"]), "line-round-limit": new Ns(xe.layout_line["line-round-limit"]), "line-sort-key": new $s(xe.layout_line["line-sort-key"]) });
	    } };
	    class Ju extends $s {
	      possiblyEvaluate(e2, t2) {
	        return t2 = new ks(Math.floor(t2.zoom), { now: t2.now, fadeDuration: t2.fadeDuration, zoomHistory: t2.zoomHistory, transition: t2.transition }), super.possiblyEvaluate(e2, t2);
	      }
	      evaluate(e2, t2, r2, n2) {
	        return t2 = O({}, t2, { zoom: Math.floor(t2.zoom) }), super.evaluate(e2, t2, r2, n2);
	      }
	    }
	    let Qu;
	    class ec extends Xs {
	      constructor(e2, t2) {
	        super(e2, Wu, t2), this.gradientVersion = 0, Qu || (Qu = new Ju(Wu.paint.properties["line-width"].specification), Qu.useIntegerZoom = true);
	      }
	      _handleSpecialPaintPropertyUpdate(e2) {
	        if ("line-gradient" === e2) {
	          const e3 = this.gradientExpression();
	          this.stepInterpolant = !!function(e4) {
	            return void 0 !== e4._styleExpression;
	          }(e3) && e3._styleExpression.expression instanceof or, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
	        }
	      }
	      gradientExpression() {
	        return this._transitionablePaint._values["line-gradient"].value.expression;
	      }
	      recalculate(e2, t2) {
	        super.recalculate(e2, t2), this.paint._values["line-floorwidth"] = Qu.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e2);
	      }
	      createBucket(e2) {
	        return new Zu(e2);
	      }
	      queryRadius(e2) {
	        const t2 = e2, r2 = tc(Ja("line-width", this, t2), Ja("line-gap-width", this, t2)), n2 = Ja("line-offset", this, t2);
	        return r2 / 2 + Math.abs(n2) + Qa(this.paint.get("line-translate"));
	      }
	      queryIntersectsFeature({ queryGeometry: e2, feature: t2, featureState: n2, geometry: i2, transform: s2, pixelsToTileUnits: o2 }) {
	        const a2 = el(e2, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -s2.bearingInRadians, o2), l2 = o2 / 2 * tc(this.paint.get("line-width").evaluate(t2, n2), this.paint.get("line-gap-width").evaluate(t2, n2)), u2 = this.paint.get("line-offset").evaluate(t2, n2);
	        return u2 && (i2 = function(e3, t3) {
	          const n3 = [];
	          for (let i3 = 0; i3 < e3.length; i3++) {
	            const s3 = e3[i3], o3 = [];
	            for (let e4 = 0; e4 < s3.length; e4++) {
	              const n4 = s3[e4 - 1], i4 = s3[e4], a3 = s3[e4 + 1], l3 = 0 === e4 ? new r(0, 0) : i4.sub(n4)._unit()._perp(), u3 = e4 === s3.length - 1 ? new r(0, 0) : a3.sub(i4)._unit()._perp(), c2 = l3._add(u3)._unit(), h2 = c2.x * u3.x + c2.y * u3.y;
	              0 !== h2 && c2._mult(1 / h2), o3.push(c2._mult(t3)._add(i4));
	            }
	            n3.push(o3);
	          }
	          return n3;
	        }(i2, u2 * o2)), function(e3, t3, r2) {
	          for (let n3 = 0; n3 < t3.length; n3++) {
	            const i3 = t3[n3];
	            if (e3.length >= 3) {
	              for (let t4 = 0; t4 < i3.length; t4++) if (Ka(e3, i3[t4])) return true;
	            }
	            if (ja(e3, i3, r2)) return true;
	          }
	          return false;
	        }(a2, i2, l2);
	      }
	      isTileClipped() {
	        return true;
	      }
	    }
	    function tc(e2, t2) {
	      return t2 > 0 ? t2 + 2 * e2 : e2;
	    }
	    const rc = Qs([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), nc = Qs([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
	    Qs([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
	    const ic = Qs([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
	    Qs([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
	    const sc = Qs([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), oc = Qs([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
	    function ac(e2, t2, r2) {
	      return e2.sections.forEach((e3) => {
	        e3.text = function(e4, t3, r3) {
	          const n2 = t3.layout.get("text-transform").evaluate(r3, {});
	          return "uppercase" === n2 ? e4 = e4.toLocaleUpperCase() : "lowercase" === n2 && (e4 = e4.toLocaleLowerCase()), Ms.applyArabicShaping && (e4 = Ms.applyArabicShaping(e4)), e4;
	        }(e3.text, t2, r2);
	      }), e2;
	    }
	    Qs([{ name: "triangle", components: 3, type: "Uint16" }]), Qs([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Qs([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Qs([{ type: "Float32", name: "offsetX" }]), Qs([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Qs([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
	    var lc = 24;
	    const uc = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" }, cc = { 10: true, 32: true, 38: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true }, hc = { 40: true };
	    function pc(e2, t2, r2, n2, i2, s2) {
	      if ("fontStack" in t2) {
	        const n3 = r2[t2.fontStack], s3 = n3 && n3[e2];
	        return s3 ? s3.metrics.advance * t2.scale + i2 : 0;
	      }
	      {
	        const e3 = n2[t2.imageName];
	        return e3 ? e3.displaySize[0] * t2.scale * lc / s2 + i2 : 0;
	      }
	    }
	    function fc(e2, t2, r2, n2) {
	      const i2 = Math.pow(e2 - t2, 2);
	      return n2 ? e2 < t2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
	    }
	    function dc(e2, t2, r2) {
	      let n2 = 0;
	      return 10 === e2 && (n2 -= 1e4), r2 && (n2 += 150), 40 !== e2 && 65288 !== e2 || (n2 += 50), 41 !== t2 && 65289 !== t2 || (n2 += 50), n2;
	    }
	    function yc(e2, t2, r2, n2, i2, s2) {
	      let o2 = null, a2 = fc(t2, r2, i2, s2);
	      for (const e3 of n2) {
	        const n3 = fc(t2 - e3.x, r2, i2, s2) + e3.badness;
	        n3 <= a2 && (o2 = e3, a2 = n3);
	      }
	      return { index: e2, x: t2, priorBreak: o2, badness: a2 };
	    }
	    function mc(e2) {
	      return e2 ? mc(e2.priorBreak).concat(e2.index) : [];
	    }
	    class gc {
	      constructor(e2 = "", t2 = [], r2 = []) {
	        this.text = e2, this.sections = t2, this.sectionIndex = r2, this.imageSectionID = null;
	      }
	      static fromFeature(e2, t2) {
	        const r2 = new gc();
	        for (let n2 = 0; n2 < e2.sections.length; n2++) {
	          const i2 = e2.sections[n2];
	          i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, t2);
	        }
	        return r2;
	      }
	      length() {
	        return [...this.text].length;
	      }
	      getSection(e2) {
	        return this.sections[this.sectionIndex[e2]];
	      }
	      getSectionIndex(e2) {
	        return this.sectionIndex[e2];
	      }
	      verticalizePunctuation() {
	        this.text = function(e2) {
	          let t2 = "", r2 = { premature: true, value: void 0 };
	          const n2 = e2[Symbol.iterator]();
	          let i2 = n2.next();
	          const s2 = e2[Symbol.iterator]();
	          s2.next();
	          let o2 = s2.next();
	          for (; !i2.done; ) t2 += !o2.done && Ss(o2.value.codePointAt(0)) && !uc[o2.value] || !r2.premature && Ss(r2.value.codePointAt(0)) && !uc[r2.value] || !uc[i2.value] ? i2.value : uc[i2.value], r2 = { value: i2.value, premature: false }, i2 = n2.next(), o2 = s2.next();
	          return t2;
	        }(this.text);
	      }
	      hasZeroWidthSpaces() {
	        return this.text.includes("");
	      }
	      trim() {
	        const e2 = this.text.match(/^\s*/), t2 = e2 ? e2[0].length : 0, r2 = this.text.match(/\S\s*$/), n2 = r2 ? r2[0].length - 1 : 0;
	        this.text = this.text.substring(t2, this.text.length - n2), this.sectionIndex = this.sectionIndex.slice(t2, this.sectionIndex.length - n2);
	      }
	      substring(e2, t2) {
	        const r2 = [...this.text].slice(e2, t2).join(""), n2 = this.sectionIndex.slice(e2, t2);
	        return new gc(r2, this.sections, n2);
	      }
	      toCodeUnitIndex(e2) {
	        return [...this.text].slice(0, e2).join("").length;
	      }
	      toString() {
	        return this.text;
	      }
	      getMaxScale() {
	        return this.sectionIndex.reduce((e2, t2) => Math.max(e2, this.sections[t2].scale), 0);
	      }
	      getMaxImageSize(e2) {
	        let t2 = 0, r2 = 0;
	        for (let n2 = 0; n2 < this.length(); n2++) {
	          const i2 = this.getSection(n2);
	          if ("imageName" in i2) {
	            const n3 = e2[i2.imageName];
	            if (!n3) continue;
	            const s2 = n3.displaySize;
	            t2 = Math.max(t2, s2[0]), r2 = Math.max(r2, s2[1]);
	          }
	        }
	        return { maxImageWidth: t2, maxImageHeight: r2 };
	      }
	      addTextSection(e2, t2) {
	        this.text += e2.text, this.sections.push({ scale: e2.scale || 1, verticalAlign: e2.verticalAlign || "bottom", fontStack: e2.fontStack || t2 });
	        const r2 = this.sections.length - 1;
	        this.sectionIndex.push(...[...e2.text].map(() => r2));
	      }
	      addImageSection(e2) {
	        const t2 = e2.image ? e2.image.name : "";
	        if (0 === t2.length) return void j("Can't add FormattedSection with an empty image.");
	        const r2 = this.getNextImageSectionCharCode();
	        r2 ? (this.text += String.fromCharCode(r2), this.sections.push({ scale: 1, verticalAlign: e2.verticalAlign || "bottom", imageName: t2 }), this.sectionIndex.push(this.sections.length - 1)) : j("Reached maximum number of images 6401");
	      }
	      getNextImageSectionCharCode() {
	        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
	      }
	      determineLineBreaks(e2, t2, r2, n2, i2) {
	        const s2 = [], o2 = this.determineAverageLineWidth(e2, t2, r2, n2, i2), a2 = this.hasZeroWidthSpaces();
	        let l2 = 0, u2 = 0;
	        const c2 = this.text[Symbol.iterator]();
	        let h2 = c2.next();
	        const p2 = this.text[Symbol.iterator]();
	        p2.next();
	        let f2 = p2.next();
	        const d2 = this.text[Symbol.iterator]();
	        d2.next(), d2.next();
	        let y2 = d2.next();
	        for (; !h2.done; ) {
	          const t3 = this.getSection(u2), m2 = h2.value.codePointAt(0);
	          if (gs(m2) || (l2 += pc(m2, t3, r2, n2, e2, i2)), !f2.done) {
	            const e3 = ys(m2), r3 = f2.value.codePointAt(0);
	            (cc[m2] || e3 || "imageName" in t3 || !y2.done && hc[r3]) && s2.push(yc(u2 + 1, l2, o2, s2, dc(m2, r3, e3 && a2), false));
	          }
	          u2++, h2 = c2.next(), f2 = p2.next(), y2 = d2.next();
	        }
	        return mc(yc(this.length(), l2, o2, s2, 0, true));
	      }
	      determineAverageLineWidth(e2, t2, r2, n2, i2) {
	        let s2 = 0, o2 = 0;
	        for (const t3 of this.text) {
	          const a2 = this.getSection(o2);
	          s2 += pc(t3.codePointAt(0), a2, r2, n2, e2, i2), o2++;
	        }
	        return s2 / Math.max(1, Math.ceil(s2 / t2));
	      }
	    }
	    const xc = 4294967296, vc = 1 / xc, bc = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf-8");
	    class wc {
	      constructor(e2 = new Uint8Array(16)) {
	        this.buf = ArrayBuffer.isView(e2) ? e2 : new Uint8Array(e2), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
	      }
	      readFields(e2, t2, r2 = this.length) {
	        for (; this.pos < r2; ) {
	          const r3 = this.readVarint(), n2 = r3 >> 3, i2 = this.pos;
	          this.type = 7 & r3, e2(n2, t2, this), this.pos === i2 && this.skip(r3);
	        }
	        return t2;
	      }
	      readMessage(e2, t2) {
	        return this.readFields(e2, t2, this.readVarint() + this.pos);
	      }
	      readFixed32() {
	        const e2 = this.dataView.getUint32(this.pos, true);
	        return this.pos += 4, e2;
	      }
	      readSFixed32() {
	        const e2 = this.dataView.getInt32(this.pos, true);
	        return this.pos += 4, e2;
	      }
	      readFixed64() {
	        const e2 = this.dataView.getUint32(this.pos, true) + this.dataView.getUint32(this.pos + 4, true) * xc;
	        return this.pos += 8, e2;
	      }
	      readSFixed64() {
	        const e2 = this.dataView.getUint32(this.pos, true) + this.dataView.getInt32(this.pos + 4, true) * xc;
	        return this.pos += 8, e2;
	      }
	      readFloat() {
	        const e2 = this.dataView.getFloat32(this.pos, true);
	        return this.pos += 4, e2;
	      }
	      readDouble() {
	        const e2 = this.dataView.getFloat64(this.pos, true);
	        return this.pos += 8, e2;
	      }
	      readVarint(e2) {
	        const t2 = this.buf;
	        let r2, n2;
	        return n2 = t2[this.pos++], r2 = 127 & n2, n2 < 128 ? r2 : (n2 = t2[this.pos++], r2 |= (127 & n2) << 7, n2 < 128 ? r2 : (n2 = t2[this.pos++], r2 |= (127 & n2) << 14, n2 < 128 ? r2 : (n2 = t2[this.pos++], r2 |= (127 & n2) << 21, n2 < 128 ? r2 : (n2 = t2[this.pos], r2 |= (15 & n2) << 28, function(e3, t3, r3) {
	          const n3 = r3.buf;
	          let i2, s2;
	          if (s2 = n3[r3.pos++], i2 = (112 & s2) >> 4, s2 < 128) return _c(e3, i2, t3);
	          if (s2 = n3[r3.pos++], i2 |= (127 & s2) << 3, s2 < 128) return _c(e3, i2, t3);
	          if (s2 = n3[r3.pos++], i2 |= (127 & s2) << 10, s2 < 128) return _c(e3, i2, t3);
	          if (s2 = n3[r3.pos++], i2 |= (127 & s2) << 17, s2 < 128) return _c(e3, i2, t3);
	          if (s2 = n3[r3.pos++], i2 |= (127 & s2) << 24, s2 < 128) return _c(e3, i2, t3);
	          if (s2 = n3[r3.pos++], i2 |= (1 & s2) << 31, s2 < 128) return _c(e3, i2, t3);
	          throw new Error("Expected varint not more than 10 bytes");
	        }(r2, e2, this)))));
	      }
	      readVarint64() {
	        return this.readVarint(true);
	      }
	      readSVarint() {
	        const e2 = this.readVarint();
	        return e2 % 2 == 1 ? (e2 + 1) / -2 : e2 / 2;
	      }
	      readBoolean() {
	        return Boolean(this.readVarint());
	      }
	      readString() {
	        const e2 = this.readVarint() + this.pos, t2 = this.pos;
	        return this.pos = e2, e2 - t2 >= 12 && bc ? bc.decode(this.buf.subarray(t2, e2)) : function(e3, t3, r2) {
	          let n2 = "", i2 = t3;
	          for (; i2 < r2; ) {
	            const t4 = e3[i2];
	            let s2, o2, a2, l2 = null, u2 = t4 > 239 ? 4 : t4 > 223 ? 3 : t4 > 191 ? 2 : 1;
	            if (i2 + u2 > r2) break;
	            1 === u2 ? t4 < 128 && (l2 = t4) : 2 === u2 ? (s2 = e3[i2 + 1], 128 == (192 & s2) && (l2 = (31 & t4) << 6 | 63 & s2, l2 <= 127 && (l2 = null))) : 3 === u2 ? (s2 = e3[i2 + 1], o2 = e3[i2 + 2], 128 == (192 & s2) && 128 == (192 & o2) && (l2 = (15 & t4) << 12 | (63 & s2) << 6 | 63 & o2, (l2 <= 2047 || l2 >= 55296 && l2 <= 57343) && (l2 = null))) : 4 === u2 && (s2 = e3[i2 + 1], o2 = e3[i2 + 2], a2 = e3[i2 + 3], 128 == (192 & s2) && 128 == (192 & o2) && 128 == (192 & a2) && (l2 = (15 & t4) << 18 | (63 & s2) << 12 | (63 & o2) << 6 | 63 & a2, (l2 <= 65535 || l2 >= 1114112) && (l2 = null))), null === l2 ? (l2 = 65533, u2 = 1) : l2 > 65535 && (l2 -= 65536, n2 += String.fromCharCode(l2 >>> 10 & 1023 | 55296), l2 = 56320 | 1023 & l2), n2 += String.fromCharCode(l2), i2 += u2;
	          }
	          return n2;
	        }(this.buf, t2, e2);
	      }
	      readBytes() {
	        const e2 = this.readVarint() + this.pos, t2 = this.buf.subarray(this.pos, e2);
	        return this.pos = e2, t2;
	      }
	      readPackedVarint(e2 = [], t2) {
	        const r2 = this.readPackedEnd();
	        for (; this.pos < r2; ) e2.push(this.readVarint(t2));
	        return e2;
	      }
	      readPackedSVarint(e2 = []) {
	        const t2 = this.readPackedEnd();
	        for (; this.pos < t2; ) e2.push(this.readSVarint());
	        return e2;
	      }
	      readPackedBoolean(e2 = []) {
	        const t2 = this.readPackedEnd();
	        for (; this.pos < t2; ) e2.push(this.readBoolean());
	        return e2;
	      }
	      readPackedFloat(e2 = []) {
	        const t2 = this.readPackedEnd();
	        for (; this.pos < t2; ) e2.push(this.readFloat());
	        return e2;
	      }
	      readPackedDouble(e2 = []) {
	        const t2 = this.readPackedEnd();
	        for (; this.pos < t2; ) e2.push(this.readDouble());
	        return e2;
	      }
	      readPackedFixed32(e2 = []) {
	        const t2 = this.readPackedEnd();
	        for (; this.pos < t2; ) e2.push(this.readFixed32());
	        return e2;
	      }
	      readPackedSFixed32(e2 = []) {
	        const t2 = this.readPackedEnd();
	        for (; this.pos < t2; ) e2.push(this.readSFixed32());
	        return e2;
	      }
	      readPackedFixed64(e2 = []) {
	        const t2 = this.readPackedEnd();
	        for (; this.pos < t2; ) e2.push(this.readFixed64());
	        return e2;
	      }
	      readPackedSFixed64(e2 = []) {
	        const t2 = this.readPackedEnd();
	        for (; this.pos < t2; ) e2.push(this.readSFixed64());
	        return e2;
	      }
	      readPackedEnd() {
	        return 2 === this.type ? this.readVarint() + this.pos : this.pos + 1;
	      }
	      skip(e2) {
	        const t2 = 7 & e2;
	        if (0 === t2) for (; this.buf[this.pos++] > 127; ) ;
	        else if (2 === t2) this.pos = this.readVarint() + this.pos;
	        else if (5 === t2) this.pos += 4;
	        else {
	          if (1 !== t2) throw new Error(`Unimplemented type: ${t2}`);
	          this.pos += 8;
	        }
	      }
	      writeTag(e2, t2) {
	        this.writeVarint(e2 << 3 | t2);
	      }
	      realloc(e2) {
	        let t2 = this.length || 16;
	        for (; t2 < this.pos + e2; ) t2 *= 2;
	        if (t2 !== this.length) {
	          const e3 = new Uint8Array(t2);
	          e3.set(this.buf), this.buf = e3, this.dataView = new DataView(e3.buffer), this.length = t2;
	        }
	      }
	      finish() {
	        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
	      }
	      writeFixed32(e2) {
	        this.realloc(4), this.dataView.setInt32(this.pos, e2, true), this.pos += 4;
	      }
	      writeSFixed32(e2) {
	        this.realloc(4), this.dataView.setInt32(this.pos, e2, true), this.pos += 4;
	      }
	      writeFixed64(e2) {
	        this.realloc(8), this.dataView.setInt32(this.pos, -1 & e2, true), this.dataView.setInt32(this.pos + 4, Math.floor(e2 * vc), true), this.pos += 8;
	      }
	      writeSFixed64(e2) {
	        this.realloc(8), this.dataView.setInt32(this.pos, -1 & e2, true), this.dataView.setInt32(this.pos + 4, Math.floor(e2 * vc), true), this.pos += 8;
	      }
	      writeVarint(e2) {
	        (e2 = +e2 || 0) > 268435455 || e2 < 0 ? function(e3, t2) {
	          let r2, n2;
	          if (e3 >= 0 ? (r2 = e3 % 4294967296 | 0, n2 = e3 / 4294967296 | 0) : (r2 = ~(-e3 % 4294967296), n2 = ~(-e3 / 4294967296), 4294967295 ^ r2 ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0)), e3 >= 18446744073709552e3 || e3 < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
	          t2.realloc(10), function(e4, t3, r3) {
	            r3.buf[r3.pos++] = 127 & e4 | 128, e4 >>>= 7, r3.buf[r3.pos++] = 127 & e4 | 128, e4 >>>= 7, r3.buf[r3.pos++] = 127 & e4 | 128, e4 >>>= 7, r3.buf[r3.pos++] = 127 & e4 | 128, r3.buf[r3.pos] = 127 & (e4 >>>= 7);
	          }(r2, 0, t2), function(e4, t3) {
	            const r3 = (7 & e4) << 4;
	            t3.buf[t3.pos++] |= r3 | ((e4 >>>= 3) ? 128 : 0), e4 && (t3.buf[t3.pos++] = 127 & e4 | ((e4 >>>= 7) ? 128 : 0), e4 && (t3.buf[t3.pos++] = 127 & e4 | ((e4 >>>= 7) ? 128 : 0), e4 && (t3.buf[t3.pos++] = 127 & e4 | ((e4 >>>= 7) ? 128 : 0), e4 && (t3.buf[t3.pos++] = 127 & e4 | ((e4 >>>= 7) ? 128 : 0), e4 && (t3.buf[t3.pos++] = 127 & e4)))));
	          }(n2, t2);
	        }(e2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & e2 | (e2 > 127 ? 128 : 0), e2 <= 127 || (this.buf[this.pos++] = 127 & (e2 >>>= 7) | (e2 > 127 ? 128 : 0), e2 <= 127 || (this.buf[this.pos++] = 127 & (e2 >>>= 7) | (e2 > 127 ? 128 : 0), e2 <= 127 || (this.buf[this.pos++] = e2 >>> 7 & 127))));
	      }
	      writeSVarint(e2) {
	        this.writeVarint(e2 < 0 ? 2 * -e2 - 1 : 2 * e2);
	      }
	      writeBoolean(e2) {
	        this.writeVarint(+e2);
	      }
	      writeString(e2) {
	        e2 = String(e2), this.realloc(4 * e2.length), this.pos++;
	        const t2 = this.pos;
	        this.pos = function(e3, t3, r3) {
	          for (let n2, i2, s2 = 0; s2 < t3.length; s2++) {
	            if (n2 = t3.charCodeAt(s2), n2 > 55295 && n2 < 57344) {
	              if (!i2) {
	                n2 > 56319 || s2 + 1 === t3.length ? (e3[r3++] = 239, e3[r3++] = 191, e3[r3++] = 189) : i2 = n2;
	                continue;
	              }
	              if (n2 < 56320) {
	                e3[r3++] = 239, e3[r3++] = 191, e3[r3++] = 189, i2 = n2;
	                continue;
	              }
	              n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
	            } else i2 && (e3[r3++] = 239, e3[r3++] = 191, e3[r3++] = 189, i2 = null);
	            n2 < 128 ? e3[r3++] = n2 : (n2 < 2048 ? e3[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? e3[r3++] = n2 >> 12 | 224 : (e3[r3++] = n2 >> 18 | 240, e3[r3++] = n2 >> 12 & 63 | 128), e3[r3++] = n2 >> 6 & 63 | 128), e3[r3++] = 63 & n2 | 128);
	          }
	          return r3;
	        }(this.buf, e2, this.pos);
	        const r2 = this.pos - t2;
	        r2 >= 128 && Sc(t2, r2, this), this.pos = t2 - 1, this.writeVarint(r2), this.pos += r2;
	      }
	      writeFloat(e2) {
	        this.realloc(4), this.dataView.setFloat32(this.pos, e2, true), this.pos += 4;
	      }
	      writeDouble(e2) {
	        this.realloc(8), this.dataView.setFloat64(this.pos, e2, true), this.pos += 8;
	      }
	      writeBytes(e2) {
	        const t2 = e2.length;
	        this.writeVarint(t2), this.realloc(t2);
	        for (let r2 = 0; r2 < t2; r2++) this.buf[this.pos++] = e2[r2];
	      }
	      writeRawMessage(e2, t2) {
	        this.pos++;
	        const r2 = this.pos;
	        e2(t2, this);
	        const n2 = this.pos - r2;
	        n2 >= 128 && Sc(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
	      }
	      writeMessage(e2, t2, r2) {
	        this.writeTag(e2, 2), this.writeRawMessage(t2, r2);
	      }
	      writePackedVarint(e2, t2) {
	        t2.length && this.writeMessage(e2, Ac, t2);
	      }
	      writePackedSVarint(e2, t2) {
	        t2.length && this.writeMessage(e2, Tc, t2);
	      }
	      writePackedBoolean(e2, t2) {
	        t2.length && this.writeMessage(e2, Mc, t2);
	      }
	      writePackedFloat(e2, t2) {
	        t2.length && this.writeMessage(e2, Ic, t2);
	      }
	      writePackedDouble(e2, t2) {
	        t2.length && this.writeMessage(e2, Ec, t2);
	      }
	      writePackedFixed32(e2, t2) {
	        t2.length && this.writeMessage(e2, kc, t2);
	      }
	      writePackedSFixed32(e2, t2) {
	        t2.length && this.writeMessage(e2, Fc, t2);
	      }
	      writePackedFixed64(e2, t2) {
	        t2.length && this.writeMessage(e2, Dc, t2);
	      }
	      writePackedSFixed64(e2, t2) {
	        t2.length && this.writeMessage(e2, Pc, t2);
	      }
	      writeBytesField(e2, t2) {
	        this.writeTag(e2, 2), this.writeBytes(t2);
	      }
	      writeFixed32Field(e2, t2) {
	        this.writeTag(e2, 5), this.writeFixed32(t2);
	      }
	      writeSFixed32Field(e2, t2) {
	        this.writeTag(e2, 5), this.writeSFixed32(t2);
	      }
	      writeFixed64Field(e2, t2) {
	        this.writeTag(e2, 1), this.writeFixed64(t2);
	      }
	      writeSFixed64Field(e2, t2) {
	        this.writeTag(e2, 1), this.writeSFixed64(t2);
	      }
	      writeVarintField(e2, t2) {
	        this.writeTag(e2, 0), this.writeVarint(t2);
	      }
	      writeSVarintField(e2, t2) {
	        this.writeTag(e2, 0), this.writeSVarint(t2);
	      }
	      writeStringField(e2, t2) {
	        this.writeTag(e2, 2), this.writeString(t2);
	      }
	      writeFloatField(e2, t2) {
	        this.writeTag(e2, 5), this.writeFloat(t2);
	      }
	      writeDoubleField(e2, t2) {
	        this.writeTag(e2, 1), this.writeDouble(t2);
	      }
	      writeBooleanField(e2, t2) {
	        this.writeVarintField(e2, +t2);
	      }
	    }
	    function _c(e2, t2, r2) {
	      return r2 ? 4294967296 * t2 + (e2 >>> 0) : 4294967296 * (t2 >>> 0) + (e2 >>> 0);
	    }
	    function Sc(e2, t2, r2) {
	      const n2 = t2 <= 16383 ? 1 : t2 <= 2097151 ? 2 : t2 <= 268435455 ? 3 : Math.floor(Math.log(t2) / (7 * Math.LN2));
	      r2.realloc(n2);
	      for (let t3 = r2.pos - 1; t3 >= e2; t3--) r2.buf[t3 + n2] = r2.buf[t3];
	    }
	    function Ac(e2, t2) {
	      for (let r2 = 0; r2 < e2.length; r2++) t2.writeVarint(e2[r2]);
	    }
	    function Tc(e2, t2) {
	      for (let r2 = 0; r2 < e2.length; r2++) t2.writeSVarint(e2[r2]);
	    }
	    function Ic(e2, t2) {
	      for (let r2 = 0; r2 < e2.length; r2++) t2.writeFloat(e2[r2]);
	    }
	    function Ec(e2, t2) {
	      for (let r2 = 0; r2 < e2.length; r2++) t2.writeDouble(e2[r2]);
	    }
	    function Mc(e2, t2) {
	      for (let r2 = 0; r2 < e2.length; r2++) t2.writeBoolean(e2[r2]);
	    }
	    function kc(e2, t2) {
	      for (let r2 = 0; r2 < e2.length; r2++) t2.writeFixed32(e2[r2]);
	    }
	    function Fc(e2, t2) {
	      for (let r2 = 0; r2 < e2.length; r2++) t2.writeSFixed32(e2[r2]);
	    }
	    function Dc(e2, t2) {
	      for (let r2 = 0; r2 < e2.length; r2++) t2.writeFixed64(e2[r2]);
	    }
	    function Pc(e2, t2) {
	      for (let r2 = 0; r2 < e2.length; r2++) t2.writeSFixed64(e2[r2]);
	    }
	    function Bc(e2, t2, r2) {
	      1 === e2 && r2.readMessage(zc, t2);
	    }
	    function zc(e2, t2, r2) {
	      if (3 === e2) {
	        const { id: e3, bitmap: n2, width: i2, height: s2, left: o2, top: a2, advance: l2 } = r2.readMessage(Vc, {});
	        t2.push({ id: e3, bitmap: new gl({ width: i2 + 6, height: s2 + 6 }, n2), metrics: { width: i2, height: s2, left: o2, top: a2, advance: l2 } });
	      }
	    }
	    function Vc(e2, t2, r2) {
	      1 === e2 ? t2.id = r2.readVarint() : 2 === e2 ? t2.bitmap = r2.readBytes() : 3 === e2 ? t2.width = r2.readVarint() : 4 === e2 ? t2.height = r2.readVarint() : 5 === e2 ? t2.left = r2.readSVarint() : 6 === e2 ? t2.top = r2.readSVarint() : 7 === e2 && (t2.advance = r2.readVarint());
	    }
	    function Cc(e2) {
	      let t2 = 0, r2 = 0;
	      for (const n3 of e2) t2 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
	      e2.sort((e3, t3) => t3.h - e3.h);
	      const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t2 / 0.95)), r2), h: 1 / 0 }];
	      let i2 = 0, s2 = 0;
	      for (const t3 of e2) for (let e3 = n2.length - 1; e3 >= 0; e3--) {
	        const r3 = n2[e3];
	        if (!(t3.w > r3.w || t3.h > r3.h)) {
	          if (t3.x = r3.x, t3.y = r3.y, s2 = Math.max(s2, t3.y + t3.h), i2 = Math.max(i2, t3.x + t3.w), t3.w === r3.w && t3.h === r3.h) {
	            const t4 = n2.pop();
	            t4 && e3 < n2.length && (n2[e3] = t4);
	          } else t3.h === r3.h ? (r3.x += t3.w, r3.w -= t3.w) : t3.w === r3.w ? (r3.y += t3.h, r3.h -= t3.h) : (n2.push({ x: r3.x + t3.w, y: r3.y, w: r3.w - t3.w, h: t3.h }), r3.y += t3.h, r3.h -= t3.h);
	          break;
	        }
	      }
	      return { w: i2, h: s2, fill: t2 / (i2 * s2) || 0 };
	    }
	    class Lc {
	      constructor(e2, { pixelRatio: t2, version: r2, stretchX: n2, stretchY: i2, content: s2, textFitWidth: o2, textFitHeight: a2 }) {
	        this.paddedRect = e2, this.pixelRatio = t2, this.stretchX = n2, this.stretchY = i2, this.content = s2, this.version = r2, this.textFitWidth = o2, this.textFitHeight = a2;
	      }
	      get tl() {
	        return [this.paddedRect.x + 1, this.paddedRect.y + 1];
	      }
	      get br() {
	        return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
	      }
	      get tlbr() {
	        return this.tl.concat(this.br);
	      }
	      get displaySize() {
	        return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
	      }
	    }
	    class Oc {
	      constructor(e2, t2) {
	        const r2 = {}, n2 = {};
	        this.haveRenderCallbacks = [];
	        const i2 = [];
	        this.addImages(e2, r2, i2), this.addImages(t2, n2, i2);
	        const { w: s2, h: o2 } = Cc(i2), a2 = new xl({ width: s2 || 1, height: o2 || 1 });
	        for (const t3 in e2) {
	          const n3 = e2[t3], i3 = r2[t3].paddedRect;
	          xl.copy(n3.data, a2, { x: 0, y: 0 }, { x: i3.x + 1, y: i3.y + 1 }, n3.data);
	        }
	        for (const e3 in t2) {
	          const r3 = t2[e3], i3 = n2[e3].paddedRect, s3 = i3.x + 1, o3 = i3.y + 1, l2 = r3.data.width, u2 = r3.data.height;
	          xl.copy(r3.data, a2, { x: 0, y: 0 }, { x: s3, y: o3 }, r3.data), xl.copy(r3.data, a2, { x: 0, y: u2 - 1 }, { x: s3, y: o3 - 1 }, { width: l2, height: 1 }), xl.copy(r3.data, a2, { x: 0, y: 0 }, { x: s3, y: o3 + u2 }, { width: l2, height: 1 }), xl.copy(r3.data, a2, { x: l2 - 1, y: 0 }, { x: s3 - 1, y: o3 }, { width: 1, height: u2 }), xl.copy(r3.data, a2, { x: 0, y: 0 }, { x: s3 + l2, y: o3 }, { width: 1, height: u2 });
	        }
	        this.image = a2, this.iconPositions = r2, this.patternPositions = n2;
	      }
	      addImages(e2, t2, r2) {
	        for (const n2 in e2) {
	          const i2 = e2[n2], s2 = { x: 0, y: 0, w: i2.data.width + 2, h: i2.data.height + 2 };
	          r2.push(s2), t2[n2] = new Lc(s2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
	        }
	      }
	      patchUpdatedImages(e2, t2) {
	        e2.dispatchRenderCallbacks(this.haveRenderCallbacks);
	        for (const r2 in e2.updatedImages) this.patchUpdatedImage(this.iconPositions[r2], e2.getImage(r2), t2), this.patchUpdatedImage(this.patternPositions[r2], e2.getImage(r2), t2);
	      }
	      patchUpdatedImage(e2, t2, r2) {
	        if (!e2 || !t2) return;
	        if (e2.version === t2.version) return;
	        e2.version = t2.version;
	        const [n2, i2] = e2.tl;
	        r2.update(t2.data, void 0, { x: n2, y: i2 });
	      }
	    }
	    var Rc;
	    function Nc(t2, r2, n2, i2, s2, o2, a2, l2, u2, c2, h2, p2, f2, d2, y2) {
	      const m2 = gc.fromFeature(t2, s2);
	      let g2;
	      p2 === e.ay.vertical && m2.verticalizePunctuation();
	      let x2 = m2.determineLineBreaks(c2, o2, r2, i2, d2);
	      const { processBidirectionalText: v2, processStyledBidirectionalText: b2 } = Ms;
	      if (v2 && 1 === m2.sections.length) {
	        g2 = [], x2 = x2.map((e3) => m2.toCodeUnitIndex(e3));
	        const e2 = v2(m2.toString(), x2);
	        for (const t3 of e2) {
	          const e3 = [...t3].map(() => 0);
	          g2.push(new gc(t3, m2.sections, e3));
	        }
	      } else if (b2) {
	        g2 = [], x2 = x2.map((e3) => m2.toCodeUnitIndex(e3));
	        let e2 = 0;
	        const t3 = [];
	        for (const r4 of m2.text) t3.push(...Array(r4.length).fill(m2.sectionIndex[e2])), e2++;
	        const r3 = b2(m2.text, t3, x2);
	        for (const e3 of r3) {
	          const t4 = [];
	          let r4 = "";
	          for (const n3 of e3[0]) t4.push(e3[1][r4.length]), r4 += n3;
	          g2.push(new gc(e3[0], m2.sections, t4));
	        }
	      } else g2 = function(e2, t3) {
	        const r3 = [];
	        let n3 = 0;
	        for (const i3 of t3) r3.push(e2.substring(n3, i3)), n3 = i3;
	        return n3 < e2.length() && r3.push(e2.substring(n3, e2.length())), r3;
	      }(m2, x2);
	      const w2 = [], _2 = { positionedLines: w2, text: m2.toString(), top: h2[1], bottom: h2[1], left: h2[0], right: h2[0], writingMode: p2, iconsInText: false, verticalizable: false };
	      return function(e2, t3, r3, n3, i3, s3, o3, a3, l3, u3, c3, h3) {
	        let p3 = 0, f3 = 0, d3 = 0, y3 = 0;
	        const m3 = "right" === a3 ? 1 : "left" === a3 ? 0 : 0.5, g3 = lc / h3;
	        let x3 = 0;
	        for (const o4 of i3) {
	          o4.trim();
	          const i4 = o4.getMaxScale(), a4 = { positionedGlyphs: [], lineOffset: 0 };
	          e2.positionedLines[x3] = a4;
	          const h4 = a4.positionedGlyphs;
	          let v4 = 0;
	          if (!o4.length()) {
	            f3 += s3, ++x3;
	            continue;
	          }
	          const b4 = Uc(n3, o4, g3);
	          let w3 = 0;
	          for (const s4 of o4.text) {
	            const a5 = o4.getSection(w3), d4 = s4.codePointAt(0), y4 = jc(l3, c3, d4), m4 = { glyph: d4, imageName: null, x: p3, y: f3 + -17, vertical: y4, scale: 1, fontStack: "", sectionIndex: o4.getSectionIndex(w3), metrics: null, rect: null };
	            let x4;
	            if ("fontStack" in a5) {
	              if (x4 = Gc(a5, d4, y4, b4, t3, r3), !x4) continue;
	              m4.fontStack = a5.fontStack;
	            } else {
	              if (e2.iconsInText = true, a5.scale *= g3, x4 = Xc(a5, y4, i4, b4, n3), !x4) continue;
	              v4 = Math.max(v4, x4.imageOffset), m4.imageName = a5.imageName;
	            }
	            const { rect: _4, metrics: S2, baselineOffset: A2 } = x4;
	            m4.y += A2, m4.scale = a5.scale, m4.metrics = S2, m4.rect = _4, h4.push(m4), y4 ? (e2.verticalizable = true, p3 += ("imageName" in a5 ? S2.advance : lc) * a5.scale + u3) : p3 += S2.advance * a5.scale + u3, w3++;
	          }
	          0 !== h4.length && (d3 = Math.max(p3 - u3, d3), Yc(h4, 0, h4.length - 1, m3)), p3 = 0, a4.lineOffset = Math.max(v4, (i4 - 1) * lc);
	          const _3 = s3 * i4 + v4;
	          f3 += _3, y3 = Math.max(_3, y3), ++x3;
	        }
	        const { horizontalAlign: v3, verticalAlign: b3 } = $c(o3);
	        ((function(e3, t4, r4, n4, i4, s4, o4, a4, l4) {
	          const u4 = (t4 - r4) * i4;
	          let c4 = 0;
	          c4 = s4 !== o4 ? -a4 * n4 - -17 : -n4 * l4 * o4 + 0.5 * o4;
	          for (const t5 of e3) for (const e4 of t5.positionedGlyphs) e4.x += u4, e4.y += c4;
	        }))(e2.positionedLines, m3, v3, b3, d3, y3, s3, f3, i3.length), e2.top += -b3 * f3, e2.bottom = e2.top + f3, e2.left += -v3 * d3, e2.right = e2.left + d3;
	      }(_2, r2, n2, i2, g2, a2, l2, u2, p2, c2, f2, y2), !function(e2) {
	        for (const t3 of e2) if (0 !== t3.positionedGlyphs.length) return false;
	        return true;
	      }(w2) && _2;
	    }
	    function $c(e2) {
	      let t2 = 0.5, r2 = 0.5;
	      switch (e2) {
	        case "right":
	        case "top-right":
	        case "bottom-right":
	          t2 = 1;
	          break;
	        case "left":
	        case "top-left":
	        case "bottom-left":
	          t2 = 0;
	      }
	      switch (e2) {
	        case "bottom":
	        case "bottom-right":
	        case "bottom-left":
	          r2 = 1;
	          break;
	        case "top":
	        case "top-right":
	        case "top-left":
	          r2 = 0;
	      }
	      return { horizontalAlign: t2, verticalAlign: r2 };
	    }
	    function Uc(e2, t2, r2) {
	      const n2 = t2.getMaxScale() * lc, { maxImageWidth: i2, maxImageHeight: s2 } = t2.getMaxImageSize(e2), o2 = Math.max(n2, s2 * r2);
	      return { verticalLineContentWidth: Math.max(n2, i2 * r2), horizontalLineContentHeight: o2 };
	    }
	    function qc(e2) {
	      switch (e2) {
	        case "top":
	          return 0;
	        case "center":
	          return 0.5;
	        default:
	          return 1;
	      }
	    }
	    function jc(t2, r2, n2) {
	      return !(t2 === e.ay.horizontal || !r2 && !ms(n2) || r2 && (gs(n2) || (i2 = n2, /\p{sc=Arab}/u.test(String.fromCodePoint(i2)))));
	      var i2;
	    }
	    function Gc(e2, t2, r2, n2, i2, s2) {
	      const o2 = s2[e2.fontStack], a2 = function(e3, t3, r3, n3) {
	        if (e3 && e3.rect) return e3;
	        const i3 = t3[r3.fontStack], s3 = i3 && i3[n3];
	        return s3 ? { rect: null, metrics: s3.metrics } : null;
	      }(o2 && o2[t2], i2, e2, t2);
	      if (null === a2) return null;
	      let l2;
	      if (r2) l2 = n2.verticalLineContentWidth - e2.scale * lc;
	      else {
	        const t3 = qc(e2.verticalAlign);
	        l2 = (n2.horizontalLineContentHeight - e2.scale * lc) * t3;
	      }
	      return { rect: a2.rect, metrics: a2.metrics, baselineOffset: l2 };
	    }
	    function Xc(e2, t2, r2, n2, i2) {
	      const s2 = i2[e2.imageName];
	      if (!s2) return null;
	      const o2 = s2.paddedRect, a2 = s2.displaySize, l2 = { width: a2[0], height: a2[1], left: 1, top: -3, advance: t2 ? a2[1] : a2[0] };
	      let u2;
	      if (t2) u2 = n2.verticalLineContentWidth - a2[1] * e2.scale;
	      else {
	        const t3 = qc(e2.verticalAlign);
	        u2 = (n2.horizontalLineContentHeight - a2[1] * e2.scale) * t3;
	      }
	      return { rect: o2, metrics: l2, baselineOffset: u2, imageOffset: (t2 ? a2[0] : a2[1]) * e2.scale - lc * r2 };
	    }
	    function Yc(e2, t2, r2, n2) {
	      if (0 === n2) return;
	      const i2 = e2[r2], s2 = (e2[r2].x + i2.metrics.advance * i2.scale) * n2;
	      for (let n3 = t2; n3 <= r2; n3++) e2[n3].x -= s2;
	    }
	    function Zc(e2, t2, r2) {
	      const { horizontalAlign: n2, verticalAlign: i2 } = $c(r2), s2 = t2[0] - e2.displaySize[0] * n2, o2 = t2[1] - e2.displaySize[1] * i2;
	      return { image: e2, top: o2, bottom: o2 + e2.displaySize[1], left: s2, right: s2 + e2.displaySize[0] };
	    }
	    function Hc(e2) {
	      var t2, r2;
	      let n2 = e2.left, i2 = e2.top, s2 = e2.right - n2, o2 = e2.bottom - i2;
	      const a2 = null !== (t2 = e2.image.textFitWidth) && void 0 !== t2 ? t2 : "stretchOrShrink", l2 = null !== (r2 = e2.image.textFitHeight) && void 0 !== r2 ? r2 : "stretchOrShrink", u2 = (e2.image.content[2] - e2.image.content[0]) / (e2.image.content[3] - e2.image.content[1]);
	      if ("proportional" === l2) {
	        if ("stretchOnly" === a2 && s2 / o2 < u2 || "proportional" === a2) {
	          const e3 = Math.ceil(o2 * u2);
	          n2 *= e3 / s2, s2 = e3;
	        }
	      } else if ("proportional" === a2 && "stretchOnly" === l2 && 0 !== u2 && s2 / o2 > u2) {
	        const e3 = Math.ceil(s2 / u2);
	        i2 *= e3 / o2, o2 = e3;
	      }
	      return { x1: n2, y1: i2, x2: n2 + s2, y2: i2 + o2 };
	    }
	    function Kc(e2, t2, r2, n2, i2, s2) {
	      const o2 = e2.image;
	      let a2;
	      if (o2.content) {
	        const e3 = o2.content, t3 = o2.pixelRatio || 1;
	        a2 = [e3[0] / t3, e3[1] / t3, o2.displaySize[0] - e3[2] / t3, o2.displaySize[1] - e3[3] / t3];
	      }
	      const l2 = t2.left * s2, u2 = t2.right * s2;
	      let c2, h2, p2, f2;
	      "width" === r2 || "both" === r2 ? (f2 = i2[0] + l2 - n2[3], h2 = i2[0] + u2 + n2[1]) : (f2 = i2[0] + (l2 + u2 - o2.displaySize[0]) / 2, h2 = f2 + o2.displaySize[0]);
	      const d2 = t2.top * s2, y2 = t2.bottom * s2;
	      return "height" === r2 || "both" === r2 ? (c2 = i2[1] + d2 - n2[0], p2 = i2[1] + y2 + n2[2]) : (c2 = i2[1] + (d2 + y2 - o2.displaySize[1]) / 2, p2 = c2 + o2.displaySize[1]), { image: o2, top: c2, right: h2, bottom: p2, left: f2, collisionPadding: a2 };
	    }
	    ls("ImagePosition", Lc), ls("ImageAtlas", Oc), e.ay = void 0, (Rc = e.ay || (e.ay = {}))[Rc.none = 0] = "none", Rc[Rc.horizontal = 1] = "horizontal", Rc[Rc.vertical = 2] = "vertical", Rc[Rc.horizontalOnly = 3] = "horizontalOnly";
	    const Wc = 128, Jc = 32640;
	    function Qc(e2, t2) {
	      const { expression: r2 } = t2;
	      if ("constant" === r2.kind) return { kind: "constant", layoutSize: r2.evaluate(new ks(e2 + 1)) };
	      if ("source" === r2.kind) return { kind: "source" };
	      {
	        const { zoomStops: t3, interpolationType: n2 } = r2;
	        let i2 = 0;
	        for (; i2 < t3.length && t3[i2] <= e2; ) i2++;
	        i2 = Math.max(0, i2 - 1);
	        let s2 = i2;
	        for (; s2 < t3.length && t3[s2] < e2 + 1; ) s2++;
	        s2 = Math.min(t3.length - 1, s2);
	        const o2 = t3[i2], a2 = t3[s2];
	        return "composite" === r2.kind ? { kind: "composite", minZoom: o2, maxZoom: a2, interpolationType: n2 } : { kind: "camera", minZoom: o2, maxZoom: a2, minSize: r2.evaluate(new ks(o2)), maxSize: r2.evaluate(new ks(a2)), interpolationType: n2 };
	      }
	    }
	    function eh(e2, t2, r2) {
	      let n2 = "never";
	      const i2 = e2.get(t2);
	      return i2 ? n2 = i2 : e2.get(r2) && (n2 = "always"), n2;
	    }
	    const th = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
	    function rh(e2, t2, r2, n2, i2, s2, o2, a2, l2, u2, c2, h2, p2) {
	      const f2 = a2 ? Math.min(Jc, Math.round(a2[0])) : 0, d2 = a2 ? Math.min(Jc, Math.round(a2[1])) : 0;
	      e2.emplaceBack(t2, r2, Math.round(32 * n2), Math.round(32 * i2), s2, o2, (f2 << 1) + (l2 ? 1 : 0), d2, 16 * u2, 16 * c2, 256 * h2, 256 * p2);
	    }
	    function nh(e2, t2, r2) {
	      e2.emplaceBack(t2.x, t2.y, r2), e2.emplaceBack(t2.x, t2.y, r2), e2.emplaceBack(t2.x, t2.y, r2), e2.emplaceBack(t2.x, t2.y, r2);
	    }
	    function ih(e2) {
	      for (const t2 of e2.sections) if (Es(t2.text)) return true;
	      return false;
	    }
	    class sh {
	      constructor(e2) {
	        this.layoutVertexArray = new Xo(), this.indexArray = new Wo(), this.programConfigurations = e2, this.segments = new ta(), this.dynamicLayoutVertexArray = new Yo(), this.opacityVertexArray = new Zo(), this.hasVisibleVertices = false, this.placedSymbolArray = new ko();
	      }
	      isEmpty() {
	        return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
	      }
	      upload(e2, t2, r2, n2) {
	        this.isEmpty() || (r2 && (this.layoutVertexBuffer = e2.createVertexBuffer(this.layoutVertexArray, rc.members), this.indexBuffer = e2.createIndexBuffer(this.indexArray, t2), this.dynamicLayoutVertexBuffer = e2.createVertexBuffer(this.dynamicLayoutVertexArray, nc.members, true), this.opacityVertexBuffer = e2.createVertexBuffer(this.opacityVertexArray, th, true), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(e2));
	      }
	      destroy() {
	        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
	      }
	    }
	    ls("SymbolBuffers", sh);
	    class oh {
	      constructor(e2, t2, r2) {
	        this.layoutVertexArray = new e2(), this.layoutAttributes = t2, this.indexArray = new r2(), this.segments = new ta(), this.collisionVertexArray = new Ko();
	      }
	      upload(e2) {
	        this.layoutVertexBuffer = e2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e2.createVertexBuffer(this.collisionVertexArray, ic.members, true);
	      }
	      destroy() {
	        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
	      }
	    }
	    ls("CollisionBuffers", oh);
	    class ah {
	      constructor(t2) {
	        this.collisionBoxArray = t2.collisionBoxArray, this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((e2) => e2.id), this.index = t2.index, this.pixelRatio = t2.pixelRatio, this.sourceLayerIndex = t2.sourceLayerIndex, this.hasDependencies = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [];
	        const r2 = this.layers[0]._unevaluatedLayout._values;
	        this.textSizeData = Qc(this.zoom, r2["text-size"]), this.iconSizeData = Qc(this.zoom, r2["icon-size"]);
	        const n2 = this.layers[0].layout, i2 = n2.get("symbol-sort-key"), s2 = n2.get("symbol-z-order");
	        this.canOverlap = "never" !== eh(n2, "text-overlap", "text-allow-overlap") || "never" !== eh(n2, "icon-overlap", "icon-allow-overlap") || n2.get("text-ignore-placement") || n2.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== s2 && !i2.isConstant(), this.sortFeaturesByY = ("viewport-y" === s2 || "auto" === s2 && !this.sortFeaturesByKey) && this.canOverlap, "point" === n2.get("symbol-placement") && (this.writingModes = n2.get("text-writing-mode").map((t3) => e.ay[t3])), this.stateDependentLayerIds = this.layers.filter((e2) => e2.isStateDependent()).map((e2) => e2.id), this.sourceID = t2.sourceID;
	      }
	      createArrays() {
	        this.text = new sh(new Da(this.layers, this.zoom, (e2) => /^text/.test(e2))), this.icon = new sh(new Da(this.layers, this.zoom, (e2) => /^icon/.test(e2))), this.glyphOffsetArray = new Po(), this.lineVertexArray = new Bo(), this.symbolInstances = new Do(), this.textAnchorOffsets = new Vo();
	      }
	      calculateGlyphDependencies(e2, t2, r2, n2, i2) {
	        for (const s2 of e2) if (t2[s2.codePointAt(0)] = true, (r2 || n2) && i2) {
	          const e3 = uc[s2];
	          e3 && (t2[e3.codePointAt(0)] = true);
	        }
	      }
	      populate(t2, r2, n2) {
	        const i2 = this.layers[0], s2 = i2.layout, o2 = s2.get("text-font"), a2 = s2.get("text-field"), l2 = s2.get("icon-image"), u2 = ("constant" !== a2.value.kind || a2.value.value instanceof Ft && !a2.value.value.isEmpty() || a2.value.value.toString().length > 0) && ("constant" !== o2.value.kind || o2.value.value.length > 0), c2 = "constant" !== l2.value.kind || !!l2.value.value || Object.keys(l2.parameters).length > 0, h2 = s2.get("symbol-sort-key");
	        if (this.features = [], !u2 && !c2) return;
	        const p2 = r2.iconDependencies, f2 = r2.glyphDependencies, d2 = r2.availableImages, y2 = new ks(this.zoom);
	        for (const { feature: r3, id: a3, index: l3, sourceLayerIndex: m2 } of t2) {
	          const t3 = i2._featureFilter.needGeometry, g2 = La(r3, t3);
	          if (!i2._featureFilter.filter(y2, g2, n2)) continue;
	          let x2, v2;
	          if (t3 || (g2.geometry = Ca(r3)), u2) {
	            const e2 = i2.getValueAndResolveTokens("text-field", g2, n2, d2), t4 = Ft.factory(e2), r4 = this.hasRTLText = this.hasRTLText || ih(t4);
	            (!r4 || "unavailable" === Ms.getRTLTextPluginStatus() || r4 && Ms.isParsed()) && (x2 = ac(t4, i2, g2));
	          }
	          if (c2) {
	            const e2 = i2.getValueAndResolveTokens("icon-image", g2, n2, d2);
	            v2 = e2 instanceof Lt ? e2 : Lt.fromString(e2);
	          }
	          if (!x2 && !v2) continue;
	          const b2 = this.sortFeaturesByKey ? h2.evaluate(g2, {}, n2) : void 0;
	          if (this.features.push({ id: a3, text: x2, icon: v2, index: l3, sourceLayerIndex: m2, geometry: g2.geometry, properties: r3.properties, type: Au.types[r3.type], sortKey: b2 }), v2 && (p2[v2.name] = true), x2) {
	            const t4 = o2.evaluate(g2, {}, n2).join(","), r4 = "viewport" !== s2.get("text-rotation-alignment") && "point" !== s2.get("symbol-placement");
	            this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(e.ay.vertical) >= 0;
	            for (const e2 of x2.sections) if (e2.image) p2[e2.image.name] = true;
	            else {
	              const n3 = xs(x2.toString()), i3 = e2.fontStack || t4, s3 = f2[i3] = f2[i3] || {};
	              this.calculateGlyphDependencies(e2.text, s3, r4, this.allowVerticalPlacement, n3);
	            }
	          }
	        }
	        "line" === s2.get("symbol-placement") && (this.features = function(e2) {
	          const t3 = {}, r3 = {}, n3 = [];
	          let i3 = 0;
	          function s3(t4) {
	            n3.push(e2[t4]), i3++;
	          }
	          function o3(e3, t4, i4) {
	            const s4 = r3[e3];
	            return delete r3[e3], r3[t4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
	          }
	          function a3(e3, r4, i4) {
	            const s4 = t3[r4];
	            return delete t3[r4], t3[e3] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
	          }
	          function l3(e3, t4, r4) {
	            const n4 = r4 ? t4[0][t4[0].length - 1] : t4[0][0];
	            return `${e3}:${n4.x}:${n4.y}`;
	          }
	          for (let u3 = 0; u3 < e2.length; u3++) {
	            const c3 = e2[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
	            if (!p3) {
	              s3(u3);
	              continue;
	            }
	            const f3 = l3(p3, h3), d3 = l3(p3, h3, true);
	            if (f3 in r3 && d3 in t3 && r3[f3] !== t3[d3]) {
	              const e3 = a3(f3, d3, h3), i4 = o3(f3, d3, n3[e3].geometry);
	              delete t3[f3], delete r3[d3], r3[l3(p3, n3[i4].geometry, true)] = i4, n3[e3].geometry = null;
	            } else f3 in r3 ? o3(f3, d3, h3) : d3 in t3 ? a3(f3, d3, h3) : (s3(u3), t3[f3] = i3 - 1, r3[d3] = i3 - 1);
	          }
	          return n3.filter((e3) => e3.geometry);
	        }(this.features)), this.sortFeaturesByKey && this.features.sort((e2, t3) => e2.sortKey - t3.sortKey);
	      }
	      update(e2, t2, r2) {
	        this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e2, t2, this.layers, { imagePositions: r2 }), this.icon.programConfigurations.updatePaintArrays(e2, t2, this.layers, { imagePositions: r2 }));
	      }
	      isEmpty() {
	        return 0 === this.symbolInstances.length && !this.hasRTLText;
	      }
	      uploadPending() {
	        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
	      }
	      upload(e2) {
	        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e2), this.iconCollisionBox.upload(e2)), this.text.upload(e2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
	      }
	      destroyDebugData() {
	        this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
	      }
	      destroy() {
	        this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
	      }
	      addToLineVertexArray(e2, t2) {
	        const r2 = this.lineVertexArray.length;
	        if (void 0 !== e2.segment) {
	          let r3 = e2.dist(t2[e2.segment + 1]), n2 = e2.dist(t2[e2.segment]);
	          const i2 = {};
	          for (let n3 = e2.segment + 1; n3 < t2.length; n3++) i2[n3] = { x: t2[n3].x, y: t2[n3].y, tileUnitDistanceFromAnchor: r3 }, n3 < t2.length - 1 && (r3 += t2[n3 + 1].dist(t2[n3]));
	          for (let r4 = e2.segment || 0; r4 >= 0; r4--) i2[r4] = { x: t2[r4].x, y: t2[r4].y, tileUnitDistanceFromAnchor: n2 }, r4 > 0 && (n2 += t2[r4 - 1].dist(t2[r4]));
	          for (let e3 = 0; e3 < t2.length; e3++) {
	            const t3 = i2[e3];
	            this.lineVertexArray.emplaceBack(t3.x, t3.y, t3.tileUnitDistanceFromAnchor);
	          }
	        }
	        return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
	      }
	      addSymbols(t2, r2, n2, i2, s2, o2, a2, l2, u2, c2, h2, p2) {
	        const f2 = t2.indexArray, d2 = t2.layoutVertexArray, y2 = t2.segments.prepareSegment(4 * r2.length, d2, f2, this.canOverlap ? o2.sortKey : void 0), m2 = this.glyphOffsetArray.length, g2 = y2.vertexLength, x2 = this.allowVerticalPlacement && a2 === e.ay.vertical ? Math.PI / 2 : 0, v2 = o2.text && o2.text.sections;
	        for (let e2 = 0; e2 < r2.length; e2++) {
	          const { tl: i3, tr: s3, bl: a3, br: u3, tex: c3, pixelOffsetTL: h3, pixelOffsetBR: m3, minFontScaleX: g3, minFontScaleY: b2, glyphOffset: w2, isSDF: _2, sectionIndex: S2 } = r2[e2], A2 = y2.vertexLength, T2 = w2[1];
	          rh(d2, l2.x, l2.y, i3.x, T2 + i3.y, c3.x, c3.y, n2, _2, h3.x, h3.y, g3, b2), rh(d2, l2.x, l2.y, s3.x, T2 + s3.y, c3.x + c3.w, c3.y, n2, _2, m3.x, h3.y, g3, b2), rh(d2, l2.x, l2.y, a3.x, T2 + a3.y, c3.x, c3.y + c3.h, n2, _2, h3.x, m3.y, g3, b2), rh(d2, l2.x, l2.y, u3.x, T2 + u3.y, c3.x + c3.w, c3.y + c3.h, n2, _2, m3.x, m3.y, g3, b2), nh(t2.dynamicLayoutVertexArray, l2, x2), f2.emplaceBack(A2, A2 + 2, A2 + 1), f2.emplaceBack(A2 + 1, A2 + 2, A2 + 3), y2.vertexLength += 4, y2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w2[0]), e2 !== r2.length - 1 && S2 === r2[e2 + 1].sectionIndex || t2.programConfigurations.populatePaintArrays(d2.length, o2, o2.index, { imagePositions: {}, canonical: p2, formattedSection: v2 && v2[S2] });
	        }
	        t2.placedSymbolArray.emplaceBack(l2.x, l2.y, m2, this.glyphOffsetArray.length - m2, g2, u2, c2, l2.segment, n2 ? n2[0] : 0, n2 ? n2[1] : 0, i2[0], i2[1], a2, 0, false, 0, h2);
	      }
	      _addCollisionDebugVertex(e2, t2, r2, n2, i2, s2) {
	        return t2.emplaceBack(0, 0), e2.emplaceBack(r2.x, r2.y, n2, i2, Math.round(s2.x), Math.round(s2.y));
	      }
	      addCollisionDebugVertices(e2, t2, n2, i2, s2, o2, a2) {
	        const l2 = s2.segments.prepareSegment(4, s2.layoutVertexArray, s2.indexArray), u2 = l2.vertexLength, c2 = s2.layoutVertexArray, h2 = s2.collisionVertexArray, p2 = a2.anchorX, f2 = a2.anchorY;
	        this._addCollisionDebugVertex(c2, h2, o2, p2, f2, new r(e2, t2)), this._addCollisionDebugVertex(c2, h2, o2, p2, f2, new r(n2, t2)), this._addCollisionDebugVertex(c2, h2, o2, p2, f2, new r(n2, i2)), this._addCollisionDebugVertex(c2, h2, o2, p2, f2, new r(e2, i2)), l2.vertexLength += 4;
	        const d2 = s2.indexArray;
	        d2.emplaceBack(u2, u2 + 1), d2.emplaceBack(u2 + 1, u2 + 2), d2.emplaceBack(u2 + 2, u2 + 3), d2.emplaceBack(u2 + 3, u2), l2.primitiveLength += 4;
	      }
	      addDebugCollisionBoxes(e2, t2, r2, n2) {
	        for (let i2 = e2; i2 < t2; i2++) {
	          const e3 = this.collisionBoxArray.get(i2);
	          this.addCollisionDebugVertices(e3.x1, e3.y1, e3.x2, e3.y2, n2 ? this.textCollisionBox : this.iconCollisionBox, e3.anchorPoint, r2);
	        }
	      }
	      generateCollisionDebugBuffers() {
	        this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new oh(Ho, sc.members, Jo), this.iconCollisionBox = new oh(Ho, sc.members, Jo);
	        for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
	          const t2 = this.symbolInstances.get(e2);
	          this.addDebugCollisionBoxes(t2.textBoxStartIndex, t2.textBoxEndIndex, t2, true), this.addDebugCollisionBoxes(t2.verticalTextBoxStartIndex, t2.verticalTextBoxEndIndex, t2, true), this.addDebugCollisionBoxes(t2.iconBoxStartIndex, t2.iconBoxEndIndex, t2, false), this.addDebugCollisionBoxes(t2.verticalIconBoxStartIndex, t2.verticalIconBoxEndIndex, t2, false);
	        }
	      }
	      _deserializeCollisionBoxesForSymbol(e2, t2, r2, n2, i2, s2, o2, a2, l2) {
	        const u2 = {};
	        for (let n3 = t2; n3 < r2; n3++) {
	          const t3 = e2.get(n3);
	          u2.textBox = { x1: t3.x1, y1: t3.y1, x2: t3.x2, y2: t3.y2, anchorPointX: t3.anchorPointX, anchorPointY: t3.anchorPointY }, u2.textFeatureIndex = t3.featureIndex;
	          break;
	        }
	        for (let t3 = n2; t3 < i2; t3++) {
	          const r3 = e2.get(t3);
	          u2.verticalTextBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalTextFeatureIndex = r3.featureIndex;
	          break;
	        }
	        for (let t3 = s2; t3 < o2; t3++) {
	          const r3 = e2.get(t3);
	          u2.iconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.iconFeatureIndex = r3.featureIndex;
	          break;
	        }
	        for (let t3 = a2; t3 < l2; t3++) {
	          const r3 = e2.get(t3);
	          u2.verticalIconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalIconFeatureIndex = r3.featureIndex;
	          break;
	        }
	        return u2;
	      }
	      deserializeCollisionBoxes(e2) {
	        this.collisionArrays = [];
	        for (let t2 = 0; t2 < this.symbolInstances.length; t2++) {
	          const r2 = this.symbolInstances.get(t2);
	          this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
	        }
	      }
	      hasTextData() {
	        return this.text.segments.get().length > 0;
	      }
	      hasIconData() {
	        return this.icon.segments.get().length > 0;
	      }
	      hasDebugData() {
	        return this.textCollisionBox && this.iconCollisionBox;
	      }
	      hasTextCollisionBoxData() {
	        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
	      }
	      hasIconCollisionBoxData() {
	        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
	      }
	      addIndicesForPlacedSymbol(e2, t2) {
	        const r2 = e2.placedSymbolArray.get(t2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
	        for (let t3 = r2.vertexStartIndex; t3 < n2; t3 += 4) e2.indexArray.emplaceBack(t3, t3 + 2, t3 + 1), e2.indexArray.emplaceBack(t3 + 1, t3 + 2, t3 + 3);
	      }
	      getSortedSymbolIndexes(e2) {
	        if (this.sortedAngle === e2 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
	        const t2 = Math.sin(e2), r2 = Math.cos(e2), n2 = [], i2 = [], s2 = [];
	        for (let e3 = 0; e3 < this.symbolInstances.length; ++e3) {
	          s2.push(e3);
	          const o2 = this.symbolInstances.get(e3);
	          n2.push(0 | Math.round(t2 * o2.anchorX + r2 * o2.anchorY)), i2.push(o2.featureIndex);
	        }
	        return s2.sort((e3, t3) => n2[e3] - n2[t3] || i2[t3] - i2[e3]), s2;
	      }
	      addToSortKeyRanges(e2, t2) {
	        const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
	        r2 && r2.sortKey === t2 ? r2.symbolInstanceEnd = e2 + 1 : this.sortKeyRanges.push({ sortKey: t2, symbolInstanceStart: e2, symbolInstanceEnd: e2 + 1 });
	      }
	      sortFeatures(e2) {
	        if (this.sortFeaturesByY && this.sortedAngle !== e2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
	          this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e2), this.sortedAngle = e2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
	          for (const e3 of this.symbolInstanceIndexes) {
	            const t2 = this.symbolInstances.get(e3);
	            this.featureSortOrder.push(t2.featureIndex), [t2.rightJustifiedTextSymbolIndex, t2.centerJustifiedTextSymbolIndex, t2.leftJustifiedTextSymbolIndex].forEach((e4, t3, r2) => {
	              e4 >= 0 && r2.indexOf(e4) === t3 && this.addIndicesForPlacedSymbol(this.text, e4);
	            }), t2.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, t2.verticalPlacedTextSymbolIndex), t2.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, t2.placedIconSymbolIndex), t2.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, t2.verticalPlacedIconSymbolIndex);
	          }
	          this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
	        }
	      }
	    }
	    let lh, uh;
	    ls("SymbolBucket", ah, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), ah.MAX_GLYPHS = 65535, ah.addDynamicAttributes = nh;
	    var ch = { get paint() {
	      return uh = uh || new Gs({ "icon-opacity": new $s(xe.paint_symbol["icon-opacity"]), "icon-color": new $s(xe.paint_symbol["icon-color"]), "icon-halo-color": new $s(xe.paint_symbol["icon-halo-color"]), "icon-halo-width": new $s(xe.paint_symbol["icon-halo-width"]), "icon-halo-blur": new $s(xe.paint_symbol["icon-halo-blur"]), "icon-translate": new Ns(xe.paint_symbol["icon-translate"]), "icon-translate-anchor": new Ns(xe.paint_symbol["icon-translate-anchor"]), "text-opacity": new $s(xe.paint_symbol["text-opacity"]), "text-color": new $s(xe.paint_symbol["text-color"], { runtimeType: Oe, getOverride: (e2) => e2.textColor, hasOverride: (e2) => !!e2.textColor }), "text-halo-color": new $s(xe.paint_symbol["text-halo-color"]), "text-halo-width": new $s(xe.paint_symbol["text-halo-width"]), "text-halo-blur": new $s(xe.paint_symbol["text-halo-blur"]), "text-translate": new Ns(xe.paint_symbol["text-translate"]), "text-translate-anchor": new Ns(xe.paint_symbol["text-translate-anchor"]) });
	    }, get layout() {
	      return lh = lh || new Gs({ "symbol-placement": new Ns(xe.layout_symbol["symbol-placement"]), "symbol-spacing": new Ns(xe.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Ns(xe.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new $s(xe.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Ns(xe.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Ns(xe.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Ns(xe.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Ns(xe.layout_symbol["icon-ignore-placement"]), "icon-optional": new Ns(xe.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Ns(xe.layout_symbol["icon-rotation-alignment"]), "icon-size": new $s(xe.layout_symbol["icon-size"]), "icon-text-fit": new Ns(xe.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Ns(xe.layout_symbol["icon-text-fit-padding"]), "icon-image": new $s(xe.layout_symbol["icon-image"]), "icon-rotate": new $s(xe.layout_symbol["icon-rotate"]), "icon-padding": new $s(xe.layout_symbol["icon-padding"]), "icon-keep-upright": new Ns(xe.layout_symbol["icon-keep-upright"]), "icon-offset": new $s(xe.layout_symbol["icon-offset"]), "icon-anchor": new $s(xe.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Ns(xe.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Ns(xe.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Ns(xe.layout_symbol["text-rotation-alignment"]), "text-field": new $s(xe.layout_symbol["text-field"]), "text-font": new $s(xe.layout_symbol["text-font"]), "text-size": new $s(xe.layout_symbol["text-size"]), "text-max-width": new $s(xe.layout_symbol["text-max-width"]), "text-line-height": new Ns(xe.layout_symbol["text-line-height"]), "text-letter-spacing": new $s(xe.layout_symbol["text-letter-spacing"]), "text-justify": new $s(xe.layout_symbol["text-justify"]), "text-radial-offset": new $s(xe.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Ns(xe.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new $s(xe.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new $s(xe.layout_symbol["text-anchor"]), "text-max-angle": new Ns(xe.layout_symbol["text-max-angle"]), "text-writing-mode": new Ns(xe.layout_symbol["text-writing-mode"]), "text-rotate": new $s(xe.layout_symbol["text-rotate"]), "text-padding": new Ns(xe.layout_symbol["text-padding"]), "text-keep-upright": new Ns(xe.layout_symbol["text-keep-upright"]), "text-transform": new $s(xe.layout_symbol["text-transform"]), "text-offset": new $s(xe.layout_symbol["text-offset"]), "text-allow-overlap": new Ns(xe.layout_symbol["text-allow-overlap"]), "text-overlap": new Ns(xe.layout_symbol["text-overlap"]), "text-ignore-placement": new Ns(xe.layout_symbol["text-ignore-placement"]), "text-optional": new Ns(xe.layout_symbol["text-optional"]) });
	    } };
	    class hh {
	      constructor(e2) {
	        if (void 0 === e2.property.overrides) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
	        this.type = e2.property.overrides ? e2.property.overrides.runtimeType : ze, this.defaultValue = e2;
	      }
	      evaluate(e2) {
	        if (e2.formattedSection) {
	          const t2 = this.defaultValue.property.overrides;
	          if (t2 && t2.hasOverride(e2.formattedSection)) return t2.getOverride(e2.formattedSection);
	        }
	        return e2.feature && e2.featureState ? this.defaultValue.evaluate(e2.feature, e2.featureState) : this.defaultValue.property.specification.default;
	      }
	      eachChild(e2) {
	        this.defaultValue.isConstant() || e2(this.defaultValue.value._styleExpression.expression);
	      }
	      outputDefined() {
	        return false;
	      }
	      serialize() {
	        return null;
	      }
	    }
	    ls("FormatSectionOverride", hh, { omit: ["defaultValue"] });
	    class ph extends Xs {
	      constructor(e2, t2) {
	        super(e2, ch, t2);
	      }
	      recalculate(e2, t2) {
	        if (super.recalculate(e2, t2), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
	          const e3 = this.layout.get("text-writing-mode");
	          if (e3) {
	            const t3 = [];
	            for (const r2 of e3) t3.indexOf(r2) < 0 && t3.push(r2);
	            this.layout._values["text-writing-mode"] = t3;
	          } else this.layout._values["text-writing-mode"] = ["horizontal"];
	        }
	        this._setPaintOverrides();
	      }
	      getValueAndResolveTokens(e2, t2, r2, n2) {
	        const i2 = this.layout.get(e2).evaluate(t2, {}, r2, n2), s2 = this._unevaluatedLayout._values[e2];
	        return s2.isDataDriven() || ti(s2.value) || !i2 ? i2 : function(e3, t3) {
	          return t3.replace(/{([^{}]+)}/g, (t4, r3) => e3 && r3 in e3 ? String(e3[r3]) : "");
	        }(t2.properties, i2);
	      }
	      createBucket(e2) {
	        return new ah(e2);
	      }
	      queryRadius() {
	        return 0;
	      }
	      queryIntersectsFeature() {
	        throw new Error("Should take a different path in FeatureIndex");
	      }
	      _setPaintOverrides() {
	        for (const e2 of ch.paint.overridableProperties) {
	          if (!ph.hasPaintOverride(this.layout, e2)) continue;
	          const t2 = this.paint.get(e2), r2 = new hh(t2), n2 = new ei(r2, t2.property.specification);
	          let i2 = null;
	          i2 = "constant" === t2.value.kind || "source" === t2.value.kind ? new ni("source", n2) : new ii("composite", n2, t2.value.zoomStops), this.paint._values[e2] = new Os(t2.property, i2, t2.parameters);
	        }
	      }
	      _handleOverridablePaintPropertyUpdate(e2, t2, r2) {
	        return !(!this.layout || t2.isDataDriven() || r2.isDataDriven()) && ph.hasPaintOverride(this.layout, e2);
	      }
	      static hasPaintOverride(e2, t2) {
	        const r2 = e2.get("text-field"), n2 = ch.paint.properties[t2];
	        let i2 = false;
	        const s2 = (e3) => {
	          for (const t3 of e3) if (n2.overrides && n2.overrides.hasOverride(t3)) return void (i2 = true);
	        };
	        if ("constant" === r2.value.kind && r2.value.value instanceof Ft) s2(r2.value.value.sections);
	        else if ("source" === r2.value.kind || "composite" === r2.value.kind) {
	          const e3 = (t4) => {
	            i2 || (t4 instanceof qt && $t(t4.value) === qe ? s2(t4.value.sections) : t4 instanceof Er ? s2(t4.sections) : t4.eachChild(e3));
	          }, t3 = r2.value;
	          t3._styleExpression && e3(t3._styleExpression.expression);
	        }
	        return i2;
	      }
	    }
	    let fh;
	    var dh = { get paint() {
	      return fh = fh || new Gs({ "background-color": new Ns(xe.paint_background["background-color"]), "background-pattern": new qs(xe.paint_background["background-pattern"]), "background-opacity": new Ns(xe.paint_background["background-opacity"]) });
	    } };
	    class yh extends Xs {
	      constructor(e2, t2) {
	        super(e2, dh, t2);
	      }
	    }
	    class mh extends Xs {
	      constructor(e2, t2) {
	        super(e2, {}, t2), this.onAdd = (e3) => {
	          this.implementation.onAdd && this.implementation.onAdd(e3, e3.painter.context.gl);
	        }, this.onRemove = (e3) => {
	          this.implementation.onRemove && this.implementation.onRemove(e3, e3.painter.context.gl);
	        }, this.implementation = e2;
	      }
	      is3D() {
	        return "3d" === this.implementation.renderingMode;
	      }
	      hasOffscreenPass() {
	        return void 0 !== this.implementation.prerender;
	      }
	      recalculate() {
	      }
	      updateTransitions() {
	      }
	      hasTransition() {
	        return false;
	      }
	      serialize() {
	        throw new Error("Custom layers cannot be serialized");
	      }
	    }
	    class gh {
	      constructor(e2) {
	        this._methodToThrottle = e2, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
	          this._triggered = false, this._methodToThrottle();
	        });
	      }
	      trigger() {
	        this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
	          this._triggered = false, this._methodToThrottle();
	        }, 0));
	      }
	      remove() {
	        delete this._channel, this._methodToThrottle = () => {
	        };
	      }
	    }
	    const xh = { once: true }, vh = 63710088e-1;
	    class bh {
	      constructor(e2, t2) {
	        if (isNaN(e2) || isNaN(t2)) throw new Error(`Invalid LngLat object: (${e2}, ${t2})`);
	        if (this.lng = +e2, this.lat = +t2, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
	      }
	      wrap() {
	        return new bh(L(this.lng, -180, 180), this.lat);
	      }
	      toArray() {
	        return [this.lng, this.lat];
	      }
	      toString() {
	        return `LngLat(${this.lng}, ${this.lat})`;
	      }
	      distanceTo(e2) {
	        const t2 = Math.PI / 180, r2 = this.lat * t2, n2 = e2.lat * t2, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((e2.lng - this.lng) * t2);
	        return vh * Math.acos(Math.min(i2, 1));
	      }
	      static convert(e2) {
	        if (e2 instanceof bh) return e2;
	        if (Array.isArray(e2) && (2 === e2.length || 3 === e2.length)) return new bh(Number(e2[0]), Number(e2[1]));
	        if (!Array.isArray(e2) && "object" == typeof e2 && null !== e2) return new bh(Number("lng" in e2 ? e2.lng : e2.lon), Number(e2.lat));
	        throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
	      }
	    }
	    const wh = 2 * Math.PI * vh;
	    function _h(e2) {
	      return wh * Math.cos(e2 * Math.PI / 180);
	    }
	    function Sh(e2) {
	      return (180 + e2) / 360;
	    }
	    function Ah(e2) {
	      return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e2 * Math.PI / 360))) / 360;
	    }
	    function Th(e2, t2) {
	      return e2 / _h(t2);
	    }
	    function Ih(e2) {
	      return 360 * e2 - 180;
	    }
	    function Eh(e2) {
	      return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * e2) * Math.PI / 180)) - 90;
	    }
	    function Mh(e2, t2) {
	      return e2 * _h(Eh(t2));
	    }
	    class kh {
	      constructor(e2, t2, r2 = 0) {
	        this.x = +e2, this.y = +t2, this.z = +r2;
	      }
	      static fromLngLat(e2, t2 = 0) {
	        const r2 = bh.convert(e2);
	        return new kh(Sh(r2.lng), Ah(r2.lat), Th(t2, r2.lat));
	      }
	      toLngLat() {
	        return new bh(Ih(this.x), Eh(this.y));
	      }
	      toAltitude() {
	        return Mh(this.z, this.y);
	      }
	      meterInMercatorCoordinateUnits() {
	        return 1 / wh * (e2 = Eh(this.y), 1 / Math.cos(e2 * Math.PI / 180));
	        var e2;
	      }
	    }
	    function Fh(e2, t2, r2) {
	      var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
	      return [e2 * n2 - 2 * Math.PI * 6378137 / 2, t2 * n2 - 2 * Math.PI * 6378137 / 2];
	    }
	    class Dh {
	      constructor(e2, t2, r2) {
	        if (!function(e3, t3, r3) {
	          return !(e3 < 0 || e3 > 25 || r3 < 0 || r3 >= Math.pow(2, e3) || t3 < 0 || t3 >= Math.pow(2, e3));
	        }(e2, t2, r2)) throw new Error(`x=${t2}, y=${r2}, z=${e2} outside of bounds. 0<=x<${Math.pow(2, e2)}, 0<=y<${Math.pow(2, e2)} 0<=z<=25 `);
	        this.z = e2, this.x = t2, this.y = r2, this.key = zh(0, e2, e2, t2, r2);
	      }
	      equals(e2) {
	        return this.z === e2.z && this.x === e2.x && this.y === e2.y;
	      }
	      url(e2, t2, r2) {
	        const n2 = (s2 = this.y, o2 = this.z, a2 = Fh(256 * (i2 = this.x), 256 * (s2 = Math.pow(2, o2) - s2 - 1), o2), l2 = Fh(256 * (i2 + 1), 256 * (s2 + 1), o2), a2[0] + "," + a2[1] + "," + l2[0] + "," + l2[1]);
	        var i2, s2, o2, a2, l2;
	        const u2 = function(e3, t3, r3) {
	          let n3, i3 = "";
	          for (let s3 = e3; s3 > 0; s3--) n3 = 1 << s3 - 1, i3 += (t3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
	          return i3;
	        }(this.z, this.x, this.y);
	        return e2[(this.x + this.y) % e2.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, t2 > 1 ? "@2x" : "").replace(/{quadkey}/g, u2).replace(/{bbox-epsg-3857}/g, n2);
	      }
	      isChildOf(e2) {
	        const t2 = this.z - e2.z;
	        return t2 > 0 && e2.x === this.x >> t2 && e2.y === this.y >> t2;
	      }
	      getTilePoint(e2) {
	        const t2 = Math.pow(2, this.z);
	        return new r((e2.x * t2 - this.x) * k, (e2.y * t2 - this.y) * k);
	      }
	      toString() {
	        return `${this.z}/${this.x}/${this.y}`;
	      }
	    }
	    class Ph {
	      constructor(e2, t2) {
	        this.wrap = e2, this.canonical = t2, this.key = zh(e2, t2.z, t2.z, t2.x, t2.y);
	      }
	    }
	    class Bh {
	      constructor(e2, t2, r2, n2, i2) {
	        if (this.terrainRttPosMatrix32f = null, e2 < r2) throw new Error(`overscaledZ should be >= z; overscaledZ = ${e2}; z = ${r2}`);
	        this.overscaledZ = e2, this.wrap = t2, this.canonical = new Dh(r2, +n2, +i2), this.key = zh(t2, e2, r2, n2, i2);
	      }
	      clone() {
	        return new Bh(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
	      }
	      equals(e2) {
	        return this.overscaledZ === e2.overscaledZ && this.wrap === e2.wrap && this.canonical.equals(e2.canonical);
	      }
	      scaledTo(e2) {
	        if (e2 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e2}; overscaledZ = ${this.overscaledZ}`);
	        const t2 = this.canonical.z - e2;
	        return e2 > this.canonical.z ? new Bh(e2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Bh(e2, this.wrap, e2, this.canonical.x >> t2, this.canonical.y >> t2);
	      }
	      isOverscaled() {
	        return this.overscaledZ > this.canonical.z;
	      }
	      calculateScaledKey(e2, t2) {
	        if (e2 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e2}; overscaledZ = ${this.overscaledZ}`);
	        const r2 = this.canonical.z - e2;
	        return e2 > this.canonical.z ? zh(this.wrap * +t2, e2, this.canonical.z, this.canonical.x, this.canonical.y) : zh(this.wrap * +t2, e2, e2, this.canonical.x >> r2, this.canonical.y >> r2);
	      }
	      isChildOf(e2) {
	        if (e2.wrap !== this.wrap) return false;
	        if (this.overscaledZ - e2.overscaledZ <= 0) return false;
	        if (0 === e2.overscaledZ) return this.overscaledZ > 0;
	        const t2 = this.canonical.z - e2.canonical.z;
	        return !(t2 < 0) && e2.canonical.x === this.canonical.x >> t2 && e2.canonical.y === this.canonical.y >> t2;
	      }
	      children(e2) {
	        if (this.overscaledZ >= e2) return [new Bh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
	        const t2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
	        return [new Bh(t2, this.wrap, t2, r2, n2), new Bh(t2, this.wrap, t2, r2 + 1, n2), new Bh(t2, this.wrap, t2, r2, n2 + 1), new Bh(t2, this.wrap, t2, r2 + 1, n2 + 1)];
	      }
	      isLessThan(e2) {
	        return this.wrap < e2.wrap || !(this.wrap > e2.wrap) && (this.overscaledZ < e2.overscaledZ || !(this.overscaledZ > e2.overscaledZ) && (this.canonical.x < e2.canonical.x || !(this.canonical.x > e2.canonical.x) && this.canonical.y < e2.canonical.y));
	      }
	      wrapped() {
	        return new Bh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
	      }
	      unwrapTo(e2) {
	        return new Bh(this.overscaledZ, e2, this.canonical.z, this.canonical.x, this.canonical.y);
	      }
	      overscaleFactor() {
	        return Math.pow(2, this.overscaledZ - this.canonical.z);
	      }
	      toUnwrapped() {
	        return new Ph(this.wrap, this.canonical);
	      }
	      toString() {
	        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
	      }
	      getTilePoint(e2) {
	        return this.canonical.getTilePoint(new kh(e2.x - this.wrap, e2.y));
	      }
	    }
	    function zh(e2, t2, r2, n2, i2) {
	      (e2 *= 2) < 0 && (e2 = -1 * e2 - 1);
	      const s2 = 1 << r2;
	      return (s2 * s2 * e2 + s2 * i2 + n2).toString(36) + r2.toString(36) + t2.toString(36);
	    }
	    function Vh(e2, t2) {
	      return t2 ? e2.properties[t2] : e2.id;
	    }
	    function Ch(e2, t2) {
	      const r2 = { id: e2.id };
	      if (t2.removeAllProperties && (delete e2.removeProperties, delete e2.addOrUpdateProperties, delete t2.removeProperties), t2.removeProperties) for (const r3 of t2.removeProperties) {
	        const t3 = e2.addOrUpdateProperties.findIndex((e3) => e3.key === r3);
	        t3 > -1 && e2.addOrUpdateProperties.splice(t3, 1);
	      }
	      return (e2.removeAllProperties || t2.removeAllProperties) && (r2.removeAllProperties = true), (e2.removeProperties || t2.removeProperties) && (r2.removeProperties = [...e2.removeProperties || [], ...t2.removeProperties || []]), (e2.addOrUpdateProperties || t2.addOrUpdateProperties) && (r2.addOrUpdateProperties = [...e2.addOrUpdateProperties || [], ...t2.addOrUpdateProperties || []]), (e2.newGeometry || t2.newGeometry) && (r2.newGeometry = t2.newGeometry || e2.newGeometry), r2;
	    }
	    function Lh(e2) {
	      var t2, r2;
	      if (!e2) return {};
	      const n2 = {};
	      return n2.removeAll = e2.removeAll, n2.remove = new Set(e2.remove || []), n2.add = new Map(null === (t2 = e2.add) || void 0 === t2 ? void 0 : t2.map((e3) => [e3.id, e3])), n2.update = new Map(null === (r2 = e2.update) || void 0 === r2 ? void 0 : r2.map((e3) => [e3.id, e3])), n2;
	    }
	    ls("CanonicalTileID", Dh), ls("OverscaledTileID", Bh, { omit: ["terrainRttPosMatrix32f"] });
	    class Oh {
	      constructor(e2) {
	        this._stringToNumber = {}, this._numberToString = [];
	        for (let t2 = 0; t2 < e2.length; t2++) {
	          const r2 = e2[t2];
	          this._stringToNumber[r2] = t2, this._numberToString[t2] = r2;
	        }
	      }
	      encode(e2) {
	        return this._stringToNumber[e2];
	      }
	      decode(e2) {
	        if (e2 >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${e2} can't be >= this._numberToString.length ${this._numberToString.length}`);
	        return this._numberToString[e2];
	      }
	    }
	    class Rh {
	      constructor(e2, t2, r2, n2, i2) {
	        this.type = "Feature", this._vectorTileFeature = e2, e2._z = t2, e2._x = r2, e2._y = n2, this.properties = e2.properties, this.id = i2;
	      }
	      get geometry() {
	        return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
	      }
	      set geometry(e2) {
	        this._geometry = e2;
	      }
	      toJSON() {
	        const e2 = { geometry: this.geometry };
	        for (const t2 in this) "_geometry" !== t2 && "_vectorTileFeature" !== t2 && (e2[t2] = this[t2]);
	        return e2;
	      }
	    }
	    class Nh {
	      _name;
	      dataBuffer;
	      nullabilityBuffer;
	      _size;
	      constructor(e2, t2, r2) {
	        this._name = e2, this.dataBuffer = t2, "number" == typeof r2 ? this._size = r2 : (this.nullabilityBuffer = r2, this._size = r2.size());
	      }
	      getValue(e2) {
	        return this.nullabilityBuffer && !this.nullabilityBuffer.get(e2) ? null : this.getValueFromBuffer(e2);
	      }
	      has(e2) {
	        return this.nullabilityBuffer && this.nullabilityBuffer.get(e2) || !this.nullabilityBuffer;
	      }
	      get name() {
	        return this._name;
	      }
	      get size() {
	        return this._size;
	      }
	    }
	    class $h extends Nh {
	    }
	    class Uh extends $h {
	      getValueFromBuffer(e2) {
	        return this.dataBuffer[e2];
	      }
	    }
	    class qh extends $h {
	      getValueFromBuffer(e2) {
	        return this.dataBuffer[e2];
	      }
	    }
	    class jh extends Nh {
	      delta;
	      constructor(e2, t2, r2, n2) {
	        super(e2, t2, n2), this.delta = r2;
	      }
	    }
	    class Gh extends jh {
	      constructor(e2, t2, r2, n2) {
	        super(e2, Int32Array.of(t2), r2, n2);
	      }
	      getValueFromBuffer(e2) {
	        return this.dataBuffer[0] + e2 * this.delta;
	      }
	    }
	    class Xh extends Nh {
	      constructor(e2, t2, r2) {
	        super(e2, Int32Array.of(t2), r2);
	      }
	      getValueFromBuffer(e2) {
	        return this.dataBuffer[0];
	      }
	    }
	    class Yh {
	      _name;
	      _geometryVector;
	      _idVector;
	      _propertyVectors;
	      _extent;
	      propertyVectorsMap;
	      constructor(e2, t2, r2, n2, i2 = 4096) {
	        this._name = e2, this._geometryVector = t2, this._idVector = r2, this._propertyVectors = n2, this._extent = i2;
	      }
	      get name() {
	        return this._name;
	      }
	      get idVector() {
	        return this._idVector;
	      }
	      get geometryVector() {
	        return this._geometryVector;
	      }
	      get propertyVectors() {
	        return this._propertyVectors;
	      }
	      getPropertyVector(e2) {
	        return this.propertyVectorsMap || (this.propertyVectorsMap = new Map(this._propertyVectors.map((e3) => [e3.name, e3]))), this.propertyVectorsMap.get(e2);
	      }
	      *[Symbol.iterator]() {
	        const e2 = this.geometryVector[Symbol.iterator]();
	        let t2 = 0;
	        for (; t2 < this.numFeatures; ) {
	          let r2;
	          this.idVector && (r2 = this.containsMaxSaveIntegerValues(this.idVector) ? Number(this.idVector.getValue(t2)) : this.idVector.getValue(t2));
	          const n2 = e2?.next().value, i2 = {};
	          for (const e3 of this.propertyVectors) {
	            if (!e3) continue;
	            const r3 = e3.name, n3 = e3.getValue(t2);
	            null !== n3 && (i2[r3] = n3);
	          }
	          t2++, yield { id: r2, geometry: n2, properties: i2 };
	        }
	      }
	      get numFeatures() {
	        return this.geometryVector.numGeometries;
	      }
	      get extent() {
	        return this._extent;
	      }
	      getFeatures() {
	        const e2 = [], t2 = this.geometryVector.getGeometries();
	        for (let r2 = 0; r2 < this.numFeatures; r2++) {
	          let n2;
	          this.idVector && (n2 = this.containsMaxSaveIntegerValues(this.idVector) ? Number(this.idVector.getValue(r2)) : this.idVector.getValue(r2));
	          const i2 = { coordinates: t2[r2], type: this.geometryVector.geometryType(r2) }, s2 = {};
	          for (const e3 of this.propertyVectors) {
	            if (!e3) continue;
	            const t3 = e3.name, n3 = e3.getValue(r2);
	            null !== n3 && (s2[t3] = n3);
	          }
	          e2.push({ id: n2, geometry: i2, properties: s2 });
	        }
	        return e2;
	      }
	      containsMaxSaveIntegerValues(e2) {
	        return e2 instanceof Uh || e2 instanceof Xh && e2 instanceof Gh || e2 instanceof qh;
	      }
	    }
	    class Zh {
	      value;
	      constructor(e2) {
	        this.value = e2;
	      }
	      get() {
	        return this.value;
	      }
	      set(e2) {
	        this.value = e2;
	      }
	      increment() {
	        return this.value++;
	      }
	      add(e2) {
	        this.value += e2;
	      }
	    }
	    var Hh, Kh, Wh, Jh, Qh, ep, tp, rp, np, ip;
	    !function(e2) {
	      e2.PRESENT = "PRESENT", e2.DATA = "DATA", e2.OFFSET = "OFFSET", e2.LENGTH = "LENGTH";
	    }(Hh || (Hh = {}));
	    class sp {
	      _dictionaryType;
	      _offsetType;
	      _lengthType;
	      constructor(e2, t2, r2) {
	        this._dictionaryType = e2, this._offsetType = t2, this._lengthType = r2;
	      }
	      get dictionaryType() {
	        return this._dictionaryType;
	      }
	      get offsetType() {
	        return this._offsetType;
	      }
	      get lengthType() {
	        return this._lengthType;
	      }
	    }
	    function op(e2, t2, r2) {
	      const n2 = new Int32Array(r2);
	      let i2 = 0, s2 = t2.get();
	      for (let t3 = 0; t3 < n2.length; t3++) {
	        let t4 = e2[s2++], r3 = 127 & t4;
	        t4 < 128 || (t4 = e2[s2++], r3 |= (127 & t4) << 7, t4 < 128 || (t4 = e2[s2++], r3 |= (127 & t4) << 14, t4 < 128 || (t4 = e2[s2++], r3 |= (127 & t4) << 21, t4 < 128 || (t4 = e2[s2++], r3 |= (15 & t4) << 28)))), n2[i2++] = r3;
	      }
	      return t2.set(s2), n2;
	    }
	    function ap(e2, t2, r2) {
	      const n2 = new BigInt64Array(r2);
	      for (let r3 = 0; r3 < n2.length; r3++) n2[r3] = pp(e2, t2);
	      return n2;
	    }
	    function lp(e2, t2) {
	      let r2, n2;
	      return n2 = e2[t2.get()], t2.increment(), r2 = 127 & n2, n2 < 128 ? r2 : (n2 = e2[t2.get()], t2.increment(), r2 |= (127 & n2) << 7, n2 < 128 ? r2 : (n2 = e2[t2.get()], t2.increment(), r2 |= (127 & n2) << 14, n2 < 128 ? r2 : (n2 = e2[t2.get()], t2.increment(), r2 |= (127 & n2) << 21, n2 < 128 ? r2 : (n2 = e2[t2.get()], r2 |= (15 & n2) << 28, function(e3, t3, r3) {
	        let n3, i2;
	        if (i2 = t3[r3.get()], r3.increment(), n3 = (112 & i2) >> 4, i2 < 128) return 4294967296 * n3 + (e3 >>> 0);
	        if (i2 = t3[r3.get()], r3.increment(), n3 |= (127 & i2) << 3, i2 < 128) return 4294967296 * n3 + (e3 >>> 0);
	        if (i2 = t3[r3.get()], r3.increment(), n3 |= (127 & i2) << 10, i2 < 128) return 4294967296 * n3 + (e3 >>> 0);
	        if (i2 = t3[r3.get()], r3.increment(), n3 |= (127 & i2) << 17, i2 < 128) return 4294967296 * n3 + (e3 >>> 0);
	        if (i2 = t3[r3.get()], r3.increment(), n3 |= (127 & i2) << 24, i2 < 128) return 4294967296 * n3 + (e3 >>> 0);
	        if (i2 = t3[r3.get()], r3.increment(), n3 |= (1 & i2) << 31, i2 < 128) return 4294967296 * n3 + (e3 >>> 0);
	        throw new Error("Expected varint not more than 10 bytes");
	      }(r2, e2, t2)))));
	    }
	    function up(e2, t2, r2, n2) {
	      throw new Error("FastPFor is not implemented yet.");
	    }
	    function cp(e2) {
	      return e2 >>> 1 ^ -(1 & e2);
	    }
	    function hp(e2) {
	      return e2 >> 1n ^ -(1n & e2);
	    }
	    function pp(e2, t2) {
	      let r2 = 0n, n2 = 0, i2 = t2.get();
	      for (; i2 < e2.length; ) {
	        const t3 = e2[i2++];
	        if (r2 |= BigInt(127 & t3) << BigInt(n2), !(128 & t3)) break;
	        if (n2 += 7, n2 >= 64) throw new Error("Varint too long");
	      }
	      return t2.set(i2), r2;
	    }
	    function fp(e2, t2, r2) {
	      const n2 = new Int32Array(r2);
	      let i2 = 0;
	      for (let r3 = 0; r3 < t2; r3++) {
	        const s2 = e2[r3];
	        n2.fill(e2[r3 + t2], i2, i2 + s2), i2 += s2;
	      }
	      return n2;
	    }
	    function dp(e2, t2, r2) {
	      const n2 = new BigInt64Array(r2);
	      let i2 = 0;
	      for (let r3 = 0; r3 < t2; r3++) {
	        const s2 = Number(e2[r3]);
	        n2.fill(e2[r3 + t2], i2, i2 + s2), i2 += s2;
	      }
	      return n2;
	    }
	    function yp(e2, t2, r2) {
	      const n2 = new Float64Array(r2);
	      let i2 = 0;
	      for (let r3 = 0; r3 < t2; r3++) {
	        const s2 = e2[r3];
	        n2.fill(e2[r3 + t2], i2, i2 + s2), i2 += s2;
	      }
	      return n2;
	    }
	    function mp(e2) {
	      const t2 = e2.length / 4 * 4;
	      let r2 = 1;
	      if (t2 >= 4) for (let n2 = e2[0]; r2 < t2 - 4; r2 += 4) n2 = e2[r2] += n2, n2 = e2[r2 + 1] += n2, n2 = e2[r2 + 2] += n2, n2 = e2[r2 + 3] += n2;
	      for (; r2 != e2.length; ) e2[r2] += e2[r2 - 1], ++r2;
	    }
	    function gp(e2) {
	      e2[0] = e2[0] >>> 1 ^ -(1 & e2[0]), e2[1] = e2[1] >>> 1 ^ -(1 & e2[1]);
	      const t2 = e2.length / 4 * 4;
	      let r2 = 2;
	      if (t2 >= 4) for (; r2 < t2 - 4; r2 += 4) {
	        const t3 = e2[r2], n2 = e2[r2 + 1], i2 = e2[r2 + 2], s2 = e2[r2 + 3];
	        e2[r2] = (t3 >>> 1 ^ -(1 & t3)) + e2[r2 - 2], e2[r2 + 1] = (n2 >>> 1 ^ -(1 & n2)) + e2[r2 - 1], e2[r2 + 2] = (i2 >>> 1 ^ -(1 & i2)) + e2[r2], e2[r2 + 3] = (s2 >>> 1 ^ -(1 & s2)) + e2[r2 + 1];
	      }
	      for (; r2 != e2.length; r2 += 2) e2[r2] = (e2[r2] >>> 1 ^ -(1 & e2[r2])) + e2[r2 - 2], e2[r2 + 1] = (e2[r2 + 1] >>> 1 ^ -(1 & e2[r2 + 1])) + e2[r2 - 1];
	    }
	    function xp(e2, t2, r2) {
	      return Math.min(r2, Math.max(t2, e2));
	    }
	    !function(e2) {
	      e2.NONE = "NONE", e2.DELTA = "DELTA", e2.COMPONENTWISE_DELTA = "COMPONENTWISE_DELTA", e2.RLE = "RLE", e2.MORTON = "MORTON", e2.PDE = "PDE";
	    }(Kh || (Kh = {})), function(e2) {
	      e2.NONE = "NONE", e2.FAST_PFOR = "FAST_PFOR", e2.VARINT = "VARINT", e2.ALP = "ALP";
	    }(Wh || (Wh = {})), function(e2) {
	      e2.NONE = "NONE", e2.SINGLE = "SINGLE", e2.SHARED = "SHARED", e2.VERTEX = "VERTEX", e2.MORTON = "MORTON", e2.FSST = "FSST";
	    }(Jh || (Jh = {})), function(e2) {
	      e2.VERTEX = "VERTEX", e2.INDEX = "INDEX", e2.STRING = "STRING", e2.KEY = "KEY";
	    }(Qh || (Qh = {})), function(e2) {
	      e2.VAR_BINARY = "VAR_BINARY", e2.GEOMETRIES = "GEOMETRIES", e2.PARTS = "PARTS", e2.RINGS = "RINGS", e2.TRIANGLES = "TRIANGLES", e2.SYMBOL = "SYMBOL", e2.DICTIONARY = "DICTIONARY";
	    }(ep || (ep = {}));
	    class vp {
	      _physicalStreamType;
	      _logicalStreamType;
	      _logicalLevelTechnique1;
	      _logicalLevelTechnique2;
	      _physicalLevelTechnique;
	      _numValues;
	      _byteLength;
	      constructor(e2, t2, r2, n2, i2, s2, o2) {
	        this._physicalStreamType = e2, this._logicalStreamType = t2, this._logicalLevelTechnique1 = r2, this._logicalLevelTechnique2 = n2, this._physicalLevelTechnique = i2, this._numValues = s2, this._byteLength = o2;
	      }
	      static decode(e2, t2) {
	        const r2 = e2[t2.get()], n2 = Object.values(Hh)[r2 >> 4];
	        let i2 = null;
	        switch (n2) {
	          case Hh.DATA:
	            i2 = new sp(Object.values(Jh)[15 & r2]);
	            break;
	          case Hh.OFFSET:
	            i2 = new sp(null, Object.values(Qh)[15 & r2]);
	            break;
	          case Hh.LENGTH:
	            i2 = new sp(null, null, Object.values(ep)[15 & r2]);
	        }
	        t2.increment();
	        const s2 = e2[t2.get()], o2 = Object.values(Kh)[s2 >> 5], a2 = Object.values(Kh)[s2 >> 2 & 7], l2 = Object.values(Wh)[3 & s2];
	        t2.increment();
	        const u2 = op(e2, t2, 2);
	        return new vp(n2, i2, o2, a2, l2, u2[0], u2[1]);
	      }
	      get physicalStreamType() {
	        return this._physicalStreamType;
	      }
	      get logicalStreamType() {
	        return this._logicalStreamType;
	      }
	      get logicalLevelTechnique1() {
	        return this._logicalLevelTechnique1;
	      }
	      get logicalLevelTechnique2() {
	        return this._logicalLevelTechnique2;
	      }
	      get physicalLevelTechnique() {
	        return this._physicalLevelTechnique;
	      }
	      get numValues() {
	        return this._numValues;
	      }
	      get byteLength() {
	        return this._byteLength;
	      }
	      getDecompressedCount() {
	        return this._numValues;
	      }
	    }
	    class bp extends vp {
	      num_bits;
	      coordinate_shift;
	      constructor(e2, t2, r2, n2, i2, s2, o2, a2, l2) {
	        super(e2, t2, r2, n2, i2, s2, o2), this.num_bits = a2, this.coordinate_shift = l2;
	      }
	      static decode(e2, t2) {
	        const r2 = vp.decode(e2, t2), n2 = op(e2, t2, 2);
	        return new bp(r2.physicalStreamType, r2.logicalStreamType, r2.logicalLevelTechnique1, r2.logicalLevelTechnique2, r2.physicalLevelTechnique, r2.numValues, r2.byteLength, n2[0], n2[1]);
	      }
	      static decodePartial(e2, t2, r2) {
	        const n2 = op(t2, r2, 2);
	        return new bp(e2.physicalStreamType, e2.logicalStreamType, e2.logicalLevelTechnique1, e2.logicalLevelTechnique2, e2.physicalLevelTechnique, e2.numValues, e2.byteLength, n2[0], n2[1]);
	      }
	      numBits() {
	        return this.num_bits;
	      }
	      coordinateShift() {
	        return this.coordinate_shift;
	      }
	    }
	    class wp extends vp {
	      _runs;
	      _numRleValues;
	      constructor(e2, t2, r2, n2, i2, s2, o2, a2, l2) {
	        super(e2, t2, r2, n2, i2, s2, o2), this._runs = a2, this._numRleValues = l2;
	      }
	      static decode(e2, t2) {
	        const r2 = vp.decode(e2, t2), n2 = op(e2, t2, 2);
	        return new wp(r2.physicalStreamType, r2.logicalStreamType, r2.logicalLevelTechnique1, r2.logicalLevelTechnique2, r2.physicalLevelTechnique, r2.numValues, r2.byteLength, n2[0], n2[1]);
	      }
	      static decodePartial(e2, t2, r2) {
	        const n2 = op(t2, r2, 2);
	        return new wp(e2.physicalStreamType, e2.logicalStreamType, e2.logicalLevelTechnique1, e2.logicalLevelTechnique2, e2.physicalLevelTechnique, e2.numValues, e2.byteLength, n2[0], n2[1]);
	      }
	      get runs() {
	        return this._runs;
	      }
	      get numRleValues() {
	        return this._numRleValues;
	      }
	      getDecompressedCount() {
	        return this._numRleValues;
	      }
	    }
	    class _p {
	      static decode(e2, t2) {
	        const r2 = vp.decode(e2, t2);
	        return r2.logicalLevelTechnique1 === Kh.MORTON ? bp.decodePartial(r2, e2, t2) : Kh.RLE !== r2.logicalLevelTechnique1 && Kh.RLE !== r2.logicalLevelTechnique2 || Wh.NONE === r2.physicalLevelTechnique ? r2 : wp.decodePartial(r2, e2, t2);
	      }
	    }
	    !function(e2) {
	      e2[e2.FLAT = 0] = "FLAT", e2[e2.CONST = 1] = "CONST", e2[e2.SEQUENCE = 2] = "SEQUENCE", e2[e2.DICTIONARY = 3] = "DICTIONARY", e2[e2.FSST_DICTIONARY = 4] = "FSST_DICTIONARY";
	    }(tp || (tp = {}));
	    class Sp {
	      values;
	      _size;
	      constructor(e2, t2) {
	        this.values = e2, this._size = t2;
	      }
	      get(e2) {
	        const t2 = Math.floor(e2 / 8);
	        return 1 == (this.values[t2] >> e2 % 8 & 1);
	      }
	      set(e2, t2) {
	        const r2 = Math.floor(e2 / 8);
	        this.values[r2] = this.values[r2] | (t2 ? 1 : 0) << e2 % 8;
	      }
	      getInt(e2) {
	        const t2 = Math.floor(e2 / 8);
	        return this.values[t2] >> e2 % 8 & 1;
	      }
	      size() {
	        return this._size;
	      }
	      getBuffer() {
	        return this.values;
	      }
	    }
	    class Ap {
	      constructor() {
	      }
	      static decodeIntStream(e2, t2, r2, n2, i2) {
	        const s2 = Ap.decodePhysicalLevelTechnique(e2, t2, r2);
	        return this.decodeIntBuffer(s2, r2, n2, i2);
	      }
	      static decodeLengthStreamToOffsetBuffer(e2, t2, r2) {
	        const n2 = Ap.decodePhysicalLevelTechnique(e2, t2, r2);
	        return this.decodeLengthToOffsetBuffer(n2, r2);
	      }
	      static decodePhysicalLevelTechnique(e2, t2, r2) {
	        const n2 = r2.physicalLevelTechnique;
	        if (n2 === Wh.FAST_PFOR) return up();
	        if (n2 === Wh.VARINT) return op(e2, t2, r2.numValues);
	        if (n2 === Wh.NONE) {
	          const n3 = t2.get();
	          t2.add(r2.byteLength);
	          const i2 = e2.subarray(n3, t2.get());
	          return new Int32Array(i2);
	        }
	        throw new Error("Specified physicalLevelTechnique is not supported (yet).");
	      }
	      static decodeConstIntStream(e2, t2, r2, n2) {
	        const i2 = Ap.decodePhysicalLevelTechnique(e2, t2, r2);
	        if (1 === i2.length) {
	          const e3 = i2[0];
	          return n2 ? cp(e3) : e3;
	        }
	        return n2 ? function(e3) {
	          return cp(e3[1]);
	        }(i2) : function(e3) {
	          return e3[1];
	        }(i2);
	      }
	      static decodeSequenceIntStream(e2, t2, r2) {
	        return function(e3) {
	          if (2 == e3.length) {
	            const t3 = cp(e3[1]);
	            return [t3, t3];
	          }
	          return [cp(e3[2]), cp(e3[3])];
	        }(Ap.decodePhysicalLevelTechnique(e2, t2, r2));
	      }
	      static decodeSequenceLongStream(e2, t2, r2) {
	        return function(e3) {
	          if (2 == e3.length) {
	            const t3 = hp(e3[1]);
	            return [t3, t3];
	          }
	          return [hp(e3[2]), hp(e3[3])];
	        }(ap(e2, t2, r2.numValues));
	      }
	      static decodeLongStream(e2, t2, r2, n2) {
	        const i2 = ap(e2, t2, r2.numValues);
	        return this.decodeLongBuffer(i2, r2, n2);
	      }
	      static decodeLongFloat64Stream(e2, t2, r2, n2) {
	        const i2 = function(e3, t3, r3) {
	          const n3 = new Float64Array(t3);
	          for (let i3 = 0; i3 < t3; i3++) n3[i3] = lp(e3, r3);
	          return n3;
	        }(e2, r2.numValues, t2);
	        return this.decodeFloat64Buffer(i2, r2, n2);
	      }
	      static decodeConstLongStream(e2, t2, r2, n2) {
	        const i2 = ap(e2, t2, r2.numValues);
	        if (1 === i2.length) {
	          const e3 = i2[0];
	          return n2 ? hp(e3) : e3;
	        }
	        return n2 ? function(e3) {
	          return hp(e3[1]);
	        }(i2) : function(e3) {
	          return e3[1];
	        }(i2);
	      }
	      static decodeIntBuffer(e2, t2, r2, n2) {
	        switch (t2.logicalLevelTechnique1) {
	          case Kh.DELTA:
	            return t2.logicalLevelTechnique2 === Kh.RLE ? function(e3, t3, r3) {
	              const n3 = new Int32Array(r3);
	              let i2 = 0, s2 = 0;
	              for (let r4 = 0; r4 < t3; r4++) {
	                const o2 = e3[r4], a2 = cp(e3[r4 + t3]);
	                for (let e4 = 0; e4 < o2; e4++) s2 += a2, n3[i2++] = s2;
	              }
	              return n3;
	            }(e2, t2.runs, t2.numRleValues) : (function(e3) {
	              e3[0] = e3[0] >>> 1 ^ -(1 & e3[0]);
	              const t3 = e3.length / 4 * 4;
	              let r3 = 1;
	              if (t3 >= 4) for (; r3 < t3 - 4; r3 += 4) {
	                const t4 = e3[r3], n3 = e3[r3 + 1], i2 = e3[r3 + 2], s2 = e3[r3 + 3];
	                e3[r3] = (t4 >>> 1 ^ -(1 & t4)) + e3[r3 - 1], e3[r3 + 1] = (n3 >>> 1 ^ -(1 & n3)) + e3[r3], e3[r3 + 2] = (i2 >>> 1 ^ -(1 & i2)) + e3[r3 + 1], e3[r3 + 3] = (s2 >>> 1 ^ -(1 & s2)) + e3[r3 + 2];
	              }
	              for (; r3 != e3.length; ++r3) e3[r3] = (e3[r3] >>> 1 ^ -(1 & e3[r3])) + e3[r3 - 1];
	            }(e2), e2);
	          case Kh.RLE:
	            return function(e3, t3, r3) {
	              return r3 ? function(e4, t4, r4) {
	                const n3 = new Int32Array(r4);
	                let i2 = 0;
	                for (let r5 = 0; r5 < t4; r5++) {
	                  const s2 = e4[r5];
	                  let o2 = e4[r5 + t4];
	                  o2 = o2 >>> 1 ^ -(1 & o2), n3.fill(o2, i2, i2 + s2), i2 += s2;
	                }
	                return n3;
	              }(e3, t3.runs, t3.numRleValues) : fp(e3, t3.runs, t3.numRleValues);
	            }(e2, t2, r2);
	          case Kh.MORTON:
	            return mp(e2), e2;
	          case Kh.COMPONENTWISE_DELTA:
	            return n2 ? (function(e3, t3, r3, n3) {
	              let i2 = e3[0] >>> 1 ^ -(1 & e3[0]), s2 = e3[1] >>> 1 ^ -(1 & e3[1]);
	              e3[0] = xp(Math.round(i2 * t3), r3, n3), e3[1] = xp(Math.round(s2 * t3), r3, n3);
	              const o2 = e3.length / 16;
	              let a2 = 2;
	              if (o2 >= 4) for (; a2 < o2 - 4; a2 += 4) {
	                const o3 = e3[a2], l2 = e3[a2 + 1], u2 = (o3 >>> 1 ^ -(1 & o3)) + i2, c2 = (l2 >>> 1 ^ -(1 & l2)) + s2;
	                e3[a2] = xp(Math.round(u2 * t3), r3, n3), e3[a2 + 1] = xp(Math.round(c2 * t3), r3, n3);
	                const h2 = e3[a2 + 2], p2 = e3[a2 + 3];
	                i2 = (h2 >>> 1 ^ -(1 & h2)) + u2, s2 = (p2 >>> 1 ^ -(1 & p2)) + c2, e3[a2 + 2] = xp(Math.round(i2 * t3), r3, n3), e3[a2 + 3] = xp(Math.round(s2 * t3), r3, n3);
	              }
	              for (; a2 != e3.length; a2 += 2) i2 += e3[a2] >>> 1 ^ -(1 & e3[a2]), s2 += e3[a2 + 1] >>> 1 ^ -(1 & e3[a2 + 1]), e3[a2] = xp(Math.round(i2 * t3), r3, n3), e3[a2 + 1] = xp(Math.round(s2 * t3), r3, n3);
	            }(e2, n2.scale, n2.min, n2.max), e2) : (gp(e2), e2);
	          case Kh.NONE:
	            return r2 && function(e3) {
	              for (let t3 = 0; t3 < e3.length; t3++) {
	                const r3 = e3[t3];
	                e3[t3] = r3 >>> 1 ^ -(1 & r3);
	              }
	            }(e2), e2;
	          default:
	            throw new Error(`The specified Logical level technique is not supported: ${t2.logicalLevelTechnique1}`);
	        }
	      }
	      static decodeLongBuffer(e2, t2, r2) {
	        switch (t2.logicalLevelTechnique1) {
	          case Kh.DELTA:
	            return t2.logicalLevelTechnique2 === Kh.RLE ? function(e3, t3, r3) {
	              const n2 = new BigInt64Array(r3);
	              let i2 = 0, s2 = 0n;
	              for (let r4 = 0; r4 < t3; r4++) {
	                const o2 = Number(e3[r4]), a2 = hp(e3[r4 + t3]);
	                for (let e4 = 0; e4 < o2; e4++) s2 += a2, n2[i2++] = s2;
	              }
	              return n2;
	            }(e2, t2.runs, t2.numRleValues) : (function(e3) {
	              e3[0] = e3[0] >> 1n ^ -(1n & e3[0]);
	              const t3 = e3.length / 4 * 4;
	              let r3 = 1;
	              if (t3 >= 4) for (; r3 < t3 - 4; r3 += 4) {
	                const t4 = e3[r3], n2 = e3[r3 + 1], i2 = e3[r3 + 2], s2 = e3[r3 + 3];
	                e3[r3] = (t4 >> 1n ^ -(1n & t4)) + e3[r3 - 1], e3[r3 + 1] = (n2 >> 1n ^ -(1n & n2)) + e3[r3], e3[r3 + 2] = (i2 >> 1n ^ -(1n & i2)) + e3[r3 + 1], e3[r3 + 3] = (s2 >> 1n ^ -(1n & s2)) + e3[r3 + 2];
	              }
	              for (; r3 != e3.length; ++r3) e3[r3] = (e3[r3] >> 1n ^ -(1n & e3[r3])) + e3[r3 - 1];
	            }(e2), e2);
	          case Kh.RLE:
	            return function(e3, t3, r3) {
	              return r3 ? function(e4, t4, r4) {
	                const n2 = new BigInt64Array(r4);
	                let i2 = 0;
	                for (let r5 = 0; r5 < t4; r5++) {
	                  const s2 = Number(e4[r5]);
	                  let o2 = e4[r5 + t4];
	                  o2 = o2 >> 1n ^ -(1n & o2), n2.fill(o2, i2, i2 + s2), i2 += s2;
	                }
	                return n2;
	              }(e3, t3.runs, t3.numRleValues) : dp(e3, t3.runs, t3.numRleValues);
	            }(e2, t2, r2);
	          case Kh.NONE:
	            return r2 && function(e3) {
	              for (let t3 = 0; t3 < e3.length; t3++) {
	                const r3 = e3[t3];
	                e3[t3] = r3 >> 1n ^ -(1n & r3);
	              }
	            }(e2), e2;
	          default:
	            throw new Error(`The specified Logical level technique is not supported: ${t2.logicalLevelTechnique1}`);
	        }
	      }
	      static decodeFloat64Buffer(e2, t2, r2) {
	        switch (t2.logicalLevelTechnique1) {
	          case Kh.DELTA:
	            return t2.logicalLevelTechnique2 === Kh.RLE && (e2 = yp(e2, t2.runs, t2.numRleValues)), function(e3) {
	              e3[0] = e3[0] % 2 == 1 ? (e3[0] + 1) / -2 : e3[0] / 2;
	              const t3 = e3.length / 4 * 4;
	              let r3 = 1;
	              if (t3 >= 4) for (; r3 < t3 - 4; r3 += 4) {
	                const t4 = e3[r3], n2 = e3[r3 + 1], i2 = e3[r3 + 2], s2 = e3[r3 + 3];
	                e3[r3] = (t4 % 2 == 1 ? (t4 + 1) / -2 : t4 / 2) + e3[r3 - 1], e3[r3 + 1] = (n2 % 2 == 1 ? (n2 + 1) / -2 : n2 / 2) + e3[r3], e3[r3 + 2] = (i2 % 2 == 1 ? (i2 + 1) / -2 : i2 / 2) + e3[r3 + 1], e3[r3 + 3] = (s2 % 2 == 1 ? (s2 + 1) / -2 : s2 / 2) + e3[r3 + 2];
	              }
	              for (; r3 != e3.length; ++r3) e3[r3] = (e3[r3] % 2 == 1 ? (e3[r3] + 1) / -2 : e3[r3] / 2) + e3[r3 - 1];
	            }(e2), e2;
	          case Kh.RLE:
	            return function(e3, t3, r3) {
	              return r3 ? function(e4, t4, r4) {
	                const n2 = new Float64Array(r4);
	                let i2 = 0;
	                for (let r5 = 0; r5 < t4; r5++) {
	                  const s2 = e4[r5];
	                  let o2 = e4[r5 + t4];
	                  o2 = o2 % 2 == 1 ? (o2 + 1) / -2 : o2 / 2, n2.fill(o2, i2, i2 + s2), i2 += s2;
	                }
	                return n2;
	              }(e3, t3.runs, t3.numRleValues) : yp(e3, t3.runs, t3.numRleValues);
	            }(e2, t2, r2);
	          case Kh.NONE:
	            return r2 && function(e3) {
	              for (let t3 = 0; t3 < e3.length; t3++) {
	                const r3 = e3[t3];
	                e3[t3] = r3 % 2 == 1 ? (r3 + 1) / -2 : r3 / 2;
	              }
	            }(e2), e2;
	          default:
	            throw new Error(`The specified Logical level technique is not supported: ${t2.logicalLevelTechnique1}`);
	        }
	      }
	      static decodeLengthToOffsetBuffer(e2, t2) {
	        if (t2.logicalLevelTechnique1 === Kh.DELTA && t2.logicalLevelTechnique2 === Kh.NONE) return function(e3) {
	          const t3 = new Int32Array(e3.length + 1);
	          t3[0] = 0, t3[1] = cp(e3[0]);
	          let r2 = t3[1], n2 = 2;
	          for (; n2 != t3.length; ++n2) {
	            const i2 = e3[n2 - 1];
	            r2 += i2 >>> 1 ^ -(1 & i2), t3[n2] = t3[n2 - 1] + r2;
	          }
	          return t3;
	        }(e2);
	        if (t2.logicalLevelTechnique1 === Kh.RLE && t2.logicalLevelTechnique2 === Kh.NONE) return function(e3, t3, r2) {
	          const n2 = new Int32Array(r2 + 1);
	          n2[0] = 0;
	          let i2 = 1, s2 = n2[0];
	          for (let r3 = 0; r3 < t3; r3++) {
	            const o2 = e3[r3], a2 = e3[r3 + t3];
	            for (let e4 = i2; e4 < i2 + o2; e4++) n2[e4] = a2 + s2, s2 = n2[e4];
	            i2 += o2;
	          }
	          return n2;
	        }(e2, t2.runs, t2.numRleValues);
	        if (t2.logicalLevelTechnique1 === Kh.NONE && t2.logicalLevelTechnique2 === Kh.NONE) {
	          !function(e3) {
	            let t3 = 0;
	            for (let r3 = 0; r3 < e3.length; r3++) e3[r3] += t3, t3 = e3[r3];
	          }(e2);
	          const r2 = new Int32Array(t2.numValues + 1);
	          return r2[0] = 0, r2.set(e2, 1), r2;
	        }
	        if (t2.logicalLevelTechnique1 === Kh.DELTA && t2.logicalLevelTechnique2 === Kh.RLE) {
	          const r2 = function(e3, t3, r3) {
	            const n2 = new Int32Array(r3 + 1);
	            n2[0] = 0;
	            let i2 = 1, s2 = n2[0];
	            for (let r4 = 0; r4 < t3; r4++) {
	              const o2 = e3[r4];
	              let a2 = e3[r4 + t3];
	              a2 = a2 >>> 1 ^ -(1 & a2);
	              for (let e4 = i2; e4 < i2 + o2; e4++) n2[e4] = a2 + s2, s2 = n2[e4];
	              i2 += o2;
	            }
	            return n2;
	          }(e2, t2.runs, t2.numRleValues);
	          return mp(r2), r2;
	        }
	        throw new Error("Only delta encoding is supported for transforming length to offset streams yet.");
	      }
	      static decodeNullableIntStream(e2, t2, r2, n2, i2) {
	        const s2 = r2.physicalLevelTechnique === Wh.FAST_PFOR ? up() : op(e2, t2, r2.numValues);
	        return this.decodeNullableIntBuffer(s2, r2, n2, i2);
	      }
	      static decodeNullableLongStream(e2, t2, r2, n2, i2) {
	        const s2 = ap(e2, t2, r2.numValues);
	        return this.decodeNullableLongBuffer(s2, r2, n2, i2);
	      }
	      static decodeNullableIntBuffer(e2, t2, r2, n2) {
	        switch (t2.logicalLevelTechnique1) {
	          case Kh.DELTA:
	            return t2.logicalLevelTechnique2 === Kh.RLE && (e2 = fp(e2, t2.runs, t2.numRleValues)), function(e3, t3) {
	              const r3 = new Int32Array(e3.size());
	              let n3 = 0;
	              e3.get(0) ? (r3[0] = e3.get(0) ? t3[0] >>> 1 ^ -(1 & t3[0]) : 0, n3 = 1) : r3[0] = 0;
	              let i2 = 1;
	              for (; i2 != r3.length; ++i2) r3[i2] = e3.get(i2) ? r3[i2 - 1] + (t3[n3] >>> 1 ^ -(1 & t3[n3++])) : r3[i2 - 1];
	              return r3;
	            }(n2, e2);
	          case Kh.RLE:
	            return function(e3, t3, r3, n3) {
	              const i2 = t3;
	              return r3 ? function(e4, t4, r4) {
	                const n4 = new Int32Array(e4.size());
	                let i3 = 0;
	                for (let s2 = 0; s2 < r4; s2++) {
	                  const o2 = t4[s2];
	                  let a2 = t4[s2 + r4];
	                  a2 = a2 >>> 1 ^ -(1 & a2);
	                  for (let t5 = i3; t5 < i3 + o2; t5++) e4.get(t5) ? n4[t5] = a2 : (n4[t5] = 0, i3++);
	                  i3 += o2;
	                }
	                return n4;
	              }(n3, e3, i2.runs) : function(e4, t4, r4) {
	                const n4 = new Int32Array(e4.size());
	                let i3 = 0;
	                for (let s2 = 0; s2 < r4; s2++) {
	                  const o2 = t4[s2], a2 = t4[s2 + r4];
	                  for (let t5 = i3; t5 < i3 + o2; t5++) e4.get(t5) ? n4[t5] = a2 : (n4[t5] = 0, i3++);
	                  i3 += o2;
	                }
	                return n4;
	              }(n3, e3, i2.runs);
	            }(e2, t2, r2, n2);
	          case Kh.MORTON:
	            return mp(e2), e2;
	          case Kh.COMPONENTWISE_DELTA:
	            return gp(e2), e2;
	          case Kh.NONE:
	            return e2 = r2 ? function(e3, t3) {
	              const r3 = new Int32Array(e3.size());
	              let n3 = 0, i2 = 0;
	              for (; i2 != r3.length; ++i2) if (e3.get(i2)) {
	                const e4 = t3[n3++];
	                r3[i2] = e4 >>> 1 ^ -(1 & e4);
	              } else r3[i2] = 0;
	              return r3;
	            }(n2, e2) : function(e3, t3) {
	              const r3 = new Int32Array(e3.size());
	              let n3 = 0, i2 = 0;
	              for (; i2 != r3.length; ++i2) r3[i2] = e3.get(i2) ? t3[n3++] : 0;
	              return r3;
	            }(n2, e2), e2;
	          default:
	            throw new Error("The specified Logical level technique is not supported");
	        }
	      }
	      static decodeNullableLongBuffer(e2, t2, r2, n2) {
	        switch (t2.logicalLevelTechnique1) {
	          case Kh.DELTA:
	            return t2.logicalLevelTechnique2 === Kh.RLE && (e2 = dp(e2, t2.runs, t2.numRleValues)), function(e3, t3) {
	              const r3 = new BigInt64Array(e3.size());
	              let n3 = 0;
	              e3.get(0) ? (r3[0] = e3.get(0) ? t3[0] >> 1n ^ -(1n & t3[0]) : 0n, n3 = 1) : r3[0] = 0n;
	              let i2 = 1;
	              for (; i2 != r3.length; ++i2) r3[i2] = e3.get(i2) ? r3[i2 - 1] + (t3[n3] >> 1n ^ -(1n & t3[n3++])) : r3[i2 - 1];
	              return r3;
	            }(n2, e2);
	          case Kh.RLE:
	            return function(e3, t3, r3, n3) {
	              const i2 = t3;
	              return r3 ? function(e4, t4, r4) {
	                const n4 = new BigInt64Array(e4.size());
	                let i3 = 0;
	                for (let s2 = 0; s2 < r4; s2++) {
	                  const o2 = Number(t4[s2]);
	                  let a2 = t4[s2 + r4];
	                  a2 = a2 >> 1n ^ -(1n & a2);
	                  for (let t5 = i3; t5 < i3 + o2; t5++) e4.get(t5) ? n4[t5] = a2 : (n4[t5] = 0n, i3++);
	                  i3 += o2;
	                }
	                return n4;
	              }(n3, e3, i2.runs) : function(e4, t4, r4) {
	                const n4 = new BigInt64Array(e4.size());
	                let i3 = 0;
	                for (let s2 = 0; s2 < r4; s2++) {
	                  const o2 = Number(t4[s2]), a2 = t4[s2 + r4];
	                  for (let t5 = i3; t5 < i3 + o2; t5++) e4.get(t5) ? n4[t5] = a2 : (n4[t5] = 0n, i3++);
	                  i3 += o2;
	                }
	                return n4;
	              }(n3, e3, i2.runs);
	            }(e2, t2, r2, n2);
	          case Kh.NONE:
	            return e2 = r2 ? function(e3, t3) {
	              const r3 = new BigInt64Array(e3.size());
	              let n3 = 0, i2 = 0;
	              for (; i2 != r3.length; ++i2) if (e3.get(i2)) {
	                const e4 = t3[n3++];
	                r3[i2] = e4 >> 1n ^ -(1n & e4);
	              } else r3[i2] = 0n;
	              return r3;
	            }(n2, e2) : function(e3, t3) {
	              const r3 = new BigInt64Array(e3.size());
	              let n3 = 0, i2 = 0;
	              for (; i2 != r3.length; ++i2) r3[i2] = e3.get(i2) ? t3[n3++] : 0n;
	              return r3;
	            }(n2, e2), e2;
	          default:
	            throw new Error("The specified Logical level technique is not supported");
	        }
	      }
	      static getVectorType(e2, t2, r2, n2) {
	        const i2 = e2.logicalLevelTechnique1;
	        if (i2 === Kh.RLE) return 1 === e2.runs ? tp.CONST : tp.FLAT;
	        const s2 = t2 instanceof Sp ? t2.size() : t2;
	        if (i2 === Kh.DELTA && e2.logicalLevelTechnique2 === Kh.RLE) {
	          const t3 = e2.runs, i3 = 2;
	          if (e2.numRleValues !== s2) return tp.FLAT;
	          if (1 === t3) return tp.SEQUENCE;
	          if (2 === t3) {
	            const t4 = n2.get();
	            let s3;
	            if (e2.physicalLevelTechnique === Wh.VARINT) s3 = op(r2, n2, 4);
	            else {
	              const e3 = n2.get();
	              s3 = new Int32Array(r2.buffer, r2.byteOffset + e3, 4);
	            }
	            if (n2.set(t4), s3[2] === i3 && s3[3] === i3) return tp.SEQUENCE;
	          }
	        }
	        return 1 === e2.numValues ? tp.CONST : tp.FLAT;
	      }
	    }
	    class Tp extends $h {
	      getValueFromBuffer(e2) {
	        return this.dataBuffer[e2];
	      }
	    }
	    class Ip extends jh {
	      constructor(e2, t2, r2, n2) {
	        super(e2, BigInt64Array.of(t2), r2, n2);
	      }
	      getValueFromBuffer(e2) {
	        return this.dataBuffer[0] + BigInt(e2) * this.delta;
	      }
	    }
	    class Ep {
	      _geometryOffsets;
	      _partOffsets;
	      _ringOffsets;
	      constructor(e2, t2, r2) {
	        this._geometryOffsets = e2, this._partOffsets = t2, this._ringOffsets = r2;
	      }
	      get geometryOffsets() {
	        return this._geometryOffsets;
	      }
	      get partOffsets() {
	        return this._partOffsets;
	      }
	      get ringOffsets() {
	        return this._ringOffsets;
	      }
	    }
	    class Mp {
	      tileExtent;
	      _numBits;
	      _coordinateShift;
	      minBound;
	      maxBound;
	      constructor(e2, t2) {
	        this._coordinateShift = e2 < 0 ? Math.abs(e2) : 0, this.tileExtent = t2 + this._coordinateShift, this._numBits = Math.ceil(Math.log2(this.tileExtent)), this.minBound = e2, this.maxBound = t2;
	      }
	      validateCoordinates(e2) {
	        if (e2.x < this.minBound || e2.y < this.minBound || e2.x > this.maxBound || e2.y > this.maxBound) throw new Error("The specified tile buffer size is currently not supported.");
	      }
	      numBits() {
	        return this._numBits;
	      }
	      coordinateShift() {
	        return this._coordinateShift;
	      }
	    }
	    class kp extends Mp {
	      encode(e2) {
	        this.validateCoordinates(e2);
	        const t2 = e2.x + this._coordinateShift, r2 = e2.y + this._coordinateShift;
	        let n2 = 0;
	        for (let e3 = 0; e3 < this._numBits; e3++) n2 |= (t2 & 1 << e3) << e3 | (r2 & 1 << e3) << e3 + 1;
	        return n2;
	      }
	      decode(e2) {
	        return { x: this.decodeMorton(e2) - this._coordinateShift, y: this.decodeMorton(e2 >> 1) - this._coordinateShift };
	      }
	      decodeMorton(e2) {
	        let t2 = 0;
	        for (let r2 = 0; r2 < this._numBits; r2++) t2 |= (e2 & 1 << 2 * r2) >> r2;
	        return t2;
	      }
	      static decode(e2, t2, r2) {
	        return { x: kp.decodeMorton(e2, t2) - r2, y: kp.decodeMorton(e2 >> 1, t2) - r2 };
	      }
	      static decodeMorton(e2, t2) {
	        let r2 = 0;
	        for (let n2 = 0; n2 < t2; n2++) r2 |= (e2 & 1 << 2 * n2) >> n2;
	        return r2;
	      }
	    }
	    !function(e2) {
	      e2[e2.POINT = 0] = "POINT", e2[e2.LINESTRING = 1] = "LINESTRING", e2[e2.POLYGON = 2] = "POLYGON", e2[e2.MULTIPOINT = 3] = "MULTIPOINT", e2[e2.MULTILINESTRING = 4] = "MULTILINESTRING", e2[e2.MULTIPOLYGON = 5] = "MULTIPOLYGON";
	    }(rp || (rp = {})), function(e2) {
	      e2[e2.POINT = 0] = "POINT", e2[e2.LINESTRING = 1] = "LINESTRING", e2[e2.POLYGON = 2] = "POLYGON";
	    }(np || (np = {})), function(e2) {
	      e2[e2.MORTON = 0] = "MORTON", e2[e2.VEC_2 = 1] = "VEC_2", e2[e2.VEC_3 = 2] = "VEC_3";
	    }(ip || (ip = {}));
	    class Fp {
	      createPoint(e2) {
	        return [[e2]];
	      }
	      createMultiPoint(e2) {
	        return e2.map((e3) => [e3]);
	      }
	      createLineString(e2) {
	        return [e2];
	      }
	      createMultiLineString(e2) {
	        return e2;
	      }
	      createPolygon(e2, t2) {
	        return [e2, ...t2];
	      }
	      createMultiPolygon(e2) {
	        return e2.flat();
	      }
	    }
	    function Dp(e2) {
	      const t2 = new Array(e2.numGeometries);
	      let n2 = 1, i2 = 1, s2 = 1, o2 = 0;
	      const a2 = new Fp();
	      let l2 = 0, u2 = 0;
	      const c2 = e2.mortonSettings, h2 = e2.topologyVector, p2 = h2.geometryOffsets, f2 = h2.partOffsets, d2 = h2.ringOffsets, y2 = e2.vertexOffsets, m2 = e2.containsPolygonGeometry(), g2 = e2.vertexBuffer;
	      for (let h3 = 0; h3 < e2.numGeometries; h3++) {
	        const x2 = e2.geometryType(h3);
	        if (x2 === rp.POINT) {
	          if (y2 && 0 !== y2.length) if (e2.vertexBufferType === ip.VEC_2) {
	            const e3 = 2 * y2[u2++], n3 = new r(g2[e3], g2[e3 + 1]);
	            t2[o2++] = a2.createPoint(n3);
	          } else {
	            const e3 = y2[u2++], n3 = kp.decode(g2[e3], c2.numBits, c2.coordinateShift), i3 = new r(n3.x, n3.y);
	            t2[o2++] = a2.createPoint(i3);
	          }
	          else {
	            const e3 = new r(g2[l2++], g2[l2++]);
	            t2[o2++] = a2.createPoint(e3);
	          }
	          p2 && s2++, f2 && n2++, d2 && i2++;
	        } else if (x2 === rp.MULTIPOINT) {
	          const e3 = p2[s2] - p2[s2 - 1];
	          s2++;
	          const n3 = new Array(e3);
	          if (y2 && 0 !== y2.length) {
	            for (let t3 = 0; t3 < e3; t3++) {
	              const e4 = 2 * y2[u2++];
	              n3[t3] = new r(g2[e4], g2[e4 + 1]);
	            }
	            t2[o2++] = a2.createMultiPoint(n3);
	          } else {
	            for (let t3 = 0; t3 < e3; t3++) {
	              const e4 = g2[l2++], i3 = g2[l2++];
	              n3[t3] = new r(e4, i3);
	            }
	            t2[o2++] = a2.createMultiPoint(n3);
	          }
	        } else if (x2 === rp.LINESTRING) {
	          let r2, h4 = 0;
	          m2 ? (h4 = d2[i2] - d2[i2 - 1], i2++) : h4 = f2[n2] - f2[n2 - 1], n2++, y2 && 0 !== y2.length ? (r2 = e2.vertexBufferType === ip.VEC_2 ? Cp(g2, y2, u2, h4, false) : Lp(g2, y2, u2, h4, false, c2), u2 += h4) : (r2 = Vp(g2, l2, h4, false), l2 += 2 * h4), t2[o2++] = a2.createLineString(r2), p2 && s2++;
	        } else if (x2 === rp.POLYGON) {
	          const r2 = f2[n2] - f2[n2 - 1];
	          n2++;
	          const h4 = new Array(r2 - 1);
	          let m3 = d2[i2] - d2[i2 - 1];
	          if (i2++, y2 && 0 !== y2.length) {
	            const r3 = e2.vertexBufferType === ip.VEC_2 ? Bp(g2, y2, u2, m3) : zp(g2, y2, u2, m3, 0, c2);
	            u2 += m3;
	            for (let t3 = 0; t3 < h4.length; t3++) m3 = d2[i2] - d2[i2 - 1], i2++, h4[t3] = e2.vertexBufferType === ip.VEC_2 ? Bp(g2, y2, u2, m3) : zp(g2, y2, u2, m3, 0, c2), u2 += m3;
	            t2[o2++] = a2.createPolygon(r3, h4);
	          } else {
	            const e3 = Pp(g2, l2, m3);
	            l2 += 2 * m3;
	            for (let e4 = 0; e4 < h4.length; e4++) m3 = d2[i2] - d2[i2 - 1], i2++, h4[e4] = Pp(g2, l2, m3), l2 += 2 * m3;
	            t2[o2++] = a2.createPolygon(e3, h4);
	          }
	          p2 && s2++;
	        } else if (x2 === rp.MULTILINESTRING) {
	          const r2 = p2[s2] - p2[s2 - 1];
	          s2++;
	          const h4 = new Array(r2);
	          if (y2 && 0 !== y2.length) {
	            for (let t3 = 0; t3 < r2; t3++) {
	              let r3 = 0;
	              m2 ? (r3 = d2[i2] - d2[i2 - 1], i2++) : r3 = f2[n2] - f2[n2 - 1], n2++;
	              const s3 = e2.vertexBufferType === ip.VEC_2 ? Cp(g2, y2, u2, r3, false) : Lp(g2, y2, u2, r3, false, c2);
	              h4[t3] = s3, u2 += r3;
	            }
	            t2[o2++] = a2.createMultiLineString(h4);
	          } else {
	            for (let e3 = 0; e3 < r2; e3++) {
	              let t3 = 0;
	              m2 ? (t3 = d2[i2] - d2[i2 - 1], i2++) : t3 = f2[n2] - f2[n2 - 1], n2++, h4[e3] = Vp(g2, l2, t3, false), l2 += 2 * t3;
	            }
	            t2[o2++] = a2.createMultiLineString(h4);
	          }
	        } else {
	          if (x2 !== rp.MULTIPOLYGON) throw new Error("The specified geometry type is currently not supported.");
	          {
	            const r2 = p2[s2] - p2[s2 - 1];
	            s2++;
	            const h4 = new Array(r2);
	            let m3 = 0;
	            if (y2 && 0 !== y2.length) {
	              for (let t3 = 0; t3 < r2; t3++) {
	                const r3 = f2[n2] - f2[n2 - 1];
	                n2++;
	                const s3 = new Array(r3 - 1);
	                m3 = d2[i2] - d2[i2 - 1], i2++;
	                const o3 = e2.vertexBufferType === ip.VEC_2 ? Bp(g2, y2, u2, m3) : zp(g2, y2, u2, m3, 0, c2);
	                u2 += m3;
	                for (let t4 = 0; t4 < s3.length; t4++) m3 = d2[i2] - d2[i2 - 1], i2++, s3[t4] = e2.vertexBufferType === ip.VEC_2 ? Bp(g2, y2, u2, m3) : zp(g2, y2, u2, m3, 0, c2), u2 += m3;
	                h4[t3] = a2.createPolygon(o3, s3);
	              }
	              t2[o2++] = a2.createMultiPolygon(h4);
	            } else {
	              for (let e3 = 0; e3 < r2; e3++) {
	                const t3 = f2[n2] - f2[n2 - 1];
	                n2++;
	                const r3 = new Array(t3 - 1);
	                m3 = d2[i2] - d2[i2 - 1], i2++;
	                const s3 = Pp(g2, l2, m3);
	                l2 += 2 * m3;
	                for (let e4 = 0; e4 < r3.length; e4++) {
	                  const t4 = d2[i2] - d2[i2 - 1];
	                  i2++, r3[e4] = Pp(g2, l2, t4), l2 += 2 * t4;
	                }
	                h4[e3] = a2.createPolygon(s3, r3);
	              }
	              t2[o2++] = a2.createMultiPolygon(h4);
	            }
	          }
	        }
	      }
	      return t2;
	    }
	    function Pp(e2, t2, r2) {
	      return Vp(e2, t2, r2, true);
	    }
	    function Bp(e2, t2, r2, n2) {
	      return Cp(e2, t2, r2, n2, true);
	    }
	    function zp(e2, t2, r2, n2, i2, s2) {
	      return Lp(e2, t2, r2, n2, true, s2);
	    }
	    function Vp(e2, t2, n2, i2) {
	      const s2 = new Array(i2 ? n2 + 1 : n2);
	      for (let i3 = 0; i3 < 2 * n2; i3 += 2) s2[i3 / 2] = new r(e2[t2 + i3], e2[t2 + i3 + 1]);
	      return i2 && (s2[s2.length - 1] = s2[0]), s2;
	    }
	    function Cp(e2, t2, n2, i2, s2) {
	      const o2 = new Array(s2 ? i2 + 1 : i2);
	      for (let s3 = 0; s3 < 2 * i2; s3 += 2) {
	        const i3 = 2 * t2[n2 + s3 / 2];
	        o2[s3 / 2] = new r(e2[i3], e2[i3 + 1]);
	      }
	      return s2 && (o2[o2.length - 1] = o2[0]), o2;
	    }
	    function Lp(e2, t2, n2, i2, s2, o2) {
	      const a2 = new Array(s2 ? i2 + 1 : i2);
	      for (let s3 = 0; s3 < i2; s3++) {
	        const i3 = kp.decode(e2[t2[n2 + s3]], o2.numBits, o2.coordinateShift);
	        a2[s3] = new r(i3.x, i3.y);
	      }
	      return s2 && (a2[a2.length - 1] = a2[0]), a2;
	    }
	    class Op {
	      _vertexBufferType;
	      _topologyVector;
	      _vertexOffsets;
	      _vertexBuffer;
	      _mortonSettings;
	      constructor(e2, t2, r2, n2, i2) {
	        this._vertexBufferType = e2, this._topologyVector = t2, this._vertexOffsets = r2, this._vertexBuffer = n2, this._mortonSettings = i2;
	      }
	      get vertexBufferType() {
	        return this._vertexBufferType;
	      }
	      get topologyVector() {
	        return this._topologyVector;
	      }
	      get vertexOffsets() {
	        return this._vertexOffsets;
	      }
	      get vertexBuffer() {
	        return this._vertexBuffer;
	      }
	      *[Symbol.iterator]() {
	        const e2 = Dp(this);
	        let t2 = 0;
	        for (; t2 < this.numGeometries; ) yield { coordinates: e2[t2], type: this.geometryType(t2) }, t2++;
	      }
	      getSimpleEncodedVertex(e2) {
	        const t2 = this.vertexOffsets ? 2 * this.vertexOffsets[e2] : 2 * e2;
	        return [this.vertexBuffer[t2], this.vertexBuffer[t2 + 1]];
	      }
	      getVertex(e2) {
	        if (this.vertexOffsets && this.mortonSettings) {
	          const t3 = kp.decode(this.vertexBuffer[this.vertexOffsets[e2]], this.mortonSettings.numBits, this.mortonSettings.coordinateShift);
	          return [t3.x, t3.y];
	        }
	        const t2 = this.vertexOffsets ? 2 * this.vertexOffsets[e2] : 2 * e2;
	        return [this.vertexBuffer[t2], this.vertexBuffer[t2 + 1]];
	      }
	      getGeometries() {
	        return Dp(this);
	      }
	      get mortonSettings() {
	        return this._mortonSettings;
	      }
	    }
	    class Rp extends Op {
	      _numGeometries;
	      _geometryType;
	      constructor(e2, t2, r2, n2, i2, s2, o2) {
	        super(r2, n2, i2, s2, o2), this._numGeometries = e2, this._geometryType = t2;
	      }
	      static createMortonEncoded(e2, t2, r2, n2, i2, s2) {
	        return new Rp(e2, t2, ip.MORTON, r2, n2, i2, s2);
	      }
	      static create(e2, t2, r2, n2, i2) {
	        return new Rp(e2, t2, ip.VEC_2, r2, n2, i2);
	      }
	      geometryType(e2) {
	        return this._geometryType;
	      }
	      get numGeometries() {
	        return this._numGeometries;
	      }
	      containsPolygonGeometry() {
	        return this._geometryType === rp.POLYGON || this._geometryType === rp.MULTIPOLYGON;
	      }
	      containsSingleGeometryType() {
	        return true;
	      }
	    }
	    class Np extends Op {
	      _geometryTypes;
	      constructor(e2, t2, r2, n2, i2, s2) {
	        super(e2, r2, n2, i2, s2), this._geometryTypes = t2;
	      }
	      static createMortonEncoded(e2, t2, r2, n2, i2) {
	        return new Np(ip.MORTON, e2, t2, r2, n2, i2);
	      }
	      static create(e2, t2, r2, n2) {
	        return new Np(ip.VEC_2, e2, t2, r2, n2);
	      }
	      geometryType(e2) {
	        return this._geometryTypes[e2];
	      }
	      get numGeometries() {
	        return this._geometryTypes.length;
	      }
	      containsPolygonGeometry() {
	        for (let e2 = 0; e2 < this.numGeometries; e2++) if (this.geometryType(e2) === rp.POLYGON || this.geometryType(e2) === rp.MULTIPOLYGON) return true;
	        return false;
	      }
	      containsSingleGeometryType() {
	        return false;
	      }
	    }
	    class $p {
	      _triangleOffsets;
	      _indexBuffer;
	      _vertexBuffer;
	      _topologyVector;
	      constructor(e2, t2, r2, n2) {
	        this._triangleOffsets = e2, this._indexBuffer = t2, this._vertexBuffer = r2, this._topologyVector = n2;
	      }
	      get triangleOffsets() {
	        return this._triangleOffsets;
	      }
	      get indexBuffer() {
	        return this._indexBuffer;
	      }
	      get vertexBuffer() {
	        return this._vertexBuffer;
	      }
	      get topologyVector() {
	        return this._topologyVector;
	      }
	      getGeometries() {
	        if (!this._topologyVector) throw new Error("Cannot convert GpuVector to coordinates without topology information");
	        const e2 = new Array(this.numGeometries), t2 = this._topologyVector, n2 = t2.partOffsets, i2 = t2.ringOffsets, s2 = t2.geometryOffsets;
	        let o2 = 0, a2 = 1, l2 = 1, u2 = 1;
	        for (let t3 = 0; t3 < this.numGeometries; t3++) switch (this.geometryType(t3)) {
	          case rp.POLYGON:
	            {
	              const c2 = n2[a2] - n2[a2 - 1];
	              a2++;
	              const h2 = [];
	              for (let e3 = 0; e3 < c2; e3++) {
	                const e4 = i2[l2] - i2[l2 - 1];
	                l2++;
	                const t4 = [];
	                for (let n3 = 0; n3 < e4; n3++) {
	                  const e5 = this._vertexBuffer[o2++], n4 = this._vertexBuffer[o2++];
	                  t4.push(new r(e5, n4));
	                }
	                t4.length > 0 && t4.push(t4[0]), h2.push(t4);
	              }
	              e2[t3] = h2, s2 && u2++;
	            }
	            break;
	          case rp.MULTIPOLYGON: {
	            const c2 = s2[u2] - s2[u2 - 1];
	            u2++;
	            const h2 = [];
	            for (let e3 = 0; e3 < c2; e3++) {
	              const e4 = n2[a2] - n2[a2 - 1];
	              a2++;
	              for (let t4 = 0; t4 < e4; t4++) {
	                const e5 = i2[l2] - i2[l2 - 1];
	                l2++;
	                const t5 = [];
	                for (let n3 = 0; n3 < e5; n3++) {
	                  const e6 = this._vertexBuffer[o2++], n4 = this._vertexBuffer[o2++];
	                  t5.push(new r(e6, n4));
	                }
	                t5.length > 0 && t5.push(t5[0]), h2.push(t5);
	              }
	            }
	            e2[t3] = h2;
	          }
	        }
	        return e2;
	      }
	      [Symbol.iterator]() {
	        return null;
	      }
	    }
	    class Up extends $p {
	      _numGeometries;
	      _geometryType;
	      constructor(e2, t2, r2, n2, i2, s2) {
	        super(r2, n2, i2, s2), this._numGeometries = e2, this._geometryType = t2;
	      }
	      static create(e2, t2, r2, n2, i2, s2) {
	        return new Up(e2, t2, r2, n2, i2, s2);
	      }
	      geometryType(e2) {
	        return this._geometryType;
	      }
	      get numGeometries() {
	        return this._numGeometries;
	      }
	      containsSingleGeometryType() {
	        return true;
	      }
	    }
	    class qp extends $p {
	      _geometryTypes;
	      constructor(e2, t2, r2, n2, i2) {
	        super(t2, r2, n2, i2), this._geometryTypes = e2;
	      }
	      static create(e2, t2, r2, n2, i2) {
	        return new qp(e2, t2, r2, n2, i2);
	      }
	      geometryType(e2) {
	        return this._geometryTypes[e2];
	      }
	      get numGeometries() {
	        return this._geometryTypes.length;
	      }
	      containsSingleGeometryType() {
	        return false;
	      }
	    }
	    function jp(e2, t2, r2, n2, i2) {
	      const s2 = _p.decode(e2, r2);
	      let o2 = null, a2 = null, l2 = null, u2 = null, c2 = null, h2 = null, p2 = null, f2 = null;
	      if (Ap.getVectorType(s2, n2, e2, r2) === tp.CONST) {
	        const d3 = Ap.decodeConstIntStream(e2, r2, s2, false);
	        for (let n3 = 0; n3 < t2 - 1; n3++) {
	          const t3 = _p.decode(e2, r2);
	          switch (t3.physicalStreamType) {
	            case Hh.LENGTH:
	              switch (t3.logicalStreamType.lengthType) {
	                case ep.GEOMETRIES:
	                  o2 = Ap.decodeLengthStreamToOffsetBuffer(e2, r2, t3);
	                  break;
	                case ep.PARTS:
	                  a2 = Ap.decodeLengthStreamToOffsetBuffer(e2, r2, t3);
	                  break;
	                case ep.RINGS:
	                  l2 = Ap.decodeLengthStreamToOffsetBuffer(e2, r2, t3);
	                  break;
	                case ep.TRIANGLES:
	                  p2 = Ap.decodeLengthStreamToOffsetBuffer(e2, r2, t3);
	              }
	              break;
	            case Hh.OFFSET:
	              switch (t3.logicalStreamType.offsetType) {
	                case Qh.VERTEX:
	                  u2 = Ap.decodeIntStream(e2, r2, t3, false);
	                  break;
	                case Qh.INDEX:
	                  f2 = Ap.decodeIntStream(e2, r2, t3, false);
	              }
	              break;
	            case Hh.DATA:
	              if (Jh.VERTEX === t3.logicalStreamType.dictionaryType) c2 = Ap.decodeIntStream(e2, r2, t3, true, i2);
	              else {
	                const n4 = t3;
	                h2 = { numBits: n4.numBits(), coordinateShift: n4.coordinateShift() }, c2 = Ap.decodeIntStream(e2, r2, t3, false, i2);
	              }
	          }
	        }
	        if (null !== f2) {
	          if (null != o2 || null != a2) {
	            const e3 = new Ep(o2, a2, l2);
	            return Up.create(n2, d3, p2, f2, c2, e3);
	          }
	          return Up.create(n2, d3, p2, f2, c2);
	        }
	        return null === h2 ? Rp.create(n2, d3, new Ep(o2, a2, l2), u2, c2) : Rp.createMortonEncoded(n2, d3, new Ep(o2, a2, l2), u2, c2, h2);
	      }
	      const d2 = Ap.decodeIntStream(e2, r2, s2, false);
	      for (let n3 = 0; n3 < t2 - 1; n3++) {
	        const t3 = _p.decode(e2, r2);
	        switch (t3.physicalStreamType) {
	          case Hh.LENGTH:
	            switch (t3.logicalStreamType.lengthType) {
	              case ep.GEOMETRIES:
	                o2 = Ap.decodeIntStream(e2, r2, t3, false);
	                break;
	              case ep.PARTS:
	                a2 = Ap.decodeIntStream(e2, r2, t3, false);
	                break;
	              case ep.RINGS:
	                l2 = Ap.decodeIntStream(e2, r2, t3, false);
	                break;
	              case ep.TRIANGLES:
	                p2 = Ap.decodeLengthStreamToOffsetBuffer(e2, r2, t3);
	            }
	            break;
	          case Hh.OFFSET:
	            switch (t3.logicalStreamType.offsetType) {
	              case Qh.VERTEX:
	                u2 = Ap.decodeIntStream(e2, r2, t3, false);
	                break;
	              case Qh.INDEX:
	                f2 = Ap.decodeIntStream(e2, r2, t3, false);
	            }
	            break;
	          case Hh.DATA:
	            if (Jh.VERTEX === t3.logicalStreamType.dictionaryType) c2 = Ap.decodeIntStream(e2, r2, t3, true, i2);
	            else {
	              const n4 = t3;
	              h2 = { numBits: n4.numBits(), coordinateShift: n4.coordinateShift() }, c2 = Ap.decodeIntStream(e2, r2, t3, false, i2);
	            }
	        }
	      }
	      return null !== f2 && null === a2 ? qp.create(d2, p2, f2, c2) : (null !== o2 ? (o2 = Gp(d2, o2, 2), null !== a2 && null !== l2 ? (a2 = Xp(d2, o2, a2, false), l2 = function(e3, t3, r3, n3) {
	        const i3 = new Int32Array(r3[r3.length - 1] + 1);
	        let s3 = 0;
	        i3[0] = s3;
	        let o3 = 1, a3 = 1, l3 = 0;
	        for (let u3 = 0; u3 < e3.length; u3++) {
	          const c3 = e3[u3], h3 = t3[u3 + 1] - t3[u3];
	          if (0 !== c3 && 3 !== c3) for (let e4 = 0; e4 < h3; e4++) {
	            const e5 = r3[o3] - r3[o3 - 1];
	            o3++;
	            for (let t4 = 0; t4 < e5; t4++) s3 = i3[a3++] = s3 + n3[l3++];
	          }
	          else for (let e4 = 0; e4 < h3; e4++) i3[a3++] = ++s3, o3++;
	        }
	        return i3;
	      }(d2, o2, a2, l2)) : null !== a2 && (a2 = function(e3, t3, r3) {
	        const n3 = new Int32Array(t3[t3.length - 1] + 1);
	        let i3 = 0;
	        n3[0] = i3;
	        let s3 = 1, o3 = 0;
	        for (let a3 = 0; a3 < e3.length; a3++) {
	          const l3 = e3[a3], u3 = t3[a3 + 1] - t3[a3];
	          if (4 === l3 || 1 === l3) for (let e4 = 0; e4 < u3; e4++) i3 = n3[s3++] = i3 + r3[o3++];
	          else for (let e4 = 0; e4 < u3; e4++) n3[s3++] = ++i3;
	        }
	        return n3;
	      }(d2, o2, a2))) : null !== a2 && null !== l2 ? (a2 = Gp(d2, a2, 1), l2 = Xp(d2, a2, l2, true)) : null !== a2 && (a2 = Gp(d2, a2, 0)), null !== f2 ? qp.create(d2, p2, f2, c2, new Ep(o2, a2, l2)) : null === h2 ? Np.create(d2, new Ep(o2, a2, l2), u2, c2) : Np.createMortonEncoded(d2, new Ep(o2, a2, l2), u2, c2, h2));
	    }
	    function Gp(e2, t2, r2) {
	      const n2 = new Int32Array(e2.length + 1);
	      let i2 = 0;
	      n2[0] = i2;
	      let s2 = 0;
	      for (let o2 = 0; o2 < e2.length; o2++) i2 = n2[o2 + 1] = i2 + (e2[o2] > r2 ? t2[s2++] : 1);
	      return n2;
	    }
	    function Xp(e2, t2, r2, n2) {
	      const i2 = new Int32Array(t2[t2.length - 1] + 1);
	      let s2 = 0;
	      i2[0] = s2;
	      let o2 = 1, a2 = 0;
	      for (let l2 = 0; l2 < e2.length; l2++) {
	        const u2 = e2[l2], c2 = t2[l2 + 1] - t2[l2];
	        if (5 === u2 || 2 === u2 || n2 && (4 === u2 || 1 === u2)) for (let e3 = 0; e3 < c2; e3++) s2 = i2[o2++] = s2 + r2[a2++];
	        else for (let e3 = 0; e3 < c2; e3++) i2[o2++] = ++s2;
	      }
	      return i2;
	    }
	    class Yp extends Nh {
	      dataVector;
	      constructor(e2, t2, r2) {
	        super(e2, t2.getBuffer(), r2), this.dataVector = t2;
	      }
	      getValueFromBuffer(e2) {
	        return this.dataVector.get(e2);
	      }
	    }
	    class Zp extends $h {
	      getValueFromBuffer(e2) {
	        return this.dataBuffer[e2];
	      }
	    }
	    class Hp extends Nh {
	      constructor(e2, t2, r2) {
	        super(e2, BigInt64Array.of(t2), r2);
	      }
	      getValueFromBuffer(e2) {
	        return this.dataBuffer[0];
	      }
	    }
	    function Kp(e2, t2, r2) {
	      for (let n2 = 0; n2 < e2; n2++) {
	        const e3 = _p.decode(t2, r2);
	        r2.add(e3.byteLength);
	      }
	    }
	    function Wp(e2, t2, r2) {
	      return Jp(e2, Math.ceil(t2 / 8), r2);
	    }
	    function Jp(e2, t2, r2) {
	      const n2 = new Uint8Array(t2);
	      let i2 = 0;
	      for (; i2 < t2; ) {
	        const t3 = e2[r2.increment()];
	        if (t3 <= 127) {
	          const s2 = t3 + 3, o2 = e2[r2.increment()], a2 = i2 + s2;
	          n2.fill(o2, i2, a2), i2 = a2;
	        } else {
	          const s2 = 256 - t3;
	          for (let t4 = 0; t4 < s2; t4++) n2[i2++] = e2[r2.increment()];
	        }
	      }
	      return n2;
	    }
	    const Qp = new TextDecoder();
	    function ef(e2, t2, r2) {
	      return r2 - t2 >= 12 ? Qp.decode(e2.subarray(t2, r2)) : function(e3, t3, r3) {
	        let n2 = "", i2 = t3;
	        for (; i2 < r3; ) {
	          const t4 = e3[i2];
	          let s2, o2, a2, l2 = null, u2 = t4 > 239 ? 4 : t4 > 223 ? 3 : t4 > 191 ? 2 : 1;
	          if (i2 + u2 > r3) break;
	          1 === u2 ? t4 < 128 && (l2 = t4) : 2 === u2 ? (s2 = e3[i2 + 1], 128 == (192 & s2) && (l2 = (31 & t4) << 6 | 63 & s2, l2 <= 127 && (l2 = null))) : 3 === u2 ? (s2 = e3[i2 + 1], o2 = e3[i2 + 2], 128 == (192 & s2) && 128 == (192 & o2) && (l2 = (15 & t4) << 12 | (63 & s2) << 6 | 63 & o2, (l2 <= 2047 || l2 >= 55296 && l2 <= 57343) && (l2 = null))) : 4 === u2 && (s2 = e3[i2 + 1], o2 = e3[i2 + 2], a2 = e3[i2 + 3], 128 == (192 & s2) && 128 == (192 & o2) && 128 == (192 & a2) && (l2 = (15 & t4) << 18 | (63 & s2) << 12 | (63 & o2) << 6 | 63 & a2, (l2 <= 65535 || l2 >= 1114112) && (l2 = null))), null === l2 ? (l2 = 65533, u2 = 1) : l2 > 65535 && (l2 -= 65536, n2 += String.fromCharCode(l2 >>> 10 & 1023 | 55296), l2 = 56320 | 1023 & l2), n2 += String.fromCharCode(l2), i2 += u2;
	        }
	        return n2;
	      }(e2, t2, r2);
	    }
	    class tf extends Nh {
	      offsetBuffer;
	      constructor(e2, t2, r2, n2) {
	        super(e2, r2, n2), this.offsetBuffer = t2;
	      }
	    }
	    class rf extends tf {
	      textEncoder;
	      constructor(e2, t2, r2, n2) {
	        super(e2, t2, r2, n2 ?? t2.length - 1), this.textEncoder = new TextEncoder();
	      }
	      getValueFromBuffer(e2) {
	        return ef(this.dataBuffer, this.offsetBuffer[e2], this.offsetBuffer[e2 + 1]);
	      }
	    }
	    class nf extends tf {
	      indexBuffer;
	      textEncoder;
	      constructor(e2, t2, r2, n2, i2) {
	        super(e2, r2, n2, i2 ?? t2.length), this.indexBuffer = t2, this.indexBuffer = t2, this.textEncoder = new TextEncoder();
	      }
	      getValueFromBuffer(e2) {
	        const t2 = this.indexBuffer[e2];
	        return ef(this.dataBuffer, this.offsetBuffer[t2], this.offsetBuffer[t2 + 1]);
	      }
	    }
	    class sf extends tf {
	      indexBuffer;
	      symbolOffsetBuffer;
	      symbolTableBuffer;
	      textEncoder;
	      symbolLengthBuffer;
	      lengthBuffer;
	      decodedDictionary;
	      constructor(e2, t2, r2, n2, i2, s2, o2) {
	        super(e2, r2, n2, o2), this.indexBuffer = t2, this.symbolOffsetBuffer = i2, this.symbolTableBuffer = s2, this.textEncoder = new TextEncoder();
	      }
	      getValueFromBuffer(e2) {
	        null == this.decodedDictionary && (null == this.symbolLengthBuffer && (this.symbolLengthBuffer = this.offsetToLengthBuffer(this.symbolOffsetBuffer), this.lengthBuffer = this.offsetToLengthBuffer(this.offsetBuffer)), this.decodedDictionary = function(e3, t3, r2) {
	          const n2 = [], i2 = new Array(t3.length).fill(0);
	          for (let e4 = 1; e4 < t3.length; e4++) i2[e4] = i2[e4 - 1] + t3[e4 - 1];
	          for (let s2 = 0; s2 < r2.length; s2++) if (255 === r2[s2]) n2.push(r2[++s2]);
	          else {
	            const o2 = t3[r2[s2]], a2 = i2[r2[s2]];
	            for (let t4 = 0; t4 < o2; t4++) n2.push(e3[a2 + t4]);
	          }
	          return new Uint8Array(n2);
	        }(this.symbolTableBuffer, this.symbolLengthBuffer, this.dataBuffer));
	        const t2 = this.indexBuffer[e2];
	        return ef(this.decodedDictionary, this.offsetBuffer[t2], this.offsetBuffer[t2 + 1]);
	      }
	      offsetToLengthBuffer(e2) {
	        const t2 = new Uint32Array(e2.length - 1);
	        let r2 = e2[0];
	        for (let n2 = 1; n2 < e2.length; n2++) {
	          const i2 = e2[n2];
	          t2[n2 - 1] = i2 - r2, r2 = i2;
	        }
	        return t2;
	      }
	    }
	    class of {
	      static ROOT_COLUMN_NAME = "default";
	      static NESTED_COLUMN_SEPARATOR = ":";
	      constructor() {
	      }
	      static decode(e2, t2, r2, n2, i2) {
	        let s2 = null, o2 = null, a2 = null, l2 = null, u2 = null, c2 = null, h2 = null, p2 = null;
	        for (let e3 = 0; e3 < n2; e3++) {
	          const e4 = _p.decode(t2, r2);
	          if (0 !== e4.byteLength) switch (e4.physicalStreamType) {
	            case Hh.PRESENT: {
	              const n3 = Wp(t2, e4.numValues, r2);
	              c2 = new Sp(n3, e4.numValues);
	              break;
	            }
	            case Hh.OFFSET:
	              o2 = null != i2 || null != c2 ? Ap.decodeNullableIntStream(t2, r2, e4, false, i2 ?? c2) : Ap.decodeIntStream(t2, r2, e4, false);
	              break;
	            case Hh.LENGTH: {
	              const n3 = Ap.decodeLengthStreamToOffsetBuffer(t2, r2, e4);
	              ep.DICTIONARY === e4.logicalStreamType.lengthType ? s2 = n3 : ep.SYMBOL === e4.logicalStreamType.lengthType ? l2 = n3 : h2 = n3;
	              break;
	            }
	            case Hh.DATA: {
	              const n3 = t2.subarray(r2.get(), r2.get() + e4.byteLength);
	              r2.add(e4.byteLength);
	              const i3 = e4.logicalStreamType.dictionaryType;
	              Jh.FSST === i3 ? u2 = n3 : Jh.SINGLE === i3 || Jh.SHARED === i3 ? a2 = n3 : Jh.NONE === i3 && (p2 = n3);
	              break;
	            }
	          }
	        }
	        return this.decodeFsstDictionaryVector(e2, u2, o2, s2, a2, l2, i2 ?? c2) ?? this.decodeDictionaryVector(e2, a2, o2, s2, i2 ?? c2) ?? this.decodePlainStringVector(e2, h2, p2, o2, i2 ?? c2);
	      }
	      static decodeFsstDictionaryVector(e2, t2, r2, n2, i2, s2, o2) {
	        return t2 ? new sf(e2, r2, n2, i2, s2, t2, o2) : null;
	      }
	      static decodeDictionaryVector(e2, t2, r2, n2, i2) {
	        return t2 ? i2 ? new nf(e2, r2, n2, t2, i2) : new nf(e2, r2, n2, t2) : null;
	      }
	      static decodePlainStringVector(e2, t2, r2, n2, i2) {
	        if (!t2 || !r2) return null;
	        if (n2) return i2 ? new nf(e2, n2, t2, r2, i2) : new nf(e2, n2, t2, r2);
	        if (i2 && i2.size() !== t2.length - 1) {
	          const n3 = new Int32Array(i2.size());
	          let s2 = 0;
	          for (let e3 = 0; e3 < i2.size(); e3++) n3[e3] = i2.get(e3) ? s2++ : 0;
	          return new nf(e2, n3, t2, r2, i2);
	        }
	        return i2 ? new rf(e2, t2, r2, i2) : new rf(e2, t2, r2);
	      }
	      static decodeSharedDictionary(e2, t2, r2, n2, i2) {
	        let s2 = null, o2 = null, a2 = null, l2 = null, u2 = false;
	        for (; !u2; ) {
	          const r3 = _p.decode(e2, t2);
	          switch (r3.physicalStreamType) {
	            case Hh.LENGTH:
	              ep.DICTIONARY === r3.logicalStreamType.lengthType ? s2 = Ap.decodeLengthStreamToOffsetBuffer(e2, t2, r3) : a2 = Ap.decodeLengthStreamToOffsetBuffer(e2, t2, r3);
	              break;
	            case Hh.DATA:
	              Jh.SINGLE === r3.logicalStreamType.dictionaryType || Jh.SHARED === r3.logicalStreamType.dictionaryType ? (o2 = e2.subarray(t2.get(), t2.get() + r3.byteLength), u2 = true) : l2 = e2.subarray(t2.get(), t2.get() + r3.byteLength), t2.add(r3.byteLength);
	          }
	        }
	        const c2 = r2.complexType.children, h2 = [];
	        let p2 = 0;
	        for (const u3 of c2) {
	          const c3 = op(e2, t2, 1)[0];
	          if (0 == c3) continue;
	          const f2 = `${r2.name}${u3.name === of.ROOT_COLUMN_NAME ? "" : of.NESTED_COLUMN_SEPARATOR + u3.name}`;
	          if (i2 && !i2.has(f2)) {
	            Kp(c3, e2, t2);
	            continue;
	          }
	          if (2 !== c3 || "scalarField" !== u3.type || 9 !== u3.scalarField.physicalType) throw new Error("Currently only optional string fields are implemented for a struct.");
	          const d2 = _p.decode(e2, t2), y2 = Wp(e2, d2.numValues, t2), m2 = _p.decode(e2, t2), g2 = (m2 instanceof wp ? m2.numRleValues : m2.numValues) !== n2 ? Ap.decodeNullableIntStream(e2, t2, m2, false, new Sp(y2, d2.numValues)) : Ap.decodeIntStream(e2, t2, m2, false);
	          h2[p2++] = l2 ? new sf(f2, g2, s2, o2, a2, l2, new Sp(y2, d2.numValues)) : new nf(f2, g2, s2, o2, new Sp(y2, d2.numValues));
	        }
	        return h2;
	      }
	    }
	    function af(e2, t2, r2, n2, i2, s2) {
	      return "scalarType" === r2.type ? function(e3, t3, r3, n3, i3, s3) {
	        let o2 = null, a2 = 0;
	        if (0 === e3) return null;
	        if (s3.nullable) {
	          const e4 = _p.decode(t3, r3);
	          a2 = e4.numValues;
	          const n4 = r3.get(), i4 = Wp(t3, a2, r3);
	          r3.set(n4 + e4.byteLength), o2 = new Sp(i4, e4.numValues);
	        }
	        const l2 = o2 ?? n3;
	        switch (i3.physicalType) {
	          case 4:
	          case 3:
	            return function(e4, t4, r4, n4, i4) {
	              const s4 = _p.decode(e4, t4), o3 = Ap.getVectorType(s4, i4, e4, t4), a3 = 3 === n4.physicalType;
	              if (o3 === tp.FLAT) {
	                const n5 = lf(i4) ? Ap.decodeNullableIntStream(e4, t4, s4, a3, i4) : Ap.decodeIntStream(e4, t4, s4, a3);
	                return new Uh(r4.name, n5, i4);
	              }
	              if (o3 === tp.SEQUENCE) {
	                const n5 = Ap.decodeSequenceIntStream(e4, t4, s4);
	                return new Gh(r4.name, n5[0], n5[1], s4.numRleValues);
	              }
	              {
	                const n5 = Ap.decodeConstIntStream(e4, t4, s4, a3);
	                return new Xh(r4.name, n5, i4);
	              }
	            }(t3, r3, s3, i3, l2);
	          case 9:
	            return of.decode(s3.name, t3, r3, s3.nullable ? e3 - 1 : e3, o2);
	          case 0:
	            return function(e4, t4, r4, n4, i4) {
	              const s4 = _p.decode(e4, t4), o3 = s4.numValues, a3 = t4.get(), l3 = lf(i4) ? function(e5, t5, r5, n5) {
	                const i5 = Jp(e5, Math.ceil(t5 / 8), r5), s5 = new Sp(i5, t5), o4 = n5.size(), a4 = new Sp(new Uint8Array(o4), o4);
	                let l4 = 0;
	                for (let e6 = 0; e6 < n5.size(); e6++) {
	                  const t6 = !!n5.get(e6) && s5.get(l4++);
	                  a4.set(e6, t6);
	                }
	                return a4.getBuffer();
	              }(e4, o3, t4, i4) : Wp(e4, o3, t4);
	              t4.set(a3 + s4.byteLength);
	              const u2 = new Sp(l3, o3);
	              return new Yp(r4.name, u2, i4);
	            }(t3, r3, s3, 0, l2);
	          case 6:
	          case 5:
	            return function(e4, t4, r4, n4, i4) {
	              const s4 = _p.decode(e4, t4), o3 = Ap.getVectorType(s4, n4, e4, t4), a3 = 5 === i4.physicalType;
	              if (o3 === tp.FLAT) {
	                const i5 = lf(n4) ? Ap.decodeNullableLongStream(e4, t4, s4, a3, n4) : Ap.decodeLongStream(e4, t4, s4, a3);
	                return new Tp(r4.name, i5, n4);
	              }
	              if (o3 === tp.SEQUENCE) {
	                const n5 = Ap.decodeSequenceLongStream(e4, t4, s4);
	                return new Ip(r4.name, n5[0], n5[1], s4.numRleValues);
	              }
	              {
	                const i5 = Ap.decodeConstLongStream(e4, t4, s4, a3);
	                return new Hp(r4.name, i5, n4);
	              }
	            }(t3, r3, s3, l2, i3);
	          case 7:
	            return function(e4, t4, r4, n4) {
	              const i4 = _p.decode(e4, t4), s4 = lf(n4) ? function(e5, t5, r5, n5) {
	                const i5 = t5.get(), s5 = i5 + n5 * Float32Array.BYTES_PER_ELEMENT, o3 = new Uint8Array(e5.subarray(i5, s5)).buffer, a3 = new Float32Array(o3);
	                t5.set(s5);
	                const l3 = r5.size(), u2 = new Float32Array(l3);
	                let c2 = 0;
	                for (let e6 = 0; e6 < l3; e6++) u2[e6] = r5.get(e6) ? a3[c2++] : 0;
	                return u2;
	              }(e4, t4, n4, i4.numValues) : function(e5, t5, r5) {
	                const n5 = t5.get(), i5 = n5 + r5 * Float32Array.BYTES_PER_ELEMENT, s5 = new Uint8Array(e5.subarray(n5, i5)).buffer, o3 = new Float32Array(s5);
	                return t5.set(i5), o3;
	              }(e4, t4, i4.numValues);
	              return new Zp(r4.name, s4, n4);
	            }(t3, r3, s3, l2);
	          case 8:
	            return function(e4, t4, r4, n4) {
	              const i4 = _p.decode(e4, t4), s4 = lf(n4) ? function(e5, t5, r5, n5) {
	                const i5 = t5.get(), s5 = i5 + n5 * Float64Array.BYTES_PER_ELEMENT, o3 = new Uint8Array(e5.subarray(i5, s5)).buffer, a3 = new Float64Array(o3);
	                t5.set(s5);
	                const l3 = r5.size(), u2 = new Float64Array(l3);
	                let c2 = 0;
	                for (let e6 = 0; e6 < l3; e6++) u2[e6] = r5.get(e6) ? a3[c2++] : 0;
	                return u2;
	              }(e4, t4, n4, i4.numValues) : function(e5, t5, r5) {
	                const n5 = t5.get(), i5 = n5 + r5 * Float64Array.BYTES_PER_ELEMENT, s5 = new Uint8Array(e5.subarray(n5, i5)).buffer, o3 = new Float64Array(s5);
	                return t5.set(i5), o3;
	              }(e4, t4, i4.numValues);
	              return new qh(r4.name, s4, n4);
	            }(t3, r3, s3, l2);
	          default:
	            throw new Error(`The specified data type for the field is currently not supported: ${i3}`);
	        }
	      }(n2, e2, t2, i2, r2.scalarType, r2) : 1 != n2 ? null : of.decodeSharedDictionary(e2, t2, r2, i2, s2);
	    }
	    function lf(e2) {
	      return e2 instanceof Sp;
	    }
	    class uf {
	      static decodeColumnType(e2) {
	        switch (e2) {
	          case 0:
	          case 1:
	          case 2:
	          case 3: {
	            const t2 = {};
	            t2.nullable = !!(1 & e2), t2.columnScope = 0;
	            const r2 = {};
	            return r2.physicalType = e2 > 1 ? 6 : 4, r2.type = "physicalType", t2.scalarType = r2, t2.type = "scalarType", t2;
	          }
	          case 4: {
	            const e3 = { nullable: false, columnScope: 0 }, t2 = { type: "physicalType", physicalType: 0 };
	            return e3.type = "complexType", e3.complexType = t2, e3;
	          }
	          case 30: {
	            const e3 = { nullable: false, columnScope: 0 }, t2 = { type: "physicalType", physicalType: 1 };
	            return e3.type = "complexType", e3.complexType = t2, e3;
	          }
	          default:
	            return this.mapScalarType(e2);
	        }
	      }
	      static columnTypeHasName(e2) {
	        return e2 >= 10;
	      }
	      static columnTypeHasChildren(e2) {
	        return 30 === e2;
	      }
	      static hasStreamCount(e2) {
	        if ("id" === e2.name) return false;
	        if ("scalarType" === e2.type) {
	          const t2 = e2.scalarType;
	          if ("physicalType" === t2.type) switch (t2.physicalType) {
	            case 0:
	            case 1:
	            case 2:
	            case 3:
	            case 4:
	            case 5:
	            case 6:
	            case 7:
	            case 8:
	            default:
	              return false;
	            case 9:
	              return true;
	          }
	          else if ("logicalType" === t2.type) return false;
	        } else if ("complexType" === e2.type) {
	          const t2 = e2.complexType;
	          if ("physicalType" === t2.type) switch (t2.physicalType) {
	            case 0:
	            case 1:
	              return true;
	            default:
	              return false;
	          }
	        }
	        return console.warn("Unexpected column type in hasStreamCount", e2), false;
	      }
	      static mapScalarType(e2) {
	        let t2 = null;
	        switch (e2) {
	          case 10:
	          case 11:
	            t2 = 0;
	            break;
	          case 12:
	          case 13:
	            t2 = 1;
	            break;
	          case 14:
	          case 15:
	            t2 = 2;
	            break;
	          case 16:
	          case 17:
	            t2 = 3;
	            break;
	          case 18:
	          case 19:
	            t2 = 4;
	            break;
	          case 20:
	          case 21:
	            t2 = 5;
	            break;
	          case 22:
	          case 23:
	            t2 = 6;
	            break;
	          case 24:
	          case 25:
	            t2 = 7;
	            break;
	          case 26:
	          case 27:
	            t2 = 8;
	            break;
	          case 28:
	          case 29:
	            t2 = 9;
	            break;
	          default:
	            return null;
	        }
	        const r2 = {};
	        r2.nullable = !!(1 & e2), r2.columnScope = 0;
	        const n2 = { type: "physicalType" };
	        return n2.physicalType = t2, r2.type = "scalarType", r2.scalarType = n2, r2;
	      }
	    }
	    const cf = new TextDecoder();
	    function hf(e2, t2) {
	      const r2 = op(e2, t2, 1)[0];
	      if (0 === r2) return "";
	      const n2 = t2.get(), i2 = e2.subarray(n2, n2 + r2);
	      return t2.add(r2), cf.decode(i2);
	    }
	    function pf(e2, t2) {
	      const r2 = op(e2, t2, 1)[0] >>> 0, n2 = !!(4 & r2), i2 = !!(2 & r2), s2 = op(e2, t2, 1)[0] >>> 0, o2 = {};
	      if (1 & r2 && (o2.nullable = true), i2) {
	        const i3 = {};
	        if (n2 ? (i3.type = "logicalType", i3.logicalType = s2) : (i3.type = "physicalType", i3.physicalType = s2), 8 & r2) {
	          const r3 = op(e2, t2, 1)[0] >>> 0;
	          i3.children = new Array(r3);
	          for (let n3 = 0; n3 < r3; n3++) i3.children[n3] = pf(e2, t2);
	        }
	        o2.type = "complexField", o2.complexField = i3;
	      } else {
	        const e3 = {};
	        n2 ? (e3.type = "logicalType", e3.logicalType = s2) : (e3.type = "physicalType", e3.physicalType = s2), o2.type = "scalarField", o2.scalarField = e3;
	      }
	      return o2;
	    }
	    function ff(e2, t2) {
	      const r2 = op(e2, t2, 1)[0] >>> 0, n2 = uf.decodeColumnType(r2);
	      if (!n2) throw new Error(`Unsupported column type code: ${r2}`);
	      if (uf.columnTypeHasName(r2) ? n2.name = hf(e2, t2) : r2 >= 0 && r2 <= 3 ? n2.name = "id" : 4 === r2 && (n2.name = "geometry"), uf.columnTypeHasChildren(r2)) {
	        const r3 = op(e2, t2, 1)[0] >>> 0, i2 = n2.complexType;
	        i2.children = new Array(r3);
	        for (let n3 = 0; n3 < r3; n3++) i2.children[n3] = pf(e2, t2);
	      }
	      return n2;
	    }
	    function df(e2, t2) {
	      const r2 = { featureTables: [] }, n2 = {};
	      n2.name = hf(e2, t2);
	      const i2 = op(e2, t2, 1)[0] >>> 0, s2 = op(e2, t2, 1)[0] >>> 0;
	      n2.columns = new Array(s2);
	      for (let r3 = 0; r3 < s2; r3++) n2.columns[r3] = ff(e2, t2);
	      return r2.featureTables.push(n2), [r2, i2];
	    }
	    function yf(e2, t2, r2, n2, i2, s2, o2 = false) {
	      const a2 = t2.scalarType.physicalType, l2 = Ap.getVectorType(i2, s2, e2, r2);
	      if (4 === a2) switch (l2) {
	        case tp.FLAT: {
	          const t3 = Ap.decodeIntStream(e2, r2, i2, false);
	          return new Uh(n2, t3, s2);
	        }
	        case tp.SEQUENCE: {
	          const t3 = Ap.decodeSequenceIntStream(e2, r2, i2);
	          return new Gh(n2, t3[0], t3[1], i2.numRleValues);
	        }
	        case tp.CONST: {
	          const t3 = Ap.decodeConstIntStream(e2, r2, i2, false);
	          return new Xh(n2, t3, s2);
	        }
	      }
	      else switch (l2) {
	        case tp.FLAT: {
	          if (o2) {
	            const t4 = Ap.decodeLongFloat64Stream(e2, r2, i2, false);
	            return new qh(n2, t4, s2);
	          }
	          const t3 = Ap.decodeLongStream(e2, r2, i2, false);
	          return new Tp(n2, t3, s2);
	        }
	        case tp.SEQUENCE: {
	          const t3 = Ap.decodeSequenceLongStream(e2, r2, i2);
	          return new Ip(n2, t3[0], t3[1], i2.numRleValues);
	        }
	        case tp.CONST: {
	          const t3 = Ap.decodeConstLongStream(e2, r2, i2, false);
	          return new Hp(n2, t3, s2);
	        }
	      }
	      throw new Error("Vector type not supported for id column.");
	    }
	    class mf {
	      constructor(e2, t2) {
	        var r2;
	        switch (this._featureData = e2, this.properties = this._featureData.properties || {}, null === (r2 = this._featureData.geometry) || void 0 === r2 ? void 0 : r2.type) {
	          case rp.POINT:
	          case rp.MULTIPOINT:
	            this.type = 1;
	            break;
	          case rp.LINESTRING:
	          case rp.MULTILINESTRING:
	            this.type = 2;
	            break;
	          case rp.POLYGON:
	          case rp.MULTIPOLYGON:
	            this.type = 3;
	            break;
	          default:
	            this.type = 0;
	        }
	        this.extent = t2, this.id = Number(this._featureData.id);
	      }
	      projectPoint(e2, t2, r2, n2) {
	        return [360 * (e2.x + t2) / n2 - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (e2.y + r2) / n2) * Math.PI)) - 90];
	      }
	      projectLine(e2, t2, r2, n2) {
	        return e2.map((e3) => this.projectPoint(e3, t2, r2, n2));
	      }
	      toGeoJSON(e2, t2, r2) {
	        const n2 = this.extent * Math.pow(2, r2), i2 = this.extent * e2, s2 = this.extent * t2, o2 = this.loadGeometry();
	        let a2;
	        switch (this.type) {
	          case 1: {
	            const e3 = [];
	            for (const t4 of o2) e3.push(t4[0]);
	            const t3 = this.projectLine(e3, i2, s2, n2);
	            a2 = 1 === e3.length ? { type: "Point", coordinates: t3[0] } : { type: "MultiPoint", coordinates: t3 };
	            break;
	          }
	          case 2: {
	            const e3 = o2.map((e4) => this.projectLine(e4, i2, s2, n2));
	            a2 = 1 === e3.length ? { type: "LineString", coordinates: e3[0] } : { type: "MultiLineString", coordinates: e3 };
	            break;
	          }
	          case 3: {
	            const e3 = Qr(o2), t3 = [];
	            for (const r3 of e3) t3.push(r3.map((e4) => this.projectLine(e4, i2, s2, n2)));
	            a2 = 1 === t3.length ? { type: "Polygon", coordinates: t3[0] } : { type: "MultiPolygon", coordinates: t3 };
	            break;
	          }
	          default:
	            throw new Error(`unknown feature type: ${this.type}`);
	        }
	        const l2 = { type: "Feature", geometry: a2, properties: this.properties };
	        return null != this.id && (l2.id = this.id), l2;
	      }
	      loadGeometry() {
	        const e2 = [];
	        for (const t2 of this._featureData.geometry.coordinates) {
	          const n2 = [];
	          for (const e3 of t2) n2.push(new r(e3.x, e3.y));
	          e2.push(n2);
	        }
	        return e2;
	      }
	      bbox() {
	        return [0, 0, 0, 0];
	      }
	    }
	    class gf {
	      constructor(e2) {
	        this.features = [], this.featureTable = e2, this.name = e2.name, this.extent = e2.extent, this.version = 2, this.features = e2.getFeatures(), this.length = this.features.length;
	      }
	      feature(e2) {
	        return new mf(this.features[e2], this.extent);
	      }
	    }
	    class xf {
	      constructor(e2) {
	        this.layers = {};
	        const t2 = function(e3, t3, r2 = true) {
	          const n2 = new Zh(0), i2 = [];
	          for (; n2.get() < e3.length; ) {
	            const s2 = op(e3, n2, 1)[0] >>> 0, o2 = n2.get() + s2;
	            if (o2 > e3.length) throw new Error(`Block overruns tile: ${o2} > ${e3.length}`);
	            if (1 != op(e3, n2, 1)[0] >>> 0) {
	              n2.set(o2);
	              continue;
	            }
	            const a2 = df(e3, n2), l2 = a2[1], u2 = a2[0].featureTables[0];
	            let c2 = null, h2 = null;
	            const p2 = [];
	            let f2 = 0;
	            for (const i3 of u2.columns) {
	              const s3 = i3.name;
	              if ("id" === s3) {
	                let t4 = null;
	                if (i3.nullable) {
	                  const r3 = _p.decode(e3, n2), i4 = n2.get(), s4 = Wp(e3, r3.numValues, n2);
	                  n2.set(i4 + r3.byteLength), t4 = new Sp(s4, r3.numValues);
	                }
	                const o3 = _p.decode(e3, n2);
	                f2 = o3.getDecompressedCount(), c2 = yf(e3, i3, n2, s3, o3, t4 ?? f2, r2);
	              } else if ("geometry" === s3) {
	                const r3 = op(e3, n2, 1)[0];
	                if (0 === f2) {
	                  const t4 = n2.get();
	                  f2 = _p.decode(e3, n2).getDecompressedCount(), n2.set(t4);
	                }
	                h2 = jp(e3, r3, n2, f2, t3);
	              } else {
	                const t4 = uf.hasStreamCount(i3) ? op(e3, n2, 1)[0] : 1;
	                if (0 === t4 && "scalarType" === i3.type) continue;
	                const r3 = af(e3, n2, i3, t4, f2, void 0);
	                r3 && (Array.isArray(r3) ? p2.push(...r3) : p2.push(r3));
	              }
	            }
	            const d2 = new Yh(u2.name, h2, c2, p2, l2);
	            i2.push(d2), n2.set(o2);
	          }
	          return i2;
	        }(new Uint8Array(e2));
	        this.layers = t2.reduce((e3, t3) => Object.assign(Object.assign({}, e3), { [t3.name]: new gf(t3) }), {});
	      }
	    }
	    class vf {
	      constructor() {
	        this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0;
	      }
	      extend(e2) {
	        return this.minX = Math.min(this.minX, e2.x), this.minY = Math.min(this.minY, e2.y), this.maxX = Math.max(this.maxX, e2.x), this.maxY = Math.max(this.maxY, e2.y), this;
	      }
	      expandBy(e2) {
	        return this.minX -= e2, this.minY -= e2, this.maxX += e2, this.maxY += e2, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this;
	      }
	      shrinkBy(e2) {
	        return this.expandBy(-e2);
	      }
	      map(e2) {
	        const t2 = new vf();
	        return t2.extend(e2(new r(this.minX, this.minY))), t2.extend(e2(new r(this.maxX, this.minY))), t2.extend(e2(new r(this.minX, this.maxY))), t2.extend(e2(new r(this.maxX, this.maxY))), t2;
	      }
	      static fromPoints(e2) {
	        const t2 = new vf();
	        for (const r2 of e2) t2.extend(r2);
	        return t2;
	      }
	      contains(e2) {
	        return e2.x >= this.minX && e2.x <= this.maxX && e2.y >= this.minY && e2.y <= this.maxY;
	      }
	      empty() {
	        return this.minX > this.maxX;
	      }
	      width() {
	        return this.maxX - this.minX;
	      }
	      height() {
	        return this.maxY - this.minY;
	      }
	      covers(e2) {
	        return !this.empty() && !e2.empty() && e2.minX >= this.minX && e2.maxX <= this.maxX && e2.minY >= this.minY && e2.maxY <= this.maxY;
	      }
	      intersects(e2) {
	        return !this.empty() && !e2.empty() && e2.minX <= this.maxX && e2.maxX >= this.minX && e2.minY <= this.maxY && e2.maxY >= this.minY;
	      }
	    }
	    const bf = "_geojsonTileLayer";
	    class wf {
	      constructor(e2, t2) {
	        this.tileID = e2, this.x = e2.canonical.x, this.y = e2.canonical.y, this.z = e2.canonical.z, this.grid = new os(k, 16, 0), this.grid3D = new os(k, 16, 0), this.featureIndexArray = new Lo(), this.promoteId = t2;
	      }
	      insert(e2, t2, r2, n2, i2, s2) {
	        const o2 = this.featureIndexArray.length;
	        this.featureIndexArray.emplaceBack(r2, n2, i2);
	        const a2 = s2 ? this.grid3D : this.grid;
	        for (let e3 = 0; e3 < t2.length; e3++) {
	          const r3 = t2[e3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
	          for (let e4 = 0; e4 < r3.length; e4++) {
	            const t3 = r3[e4];
	            n3[0] = Math.min(n3[0], t3.x), n3[1] = Math.min(n3[1], t3.y), n3[2] = Math.max(n3[2], t3.x), n3[3] = Math.max(n3[3], t3.y);
	          }
	          n3[0] < k && n3[1] < k && n3[2] >= 0 && n3[3] >= 0 && a2.insert(o2, n3[0], n3[1], n3[2], n3[3]);
	        }
	      }
	      loadVTLayers() {
	        return this.vtLayers || (this.vtLayers = "mlt" !== this.encoding ? new ku(new wc(this.rawTileData)).layers : new xf(this.rawTileData).layers, this.sourceLayerCoder = new Oh(this.vtLayers ? Object.keys(this.vtLayers).sort() : [bf])), this.vtLayers;
	      }
	      query(e2, t2, n2, i2) {
	        this.loadVTLayers();
	        const s2 = e2.params, o2 = k / e2.tileSize / e2.scale, a2 = pi(s2.filter, s2.globalState), l2 = e2.queryGeometry, u2 = e2.queryPadding * o2, c2 = vf.fromPoints(l2), h2 = this.grid.query(c2.minX - u2, c2.minY - u2, c2.maxX + u2, c2.maxY + u2), p2 = vf.fromPoints(e2.cameraQueryGeometry).expandBy(u2), f2 = this.grid3D.query(p2.minX, p2.minY, p2.maxX, p2.maxY, (t3, n3, i3, s3) => function(e3, t4, n4, i4, s4) {
	          for (const r2 of e3) if (t4 <= r2.x && n4 <= r2.y && i4 >= r2.x && s4 >= r2.y) return true;
	          const o3 = [new r(t4, n4), new r(t4, s4), new r(i4, s4), new r(i4, n4)];
	          if (e3.length > 2) {
	            for (const t5 of o3) if (Ka(e3, t5)) return true;
	          }
	          for (let t5 = 0; t5 < e3.length - 1; t5++) if (Wa(e3[t5], e3[t5 + 1], o3)) return true;
	          return false;
	        }(e2.cameraQueryGeometry, t3 - u2, n3 - u2, i3 + u2, s3 + u2));
	        for (const e3 of f2) h2.push(e3);
	        h2.sort(Sf);
	        const d2 = {};
	        let y2;
	        for (let r2 = 0; r2 < h2.length; r2++) {
	          const u3 = h2[r2];
	          if (u3 === y2) continue;
	          y2 = u3;
	          const c3 = this.featureIndexArray.get(u3);
	          let p3 = null;
	          this.loadMatchingFeature(d2, c3.bucketIndex, c3.sourceLayerIndex, c3.featureIndex, a2, s2.layers, s2.availableImages, t2, n2, i2, (t3, r3, n3) => (p3 || (p3 = Ca(t3)), r3.queryIntersectsFeature({ queryGeometry: l2, feature: t3, featureState: n3, geometry: p3, zoom: this.z, transform: e2.transform, pixelsToTileUnits: o2, pixelPosMatrix: e2.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: e2.getElevation })));
	        }
	        return d2;
	      }
	      loadMatchingFeature(e2, t2, r2, n2, i2, s2, o2, a2, l2, u2, c2) {
	        const h2 = this.bucketLayerIDs[t2];
	        if (s2 && !h2.some((e3) => s2.has(e3))) return;
	        const p2 = this.sourceLayerCoder.decode(r2), f2 = this.vtLayers[p2].feature(n2);
	        if (i2.needGeometry) {
	          const e3 = La(f2, true);
	          if (!i2.filter(new ks(this.tileID.overscaledZ), e3, this.tileID.canonical)) return;
	        } else if (!i2.filter(new ks(this.tileID.overscaledZ), f2)) return;
	        const d2 = this.getId(f2, p2);
	        for (let t3 = 0; t3 < h2.length; t3++) {
	          const r3 = h2[t3];
	          if (s2 && !s2.has(r3)) continue;
	          const i3 = a2[r3];
	          if (!i3) continue;
	          let p3 = {};
	          d2 && u2 && (p3 = u2.getState(i3.sourceLayer || bf, d2));
	          const y2 = O({}, l2[r3]);
	          y2.paint = _f(y2.paint, i3.paint, f2, p3, o2), y2.layout = _f(y2.layout, i3.layout, f2, p3, o2);
	          const m2 = !c2 || c2(f2, i3, p3);
	          if (!m2) continue;
	          const g2 = new Rh(f2, this.z, this.x, this.y, d2);
	          g2.layer = y2;
	          let x2 = e2[r3];
	          void 0 === x2 && (x2 = e2[r3] = []), x2.push({ featureIndex: n2, feature: g2, intersectionZ: m2 });
	        }
	      }
	      lookupSymbolFeatures(e2, t2, r2, n2, i2, s2, o2, a2) {
	        const l2 = {};
	        this.loadVTLayers();
	        const u2 = pi(i2.filterSpec, i2.globalState);
	        for (const i3 of e2) this.loadMatchingFeature(l2, r2, n2, i3, u2, s2, o2, a2, t2);
	        return l2;
	      }
	      hasLayer(e2) {
	        for (const t2 of this.bucketLayerIDs) for (const r2 of t2) if (e2 === r2) return true;
	        return false;
	      }
	      getId(e2, t2) {
	        var r2;
	        let n2 = e2.id;
	        return this.promoteId && (n2 = e2.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[t2]], "boolean" == typeof n2 && (n2 = Number(n2)), void 0 === n2 && (null === (r2 = e2.properties) || void 0 === r2 ? void 0 : r2.cluster) && this.promoteId && (n2 = Number(e2.properties.cluster_id))), n2;
	      }
	    }
	    function _f(e2, t2, r2, n2, i2) {
	      return N(e2, (e3, s2) => {
	        const o2 = t2 instanceof Rs ? t2.get(s2) : null;
	        return o2 && o2.evaluate ? o2.evaluate(r2, n2, i2) : o2;
	      });
	    }
	    function Sf(e2, t2) {
	      return t2 - e2;
	    }
	    function Af(e2, t2, n2, i2, s2) {
	      const o2 = [];
	      for (let a2 = 0; a2 < e2.length; a2++) {
	        const l2 = e2[a2];
	        let u2;
	        for (let e3 = 0; e3 < l2.length - 1; e3++) {
	          let a3 = l2[e3], c2 = l2[e3 + 1];
	          a3.x < t2 && c2.x < t2 || (a3.x < t2 ? a3 = new r(t2, a3.y + (t2 - a3.x) / (c2.x - a3.x) * (c2.y - a3.y))._round() : c2.x < t2 && (c2 = new r(t2, a3.y + (t2 - a3.x) / (c2.x - a3.x) * (c2.y - a3.y))._round()), a3.y < n2 && c2.y < n2 || (a3.y < n2 ? a3 = new r(a3.x + (n2 - a3.y) / (c2.y - a3.y) * (c2.x - a3.x), n2)._round() : c2.y < n2 && (c2 = new r(a3.x + (n2 - a3.y) / (c2.y - a3.y) * (c2.x - a3.x), n2)._round()), a3.x >= i2 && c2.x >= i2 || (a3.x >= i2 ? a3 = new r(i2, a3.y + (i2 - a3.x) / (c2.x - a3.x) * (c2.y - a3.y))._round() : c2.x >= i2 && (c2 = new r(i2, a3.y + (i2 - a3.x) / (c2.x - a3.x) * (c2.y - a3.y))._round()), a3.y >= s2 && c2.y >= s2 || (a3.y >= s2 ? a3 = new r(a3.x + (s2 - a3.y) / (c2.y - a3.y) * (c2.x - a3.x), s2)._round() : c2.y >= s2 && (c2 = new r(a3.x + (s2 - a3.y) / (c2.y - a3.y) * (c2.x - a3.x), s2)._round()), u2 && a3.equals(u2[u2.length - 1]) || (u2 = [a3], o2.push(u2)), u2.push(c2)))));
	        }
	      }
	      return o2;
	    }
	    function Tf(e2, t2, r2, n2, i2) {
	      switch (t2) {
	        case 1:
	          return function(e3, t3, r3, n3) {
	            const i3 = [];
	            for (const s2 of e3) for (const e4 of s2) {
	              const s3 = 0 === n3 ? e4.x : e4.y;
	              s3 >= t3 && s3 <= r3 && i3.push([e4]);
	            }
	            return i3;
	          }(e2, r2, n2, i2);
	        case 2:
	          return Ef(e2, r2, n2, i2, false);
	        case 3:
	          return Ef(e2, r2, n2, i2, true);
	      }
	      return [];
	    }
	    function If(e2, t2, n2, i2, s2) {
	      const o2 = 0 === i2 ? Mf : kf;
	      let a2 = [];
	      const l2 = [];
	      for (let r2 = 0; r2 < e2.length - 1; r2++) {
	        const u3 = e2[r2], c3 = e2[r2 + 1], h2 = 0 === i2 ? u3.x : u3.y, p2 = 0 === i2 ? c3.x : c3.y;
	        let f2 = false;
	        h2 < t2 ? p2 > t2 && a2.push(o2(u3, c3, t2)) : h2 > n2 ? p2 < n2 && a2.push(o2(u3, c3, n2)) : a2.push(u3), p2 < t2 && h2 >= t2 && (a2.push(o2(u3, c3, t2)), f2 = true), p2 > n2 && h2 <= n2 && (a2.push(o2(u3, c3, n2)), f2 = true), !s2 && f2 && (l2.push(a2), a2 = []);
	      }
	      const u2 = e2.length - 1, c2 = 0 === i2 ? e2[u2].x : e2[u2].y;
	      return c2 >= t2 && c2 <= n2 && a2.push(e2[u2]), s2 && a2.length > 0 && !a2[0].equals(a2[a2.length - 1]) && a2.push(new r(a2[0].x, a2[0].y)), a2.length > 0 && l2.push(a2), l2;
	    }
	    function Ef(e2, t2, r2, n2, i2) {
	      const s2 = [];
	      for (const o2 of e2) {
	        const e3 = If(o2, t2, r2, n2, i2);
	        e3.length > 0 && s2.push(...e3);
	      }
	      return s2;
	    }
	    function Mf(e2, t2, n2) {
	      return new r(n2, e2.y + (n2 - e2.x) / (t2.x - e2.x) * (t2.y - e2.y));
	    }
	    function kf(e2, t2, n2) {
	      return new r(e2.x + (n2 - e2.y) / (t2.y - e2.y) * (t2.x - e2.x), n2);
	    }
	    ls("FeatureIndex", wf, { omit: ["rawTileData", "sourceLayerCoder"] });
	    class Ff extends r {
	      constructor(e2, t2, r2, n2) {
	        super(e2, t2), this.angle = r2, void 0 !== n2 && (this.segment = n2);
	      }
	      clone() {
	        return new Ff(this.x, this.y, this.angle, this.segment);
	      }
	    }
	    function Df(e2, t2, r2, n2, i2) {
	      if (void 0 === t2.segment || 0 === r2) return true;
	      let s2 = t2, o2 = t2.segment + 1, a2 = 0;
	      for (; a2 > -r2 / 2; ) {
	        if (o2--, o2 < 0) return false;
	        a2 -= e2[o2].dist(s2), s2 = e2[o2];
	      }
	      a2 += e2[o2].dist(e2[o2 + 1]), o2++;
	      const l2 = [];
	      let u2 = 0;
	      for (; a2 < r2 / 2; ) {
	        const t3 = e2[o2], r3 = e2[o2 + 1];
	        if (!r3) return false;
	        let s3 = e2[o2 - 1].angleTo(t3) - t3.angleTo(r3);
	        for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: a2, angleDelta: s3 }), u2 += s3; a2 - l2[0].distance > n2; ) u2 -= l2.shift().angleDelta;
	        if (u2 > i2) return false;
	        o2++, a2 += t3.dist(r3);
	      }
	      return true;
	    }
	    function Pf(e2) {
	      let t2 = 0;
	      for (let r2 = 0; r2 < e2.length - 1; r2++) t2 += e2[r2].dist(e2[r2 + 1]);
	      return t2;
	    }
	    function Bf(e2, t2, r2) {
	      return e2 ? 0.6 * t2 * r2 : 0;
	    }
	    function zf(e2, t2) {
	      return Math.max(e2 ? e2.right - e2.left : 0, t2 ? t2.right - t2.left : 0);
	    }
	    function Vf(e2, t2, r2, n2, i2, s2) {
	      const o2 = Bf(r2, i2, s2), a2 = zf(r2, n2) * s2;
	      let l2 = 0;
	      const u2 = Pf(e2) / 2;
	      for (let r3 = 0; r3 < e2.length - 1; r3++) {
	        const n3 = e2[r3], i3 = e2[r3 + 1], s3 = n3.dist(i3);
	        if (l2 + s3 > u2) {
	          const c2 = (u2 - l2) / s3, h2 = dr.number(n3.x, i3.x, c2), p2 = dr.number(n3.y, i3.y, c2), f2 = new Ff(h2, p2, i3.angleTo(n3), r3);
	          return f2._round(), !o2 || Df(e2, f2, a2, o2, t2) ? f2 : void 0;
	        }
	        l2 += s3;
	      }
	    }
	    function Cf(e2, t2, r2, n2, i2, s2, o2, a2, l2) {
	      const u2 = Bf(n2, s2, o2), c2 = zf(n2, i2), h2 = c2 * o2, p2 = 0 === e2[0].x || e2[0].x === l2 || 0 === e2[0].y || e2[0].y === l2;
	      return t2 - h2 < t2 / 4 && (t2 = h2 + t2 / 4), Lf(e2, p2 ? t2 / 2 * a2 % t2 : (c2 / 2 + 2 * s2) * o2 * a2 % t2, t2, u2, r2, h2, p2, false, l2);
	    }
	    function Lf(e2, t2, r2, n2, i2, s2, o2, a2, l2) {
	      const u2 = s2 / 2, c2 = Pf(e2);
	      let h2 = 0, p2 = t2 - r2, f2 = [];
	      for (let t3 = 0; t3 < e2.length - 1; t3++) {
	        const o3 = e2[t3], a3 = e2[t3 + 1], d2 = o3.dist(a3), y2 = a3.angleTo(o3);
	        for (; p2 + r2 < h2 + d2; ) {
	          p2 += r2;
	          const m2 = (p2 - h2) / d2, g2 = dr.number(o3.x, a3.x, m2), x2 = dr.number(o3.y, a3.y, m2);
	          if (g2 >= 0 && g2 < l2 && x2 >= 0 && x2 < l2 && p2 - u2 >= 0 && p2 + u2 <= c2) {
	            const r3 = new Ff(g2, x2, y2, t3);
	            r3._round(), n2 && !Df(e2, r3, s2, n2, i2) || f2.push(r3);
	          }
	        }
	        h2 += d2;
	      }
	      return a2 || f2.length || o2 || (f2 = Lf(e2, h2 / 2, r2, n2, i2, s2, o2, true, l2)), f2;
	    }
	    function Of(e2, t2, n2, i2) {
	      const s2 = [], o2 = e2.image, a2 = o2.pixelRatio, l2 = o2.paddedRect.w - 2, u2 = o2.paddedRect.h - 2;
	      let c2 = { x1: e2.left, y1: e2.top, x2: e2.right, y2: e2.bottom };
	      const h2 = o2.stretchX || [[0, l2]], p2 = o2.stretchY || [[0, u2]], f2 = (e3, t3) => e3 + t3[1] - t3[0], d2 = h2.reduce(f2, 0), y2 = p2.reduce(f2, 0), m2 = l2 - d2, g2 = u2 - y2;
	      let x2 = 0, v2 = d2, b2 = 0, w2 = y2, _2 = 0, S2 = m2, A2 = 0, T2 = g2;
	      if (o2.content && i2) {
	        const t3 = o2.content, r2 = t3[2] - t3[0], n3 = t3[3] - t3[1];
	        (o2.textFitWidth || o2.textFitHeight) && (c2 = Hc(e2)), x2 = Rf(h2, 0, t3[0]), b2 = Rf(p2, 0, t3[1]), v2 = Rf(h2, t3[0], t3[2]), w2 = Rf(p2, t3[1], t3[3]), _2 = t3[0] - x2, A2 = t3[1] - b2, S2 = r2 - v2, T2 = n3 - w2;
	      }
	      const I2 = c2.x1, E2 = c2.y1, M2 = c2.x2 - I2, k2 = c2.y2 - E2, F2 = (e3, i3, s3, l3) => {
	        const u3 = $f(e3.stretch - x2, v2, M2, I2), c3 = Uf(e3.fixed - _2, S2, e3.stretch, d2), h3 = $f(i3.stretch - b2, w2, k2, E2), p3 = Uf(i3.fixed - A2, T2, i3.stretch, y2), f3 = $f(s3.stretch - x2, v2, M2, I2), m3 = Uf(s3.fixed - _2, S2, s3.stretch, d2), g3 = $f(l3.stretch - b2, w2, k2, E2), F3 = Uf(l3.fixed - A2, T2, l3.stretch, y2), D2 = new r(u3, h3), P2 = new r(f3, h3), B2 = new r(f3, g3), z2 = new r(u3, g3), V2 = new r(c3 / a2, p3 / a2), C2 = new r(m3 / a2, F3 / a2), L2 = t2 * Math.PI / 180;
	        if (L2) {
	          const e4 = Math.sin(L2), t3 = Math.cos(L2), r2 = [t3, -e4, e4, t3];
	          D2._matMult(r2), P2._matMult(r2), z2._matMult(r2), B2._matMult(r2);
	        }
	        const O2 = e3.stretch + e3.fixed, R2 = i3.stretch + i3.fixed;
	        return { tl: D2, tr: P2, bl: z2, br: B2, tex: { x: o2.paddedRect.x + 1 + O2, y: o2.paddedRect.y + 1 + R2, w: s3.stretch + s3.fixed - O2, h: l3.stretch + l3.fixed - R2 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: V2, pixelOffsetBR: C2, minFontScaleX: S2 / a2 / M2, minFontScaleY: T2 / a2 / k2, isSDF: n2 };
	      };
	      if (i2 && (o2.stretchX || o2.stretchY)) {
	        const e3 = Nf(h2, m2, d2), t3 = Nf(p2, g2, y2);
	        for (let r2 = 0; r2 < e3.length - 1; r2++) {
	          const n3 = e3[r2], i3 = e3[r2 + 1];
	          for (let e4 = 0; e4 < t3.length - 1; e4++) s2.push(F2(n3, t3[e4], i3, t3[e4 + 1]));
	        }
	      } else s2.push(F2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l2 + 1 }, { fixed: 0, stretch: u2 + 1 }));
	      return s2;
	    }
	    function Rf(e2, t2, r2) {
	      let n2 = 0;
	      for (const i2 of e2) n2 += Math.max(t2, Math.min(r2, i2[1])) - Math.max(t2, Math.min(r2, i2[0]));
	      return n2;
	    }
	    function Nf(e2, t2, r2) {
	      const n2 = [{ fixed: -1, stretch: 0 }];
	      for (const [t3, r3] of e2) {
	        const e3 = n2[n2.length - 1];
	        n2.push({ fixed: t3 - e3.stretch, stretch: e3.stretch }), n2.push({ fixed: t3 - e3.stretch, stretch: e3.stretch + (r3 - t3) });
	      }
	      return n2.push({ fixed: t2 + 1, stretch: r2 }), n2;
	    }
	    function $f(e2, t2, r2, n2) {
	      return e2 / t2 * r2 + n2;
	    }
	    function Uf(e2, t2, r2, n2) {
	      return e2 - t2 * r2 / n2;
	    }
	    ls("Anchor", Ff);
	    class qf {
	      constructor(e2, t2, n2, i2, s2, o2, a2, l2, u2, c2) {
	        var h2;
	        if (this.boxStartIndex = e2.length, u2) {
	          let e3 = o2.top, t3 = o2.bottom;
	          const r2 = o2.collisionPadding;
	          r2 && (e3 -= r2[1], t3 += r2[3]);
	          let n3 = t3 - e3;
	          n3 > 0 && (n3 = Math.max(10, n3), this.circleDiameter = n3);
	        } else {
	          const u3 = (null === (h2 = o2.image) || void 0 === h2 ? void 0 : h2.content) && (o2.image.textFitWidth || o2.image.textFitHeight) ? Hc(o2) : { x1: o2.left, y1: o2.top, x2: o2.right, y2: o2.bottom };
	          u3.y1 = u3.y1 * a2 - l2[0], u3.y2 = u3.y2 * a2 + l2[2], u3.x1 = u3.x1 * a2 - l2[3], u3.x2 = u3.x2 * a2 + l2[1];
	          const p2 = o2.collisionPadding;
	          if (p2 && (u3.x1 -= p2[0] * a2, u3.y1 -= p2[1] * a2, u3.x2 += p2[2] * a2, u3.y2 += p2[3] * a2), c2) {
	            const e3 = new r(u3.x1, u3.y1), t3 = new r(u3.x2, u3.y1), n3 = new r(u3.x1, u3.y2), i3 = new r(u3.x2, u3.y2), s3 = c2 * Math.PI / 180;
	            e3._rotate(s3), t3._rotate(s3), n3._rotate(s3), i3._rotate(s3), u3.x1 = Math.min(e3.x, t3.x, n3.x, i3.x), u3.x2 = Math.max(e3.x, t3.x, n3.x, i3.x), u3.y1 = Math.min(e3.y, t3.y, n3.y, i3.y), u3.y2 = Math.max(e3.y, t3.y, n3.y, i3.y);
	          }
	          e2.emplaceBack(t2.x, t2.y, u3.x1, u3.y1, u3.x2, u3.y2, n2, i2, s2);
	        }
	        this.boxEndIndex = e2.length;
	      }
	    }
	    class jf {
	      constructor(e2 = [], t2 = (e3, t3) => e3 < t3 ? -1 : e3 > t3 ? 1 : 0) {
	        if (this.data = e2, this.length = this.data.length, this.compare = t2, this.length > 0) for (let e3 = (this.length >> 1) - 1; e3 >= 0; e3--) this._down(e3);
	      }
	      push(e2) {
	        this.data.push(e2), this._up(this.length++);
	      }
	      pop() {
	        if (0 === this.length) return;
	        const e2 = this.data[0], t2 = this.data.pop();
	        return --this.length > 0 && (this.data[0] = t2, this._down(0)), e2;
	      }
	      peek() {
	        return this.data[0];
	      }
	      _up(e2) {
	        const { data: t2, compare: r2 } = this, n2 = t2[e2];
	        for (; e2 > 0; ) {
	          const i2 = e2 - 1 >> 1, s2 = t2[i2];
	          if (r2(n2, s2) >= 0) break;
	          t2[e2] = s2, e2 = i2;
	        }
	        t2[e2] = n2;
	      }
	      _down(e2) {
	        const { data: t2, compare: r2 } = this, n2 = this.length >> 1, i2 = t2[e2];
	        for (; e2 < n2; ) {
	          let n3 = 1 + (e2 << 1);
	          const s2 = n3 + 1;
	          if (s2 < this.length && r2(t2[s2], t2[n3]) < 0 && (n3 = s2), r2(t2[n3], i2) >= 0) break;
	          t2[e2] = t2[n3], e2 = n3;
	        }
	        t2[e2] = i2;
	      }
	    }
	    function Gf(e2, t2 = 1, n2 = false) {
	      const i2 = vf.fromPoints(e2[0]), s2 = Math.min(i2.width(), i2.height());
	      let o2 = s2 / 2;
	      const a2 = new jf([], Xf), { minX: l2, minY: u2, maxX: c2, maxY: h2 } = i2;
	      if (0 === s2) return new r(l2, u2);
	      for (let t3 = l2; t3 < c2; t3 += s2) for (let r2 = u2; r2 < h2; r2 += s2) a2.push(new Yf(t3 + o2, r2 + o2, o2, e2));
	      let p2 = function(e3) {
	        let t3 = 0, r2 = 0, n3 = 0;
	        const i3 = e3[0];
	        for (let e4 = 0, s3 = i3.length, o3 = s3 - 1; e4 < s3; o3 = e4++) {
	          const s4 = i3[e4], a3 = i3[o3], l3 = s4.x * a3.y - a3.x * s4.y;
	          r2 += (s4.x + a3.x) * l3, n3 += (s4.y + a3.y) * l3, t3 += 3 * l3;
	        }
	        return new Yf(r2 / t3, n3 / t3, 0, e3);
	      }(e2), f2 = a2.length;
	      for (; a2.length; ) {
	        const r2 = a2.pop();
	        (r2.d > p2.d || !p2.d) && (p2 = r2, n2 && console.log("found best %d after %d probes", Math.round(1e4 * r2.d) / 1e4, f2)), r2.max - p2.d <= t2 || (o2 = r2.h / 2, a2.push(new Yf(r2.p.x - o2, r2.p.y - o2, o2, e2)), a2.push(new Yf(r2.p.x + o2, r2.p.y - o2, o2, e2)), a2.push(new Yf(r2.p.x - o2, r2.p.y + o2, o2, e2)), a2.push(new Yf(r2.p.x + o2, r2.p.y + o2, o2, e2)), f2 += 4);
	      }
	      return n2 && (console.log(`num probes: ${f2}`), console.log(`best distance: ${p2.d}`)), p2.p;
	    }
	    function Xf(e2, t2) {
	      return t2.max - e2.max;
	    }
	    function Yf(e2, t2, n2, i2) {
	      this.p = new r(e2, t2), this.h = n2, this.d = function(e3, t3) {
	        let r2 = false, n3 = 1 / 0;
	        for (let i3 = 0; i3 < t3.length; i3++) {
	          const s2 = t3[i3];
	          for (let t4 = 0, i4 = s2.length, o2 = i4 - 1; t4 < i4; o2 = t4++) {
	            const i5 = s2[t4], a2 = s2[o2];
	            i5.y > e3.y != a2.y > e3.y && e3.x < (a2.x - i5.x) * (e3.y - i5.y) / (a2.y - i5.y) + i5.x && (r2 = !r2), n3 = Math.min(n3, Za(e3, i5, a2));
	          }
	        }
	        return (r2 ? 1 : -1) * Math.sqrt(n3);
	      }(this.p, i2), this.max = this.d + this.h * Math.SQRT2;
	    }
	    var Zf;
	    e.aO = void 0, (Zf = e.aO || (e.aO = {}))[Zf.center = 1] = "center", Zf[Zf.left = 2] = "left", Zf[Zf.right = 3] = "right", Zf[Zf.top = 4] = "top", Zf[Zf.bottom = 5] = "bottom", Zf[Zf["top-left"] = 6] = "top-left", Zf[Zf["top-right"] = 7] = "top-right", Zf[Zf["bottom-left"] = 8] = "bottom-left", Zf[Zf["bottom-right"] = 9] = "bottom-right";
	    const Hf = Number.POSITIVE_INFINITY;
	    function Kf(e2, t2) {
	      return t2[1] !== Hf ? function(e3, t3, r2) {
	        let n2 = 0, i2 = 0;
	        switch (t3 = Math.abs(t3), r2 = Math.abs(r2), e3) {
	          case "top-right":
	          case "top-left":
	          case "top":
	            i2 = r2 - 7;
	            break;
	          case "bottom-right":
	          case "bottom-left":
	          case "bottom":
	            i2 = 7 - r2;
	        }
	        switch (e3) {
	          case "top-right":
	          case "bottom-right":
	          case "right":
	            n2 = -t3;
	            break;
	          case "top-left":
	          case "bottom-left":
	          case "left":
	            n2 = t3;
	        }
	        return [n2, i2];
	      }(e2, t2[0], t2[1]) : function(e3, t3) {
	        let r2 = 0, n2 = 0;
	        t3 < 0 && (t3 = 0);
	        const i2 = t3 / Math.SQRT2;
	        switch (e3) {
	          case "top-right":
	          case "top-left":
	            n2 = i2 - 7;
	            break;
	          case "bottom-right":
	          case "bottom-left":
	            n2 = 7 - i2;
	            break;
	          case "bottom":
	            n2 = 7 - t3;
	            break;
	          case "top":
	            n2 = t3 - 7;
	        }
	        switch (e3) {
	          case "top-right":
	          case "bottom-right":
	            r2 = -i2;
	            break;
	          case "top-left":
	          case "bottom-left":
	            r2 = i2;
	            break;
	          case "left":
	            r2 = t3;
	            break;
	          case "right":
	            r2 = -t3;
	        }
	        return [r2, n2];
	      }(e2, t2[0]);
	    }
	    function Wf(e2, t2, r2) {
	      var n2;
	      const i2 = e2.layout, s2 = null === (n2 = i2.get("text-variable-anchor-offset")) || void 0 === n2 ? void 0 : n2.evaluate(t2, {}, r2);
	      if (s2) {
	        const e3 = s2.values, t3 = [];
	        for (let r3 = 0; r3 < e3.length; r3 += 2) {
	          const n3 = t3[r3] = e3[r3], i3 = e3[r3 + 1].map((e4) => e4 * lc);
	          n3.startsWith("top") ? i3[1] -= 7 : n3.startsWith("bottom") && (i3[1] += 7), t3[r3 + 1] = i3;
	        }
	        return new Ct(t3);
	      }
	      const o2 = i2.get("text-variable-anchor");
	      if (o2) {
	        let n3;
	        n3 = void 0 !== e2._unevaluatedLayout.getValue("text-radial-offset") ? [i2.get("text-radial-offset").evaluate(t2, {}, r2) * lc, Hf] : i2.get("text-offset").evaluate(t2, {}, r2).map((e3) => e3 * lc);
	        const s3 = [];
	        for (const e3 of o2) s3.push(e3, Kf(e3, n3));
	        return new Ct(s3);
	      }
	      return null;
	    }
	    function Jf(e2) {
	      switch (e2) {
	        case "right":
	        case "top-right":
	        case "bottom-right":
	          return "right";
	        case "left":
	        case "top-left":
	        case "bottom-left":
	          return "left";
	      }
	      return "center";
	    }
	    function Qf(t2, r2, n2, i2, s2, o2, a2, l2, u2, c2, h2, p2) {
	      let f2 = o2.textMaxSize.evaluate(r2, {});
	      void 0 === f2 && (f2 = a2);
	      const d2 = t2.layers[0].layout, y2 = d2.get("icon-offset").evaluate(r2, {}, h2), m2 = td(n2.horizontal), g2 = a2 / 24, x2 = t2.tilePixelRatio * g2, v2 = t2.tilePixelRatio * f2 / 24, b2 = t2.tilePixelRatio * l2, w2 = t2.tilePixelRatio * d2.get("symbol-spacing"), _2 = d2.get("text-padding") * t2.tilePixelRatio, S2 = function(e2, t3, r3, n3 = 1) {
	        const i3 = e2.get("icon-padding").evaluate(t3, {}, r3), s3 = i3 && i3.values;
	        return [s3[0] * n3, s3[1] * n3, s3[2] * n3, s3[3] * n3];
	      }(d2, r2, h2, t2.tilePixelRatio), A2 = d2.get("text-max-angle") / 180 * Math.PI, T2 = "viewport" !== d2.get("text-rotation-alignment") && "point" !== d2.get("symbol-placement"), I2 = "map" === d2.get("icon-rotation-alignment") && "point" !== d2.get("symbol-placement"), E2 = d2.get("symbol-placement"), M2 = w2 / 2, F2 = d2.get("icon-text-fit");
	      let D2;
	      i2 && "none" !== F2 && (t2.allowVerticalPlacement && n2.vertical && (D2 = Kc(i2, n2.vertical, F2, d2.get("icon-text-fit-padding"), y2, g2)), m2 && (i2 = Kc(i2, m2, F2, d2.get("icon-text-fit-padding"), y2, g2)));
	      const P2 = h2 ? p2.line.getGranularityForZoomLevel(h2.z) : 1, B2 = (l3, p3) => {
	        p3.x < 0 || p3.x >= k || p3.y < 0 || p3.y >= k || function(t3, r3, n3, i3, s3, o3, a3, l4, u3, c3, h3, p4, f3, d3, y3, m3, g3, x3, v3, b3, w3, _3, S3, A3, T3) {
	          const I3 = t3.addToLineVertexArray(r3, n3);
	          let E3, M3, k2, F3, D3 = 0, P3 = 0, B3 = 0, z2 = 0, V2 = -1, C2 = -1;
	          const L2 = {};
	          let O2 = pa("");
	          if (t3.allowVerticalPlacement && i3.vertical) {
	            const e2 = l4.layout.get("text-rotate").evaluate(w3, {}, A3) + 90;
	            k2 = new qf(u3, r3, c3, h3, p4, i3.vertical, f3, d3, y3, e2), a3 && (F3 = new qf(u3, r3, c3, h3, p4, a3, g3, x3, y3, e2));
	          }
	          if (s3) {
	            const n4 = l4.layout.get("icon-rotate").evaluate(w3, {}), i4 = "none" !== l4.layout.get("icon-text-fit"), o4 = Of(s3, n4, S3, i4), f4 = a3 ? Of(a3, n4, S3, i4) : void 0;
	            M3 = new qf(u3, r3, c3, h3, p4, s3, g3, x3, false, n4), D3 = 4 * o4.length;
	            const d4 = t3.iconSizeData;
	            let y4 = null;
	            "source" === d4.kind ? (y4 = [Wc * l4.layout.get("icon-size").evaluate(w3, {})], y4[0] > Jc && j(`${t3.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : "composite" === d4.kind && (y4 = [Wc * _3.compositeIconSizes[0].evaluate(w3, {}, A3), Wc * _3.compositeIconSizes[1].evaluate(w3, {}, A3)], (y4[0] > Jc || y4[1] > Jc) && j(`${t3.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), t3.addSymbols(t3.icon, o4, y4, b3, v3, w3, e.ay.none, r3, I3.lineStartIndex, I3.lineLength, -1, A3), V2 = t3.icon.placedSymbolArray.length - 1, f4 && (P3 = 4 * f4.length, t3.addSymbols(t3.icon, f4, y4, b3, v3, w3, e.ay.vertical, r3, I3.lineStartIndex, I3.lineLength, -1, A3), C2 = t3.icon.placedSymbolArray.length - 1);
	          }
	          const R2 = Object.keys(i3.horizontal);
	          for (const n4 of R2) {
	            const s4 = i3.horizontal[n4];
	            if (!E3) {
	              O2 = pa(s4.text);
	              const e2 = l4.layout.get("text-rotate").evaluate(w3, {}, A3);
	              E3 = new qf(u3, r3, c3, h3, p4, s4, f3, d3, y3, e2);
	            }
	            const a4 = 1 === s4.positionedLines.length;
	            if (B3 += ed(t3, r3, s4, o3, l4, y3, w3, m3, I3, i3.vertical ? e.ay.horizontal : e.ay.horizontalOnly, a4 ? R2 : [n4], L2, V2, _3, A3), a4) break;
	          }
	          i3.vertical && (z2 += ed(t3, r3, i3.vertical, o3, l4, y3, w3, m3, I3, e.ay.vertical, ["vertical"], L2, C2, _3, A3));
	          const N2 = E3 ? E3.boxStartIndex : t3.collisionBoxArray.length, $2 = E3 ? E3.boxEndIndex : t3.collisionBoxArray.length, U2 = k2 ? k2.boxStartIndex : t3.collisionBoxArray.length, q2 = k2 ? k2.boxEndIndex : t3.collisionBoxArray.length, G2 = M3 ? M3.boxStartIndex : t3.collisionBoxArray.length, X2 = M3 ? M3.boxEndIndex : t3.collisionBoxArray.length, Y2 = F3 ? F3.boxStartIndex : t3.collisionBoxArray.length, Z2 = F3 ? F3.boxEndIndex : t3.collisionBoxArray.length;
	          let H2 = -1;
	          const K2 = (e2, t4) => e2 && e2.circleDiameter ? Math.max(e2.circleDiameter, t4) : t4;
	          H2 = K2(E3, H2), H2 = K2(k2, H2), H2 = K2(M3, H2), H2 = K2(F3, H2);
	          const W2 = H2 > -1 ? 1 : 0;
	          W2 && (H2 *= T3 / lc), t3.glyphOffsetArray.length >= ah.MAX_GLYPHS && j("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== w3.sortKey && t3.addToSortKeyRanges(t3.symbolInstances.length, w3.sortKey);
	          const J2 = Wf(l4, w3, A3), [Q2, ee2] = function(t4, r4) {
	            const n4 = t4.length, i4 = null == r4 ? void 0 : r4.values;
	            if ((null == i4 ? void 0 : i4.length) > 0) for (let r5 = 0; r5 < i4.length; r5 += 2) {
	              const n5 = i4[r5 + 1];
	              t4.emplaceBack(e.aO[i4[r5]], n5[0], n5[1]);
	            }
	            return [n4, t4.length];
	          }(t3.textAnchorOffsets, J2);
	          t3.symbolInstances.emplaceBack(r3.x, r3.y, L2.right >= 0 ? L2.right : -1, L2.center >= 0 ? L2.center : -1, L2.left >= 0 ? L2.left : -1, L2.vertical || -1, V2, C2, O2, N2, $2, U2, q2, G2, X2, Y2, Z2, c3, B3, z2, D3, P3, W2, 0, f3, H2, Q2, ee2);
	        }(t2, p3, l3, n2, i2, s2, D2, t2.layers[0], t2.collisionBoxArray, r2.index, r2.sourceLayerIndex, t2.index, x2, [_2, _2, _2, _2], T2, u2, b2, S2, I2, y2, r2, o2, c2, h2, a2);
	      };
	      if ("line" === E2) for (const e2 of Af(r2.geometry, 0, 0, k, k)) {
	        const r3 = pu(e2, P2), s3 = Cf(r3, w2, A2, n2.vertical || m2, i2, 24, v2, t2.overscaling, k);
	        for (const e3 of s3) m2 && rd(t2, m2.text, M2, e3) || B2(r3, e3);
	      }
	      else if ("line-center" === E2) {
	        for (const e2 of r2.geometry) if (e2.length > 1) {
	          const t3 = pu(e2, P2), r3 = Vf(t3, A2, n2.vertical || m2, i2, 24, v2);
	          r3 && B2(t3, r3);
	        }
	      } else if ("Polygon" === r2.type) for (const e2 of Qr(r2.geometry, 0)) {
	        const t3 = Gf(e2, 16);
	        B2(pu(e2[0], P2, true), new Ff(t3.x, t3.y, 0));
	      }
	      else if ("LineString" === r2.type) for (const e2 of r2.geometry) {
	        const t3 = pu(e2, P2);
	        B2(t3, new Ff(t3[0].x, t3[0].y, 0));
	      }
	      else if ("Point" === r2.type) for (const e2 of r2.geometry) for (const t3 of e2) B2([t3], new Ff(t3.x, t3.y, 0));
	    }
	    function ed(e2, t2, n2, i2, s2, o2, a2, l2, u2, c2, h2, p2, f2, d2, y2) {
	      const m2 = function(e3, t3, n3, i3, s3, o3, a3, l3) {
	        const u3 = i3.layout.get("text-rotate").evaluate(o3, {}) * Math.PI / 180, c3 = [];
	        for (const e4 of t3.positionedLines) for (const i4 of e4.positionedGlyphs) {
	          if (!i4.rect) continue;
	          const o4 = i4.rect || {};
	          let h3 = 4, p3 = true, f3 = 1, d3 = 0;
	          const y3 = (s3 || l3) && i4.vertical, m3 = i4.metrics.advance * i4.scale / 2;
	          if (l3 && t3.verticalizable && (d3 = e4.lineOffset / 2 - (i4.imageName ? -(lc - i4.metrics.width * i4.scale) / 2 : (i4.scale - 1) * lc)), i4.imageName) {
	            const e5 = a3[i4.imageName];
	            p3 = e5.sdf, f3 = e5.pixelRatio, h3 = 1 / f3;
	          }
	          const g3 = s3 ? [i4.x + m3, i4.y] : [0, 0];
	          let x3 = s3 ? [0, 0] : [i4.x + m3 + n3[0], i4.y + n3[1] - d3], v2 = [0, 0];
	          y3 && (v2 = x3, x3 = [0, 0]);
	          const b2 = i4.metrics.isDoubleResolution ? 2 : 1, w2 = (i4.metrics.left - h3) * i4.scale - m3 + x3[0], _2 = (-i4.metrics.top - h3) * i4.scale + x3[1], S2 = w2 + o4.w / b2 * i4.scale / f3, A2 = _2 + o4.h / b2 * i4.scale / f3, T2 = new r(w2, _2), I2 = new r(S2, _2), E2 = new r(w2, A2), M2 = new r(S2, A2);
	          if (y3) {
	            const e5 = new r(-m3, m3 - -17), t4 = -Math.PI / 2, n4 = 12 - m3, s4 = new r(22 - n4, -(i4.imageName ? n4 : 0)), o5 = new r(...v2);
	            T2._rotateAround(t4, e5)._add(s4)._add(o5), I2._rotateAround(t4, e5)._add(s4)._add(o5), E2._rotateAround(t4, e5)._add(s4)._add(o5), M2._rotateAround(t4, e5)._add(s4)._add(o5);
	          }
	          if (u3) {
	            const e5 = Math.sin(u3), t4 = Math.cos(u3), r2 = [t4, -e5, e5, t4];
	            T2._matMult(r2), I2._matMult(r2), E2._matMult(r2), M2._matMult(r2);
	          }
	          const k2 = new r(0, 0), F2 = new r(0, 0);
	          c3.push({ tl: T2, tr: I2, bl: E2, br: M2, tex: o4, writingMode: t3.writingMode, glyphOffset: g3, sectionIndex: i4.sectionIndex, isSDF: p3, pixelOffsetTL: k2, pixelOffsetBR: F2, minFontScaleX: 0, minFontScaleY: 0 });
	        }
	        return c3;
	      }(0, n2, l2, s2, o2, a2, i2, e2.allowVerticalPlacement), g2 = e2.textSizeData;
	      let x2 = null;
	      "source" === g2.kind ? (x2 = [Wc * s2.layout.get("text-size").evaluate(a2, {})], x2[0] > Jc && j(`${e2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : "composite" === g2.kind && (x2 = [Wc * d2.compositeTextSizes[0].evaluate(a2, {}, y2), Wc * d2.compositeTextSizes[1].evaluate(a2, {}, y2)], (x2[0] > Jc || x2[1] > Jc) && j(`${e2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), e2.addSymbols(e2.text, m2, x2, l2, o2, a2, c2, t2, u2.lineStartIndex, u2.lineLength, f2, y2);
	      for (const t3 of h2) p2[t3] = e2.text.placedSymbolArray.length - 1;
	      return 4 * m2.length;
	    }
	    function td(e2) {
	      for (const t2 in e2) return e2[t2];
	      return null;
	    }
	    function rd(e2, t2, r2, n2) {
	      const i2 = e2.compareText;
	      if (t2 in i2) {
	        const e3 = i2[t2];
	        for (let t3 = e3.length - 1; t3 >= 0; t3--) if (n2.dist(e3[t3]) < r2) return true;
	      } else i2[t2] = [];
	      return i2[t2].push(n2), false;
	    }
	    const nd = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
	    class id {
	      static from(e2) {
	        if (!(e2 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
	        const [t2, r2] = new Uint8Array(e2, 0, 2);
	        if (219 !== t2) throw new Error("Data does not appear to be in a KDBush format.");
	        const n2 = r2 >> 4;
	        if (1 !== n2) throw new Error(`Got v${n2} data when expected v1.`);
	        const i2 = nd[15 & r2];
	        if (!i2) throw new Error("Unrecognized array type.");
	        const [s2] = new Uint16Array(e2, 2, 1), [o2] = new Uint32Array(e2, 4, 1);
	        return new id(o2, s2, i2, e2);
	      }
	      constructor(e2, t2 = 64, r2 = Float64Array, n2) {
	        if (isNaN(e2) || e2 < 0) throw new Error(`Unpexpected numItems value: ${e2}.`);
	        this.numItems = +e2, this.nodeSize = Math.min(Math.max(+t2, 2), 65535), this.ArrayType = r2, this.IndexArrayType = e2 < 65536 ? Uint16Array : Uint32Array;
	        const i2 = nd.indexOf(this.ArrayType), s2 = 2 * e2 * this.ArrayType.BYTES_PER_ELEMENT, o2 = e2 * this.IndexArrayType.BYTES_PER_ELEMENT, a2 = (8 - o2 % 8) % 8;
	        if (i2 < 0) throw new Error(`Unexpected typed array class: ${r2}.`);
	        n2 && n2 instanceof ArrayBuffer ? (this.data = n2, this.ids = new this.IndexArrayType(this.data, 8, e2), this.coords = new this.ArrayType(this.data, 8 + o2 + a2, 2 * e2), this._pos = 2 * e2, this._finished = true) : (this.data = new ArrayBuffer(8 + s2 + o2 + a2), this.ids = new this.IndexArrayType(this.data, 8, e2), this.coords = new this.ArrayType(this.data, 8 + o2 + a2, 2 * e2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i2]), new Uint16Array(this.data, 2, 1)[0] = t2, new Uint32Array(this.data, 4, 1)[0] = e2);
	      }
	      add(e2, t2) {
	        const r2 = this._pos >> 1;
	        return this.ids[r2] = r2, this.coords[this._pos++] = e2, this.coords[this._pos++] = t2, r2;
	      }
	      finish() {
	        const e2 = this._pos >> 1;
	        if (e2 !== this.numItems) throw new Error(`Added ${e2} items when expected ${this.numItems}.`);
	        return sd(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
	      }
	      range(e2, t2, r2, n2) {
	        if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
	        const { ids: i2, coords: s2, nodeSize: o2 } = this, a2 = [0, i2.length - 1, 0], l2 = [];
	        for (; a2.length; ) {
	          const u2 = a2.pop() || 0, c2 = a2.pop() || 0, h2 = a2.pop() || 0;
	          if (c2 - h2 <= o2) {
	            for (let o3 = h2; o3 <= c2; o3++) {
	              const a3 = s2[2 * o3], u3 = s2[2 * o3 + 1];
	              a3 >= e2 && a3 <= r2 && u3 >= t2 && u3 <= n2 && l2.push(i2[o3]);
	            }
	            continue;
	          }
	          const p2 = h2 + c2 >> 1, f2 = s2[2 * p2], d2 = s2[2 * p2 + 1];
	          f2 >= e2 && f2 <= r2 && d2 >= t2 && d2 <= n2 && l2.push(i2[p2]), (0 === u2 ? e2 <= f2 : t2 <= d2) && (a2.push(h2), a2.push(p2 - 1), a2.push(1 - u2)), (0 === u2 ? r2 >= f2 : n2 >= d2) && (a2.push(p2 + 1), a2.push(c2), a2.push(1 - u2));
	        }
	        return l2;
	      }
	      within(e2, t2, r2) {
	        if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
	        const { ids: n2, coords: i2, nodeSize: s2 } = this, o2 = [0, n2.length - 1, 0], a2 = [], l2 = r2 * r2;
	        for (; o2.length; ) {
	          const u2 = o2.pop() || 0, c2 = o2.pop() || 0, h2 = o2.pop() || 0;
	          if (c2 - h2 <= s2) {
	            for (let r3 = h2; r3 <= c2; r3++) ud(i2[2 * r3], i2[2 * r3 + 1], e2, t2) <= l2 && a2.push(n2[r3]);
	            continue;
	          }
	          const p2 = h2 + c2 >> 1, f2 = i2[2 * p2], d2 = i2[2 * p2 + 1];
	          ud(f2, d2, e2, t2) <= l2 && a2.push(n2[p2]), (0 === u2 ? e2 - r2 <= f2 : t2 - r2 <= d2) && (o2.push(h2), o2.push(p2 - 1), o2.push(1 - u2)), (0 === u2 ? e2 + r2 >= f2 : t2 + r2 >= d2) && (o2.push(p2 + 1), o2.push(c2), o2.push(1 - u2));
	        }
	        return a2;
	      }
	    }
	    function sd(e2, t2, r2, n2, i2, s2) {
	      if (i2 - n2 <= r2) return;
	      const o2 = n2 + i2 >> 1;
	      od(e2, t2, o2, n2, i2, s2), sd(e2, t2, r2, n2, o2 - 1, 1 - s2), sd(e2, t2, r2, o2 + 1, i2, 1 - s2);
	    }
	    function od(e2, t2, r2, n2, i2, s2) {
	      for (; i2 > n2; ) {
	        if (i2 - n2 > 600) {
	          const o3 = i2 - n2 + 1, a3 = r2 - n2 + 1, l3 = Math.log(o3), u2 = 0.5 * Math.exp(2 * l3 / 3), c2 = 0.5 * Math.sqrt(l3 * u2 * (o3 - u2) / o3) * (a3 - o3 / 2 < 0 ? -1 : 1);
	          od(e2, t2, r2, Math.max(n2, Math.floor(r2 - a3 * u2 / o3 + c2)), Math.min(i2, Math.floor(r2 + (o3 - a3) * u2 / o3 + c2)), s2);
	        }
	        const o2 = t2[2 * r2 + s2];
	        let a2 = n2, l2 = i2;
	        for (ad(e2, t2, n2, r2), t2[2 * i2 + s2] > o2 && ad(e2, t2, n2, i2); a2 < l2; ) {
	          for (ad(e2, t2, a2, l2), a2++, l2--; t2[2 * a2 + s2] < o2; ) a2++;
	          for (; t2[2 * l2 + s2] > o2; ) l2--;
	        }
	        t2[2 * n2 + s2] === o2 ? ad(e2, t2, n2, l2) : (l2++, ad(e2, t2, l2, i2)), l2 <= r2 && (n2 = l2 + 1), r2 <= l2 && (i2 = l2 - 1);
	      }
	    }
	    function ad(e2, t2, r2, n2) {
	      ld(e2, r2, n2), ld(t2, 2 * r2, 2 * n2), ld(t2, 2 * r2 + 1, 2 * n2 + 1);
	    }
	    function ld(e2, t2, r2) {
	      const n2 = e2[t2];
	      e2[t2] = e2[r2], e2[r2] = n2;
	    }
	    function ud(e2, t2, r2, n2) {
	      const i2 = e2 - r2, s2 = t2 - n2;
	      return i2 * i2 + s2 * s2;
	    }
	    var cd;
	    e.cG = void 0, (cd = e.cG || (e.cG = {})).create = "create", cd.load = "load", cd.fullLoad = "fullLoad";
	    let hd = null, pd = [];
	    const fd = 1e3 / 60, dd = "loadTime", yd = "fullLoadTime", md = { mark(e2) {
	      performance.mark(e2);
	    }, frame(e2) {
	      const t2 = e2;
	      null != hd && pd.push(t2 - hd), hd = t2;
	    }, clearMetrics() {
	      hd = null, pd = [], performance.clearMeasures(dd), performance.clearMeasures(yd);
	      for (const t2 in e.cG) performance.clearMarks(e.cG[t2]);
	    }, getPerformanceMetrics() {
	      performance.measure(dd, e.cG.create, e.cG.load), performance.measure(yd, e.cG.create, e.cG.fullLoad);
	      const t2 = performance.getEntriesByName(dd)[0].duration, r2 = performance.getEntriesByName(yd)[0].duration, n2 = pd.length, i2 = 1 / (pd.reduce((e2, t3) => e2 + t3, 0) / n2 / 1e3), s2 = pd.filter((e2) => e2 > fd).reduce((e2, t3) => e2 + (t3 - fd) / fd, 0);
	      return { loadTime: t2, fullLoadTime: r2, fps: i2, percentDroppedFrames: s2 / (n2 + s2) * 100, totalFrames: n2 };
	    } };
	    e.$ = h, e.A = f, e.B = ss, e.C = es, e.D = Ns, e.E = ge, e.F = function([e2, t2, r2]) {
	      return t2 += 90, t2 *= Math.PI / 180, r2 *= Math.PI / 180, { x: e2 * Math.cos(t2) * Math.sin(r2), y: e2 * Math.sin(t2) * Math.sin(r2), z: e2 * Math.cos(r2) };
	    }, e.G = dr, e.H = ks, e.I = Lc, e.J = rs, e.K = function(e2) {
	      if (null == Y) {
	        const t2 = e2.navigator ? e2.navigator.userAgent : null;
	        Y = !!e2.safari || !(!t2 || !(/\b(iPad|iPhone|iPod)\b/.test(t2) || t2.match("Safari") && !t2.match("Chrome")));
	      }
	      return Y;
	    }, e.L = class {
	      constructor(e2, t2) {
	        this.target = e2, this.mapId = t2, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new gh(() => this.process()), this.subscription = Q(this.target, "message", (e3) => this.receive(e3), false), this.globalScope = X(self) ? e2 : window;
	      }
	      registerMessageHandler(e2, t2) {
	        this.messageHandlers[e2] = t2;
	      }
	      unregisterMessageHandler(e2) {
	        delete this.messageHandlers[e2];
	      }
	      sendAsync(e2, t2) {
	        return new Promise((r2, n2) => {
	          const i2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), s2 = t2 ? Q(t2.signal, "abort", () => {
	            null == s2 || s2.unsubscribe(), delete this.resolveRejects[i2];
	            const t3 = { id: i2, type: "<cancel>", origin: location.origin, targetMapId: e2.targetMapId, sourceMapId: this.mapId };
	            this.target.postMessage(t3);
	          }, xh) : null;
	          this.resolveRejects[i2] = { resolve: (e3) => {
	            null == s2 || s2.unsubscribe(), r2(e3);
	          }, reject: (e3) => {
	            null == s2 || s2.unsubscribe(), n2(e3);
	          } };
	          const o2 = [], a2 = Object.assign(Object.assign({}, e2), { id: i2, sourceMapId: this.mapId, origin: location.origin, data: ps(e2.data, o2) });
	          this.target.postMessage(a2, { transfer: o2 });
	        });
	      }
	      receive(e2) {
	        const t2 = e2.data, r2 = t2.id;
	        if (!("file://" !== t2.origin && "file://" !== location.origin && "resource://android" !== t2.origin && "resource://android" !== location.origin && t2.origin !== location.origin || t2.targetMapId && this.mapId !== t2.targetMapId)) {
	          if ("<cancel>" === t2.type) {
	            delete this.tasks[r2];
	            const e3 = this.abortControllers[r2];
	            return delete this.abortControllers[r2], void (e3 && e3.abort());
	          }
	          if (X(self) || t2.mustQueue) return this.tasks[r2] = t2, this.taskQueue.push(r2), void this.invoker.trigger();
	          this.processTask(r2, t2);
	        }
	      }
	      process() {
	        if (0 === this.taskQueue.length) return;
	        const e2 = this.taskQueue.shift(), t2 = this.tasks[e2];
	        delete this.tasks[e2], this.taskQueue.length > 0 && this.invoker.trigger(), t2 && this.processTask(e2, t2);
	      }
	      processTask(e2, r2) {
	        return t(this, void 0, void 0, function* () {
	          if ("<response>" === r2.type) {
	            const t3 = this.resolveRejects[e2];
	            if (delete this.resolveRejects[e2], !t3) return;
	            return void (r2.error ? t3.reject(fs(r2.error)) : t3.resolve(fs(r2.data)));
	          }
	          if (!this.messageHandlers[r2.type]) return void this.completeTask(e2, new Error(`Could not find a registered handler for ${r2.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
	          const t2 = fs(r2.data), n2 = new AbortController();
	          this.abortControllers[e2] = n2;
	          try {
	            const i2 = yield this.messageHandlers[r2.type](r2.sourceMapId, t2, n2);
	            this.completeTask(e2, null, i2);
	          } catch (t3) {
	            this.completeTask(e2, t3);
	          }
	        });
	      }
	      completeTask(e2, t2, r2) {
	        const n2 = [];
	        delete this.abortControllers[e2];
	        const i2 = { id: e2, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: t2 ? ps(t2) : null, data: ps(r2, n2) };
	        this.target.postMessage(i2, { transfer: n2 });
	      }
	      remove() {
	        this.invoker.remove(), this.subscription.unsubscribe();
	      }
	    }, e.M = le, e.N = function() {
	      var e2 = new f(16);
	      return f != Float32Array && (e2[1] = 0, e2[2] = 0, e2[3] = 0, e2[4] = 0, e2[6] = 0, e2[7] = 0, e2[8] = 0, e2[9] = 0, e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0), e2[0] = 1, e2[5] = 1, e2[10] = 1, e2[15] = 1, e2;
	    }, e.O = function(e2, t2, r2) {
	      var n2, i2, s2, o2, a2, l2, u2, c2, h2, p2, f2, d2, y2 = r2[0], m2 = r2[1], g2 = r2[2];
	      return t2 === e2 ? (e2[12] = t2[0] * y2 + t2[4] * m2 + t2[8] * g2 + t2[12], e2[13] = t2[1] * y2 + t2[5] * m2 + t2[9] * g2 + t2[13], e2[14] = t2[2] * y2 + t2[6] * m2 + t2[10] * g2 + t2[14], e2[15] = t2[3] * y2 + t2[7] * m2 + t2[11] * g2 + t2[15]) : (i2 = t2[1], s2 = t2[2], o2 = t2[3], a2 = t2[4], l2 = t2[5], u2 = t2[6], c2 = t2[7], h2 = t2[8], p2 = t2[9], f2 = t2[10], d2 = t2[11], e2[0] = n2 = t2[0], e2[1] = i2, e2[2] = s2, e2[3] = o2, e2[4] = a2, e2[5] = l2, e2[6] = u2, e2[7] = c2, e2[8] = h2, e2[9] = p2, e2[10] = f2, e2[11] = d2, e2[12] = n2 * y2 + a2 * m2 + h2 * g2 + t2[12], e2[13] = i2 * y2 + l2 * m2 + p2 * g2 + t2[13], e2[14] = s2 * y2 + u2 * m2 + f2 * g2 + t2[14], e2[15] = o2 * y2 + c2 * m2 + d2 * g2 + t2[15]), e2;
	    }, e.P = r, e.Q = function(e2, t2, r2) {
	      var n2 = r2[0], i2 = r2[1], s2 = r2[2];
	      return e2[0] = t2[0] * n2, e2[1] = t2[1] * n2, e2[2] = t2[2] * n2, e2[3] = t2[3] * n2, e2[4] = t2[4] * i2, e2[5] = t2[5] * i2, e2[6] = t2[6] * i2, e2[7] = t2[7] * i2, e2[8] = t2[8] * s2, e2[9] = t2[9] * s2, e2[10] = t2[10] * s2, e2[11] = t2[11] * s2, e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
	    }, e.R = xl, e.S = function(e2, t2, r2) {
	      var n2 = t2[0], i2 = t2[1], s2 = t2[2], o2 = t2[3], a2 = t2[4], l2 = t2[5], u2 = t2[6], c2 = t2[7], h2 = t2[8], p2 = t2[9], f2 = t2[10], d2 = t2[11], y2 = t2[12], m2 = t2[13], g2 = t2[14], x2 = t2[15], v2 = r2[0], b2 = r2[1], w2 = r2[2], _2 = r2[3];
	      return e2[0] = v2 * n2 + b2 * a2 + w2 * h2 + _2 * y2, e2[1] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, e2[2] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, e2[3] = v2 * o2 + b2 * c2 + w2 * d2 + _2 * x2, e2[4] = (v2 = r2[4]) * n2 + (b2 = r2[5]) * a2 + (w2 = r2[6]) * h2 + (_2 = r2[7]) * y2, e2[5] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, e2[6] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, e2[7] = v2 * o2 + b2 * c2 + w2 * d2 + _2 * x2, e2[8] = (v2 = r2[8]) * n2 + (b2 = r2[9]) * a2 + (w2 = r2[10]) * h2 + (_2 = r2[11]) * y2, e2[9] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, e2[10] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, e2[11] = v2 * o2 + b2 * c2 + w2 * d2 + _2 * x2, e2[12] = (v2 = r2[12]) * n2 + (b2 = r2[13]) * a2 + (w2 = r2[14]) * h2 + (_2 = r2[15]) * y2, e2[13] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, e2[14] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, e2[15] = v2 * o2 + b2 * c2 + w2 * d2 + _2 * x2, e2;
	    }, e.T = El, e.U = function(e2, t2) {
	      const r2 = {};
	      for (let n2 = 0; n2 < t2.length; n2++) {
	        const i2 = t2[n2];
	        i2 in e2 && (r2[i2] = e2[i2]);
	      }
	      return r2;
	    }, e.V = bh, e.W = L, e.X = Ah, e.Y = Sh, e.Z = c, e._ = t, e.a = oe, e.a$ = v, e.a0 = K, e.a1 = Bh, e.a2 = Ih, e.a3 = Eh, e.a4 = k, e.a5 = function(e2, t2, r2) {
	      if (!e2) return t2 || {};
	      if (!t2) return e2 || {};
	      const n2 = Lh(e2), i2 = Lh(t2);
	      !function(e3, t3) {
	        t3.removeAll && (e3.add.clear(), e3.update.clear(), e3.remove.clear(), t3.remove.clear());
	        for (const r3 of t3.remove) e3.add.delete(r3), e3.update.delete(r3);
	        for (const [r3, n3] of t3.update) {
	          const i3 = e3.update.get(r3);
	          i3 && (t3.update.set(r3, Ch(i3, n3)), e3.update.delete(r3));
	        }
	      }(n2, i2);
	      const s2 = {};
	      if ((n2.removeAll || i2.removeAll) && (s2.removeAll = true), s2.remove = /* @__PURE__ */ new Set([...n2.remove, ...i2.remove]), s2.add = new Map([...n2.add, ...i2.add]), s2.update = new Map([...n2.update, ...i2.update]), s2.remove.size && s2.add.size) for (const e3 of s2.add.keys()) s2.remove.delete(e3);
	      return function(e3) {
	        const t3 = {};
	        return e3.removeAll && (t3.removeAll = e3.removeAll), e3.remove && (t3.remove = Array.from(e3.remove)), e3.add && (t3.add = Array.from(e3.add.values())), e3.update && (t3.update = Array.from(e3.update.values())), t3;
	      }(s2);
	    }, e.a6 = function(e2, t2) {
	      if (null == e2) return true;
	      if ("Feature" === e2.type) return null != Vh(e2, t2);
	      if ("FeatureCollection" === e2.type) {
	        const r2 = /* @__PURE__ */ new Set();
	        for (const n2 of e2.features) {
	          const e3 = Vh(n2, t2);
	          if (null == e3) return false;
	          if (r2.has(e3)) return false;
	          r2.add(e3);
	        }
	        return true;
	      }
	      return false;
	    }, e.a7 = function(e2, t2) {
	      const r2 = /* @__PURE__ */ new Map();
	      if (null == e2) ;
	      else if ("Feature" === e2.type) r2.set(Vh(e2, t2), e2);
	      else for (const n2 of e2.features) r2.set(Vh(n2, t2), n2);
	      return r2;
	    }, e.a8 = function(e2, t2, r2) {
	      var n2, i2;
	      if (t2.removeAll) e2.clear();
	      else if (t2.remove) for (const r3 of t2.remove) e2.delete(r3);
	      if (t2.add) for (const n3 of t2.add) {
	        const t3 = Vh(n3, r2);
	        null != t3 && e2.set(t3, n3);
	      }
	      if (t2.update) for (const r3 of t2.update) {
	        let t3 = e2.get(r3.id);
	        if (!t3) continue;
	        const s2 = !!r3.newGeometry, o2 = r3.removeAllProperties || (null === (n2 = r3.removeProperties) || void 0 === n2 ? void 0 : n2.length) > 0 || (null === (i2 = r3.addOrUpdateProperties) || void 0 === i2 ? void 0 : i2.length) > 0;
	        if ((s2 || o2) && (t3 = Object.assign({}, t3), e2.set(r3.id, t3), s2 && (t3.geometry = r3.newGeometry), o2)) {
	          if (t3.properties = r3.removeAllProperties ? {} : Object.assign({}, t3.properties || {}), r3.removeProperties) for (const e3 of r3.removeProperties) delete t3.properties[e3];
	          if (r3.addOrUpdateProperties) for (const { key: e3, value: n3 } of r3.addOrUpdateProperties) t3.properties[e3] = n3;
	        }
	      }
	    }, e.a9 = bf, e.aA = function(e2, t2) {
	      var r2 = t2[0], n2 = t2[1], i2 = t2[2], s2 = t2[3], o2 = t2[4], a2 = t2[5], l2 = t2[6], u2 = t2[7], c2 = t2[8], h2 = t2[9], p2 = t2[10], f2 = t2[11], d2 = t2[12], y2 = t2[13], m2 = t2[14], g2 = t2[15], x2 = r2 * a2 - n2 * o2, v2 = r2 * l2 - i2 * o2, b2 = r2 * u2 - s2 * o2, w2 = n2 * l2 - i2 * a2, _2 = n2 * u2 - s2 * a2, S2 = i2 * u2 - s2 * l2, A2 = c2 * y2 - h2 * d2, T2 = c2 * m2 - p2 * d2, I2 = c2 * g2 - f2 * d2, E2 = h2 * m2 - p2 * y2, M2 = h2 * g2 - f2 * y2, k2 = p2 * g2 - f2 * m2, F2 = x2 * k2 - v2 * M2 + b2 * E2 + w2 * I2 - _2 * T2 + S2 * A2;
	      return F2 ? (e2[0] = (a2 * k2 - l2 * M2 + u2 * E2) * (F2 = 1 / F2), e2[1] = (i2 * M2 - n2 * k2 - s2 * E2) * F2, e2[2] = (y2 * S2 - m2 * _2 + g2 * w2) * F2, e2[3] = (p2 * _2 - h2 * S2 - f2 * w2) * F2, e2[4] = (l2 * I2 - o2 * k2 - u2 * T2) * F2, e2[5] = (r2 * k2 - i2 * I2 + s2 * T2) * F2, e2[6] = (m2 * b2 - d2 * S2 - g2 * v2) * F2, e2[7] = (c2 * S2 - p2 * b2 + f2 * v2) * F2, e2[8] = (o2 * M2 - a2 * I2 + u2 * A2) * F2, e2[9] = (n2 * I2 - r2 * M2 - s2 * A2) * F2, e2[10] = (d2 * _2 - y2 * b2 + g2 * x2) * F2, e2[11] = (h2 * b2 - c2 * _2 - f2 * x2) * F2, e2[12] = (a2 * T2 - o2 * E2 - l2 * A2) * F2, e2[13] = (r2 * E2 - n2 * T2 + i2 * A2) * F2, e2[14] = (y2 * v2 - d2 * w2 - m2 * x2) * F2, e2[15] = (c2 * w2 - h2 * v2 + p2 * x2) * F2, e2) : null;
	    }, e.aB = E, e.aC = function(e2) {
	      var t2 = e2[0], r2 = e2[1];
	      return Math.sqrt(t2 * t2 + r2 * r2);
	    }, e.aD = function(e2) {
	      return e2[0] = 0, e2[1] = 0, e2;
	    }, e.aE = function(e2, t2, r2) {
	      return e2[0] = t2[0] * r2, e2[1] = t2[1] * r2, e2;
	    }, e.aF = nh, e.aG = A, e.aH = function(e2, t2, n2, i2) {
	      const s2 = t2.y - e2.y, o2 = t2.x - e2.x, a2 = i2.y - n2.y, l2 = i2.x - n2.x, u2 = a2 * o2 - l2 * s2;
	      if (0 === u2) return null;
	      const c2 = (l2 * (e2.y - n2.y) - a2 * (e2.x - n2.x)) / u2;
	      return new r(e2.x + c2 * o2, e2.y + c2 * s2);
	    }, e.aI = Af, e.aJ = $a, e.aK = function(e2) {
	      let t2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
	      for (const s2 of e2) t2 = Math.min(t2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
	      return [t2, r2, n2, i2];
	    }, e.aL = lc, e.aM = F, e.aN = function(e2, t2, r2, n2, i2 = false) {
	      if (!r2[0] && !r2[1]) return [0, 0];
	      const s2 = i2 ? "map" === n2 ? -e2.bearingInRadians : 0 : "viewport" === n2 ? e2.bearingInRadians : 0;
	      if (s2) {
	        const e3 = Math.sin(s2), t3 = Math.cos(s2);
	        r2 = [r2[0] * t3 - r2[1] * e3, r2[0] * e3 + r2[1] * t3];
	      }
	      return [i2 ? r2[0] : F(t2, r2[0], e2.zoom), i2 ? r2[1] : F(t2, r2[1], e2.zoom)];
	    }, e.aP = eh, e.aQ = Jf, e.aR = $c, e.aS = id, e.aT = Qs, e.aU = au, e.aV = Oo, e.aW = ta, e.aX = Wo, e.aY = te, e.aZ = Mh, e.a_ = b, e.aa = kh, e.ab = vf, e.ac = 25, e.ad = Dh, e.ae = (e2) => {
	      const t2 = window.document.createElement("video");
	      return t2.muted = true, new Promise((r2) => {
	        t2.onloadstart = () => {
	          r2(t2);
	        };
	        for (const r3 of e2) {
	          const e3 = window.document.createElement("source");
	          pe(r3) || (t2.crossOrigin = "Anonymous"), e3.src = r3, t2.appendChild(e3);
	        }
	      });
	    }, e.af = Fe, e.ag = function() {
	      return R++;
	    }, e.ah = Eo, e.ai = ah, e.aj = pi, e.ak = La, e.al = Rh, e.am = function(e2) {
	      const t2 = {};
	      if (e2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (e3, r2, n2, i2) => {
	        const s2 = n2 || i2;
	        return t2[r2] = !s2 || s2.toLowerCase(), "";
	      }), t2["max-age"]) {
	        const e3 = parseInt(t2["max-age"], 10);
	        isNaN(e3) ? delete t2["max-age"] : t2["max-age"] = e3;
	      }
	      return t2;
	    }, e.an = C, e.ao = 85.051129, e.ap = ee, e.aq = function(e2) {
	      return Math.pow(2, e2);
	    }, e.ar = y, e.as = Th, e.at = function(e2) {
	      return Math.log(e2) / Math.LN2;
	    }, e.au = function(e2) {
	      var t2 = e2[0], r2 = e2[1];
	      return t2 * t2 + r2 * r2;
	    }, e.av = class {
	      constructor(e2, t2) {
	        this.max = e2, this.onRemove = t2, this.reset();
	      }
	      reset() {
	        for (const e2 in this.data) for (const t2 of this.data[e2]) t2.timeout && clearTimeout(t2.timeout), this.onRemove(t2.value);
	        return this.data = {}, this.order = [], this;
	      }
	      add(e2, t2, r2) {
	        const n2 = e2.wrapped().key;
	        void 0 === this.data[n2] && (this.data[n2] = []);
	        const i2 = { value: t2, timeout: void 0 };
	        if (void 0 !== r2 && (i2.timeout = setTimeout(() => {
	          this.remove(e2, i2);
	        }, r2)), this.data[n2].push(i2), this.order.push(n2), this.order.length > this.max) {
	          const e3 = this._getAndRemoveByKey(this.order[0]);
	          e3 && this.onRemove(e3);
	        }
	        return this;
	      }
	      has(e2) {
	        return e2.wrapped().key in this.data;
	      }
	      getAndRemove(e2) {
	        return this.has(e2) ? this._getAndRemoveByKey(e2.wrapped().key) : null;
	      }
	      _getAndRemoveByKey(e2) {
	        const t2 = this.data[e2].shift();
	        return t2.timeout && clearTimeout(t2.timeout), 0 === this.data[e2].length && delete this.data[e2], this.order.splice(this.order.indexOf(e2), 1), t2.value;
	      }
	      getByKey(e2) {
	        const t2 = this.data[e2];
	        return t2 ? t2[0].value : null;
	      }
	      get(e2) {
	        return this.has(e2) ? this.data[e2.wrapped().key][0].value : null;
	      }
	      remove(e2, t2) {
	        if (!this.has(e2)) return this;
	        const r2 = e2.wrapped().key, n2 = void 0 === t2 ? 0 : this.data[r2].indexOf(t2), i2 = this.data[r2][n2];
	        return this.data[r2].splice(n2, 1), i2.timeout && clearTimeout(i2.timeout), 0 === this.data[r2].length && delete this.data[r2], this.onRemove(i2.value), this.order.splice(this.order.indexOf(r2), 1), this;
	      }
	      setMaxSize(e2) {
	        for (this.max = e2; this.order.length > this.max; ) {
	          const e3 = this._getAndRemoveByKey(this.order[0]);
	          e3 && this.onRemove(e3);
	        }
	        return this;
	      }
	      filter(e2) {
	        const t2 = [];
	        for (const r2 in this.data) for (const n2 of this.data[r2]) e2(n2.value) || t2.push(n2);
	        for (const e3 of t2) this.remove(e3.value.tileID, e3);
	      }
	    }, e.aw = function(e2) {
	      if (!e2.length) return /* @__PURE__ */ new Set();
	      const t2 = Math.max(...e2.map((e3) => e3.canonical.z));
	      let r2 = 1 / 0, n2 = -1 / 0, i2 = 1 / 0, s2 = -1 / 0;
	      const o2 = [];
	      for (const a3 of e2) {
	        const { x: e3, y: l2, z: u2 } = a3.canonical, c2 = Math.pow(2, t2 - u2), h2 = e3 * c2, p2 = l2 * c2;
	        o2.push({ id: a3, x: h2, y: p2 }), h2 < r2 && (r2 = h2), h2 > n2 && (n2 = h2), p2 < i2 && (i2 = p2), p2 > s2 && (s2 = p2);
	      }
	      const a2 = /* @__PURE__ */ new Set();
	      for (const e3 of o2) e3.x !== r2 && e3.x !== n2 && e3.y !== i2 && e3.y !== s2 || a2.add(e3.id);
	      return a2;
	    }, e.ax = function(e2, t2) {
	      let r2 = 0, n2 = 0;
	      if ("constant" === e2.kind) n2 = e2.layoutSize;
	      else if ("source" !== e2.kind) {
	        const { interpolationType: i2, minZoom: s2, maxZoom: o2 } = e2, a2 = i2 ? C(pr.interpolationFactor(i2, t2, s2, o2), 0, 1) : 0;
	        "camera" === e2.kind ? n2 = dr.number(e2.minSize, e2.maxSize, a2) : r2 = a2;
	      }
	      return { uSizeT: r2, uSize: n2 };
	    }, e.az = function(e2, { uSize: t2, uSizeT: r2 }, { lowerSize: n2, upperSize: i2 }) {
	      return "source" === e2.kind ? n2 / Wc : "composite" === e2.kind ? dr.number(n2 / Wc, i2 / Wc, r2) : t2;
	    }, e.b = Z, e.b$ = class extends ga {
	      constructor(e2, t2) {
	        super(e2, t2), this.current = wa;
	      }
	      set(e2) {
	        if (e2[12] !== this.current[12] || e2[0] !== this.current[0]) return this.current = e2, void this.gl.uniformMatrix4fv(this.location, false, e2);
	        for (let t2 = 1; t2 < 16; t2++) if (e2[t2] !== this.current[t2]) {
	          this.current = e2, this.gl.uniformMatrix4fv(this.location, false, e2);
	          break;
	        }
	      }
	    }, e.b0 = function(e2) {
	      var t2 = new f(3);
	      return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2;
	    }, e.b1 = function(e2, t2, r2) {
	      return e2[0] = t2[0] - r2[0], e2[1] = t2[1] - r2[1], e2[2] = t2[2] - r2[2], e2;
	    }, e.b2 = function(e2, t2) {
	      var r2 = t2[0], n2 = t2[1], i2 = t2[2], s2 = r2 * r2 + n2 * n2 + i2 * i2;
	      return s2 > 0 && (s2 = 1 / Math.sqrt(s2)), e2[0] = t2[0] * s2, e2[1] = t2[1] * s2, e2[2] = t2[2] * s2, e2;
	    }, e.b3 = w, e.b4 = function(e2, t2) {
	      return e2[0] * t2[0] + e2[1] * t2[1] + e2[2] * t2[2];
	    }, e.b5 = function(e2, t2, r2) {
	      return e2[0] = t2[0] * r2[0], e2[1] = t2[1] * r2[1], e2[2] = t2[2] * r2[2], e2[3] = t2[3] * r2[3], e2;
	    }, e.b6 = g, e.b7 = function(e2, t2, r2) {
	      const n2 = t2[0] * r2[0] + t2[1] * r2[1] + t2[2] * r2[2];
	      return 0 === n2 ? null : (-(e2[0] * r2[0] + e2[1] * r2[1] + e2[2] * r2[2]) - r2[3]) / n2;
	    }, e.b8 = S, e.b9 = function(e2, t2, r2) {
	      return e2[0] = t2[0] * r2, e2[1] = t2[1] * r2, e2[2] = t2[2] * r2, e2[3] = t2[3] * r2, e2;
	    }, e.bA = I, e.bB = function(e2, t2, r2) {
	      var n2 = r2[0], i2 = r2[1], s2 = r2[2], o2 = r2[3], a2 = t2[0], l2 = t2[1], u2 = t2[2], c2 = i2 * u2 - s2 * l2, h2 = s2 * a2 - n2 * u2, p2 = n2 * l2 - i2 * a2;
	      return e2[0] = a2 + o2 * (c2 += c2) + i2 * (p2 += p2) - s2 * (h2 += h2), e2[1] = l2 + o2 * h2 + s2 * c2 - n2 * p2, e2[2] = u2 + o2 * p2 + n2 * h2 - i2 * c2, e2;
	    }, e.bC = function(e2, t2, r2) {
	      const n2 = (i2 = [e2[0], e2[1], e2[2], t2[0], t2[1], t2[2], r2[0], r2[1], r2[2]])[0] * ((c2 = i2[8]) * (o2 = i2[4]) - (a2 = i2[5]) * (u2 = i2[7])) + i2[1] * (-c2 * (s2 = i2[3]) + a2 * (l2 = i2[6])) + i2[2] * (u2 * s2 - o2 * l2);
	      var i2, s2, o2, a2, l2, u2, c2;
	      if (0 === n2) return null;
	      const h2 = w([], [t2[0], t2[1], t2[2]], [r2[0], r2[1], r2[2]]), p2 = w([], [r2[0], r2[1], r2[2]], [e2[0], e2[1], e2[2]]), f2 = w([], [e2[0], e2[1], e2[2]], [t2[0], t2[1], t2[2]]), d2 = b([], h2, -e2[3]);
	      return v(d2, d2, b([], p2, -t2[3])), v(d2, d2, b([], f2, -r2[3])), b(d2, d2, 1 / n2), d2;
	    }, e.bD = vh, e.bE = function() {
	      return new Float64Array(4);
	    }, e.bF = function(e2, t2, r2, n2) {
	      var i2 = [], s2 = [];
	      return i2[0] = t2[0] - r2[0], i2[1] = t2[1] - r2[1], i2[2] = t2[2] - r2[2], s2[0] = i2[0] * Math.cos(n2) - i2[1] * Math.sin(n2), s2[1] = i2[0] * Math.sin(n2) + i2[1] * Math.cos(n2), s2[2] = i2[2], e2[0] = s2[0] + r2[0], e2[1] = s2[1] + r2[1], e2[2] = s2[2] + r2[2], e2;
	    }, e.bG = function(e2, t2, r2, n2) {
	      var i2 = [], s2 = [];
	      return i2[0] = t2[0] - r2[0], i2[1] = t2[1] - r2[1], i2[2] = t2[2] - r2[2], s2[0] = i2[0], s2[1] = i2[1] * Math.cos(n2) - i2[2] * Math.sin(n2), s2[2] = i2[1] * Math.sin(n2) + i2[2] * Math.cos(n2), e2[0] = s2[0] + r2[0], e2[1] = s2[1] + r2[1], e2[2] = s2[2] + r2[2], e2;
	    }, e.bH = function(e2, t2, r2, n2) {
	      var i2 = [], s2 = [];
	      return i2[0] = t2[0] - r2[0], i2[1] = t2[1] - r2[1], i2[2] = t2[2] - r2[2], s2[0] = i2[2] * Math.sin(n2) + i2[0] * Math.cos(n2), s2[1] = i2[1], s2[2] = i2[2] * Math.cos(n2) - i2[0] * Math.sin(n2), e2[0] = s2[0] + r2[0], e2[1] = s2[1] + r2[1], e2[2] = s2[2] + r2[2], e2;
	    }, e.bI = function(e2, t2, r2) {
	      var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = t2[0], o2 = t2[1], a2 = t2[2], l2 = t2[3], u2 = t2[8], c2 = t2[9], h2 = t2[10], p2 = t2[11];
	      return t2 !== e2 && (e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15]), e2[0] = s2 * i2 - u2 * n2, e2[1] = o2 * i2 - c2 * n2, e2[2] = a2 * i2 - h2 * n2, e2[3] = l2 * i2 - p2 * n2, e2[8] = s2 * n2 + u2 * i2, e2[9] = o2 * n2 + c2 * i2, e2[10] = a2 * n2 + h2 * i2, e2[11] = l2 * n2 + p2 * i2, e2;
	    }, e.bJ = function(e2, t2) {
	      const r2 = D(e2, 360), n2 = D(t2, 360), i2 = n2 - r2, s2 = n2 > r2 ? i2 - 360 : i2 + 360;
	      return Math.abs(i2) < Math.abs(s2) ? i2 : s2;
	    }, e.bK = function(e2) {
	      return e2[0] = 0, e2[1] = 0, e2[2] = 0, e2;
	    }, e.bL = function(e2, t2, r2, n2) {
	      const i2 = Math.sqrt(e2 * e2 + t2 * t2), s2 = Math.sqrt(r2 * r2 + n2 * n2);
	      e2 /= i2, t2 /= i2, r2 /= s2, n2 /= s2;
	      const o2 = Math.acos(e2 * r2 + t2 * n2);
	      return -t2 * r2 + e2 * n2 > 0 ? o2 : -o2;
	    }, e.bM = function(e2, t2) {
	      const r2 = D(e2, 2 * Math.PI), n2 = D(t2, 2 * Math.PI);
	      return Math.min(Math.abs(r2 - n2), Math.abs(r2 - n2 + 2 * Math.PI), Math.abs(r2 - n2 - 2 * Math.PI));
	    }, e.bN = function() {
	      const e2 = {}, t2 = xe.$version;
	      for (const r2 in xe.$root) {
	        const n2 = xe.$root[r2];
	        if (n2.required) {
	          let i2 = null;
	          i2 = "version" === r2 ? t2 : "array" === n2.type ? [] : {}, null != i2 && (e2[r2] = i2);
	        }
	      }
	      return e2;
	    }, e.bO = ce, e.bP = ds, e.bQ = function e2(t2, r2) {
	      if (Array.isArray(t2)) {
	        if (!Array.isArray(r2) || t2.length !== r2.length) return false;
	        for (let n2 = 0; n2 < t2.length; n2++) if (!e2(t2[n2], r2[n2])) return false;
	        return true;
	      }
	      if ("object" == typeof t2 && null !== t2 && null !== r2) {
	        if ("object" != typeof r2) return false;
	        if (Object.keys(t2).length !== Object.keys(r2).length) return false;
	        for (const n2 in t2) if (!e2(t2[n2], r2[n2])) return false;
	        return true;
	      }
	      return t2 === r2;
	    }, e.bR = function(e2) {
	      e2 = e2.slice();
	      const t2 = /* @__PURE__ */ Object.create(null);
	      for (let r2 = 0; r2 < e2.length; r2++) t2[e2[r2].id] = e2[r2];
	      for (let r2 = 0; r2 < e2.length; r2++) "ref" in e2[r2] && (e2[r2] = be(e2[r2], t2[e2[r2].ref]));
	      return e2;
	    }, e.bS = function(e2, t2) {
	      if ("custom" === e2.type) return new mh(e2, t2);
	      switch (e2.type) {
	        case "background":
	          return new yh(e2, t2);
	        case "circle":
	          return new cl(e2, t2);
	        case "color-relief":
	          return new Fl(e2, t2);
	        case "fill":
	          return new bu(e2, t2);
	        case "fill-extrusion":
	          return new Ru(e2, t2);
	        case "heatmap":
	          return new wl(e2, t2);
	        case "hillshade":
	          return new Al(e2, t2);
	        case "line":
	          return new ec(e2, t2);
	        case "raster":
	          return new Hs(e2, t2);
	        case "symbol":
	          return new ph(e2, t2);
	      }
	    }, e.bT = (e2) => "raster" === e2.type, e.bU = U, e.bV = function(e2, t2) {
	      if (!e2) return [{ command: "setStyle", args: [t2] }];
	      let r2 = [];
	      try {
	        if (!we(e2.version, t2.version)) return [{ command: "setStyle", args: [t2] }];
	        we(e2.center, t2.center) || r2.push({ command: "setCenter", args: [t2.center] }), we(e2.state, t2.state) || r2.push({ command: "setGlobalState", args: [t2.state] }), we(e2.centerAltitude, t2.centerAltitude) || r2.push({ command: "setCenterAltitude", args: [t2.centerAltitude] }), we(e2.zoom, t2.zoom) || r2.push({ command: "setZoom", args: [t2.zoom] }), we(e2.bearing, t2.bearing) || r2.push({ command: "setBearing", args: [t2.bearing] }), we(e2.pitch, t2.pitch) || r2.push({ command: "setPitch", args: [t2.pitch] }), we(e2.roll, t2.roll) || r2.push({ command: "setRoll", args: [t2.roll] }), we(e2.sprite, t2.sprite) || r2.push({ command: "setSprite", args: [t2.sprite] }), we(e2.glyphs, t2.glyphs) || r2.push({ command: "setGlyphs", args: [t2.glyphs] }), we(e2.transition, t2.transition) || r2.push({ command: "setTransition", args: [t2.transition] }), we(e2.light, t2.light) || r2.push({ command: "setLight", args: [t2.light] }), we(e2.terrain, t2.terrain) || r2.push({ command: "setTerrain", args: [t2.terrain] }), we(e2.sky, t2.sky) || r2.push({ command: "setSky", args: [t2.sky] }), we(e2.projection, t2.projection) || r2.push({ command: "setProjection", args: [t2.projection] });
	        const n2 = {}, i2 = [];
	        !function(e3, t3, r3, n3) {
	          let i3;
	          for (i3 in t3 = t3 || {}, e3 = e3 || {}) Object.prototype.hasOwnProperty.call(e3, i3) && (Object.prototype.hasOwnProperty.call(t3, i3) || Ae(i3, r3, n3));
	          for (i3 in t3) Object.prototype.hasOwnProperty.call(t3, i3) && (Object.prototype.hasOwnProperty.call(e3, i3) ? we(e3[i3], t3[i3]) || ("geojson" === e3[i3].type && "geojson" === t3[i3].type && Ie(e3, t3, i3) ? _e(r3, { command: "setGeoJSONSourceData", args: [i3, t3[i3].data] }) : Te(i3, t3, r3, n3)) : Se(i3, t3, r3));
	        }(e2.sources, t2.sources, i2, n2);
	        const s2 = [];
	        e2.layers && e2.layers.forEach((e3) => {
	          "source" in e3 && n2[e3.source] ? r2.push({ command: "removeLayer", args: [e3.id] }) : s2.push(e3);
	        }), r2 = r2.concat(i2), function(e3, t3, r3) {
	          t3 = t3 || [];
	          const n3 = (e3 = e3 || []).map(Me), i3 = t3.map(Me), s3 = e3.reduce(ke, {}), o2 = t3.reduce(ke, {}), a2 = n3.slice(), l2 = /* @__PURE__ */ Object.create(null);
	          let u2, c2, h2, p2, f2;
	          for (let e4 = 0, t4 = 0; e4 < n3.length; e4++) u2 = n3[e4], Object.prototype.hasOwnProperty.call(o2, u2) ? t4++ : (_e(r3, { command: "removeLayer", args: [u2] }), a2.splice(a2.indexOf(u2, t4), 1));
	          for (let e4 = 0, t4 = 0; e4 < i3.length; e4++) u2 = i3[i3.length - 1 - e4], a2[a2.length - 1 - e4] !== u2 && (Object.prototype.hasOwnProperty.call(s3, u2) ? (_e(r3, { command: "removeLayer", args: [u2] }), a2.splice(a2.lastIndexOf(u2, a2.length - t4), 1)) : t4++, p2 = a2[a2.length - e4], _e(r3, { command: "addLayer", args: [o2[u2], p2] }), a2.splice(a2.length - e4, 0, u2), l2[u2] = true);
	          for (let e4 = 0; e4 < i3.length; e4++) if (u2 = i3[e4], c2 = s3[u2], h2 = o2[u2], !l2[u2] && !we(c2, h2)) if (we(c2.source, h2.source) && we(c2["source-layer"], h2["source-layer"]) && we(c2.type, h2.type)) {
	            for (f2 in Ee(c2.layout, h2.layout, r3, u2, null, "setLayoutProperty"), Ee(c2.paint, h2.paint, r3, u2, null, "setPaintProperty"), we(c2.filter, h2.filter) || _e(r3, { command: "setFilter", args: [u2, h2.filter] }), we(c2.minzoom, h2.minzoom) && we(c2.maxzoom, h2.maxzoom) || _e(r3, { command: "setLayerZoomRange", args: [u2, h2.minzoom, h2.maxzoom] }), c2) Object.prototype.hasOwnProperty.call(c2, f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? Ee(c2[f2], h2[f2], r3, u2, f2.slice(6), "setPaintProperty") : we(c2[f2], h2[f2]) || _e(r3, { command: "setLayerProperty", args: [u2, f2, h2[f2]] }));
	            for (f2 in h2) Object.prototype.hasOwnProperty.call(h2, f2) && !Object.prototype.hasOwnProperty.call(c2, f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? Ee(c2[f2], h2[f2], r3, u2, f2.slice(6), "setPaintProperty") : we(c2[f2], h2[f2]) || _e(r3, { command: "setLayerProperty", args: [u2, f2, h2[f2]] }));
	          } else _e(r3, { command: "removeLayer", args: [u2] }), p2 = a2[a2.lastIndexOf(u2) + 1], _e(r3, { command: "addLayer", args: [h2, p2] });
	        }(s2, t2.layers, r2);
	      } catch (e3) {
	        console.warn("Unable to compute style diff:", e3), r2 = [{ command: "setStyle", args: [t2] }];
	      }
	      return r2;
	    }, e.bW = function(e2) {
	      const t2 = [], r2 = e2.id;
	      return void 0 === r2 && t2.push({ message: `layers.${r2}: missing required property "id"` }), void 0 === e2.render && t2.push({ message: `layers.${r2}: missing required method "render"` }), e2.renderingMode && "2d" !== e2.renderingMode && "3d" !== e2.renderingMode && t2.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), t2;
	    }, e.bX = N, e.bY = $, e.bZ = class extends ga {
	      constructor(e2, t2) {
	        super(e2, t2), this.current = 0;
	      }
	      set(e2) {
	        this.current !== e2 && (this.current = e2, this.gl.uniform1i(this.location, e2));
	      }
	    }, e.b_ = ba, e.ba = function(e2, t2) {
	      return e2[0] * t2[0] + e2[1] * t2[1] + e2[2] * t2[2] + e2[3];
	    }, e.bb = Ph, e.bc = zh, e.bd = function(e2, t2, r2, n2, i2) {
	      var s2 = 1 / Math.tan(t2 / 2);
	      if (e2[0] = s2 / r2, e2[1] = 0, e2[2] = 0, e2[3] = 0, e2[4] = 0, e2[5] = s2, e2[6] = 0, e2[7] = 0, e2[8] = 0, e2[9] = 0, e2[11] = -1, e2[12] = 0, e2[13] = 0, e2[15] = 0, null != i2 && i2 !== 1 / 0) {
	        var o2 = 1 / (n2 - i2);
	        e2[10] = (i2 + n2) * o2, e2[14] = 2 * i2 * n2 * o2;
	      } else e2[10] = -1, e2[14] = -2 * n2;
	      return e2;
	    }, e.be = function(e2) {
	      var t2 = new f(16);
	      return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
	    }, e.bf = function(e2, t2, r2) {
	      var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = t2[0], o2 = t2[1], a2 = t2[2], l2 = t2[3], u2 = t2[4], c2 = t2[5], h2 = t2[6], p2 = t2[7];
	      return t2 !== e2 && (e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15]), e2[0] = s2 * i2 + u2 * n2, e2[1] = o2 * i2 + c2 * n2, e2[2] = a2 * i2 + h2 * n2, e2[3] = l2 * i2 + p2 * n2, e2[4] = u2 * i2 - s2 * n2, e2[5] = c2 * i2 - o2 * n2, e2[6] = h2 * i2 - a2 * n2, e2[7] = p2 * i2 - l2 * n2, e2;
	    }, e.bg = function(e2, t2, r2) {
	      var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = t2[4], o2 = t2[5], a2 = t2[6], l2 = t2[7], u2 = t2[8], c2 = t2[9], h2 = t2[10], p2 = t2[11];
	      return t2 !== e2 && (e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15]), e2[4] = s2 * i2 + u2 * n2, e2[5] = o2 * i2 + c2 * n2, e2[6] = a2 * i2 + h2 * n2, e2[7] = l2 * i2 + p2 * n2, e2[8] = u2 * i2 - s2 * n2, e2[9] = c2 * i2 - o2 * n2, e2[10] = h2 * i2 - a2 * n2, e2[11] = p2 * i2 - l2 * n2, e2;
	    }, e.bh = function() {
	      const e2 = new Float32Array(16);
	      return y(e2), e2;
	    }, e.bi = function() {
	      const e2 = new Float64Array(16);
	      return y(e2), e2;
	    }, e.bj = function() {
	      return new Float64Array(16);
	    }, e.bk = function(e2, t2, r2) {
	      const n2 = new Float64Array(4);
	      return I(n2, e2, t2 - 90, r2), n2;
	    }, e.bl = function(e2, t2, r2, n2) {
	      var i2, s2, o2, a2, l2, u2 = t2[0], c2 = t2[1], h2 = t2[2], f2 = t2[3], d2 = r2[0], y2 = r2[1], m2 = r2[2], g2 = r2[3];
	      return (s2 = u2 * d2 + c2 * y2 + h2 * m2 + f2 * g2) < 0 && (s2 = -s2, d2 = -d2, y2 = -y2, m2 = -m2, g2 = -g2), 1 - s2 > p ? (i2 = Math.acos(s2), o2 = Math.sin(i2), a2 = Math.sin((1 - n2) * i2) / o2, l2 = Math.sin(n2 * i2) / o2) : (a2 = 1 - n2, l2 = n2), e2[0] = a2 * u2 + l2 * d2, e2[1] = a2 * c2 + l2 * y2, e2[2] = a2 * h2 + l2 * m2, e2[3] = a2 * f2 + l2 * g2, e2;
	    }, e.bm = function(e2) {
	      const t2 = new Float64Array(9);
	      var r2, n2, i2, s2, o2, a2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2;
	      h2 = (i2 = (n2 = e2)[0]) * (l2 = i2 + i2), p2 = (s2 = n2[1]) * l2, d2 = (o2 = n2[2]) * l2, y2 = o2 * (u2 = s2 + s2), g2 = (a2 = n2[3]) * l2, x2 = a2 * u2, v2 = a2 * (c2 = o2 + o2), (r2 = t2)[0] = 1 - (f2 = s2 * u2) - (m2 = o2 * c2), r2[3] = p2 - v2, r2[6] = d2 + x2, r2[1] = p2 + v2, r2[4] = 1 - h2 - m2, r2[7] = y2 - g2, r2[2] = d2 - x2, r2[5] = y2 + g2, r2[8] = 1 - h2 - f2;
	      const b2 = te(-Math.asin(C(t2[2], -1, 1)));
	      let w2, _2;
	      return Math.hypot(t2[5], t2[8]) < 1e-3 ? (w2 = 0, _2 = -te(Math.atan2(t2[3], t2[4]))) : (w2 = te(0 === t2[5] && 0 === t2[8] ? 0 : Math.atan2(t2[5], t2[8])), _2 = te(0 === t2[1] && 0 === t2[0] ? 0 : Math.atan2(t2[1], t2[0]))), { roll: w2, pitch: b2 + 90, bearing: _2 };
	    }, e.bn = function(e2, t2) {
	      return e2.roll == t2.roll && e2.pitch == t2.pitch && e2.bearing == t2.bearing;
	    }, e.bo = It, e.bp = xa, e.bq = lu, e.br = uu, e.bs = ou, e.bt = P, e.bu = B, e.bv = Ot, e.bw = function(e2, t2, r2, n2, i2) {
	      return P(n2, i2, C((e2 - t2) / (r2 - t2), 0, 1));
	    }, e.bx = D, e.by = function() {
	      return new Float64Array(3);
	    }, e.bz = function(e2, t2, r2, n2) {
	      return e2[0] = t2[0] + r2[0] * n2, e2[1] = t2[1] + r2[1] * n2, e2[2] = t2[2] + r2[2] * n2, e2;
	    }, e.c = se, e.c$ = class {
	      constructor(e2) {
	        this._marks = { start: [e2.url, "start"].join("#"), end: [e2.url, "end"].join("#"), measure: e2.url.toString() }, performance.mark(this._marks.start);
	      }
	      finish() {
	        performance.mark(this._marks.end);
	        let e2 = performance.getEntriesByName(this._marks.measure);
	        return 0 === e2.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), e2 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), e2;
	      }
	    }, e.c0 = va, e.c1 = class extends ga {
	      constructor(e2, t2) {
	        super(e2, t2), this.current = [0, 0, 0];
	      }
	      set(e2) {
	        e2[0] === this.current[0] && e2[1] === this.current[1] && e2[2] === this.current[2] || (this.current = e2, this.gl.uniform3f(this.location, e2[0], e2[1], e2[2]));
	      }
	    }, e.c2 = class extends ga {
	      constructor(e2, t2) {
	        super(e2, t2), this.current = [0, 0];
	      }
	      set(e2) {
	        e2[0] === this.current[0] && e2[1] === this.current[1] || (this.current = e2, this.gl.uniform2f(this.location, e2[0], e2[1]));
	      }
	    }, e.c3 = d, e.c4 = function(e2, t2) {
	      var r2 = Math.sin(t2), n2 = Math.cos(t2);
	      return e2[0] = n2, e2[1] = r2, e2[2] = 0, e2[3] = -r2, e2[4] = n2, e2[5] = 0, e2[6] = 0, e2[7] = 0, e2[8] = 1, e2;
	    }, e.c5 = function(e2, t2, r2) {
	      var n2 = t2[0], i2 = t2[1], s2 = t2[2];
	      return e2[0] = n2 * r2[0] + i2 * r2[3] + s2 * r2[6], e2[1] = n2 * r2[1] + i2 * r2[4] + s2 * r2[7], e2[2] = n2 * r2[2] + i2 * r2[5] + s2 * r2[8], e2;
	    }, e.c6 = function(e2, t2, r2, n2, i2, s2, o2) {
	      var a2 = 1 / (t2 - r2), l2 = 1 / (n2 - i2), u2 = 1 / (s2 - o2);
	      return e2[0] = -2 * a2, e2[1] = 0, e2[2] = 0, e2[3] = 0, e2[4] = 0, e2[5] = -2 * l2, e2[6] = 0, e2[7] = 0, e2[8] = 0, e2[9] = 0, e2[10] = 2 * u2, e2[11] = 0, e2[12] = (t2 + r2) * a2, e2[13] = (i2 + n2) * l2, e2[14] = (o2 + s2) * u2, e2[15] = 1, e2;
	    }, e.c7 = class extends ga {
	      constructor(e2, t2) {
	        super(e2, t2), this.current = new Array();
	      }
	      set(e2) {
	        if (e2 != this.current) {
	          this.current = e2;
	          const t2 = new Float32Array(4 * e2.length);
	          for (let r2 = 0; r2 < e2.length; r2++) t2[4 * r2] = e2[r2].r, t2[4 * r2 + 1] = e2[r2].g, t2[4 * r2 + 2] = e2[r2].b, t2[4 * r2 + 3] = e2[r2].a;
	          this.gl.uniform4fv(this.location, t2);
	        }
	      }
	    }, e.c8 = class extends ga {
	      constructor(e2, t2) {
	        super(e2, t2), this.current = new Array();
	      }
	      set(e2) {
	        if (e2 != this.current) {
	          this.current = e2;
	          const t2 = new Float32Array(e2);
	          this.gl.uniform1fv(this.location, t2);
	        }
	      }
	    }, e.c9 = class extends yo {
	    }, e.cA = function(e2) {
	      return re[e2] || ne[e2];
	    }, e.cB = function(e2, t2, r2) {
	      var n2 = t2[0], i2 = t2[1];
	      return e2[0] = r2[0] * n2 + r2[4] * i2 + r2[12], e2[1] = r2[1] * n2 + r2[5] * i2 + r2[13], e2;
	    }, e.cC = function(e2, t2) {
	      const { x: r2, y: n2 } = kh.fromLngLat(t2);
	      return !(e2 < 0 || e2 > 25 || n2 < 0 || n2 >= 1 || r2 < 0 || r2 >= 1);
	    }, e.cD = function(e2, t2) {
	      return e2[0] = t2[0], e2[1] = 0, e2[2] = 0, e2[3] = 0, e2[4] = 0, e2[5] = t2[1], e2[6] = 0, e2[7] = 0, e2[8] = 0, e2[9] = 0, e2[10] = t2[2], e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0, e2[15] = 1, e2;
	    }, e.cE = class extends ro {
	    }, e.cF = md, e.cH = function(e2) {
	      return e2.message === ie;
	    }, e.cI = ue, e.cJ = function(e2, t2) {
	      oe.REGISTERED_PROTOCOLS[e2] = t2;
	    }, e.cK = function(e2) {
	      delete oe.REGISTERED_PROTOCOLS[e2];
	    }, e.cL = function(e2, t2) {
	      const r2 = {};
	      for (let n3 = 0; n3 < e2.length; n3++) {
	        const i2 = t2 && t2[e2[n3].id] || wi(e2[n3]);
	        t2 && (t2[e2[n3].id] = i2);
	        let s2 = r2[i2];
	        s2 || (s2 = r2[i2] = []), s2.push(e2[n3]);
	      }
	      const n2 = [];
	      for (const e3 in r2) n2.push(r2[e3]);
	      return n2;
	    }, e.cM = ls, e.cN = Oh, e.cO = wf, e.cP = Oc, e.cQ = function(t2) {
	      t2.bucket.createArrays(), t2.bucket.tilePixelRatio = k / (512 * t2.bucket.overscaling), t2.bucket.compareText = {}, t2.bucket.iconsNeedLinear = false;
	      const r2 = t2.bucket.layers[0], n2 = r2.layout, i2 = r2._unevaluatedLayout._values, s2 = { layoutIconSize: i2["icon-size"].possiblyEvaluate(new ks(t2.bucket.zoom + 1), t2.canonical), layoutTextSize: i2["text-size"].possiblyEvaluate(new ks(t2.bucket.zoom + 1), t2.canonical), textMaxSize: i2["text-size"].possiblyEvaluate(new ks(18)) };
	      if ("composite" === t2.bucket.textSizeData.kind) {
	        const { minZoom: e2, maxZoom: r3 } = t2.bucket.textSizeData;
	        s2.compositeTextSizes = [i2["text-size"].possiblyEvaluate(new ks(e2), t2.canonical), i2["text-size"].possiblyEvaluate(new ks(r3), t2.canonical)];
	      }
	      if ("composite" === t2.bucket.iconSizeData.kind) {
	        const { minZoom: e2, maxZoom: r3 } = t2.bucket.iconSizeData;
	        s2.compositeIconSizes = [i2["icon-size"].possiblyEvaluate(new ks(e2), t2.canonical), i2["icon-size"].possiblyEvaluate(new ks(r3), t2.canonical)];
	      }
	      const o2 = n2.get("text-line-height") * lc, a2 = "viewport" !== n2.get("text-rotation-alignment") && "point" !== n2.get("symbol-placement"), l2 = n2.get("text-keep-upright"), u2 = n2.get("text-size");
	      for (const i3 of t2.bucket.features) {
	        const c2 = n2.get("text-font").evaluate(i3, {}, t2.canonical).join(","), h2 = u2.evaluate(i3, {}, t2.canonical), p2 = s2.layoutTextSize.evaluate(i3, {}, t2.canonical), f2 = s2.layoutIconSize.evaluate(i3, {}, t2.canonical), d2 = { horizontal: {}, vertical: void 0 }, y2 = i3.text;
	        let m2, g2 = [0, 0];
	        if (y2) {
	          const s3 = y2.toString(), u3 = n2.get("text-letter-spacing").evaluate(i3, {}, t2.canonical) * lc, f3 = vs(s3) ? u3 : 0, m3 = n2.get("text-anchor").evaluate(i3, {}, t2.canonical), x3 = Wf(r2, i3, t2.canonical);
	          if (!x3) {
	            const e2 = n2.get("text-radial-offset").evaluate(i3, {}, t2.canonical);
	            g2 = e2 ? Kf(m3, [e2 * lc, Hf]) : n2.get("text-offset").evaluate(i3, {}, t2.canonical).map((e3) => e3 * lc);
	          }
	          let v3 = a2 ? "center" : n2.get("text-justify").evaluate(i3, {}, t2.canonical);
	          const b2 = "point" === n2.get("symbol-placement") ? n2.get("text-max-width").evaluate(i3, {}, t2.canonical) * lc : 1 / 0, w2 = () => {
	            t2.bucket.allowVerticalPlacement && xs(s3) && (d2.vertical = Nc(y2, t2.glyphMap, t2.glyphPositions, t2.imagePositions, c2, b2, o2, m3, "left", f3, g2, e.ay.vertical, true, p2, h2));
	          };
	          if (!a2 && x3) {
	            const r3 = /* @__PURE__ */ new Set();
	            if ("auto" === v3) for (let e2 = 0; e2 < x3.values.length; e2 += 2) r3.add(Jf(x3.values[e2]));
	            else r3.add(v3);
	            let n3 = false;
	            for (const i4 of r3) if (!d2.horizontal[i4]) if (n3) d2.horizontal[i4] = d2.horizontal[0];
	            else {
	              const r4 = Nc(y2, t2.glyphMap, t2.glyphPositions, t2.imagePositions, c2, b2, o2, "center", i4, f3, g2, e.ay.horizontal, false, p2, h2);
	              r4 && (d2.horizontal[i4] = r4, n3 = 1 === r4.positionedLines.length);
	            }
	            w2();
	          } else {
	            "auto" === v3 && (v3 = Jf(m3));
	            const r3 = Nc(y2, t2.glyphMap, t2.glyphPositions, t2.imagePositions, c2, b2, o2, m3, v3, f3, g2, e.ay.horizontal, false, p2, h2);
	            r3 && (d2.horizontal[v3] = r3), w2(), xs(s3) && a2 && l2 && (d2.vertical = Nc(y2, t2.glyphMap, t2.glyphPositions, t2.imagePositions, c2, b2, o2, m3, v3, f3, g2, e.ay.vertical, false, p2, h2));
	          }
	        }
	        let x2 = false;
	        if (i3.icon && i3.icon.name) {
	          const e2 = t2.imageMap[i3.icon.name];
	          e2 && (m2 = Zc(t2.imagePositions[i3.icon.name], n2.get("icon-offset").evaluate(i3, {}, t2.canonical), n2.get("icon-anchor").evaluate(i3, {}, t2.canonical)), x2 = !!e2.sdf, void 0 === t2.bucket.sdfIcons ? t2.bucket.sdfIcons = x2 : t2.bucket.sdfIcons !== x2 && j("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e2.pixelRatio !== t2.bucket.pixelRatio || 0 !== n2.get("icon-rotate").constantOr(1)) && (t2.bucket.iconsNeedLinear = true));
	        }
	        const v2 = td(d2.horizontal) || d2.vertical;
	        t2.bucket.iconsInText = !!v2 && v2.iconsInText, (v2 || m2) && Qf(t2.bucket, i3, d2, m2, t2.imageMap, s2, p2, f2, g2, x2, t2.canonical, t2.subdivisionGranularity);
	      }
	      t2.showCollisionBoxes && t2.bucket.generateCollisionDebugBuffers();
	    }, e.cR = mu, e.cS = Bu, e.cT = Zu, e.cU = Eu, e.cV = wc, e.cW = Au, e.cX = function(e2, t2, r2, n2, i2, s2) {
	      let o2 = Tf(e2, t2, r2, i2, 0);
	      return o2 = Tf(o2, t2, n2, s2, 1), o2;
	    }, e.cY = class {
	      constructor(e2) {
	        this.maxEntries = e2, this.map = /* @__PURE__ */ new Map();
	      }
	      get(e2) {
	        const t2 = this.map.get(e2);
	        return void 0 !== t2 && (this.map.delete(e2), this.map.set(e2, t2)), t2;
	      }
	      set(e2, t2) {
	        if (this.map.has(e2)) this.map.delete(e2);
	        else if (this.map.size >= this.maxEntries) {
	          const e3 = this.map.keys().next().value;
	          this.map.delete(e3);
	        }
	        this.map.set(e2, t2);
	      }
	      clear() {
	        this.map.clear();
	      }
	    }, e.cZ = ku, e.c_ = xf, e.ca = oc, e.cb = class extends go {
	    }, e.cc = bl, e.cd = function(e2) {
	      return e2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(e2) / Math.LN2));
	    }, e.ce = vl, e.cf = function(e2, t2, r2) {
	      var n2 = t2[0], i2 = t2[1], s2 = t2[2], o2 = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15];
	      return e2[0] = (r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12]) / (o2 = o2 || 1), e2[1] = (r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13]) / o2, e2[2] = (r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14]) / o2, e2;
	    }, e.cg = class extends no {
	    }, e.ch = class extends Ao {
	    }, e.ci = function(e2, t2) {
	      return e2[0] === t2[0] && e2[1] === t2[1] && e2[2] === t2[2] && e2[3] === t2[3] && e2[4] === t2[4] && e2[5] === t2[5] && e2[6] === t2[6] && e2[7] === t2[7] && e2[8] === t2[8] && e2[9] === t2[9] && e2[10] === t2[10] && e2[11] === t2[11] && e2[12] === t2[12] && e2[13] === t2[13] && e2[14] === t2[14] && e2[15] === t2[15];
	    }, e.cj = function(e2, t2) {
	      var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], o2 = e2[4], a2 = e2[5], l2 = e2[6], u2 = e2[7], c2 = e2[8], h2 = e2[9], f2 = e2[10], d2 = e2[11], y2 = e2[12], m2 = e2[13], g2 = e2[14], x2 = e2[15], v2 = t2[0], b2 = t2[1], w2 = t2[2], _2 = t2[3], S2 = t2[4], A2 = t2[5], T2 = t2[6], I2 = t2[7], E2 = t2[8], M2 = t2[9], k2 = t2[10], F2 = t2[11], D2 = t2[12], P2 = t2[13], B2 = t2[14], z2 = t2[15];
	      return Math.abs(r2 - v2) <= p * Math.max(1, Math.abs(r2), Math.abs(v2)) && Math.abs(n2 - b2) <= p * Math.max(1, Math.abs(n2), Math.abs(b2)) && Math.abs(i2 - w2) <= p * Math.max(1, Math.abs(i2), Math.abs(w2)) && Math.abs(s2 - _2) <= p * Math.max(1, Math.abs(s2), Math.abs(_2)) && Math.abs(o2 - S2) <= p * Math.max(1, Math.abs(o2), Math.abs(S2)) && Math.abs(a2 - A2) <= p * Math.max(1, Math.abs(a2), Math.abs(A2)) && Math.abs(l2 - T2) <= p * Math.max(1, Math.abs(l2), Math.abs(T2)) && Math.abs(u2 - I2) <= p * Math.max(1, Math.abs(u2), Math.abs(I2)) && Math.abs(c2 - E2) <= p * Math.max(1, Math.abs(c2), Math.abs(E2)) && Math.abs(h2 - M2) <= p * Math.max(1, Math.abs(h2), Math.abs(M2)) && Math.abs(f2 - k2) <= p * Math.max(1, Math.abs(f2), Math.abs(k2)) && Math.abs(d2 - F2) <= p * Math.max(1, Math.abs(d2), Math.abs(F2)) && Math.abs(y2 - D2) <= p * Math.max(1, Math.abs(y2), Math.abs(D2)) && Math.abs(m2 - P2) <= p * Math.max(1, Math.abs(m2), Math.abs(P2)) && Math.abs(g2 - B2) <= p * Math.max(1, Math.abs(g2), Math.abs(B2)) && Math.abs(x2 - z2) <= p * Math.max(1, Math.abs(x2), Math.abs(z2));
	    }, e.ck = function(e2, t2) {
	      return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
	    }, e.cl = (e2) => "symbol" === e2.type, e.cm = (e2) => "circle" === e2.type, e.cn = (e2) => "heatmap" === e2.type, e.co = (e2) => "line" === e2.type, e.cp = (e2) => "fill" === e2.type, e.cq = (e2) => "fill-extrusion" === e2.type, e.cr = (e2) => "hillshade" === e2.type, e.cs = (e2) => "color-relief" === e2.type, e.ct = (e2) => "background" === e2.type, e.cu = (e2) => "custom" === e2.type, e.cv = z, e.cw = function(e2, t2, r2) {
	      const n2 = M(t2.x - r2.x, t2.y - r2.y), i2 = M(e2.x - r2.x, e2.y - r2.y);
	      var s2, o2;
	      return te(Math.atan2(n2[0] * i2[1] - n2[1] * i2[0], (s2 = n2)[0] * (o2 = i2)[0] + s2[1] * o2[1]));
	    }, e.cx = V, e.cy = function(e2, t2) {
	      return ne[t2] && (e2 instanceof MouseEvent || e2 instanceof WheelEvent);
	    }, e.cz = function(e2, t2) {
	      return re[t2] && "touches" in e2;
	    }, e.d = pe, e.d0 = function(e2, r2, n2, i2, s2) {
	      return t(this, void 0, void 0, function* () {
	        if (h()) try {
	          return yield K(e2, r2, n2, i2, s2);
	        } catch (e3) {
	        }
	        return function(e3, t2, r3, n3, i3) {
	          const s3 = e3.width, o2 = e3.height;
	          W && J || (W = new OffscreenCanvas(s3, o2), J = W.getContext("2d", { willReadFrequently: true })), W.width = s3, W.height = o2, J.drawImage(e3, 0, 0, s3, o2);
	          const a2 = J.getImageData(t2, r3, n3, i3);
	          return J.clearRect(0, 0, s3, o2), a2.data;
	        }(e2, r2, n2, i2, s2);
	      });
	    }, e.d1 = Ml, e.d2 = n, e.d3 = ri, e.d4 = Ms, e.e = O, e.f = (e2) => t(void 0, void 0, void 0, function* () {
	      if (0 === e2.byteLength) return createImageBitmap(new ImageData(1, 1));
	      const t2 = new Blob([new Uint8Array(e2)], { type: "image/png" });
	      try {
	        return createImageBitmap(t2);
	      } catch (e3) {
	        throw new Error(`Could not load image because of ${e3.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
	      }
	    }), e.g = ae, e.h = (e2) => new Promise((t2, r2) => {
	      const n2 = new Image();
	      n2.onload = () => {
	        t2(n2), URL.revokeObjectURL(n2.src), n2.onload = null, window.requestAnimationFrame(() => {
	          n2.src = H;
	        });
	      }, n2.onerror = () => r2(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
	      const i2 = new Blob([new Uint8Array(e2)], { type: "image/png" });
	      n2.src = e2.byteLength ? URL.createObjectURL(i2) : H;
	    }), e.i = X, e.j = (e2, t2) => he(O(e2, { type: "json" }), t2), e.k = me, e.l = ye, e.m = he, e.n = (e2, t2) => he(O(e2, { type: "arrayBuffer" }), t2), e.o = function(e2) {
	      return new wc(e2).readFields(Bc, []);
	    }, e.p = Cc, e.q = function(e2) {
	      return /[\u02EA\u02EB\u1100-\u11FF\u2E80-\u2FDF\u3000-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE4F\uFF00-\uFFEF]|\uD81B[\uDFE0-\uDFFF]|[\uD81C-\uD822\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFFF]|\uD82C[\uDC00-\uDEFB]|\uD83C[\uDE00-\uDEFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(e2));
	    }, e.r = gl, e.s = Q, e.t = Gs, e.u = xe, e.v = Qi, e.w = j, e.x = zs, e.y = ts, e.z = Ds;
	  });
	  define2("worker", ["./shared"], function(e) {
	    class t {
	      constructor(e2, t2) {
	        this.keyCache = {}, e2 && this.replace(e2, t2);
	      }
	      replace(e2, t2) {
	        this._layerConfigs = {}, this._layers = {}, this.update(e2, [], t2);
	      }
	      update(t2, i2, o2) {
	        for (const i3 of t2) {
	          this._layerConfigs[i3.id] = i3;
	          const t3 = this._layers[i3.id] = e.bS(i3, o2);
	          t3._featureFilter = e.aj(t3.filter, o2), this.keyCache[i3.id] && delete this.keyCache[i3.id];
	        }
	        for (const e2 of i2) delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
	        this.familiesBySource = {};
	        const s2 = e.cL(Object.values(this._layerConfigs), this.keyCache);
	        for (const t3 of s2) {
	          const i3 = t3.map((e2) => this._layers[e2.id]), o3 = i3[0];
	          if ("none" === o3.visibility) continue;
	          const s3 = o3.source || "";
	          let n2 = this.familiesBySource[s3];
	          n2 || (n2 = this.familiesBySource[s3] = {});
	          const r2 = o3.sourceLayer || e.a9;
	          let a2 = n2[r2];
	          a2 || (a2 = n2[r2] = []), a2.push(i3);
	        }
	      }
	    }
	    class i {
	      constructor(t2) {
	        const i2 = {}, o2 = [];
	        for (const e2 in t2) {
	          const s3 = t2[e2], n3 = i2[e2] = {};
	          for (const e3 in s3) {
	            const t3 = s3[+e3];
	            if (!t3 || 0 === t3.bitmap.width || 0 === t3.bitmap.height) continue;
	            const i3 = { x: 0, y: 0, w: t3.bitmap.width + 2, h: t3.bitmap.height + 2 };
	            o2.push(i3), n3[e3] = { rect: i3, metrics: t3.metrics };
	          }
	        }
	        const { w: s2, h: n2 } = e.p(o2), r2 = new e.r({ width: s2 || 1, height: n2 || 1 });
	        for (const o3 in t2) {
	          const s3 = t2[o3];
	          for (const t3 in s3) {
	            const n3 = s3[+t3];
	            if (!n3 || 0 === n3.bitmap.width || 0 === n3.bitmap.height) continue;
	            const a2 = i2[o3][t3].rect;
	            e.r.copy(n3.bitmap, r2, { x: 0, y: 0 }, { x: a2.x + 1, y: a2.y + 1 }, n3.bitmap);
	          }
	        }
	        this.image = r2, this.positions = i2;
	      }
	    }
	    e.cM("GlyphAtlas", i);
	    class o {
	      constructor(t2) {
	        this.tileID = new e.a1(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.uid = t2.uid, this.zoom = t2.zoom, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId, this.inFlightDependencies = [];
	      }
	      parse(t2, o2, n2, r2, a2) {
	        return e._(this, void 0, void 0, function* () {
	          this.status = "parsing", this.data = t2, this.collisionBoxArray = new e.ah();
	          const l2 = new e.cN(Object.keys(t2.layers).sort()), c2 = new e.cO(this.tileID, this.promoteId);
	          c2.bucketLayerIDs = [];
	          const h2 = {}, u2 = { featureIndex: c2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, dashDependencies: {}, availableImages: n2, subdivisionGranularity: a2 }, d2 = o2.familiesBySource[this.source];
	          for (const i2 in d2) {
	            const o3 = t2.layers[i2];
	            if (!o3) continue;
	            1 === o3.version && e.w(`Vector tile source "${this.source}" layer "${i2}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
	            const r3 = l2.encode(i2), a3 = [];
	            for (let e2 = 0; e2 < o3.length; e2++) {
	              const t3 = o3.feature(e2), s2 = c2.getId(t3, i2);
	              a3.push({ feature: t3, id: s2, index: e2, sourceLayerIndex: r3 });
	            }
	            for (const t3 of d2[i2]) {
	              const i3 = t3[0];
	              i3.source !== this.source && e.w(`layer.source = ${i3.source} does not equal this.source = ${this.source}`), i3.isHidden(this.zoom, true) || (s(t3, this.zoom, n2), (h2[i3.id] = i3.createBucket({ index: c2.bucketLayerIDs.length, layers: t3, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: r3, sourceID: this.source })).populate(a3, u2, this.tileID.canonical), c2.bucketLayerIDs.push(t3.map((e2) => e2.id)));
	            }
	          }
	          const f2 = e.bX(u2.glyphDependencies, (e2) => Object.keys(e2).map(Number));
	          this.inFlightDependencies.forEach((e2) => null == e2 ? void 0 : e2.abort()), this.inFlightDependencies = [];
	          let g2 = Promise.resolve({});
	          if (Object.keys(f2).length) {
	            const e2 = new AbortController();
	            this.inFlightDependencies.push(e2), g2 = r2.sendAsync({ type: "GG", data: { stacks: f2, source: this.source, tileID: this.tileID, type: "glyphs" } }, e2);
	          }
	          const p2 = Object.keys(u2.iconDependencies);
	          let m2 = Promise.resolve({});
	          if (p2.length) {
	            const e2 = new AbortController();
	            this.inFlightDependencies.push(e2), m2 = r2.sendAsync({ type: "GI", data: { icons: p2, source: this.source, tileID: this.tileID, type: "icons" } }, e2);
	          }
	          const y2 = Object.keys(u2.patternDependencies);
	          let v2 = Promise.resolve({});
	          if (y2.length) {
	            const e2 = new AbortController();
	            this.inFlightDependencies.push(e2), v2 = r2.sendAsync({ type: "GI", data: { icons: y2, source: this.source, tileID: this.tileID, type: "patterns" } }, e2);
	          }
	          const w2 = u2.dashDependencies;
	          let x2 = Promise.resolve({});
	          if (Object.keys(w2).length) {
	            const e2 = new AbortController();
	            this.inFlightDependencies.push(e2), x2 = r2.sendAsync({ type: "GDA", data: { dashes: w2 } }, e2);
	          }
	          const [_2, S2, b2, M2] = yield Promise.all([g2, m2, v2, x2]), I2 = new i(_2), P2 = new e.cP(S2, b2);
	          for (const t3 in h2) {
	            const i2 = h2[t3];
	            i2 instanceof e.ai ? (s(i2.layers, this.zoom, n2), e.cQ({ bucket: i2, glyphMap: _2, glyphPositions: I2.positions, imageMap: S2, imagePositions: P2.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: u2.subdivisionGranularity })) : i2.hasDependencies && (i2 instanceof e.cR || i2 instanceof e.cS || i2 instanceof e.cT) && (s(i2.layers, this.zoom, n2), i2.addFeatures(u2, this.tileID.canonical, P2.patternPositions, M2));
	          }
	          return this.status = "done", { buckets: Object.values(h2).filter((e2) => !e2.isEmpty()), featureIndex: c2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: I2.image, imageAtlas: P2, dashPositions: M2, glyphMap: this.returnDependencies ? _2 : null, iconMap: this.returnDependencies ? S2 : null, glyphPositions: this.returnDependencies ? I2.positions : null };
	        });
	      }
	    }
	    function s(t2, i2, o2) {
	      const s2 = new e.H(i2);
	      for (const e2 of t2) e2.recalculate(s2, o2);
	    }
	    class n extends e.cW {
	      constructor(t2, i2) {
	        super(new e.cV(), 0, i2, [], []), this.feature = t2, this.type = t2.type, this.properties = t2.tags ? t2.tags : {}, "id" in t2 && ("string" == typeof t2.id ? this.id = parseInt(t2.id, 10) : "number" != typeof t2.id || isNaN(t2.id) || (this.id = t2.id));
	      }
	      loadGeometry() {
	        const t2 = [], i2 = 1 === this.feature.type ? [this.feature.geometry] : this.feature.geometry;
	        for (const o2 of i2) {
	          const i3 = [];
	          for (const t3 of o2) i3.push(new e.P(t3[0], t3[1]));
	          t2.push(i3);
	        }
	        return t2;
	      }
	    }
	    class r extends e.cU {
	      constructor(t2, i2) {
	        super(new e.cV()), this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.version = i2 ? i2.version : 1, this.extent = i2 ? i2.extent : 4096, this.length = t2.length, this.features = t2;
	      }
	      feature(e2) {
	        return new n(this.features[e2], this.extent);
	      }
	    }
	    function a(e2, t2) {
	      t2.writeVarintField(15, e2.version || 1), t2.writeStringField(1, e2.name || ""), t2.writeVarintField(5, e2.extent || 4096);
	      const i2 = { keys: [], values: [], keycache: {}, valuecache: {} };
	      for (let o3 = 0; o3 < e2.length; o3++) i2.feature = e2.feature(o3), t2.writeMessage(2, l, i2);
	      const o2 = i2.keys;
	      for (const e3 of o2) t2.writeStringField(3, e3);
	      const s2 = i2.values;
	      for (const e3 of s2) t2.writeMessage(4, f, e3);
	    }
	    function l(e2, t2) {
	      if (!e2.feature) return;
	      const i2 = e2.feature;
	      void 0 !== i2.id && t2.writeVarintField(1, i2.id), t2.writeMessage(2, c, e2), t2.writeVarintField(3, i2.type), t2.writeMessage(4, d, i2);
	    }
	    function c(e2, t2) {
	      for (const i2 in e2.feature?.properties) {
	        let o2 = e2.feature.properties[i2], s2 = e2.keycache[i2];
	        if (null === o2) continue;
	        void 0 === s2 && (e2.keys.push(i2), s2 = e2.keys.length - 1, e2.keycache[i2] = s2), t2.writeVarint(s2), "string" != typeof o2 && "boolean" != typeof o2 && "number" != typeof o2 && (o2 = JSON.stringify(o2));
	        const n2 = typeof o2 + ":" + o2;
	        let r2 = e2.valuecache[n2];
	        void 0 === r2 && (e2.values.push(o2), r2 = e2.values.length - 1, e2.valuecache[n2] = r2), t2.writeVarint(r2);
	      }
	    }
	    function h(e2, t2) {
	      return (t2 << 3) + (7 & e2);
	    }
	    function u(e2) {
	      return e2 << 1 ^ e2 >> 31;
	    }
	    function d(e2, t2) {
	      const i2 = e2.loadGeometry(), o2 = e2.type;
	      let s2 = 0, n2 = 0;
	      for (const r2 of i2) {
	        let i3 = 1;
	        1 === o2 && (i3 = r2.length), t2.writeVarint(h(1, i3));
	        const a2 = 3 === o2 ? r2.length - 1 : r2.length;
	        for (let e3 = 0; e3 < a2; e3++) {
	          1 === e3 && 1 !== o2 && t2.writeVarint(h(2, a2 - 1));
	          const i4 = r2[e3].x - s2, l2 = r2[e3].y - n2;
	          t2.writeVarint(u(i4)), t2.writeVarint(u(l2)), s2 += i4, n2 += l2;
	        }
	        3 === e2.type && t2.writeVarint(h(7, 1));
	      }
	    }
	    function f(e2, t2) {
	      const i2 = typeof e2;
	      "string" === i2 ? t2.writeStringField(1, e2) : "boolean" === i2 ? t2.writeBooleanField(7, e2) : "number" === i2 && (e2 % 1 != 0 ? t2.writeDoubleField(3, e2) : e2 < 0 ? t2.writeSVarintField(6, e2) : t2.writeVarintField(5, e2));
	    }
	    class g extends e.cW {
	      constructor(t2, i2, o2, s2, n2) {
	        super(new e.cV(), 0, n2, [], []), this.type = t2, this.properties = o2 || {}, this.extent = n2, this.pointsArray = i2, this.id = s2;
	      }
	      loadGeometry() {
	        return this.pointsArray.map((t2) => t2.map((t3) => new e.P(t3.x, t3.y)));
	      }
	    }
	    class p extends e.cU {
	      constructor(t2, i2, o2) {
	        super(new e.cV()), this.version = 2, this._myFeatures = t2, this.name = i2, this.length = t2.length, this.extent = o2;
	      }
	      feature(e2) {
	        return this._myFeatures[e2];
	      }
	    }
	    class m {
	      constructor() {
	        this.layers = {};
	      }
	      addLayer(e2) {
	        this.layers[e2.name] = e2;
	      }
	    }
	    function y(t2) {
	      let i2 = function(t3) {
	        const i3 = new e.cV();
	        return function(e2, t4) {
	          for (const i4 in e2.layers) t4.writeMessage(3, a, e2.layers[i4]);
	        }(t3, i3), i3.finish();
	      }(t2);
	      return 0 === i2.byteOffset && i2.byteLength === i2.buffer.byteLength || (i2 = new Uint8Array(i2)), { vectorTile: t2, rawData: i2.buffer };
	    }
	    function v(t2, i2, o2) {
	      const { extent: s2 } = t2, n2 = Math.pow(2, o2.z - i2.z), r2 = (o2.x - i2.x * n2) * s2, a2 = (o2.y - i2.y * n2) * s2, l2 = [];
	      for (let i3 = 0; i3 < t2.length; i3++) {
	        const o3 = t2.feature(i3);
	        let c2 = o3.loadGeometry();
	        for (const e2 of c2) for (const t3 of e2) t3.x = t3.x * n2 - r2, t3.y = t3.y * n2 - a2;
	        const h2 = 128;
	        c2 = e.cX(c2, o3.type, -h2, -h2, s2 + h2, s2 + h2), 0 !== c2.length && l2.push(new g(o3.type, c2, o3.properties, o3.id, s2));
	      }
	      return new p(l2, t2.name, s2);
	    }
	    class w {
	      constructor(t2, i2, o2) {
	        this.actor = t2, this.layerIndex = i2, this.availableImages = o2, this.fetching = {}, this.loading = {}, this.loaded = {}, this.overzoomedTileResultCache = new e.cY(1e3);
	      }
	      loadVectorTile(t2, i2) {
	        return e._(this, void 0, void 0, function* () {
	          const o2 = yield e.n(t2.request, i2);
	          try {
	            return { vectorTile: "mlt" !== t2.encoding ? new e.cZ(new e.cV(o2.data)) : new e.c_(o2.data), rawData: o2.data, cacheControl: o2.cacheControl, expires: o2.expires };
	          } catch (e2) {
	            const i3 = new Uint8Array(o2.data);
	            let s2 = `Unable to parse the tile at ${t2.request.url}, `;
	            throw s2 += 31 === i3[0] && 139 === i3[1] ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e2.message}`, new Error(s2);
	          }
	        });
	      }
	      loadTile(t2) {
	        return e._(this, void 0, void 0, function* () {
	          const { uid: i2, overzoomParameters: s2 } = t2;
	          s2 && (t2.request = s2.overzoomRequest);
	          const n2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.c$(t2.request), r2 = new o(t2);
	          this.loading[i2] = r2;
	          const a2 = new AbortController();
	          r2.abort = a2;
	          try {
	            const o2 = yield this.loadVectorTile(t2, a2);
	            if (delete this.loading[i2], !o2) return null;
	            if (s2) {
	              const e2 = this._getOverzoomTile(t2, o2.vectorTile);
	              o2.rawData = e2.rawData, o2.vectorTile = e2.vectorTile;
	            }
	            const l2 = o2.rawData, c2 = {};
	            o2.expires && (c2.expires = o2.expires), o2.cacheControl && (c2.cacheControl = o2.cacheControl);
	            const h2 = {};
	            if (n2) {
	              const e2 = n2.finish();
	              e2 && (h2.resourceTiming = JSON.parse(JSON.stringify(e2)));
	            }
	            r2.vectorTile = o2.vectorTile;
	            const u2 = r2.parse(o2.vectorTile, this.layerIndex, this.availableImages, this.actor, t2.subdivisionGranularity);
	            this.loaded[i2] = r2, this.fetching[i2] = { rawTileData: l2, cacheControl: c2, resourceTiming: h2 };
	            try {
	              const i3 = yield u2;
	              return e.e({ rawTileData: l2.slice(0), encoding: t2.encoding }, i3, c2, h2);
	            } finally {
	              delete this.fetching[i2];
	            }
	          } catch (e2) {
	            throw delete this.loading[i2], r2.status = "done", this.loaded[i2] = r2, e2;
	          }
	        });
	      }
	      _getOverzoomTile(e2, t2) {
	        const { tileID: i2, source: o2, overzoomParameters: s2 } = e2, { maxZoomTileID: n2 } = s2, r2 = `${n2.key}_${i2.key}`, a2 = this.overzoomedTileResultCache.get(r2);
	        if (a2) return a2;
	        const l2 = new m(), c2 = this.layerIndex.familiesBySource[o2];
	        for (const e3 in c2) {
	          const o3 = t2.layers[e3];
	          if (!o3) continue;
	          const s3 = v(o3, n2, i2.canonical);
	          s3.length > 0 && l2.addLayer(s3);
	        }
	        const h2 = y(l2);
	        return this.overzoomedTileResultCache.set(r2, h2), h2;
	      }
	      reloadTile(t2) {
	        return e._(this, void 0, void 0, function* () {
	          const i2 = t2.uid;
	          if (!this.loaded || !this.loaded[i2]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
	          const o2 = this.loaded[i2];
	          if (o2.showCollisionBoxes = t2.showCollisionBoxes, "parsing" === o2.status) {
	            const s2 = yield o2.parse(o2.vectorTile, this.layerIndex, this.availableImages, this.actor, t2.subdivisionGranularity);
	            let n2;
	            if (this.fetching[i2]) {
	              const { rawTileData: o3, cacheControl: r2, resourceTiming: a2 } = this.fetching[i2];
	              delete this.fetching[i2], n2 = e.e({ rawTileData: o3.slice(0), encoding: t2.encoding }, s2, r2, a2);
	            } else n2 = s2;
	            return n2;
	          }
	          if ("done" === o2.status && o2.vectorTile) return o2.parse(o2.vectorTile, this.layerIndex, this.availableImages, this.actor, t2.subdivisionGranularity);
	        });
	      }
	      abortTile(t2) {
	        return e._(this, void 0, void 0, function* () {
	          const e2 = this.loading, i2 = t2.uid;
	          e2 && e2[i2] && e2[i2].abort && (e2[i2].abort.abort(), delete e2[i2]);
	        });
	      }
	      removeTile(t2) {
	        return e._(this, void 0, void 0, function* () {
	          this.loaded && this.loaded[t2.uid] && delete this.loaded[t2.uid];
	        });
	      }
	    }
	    class x {
	      constructor() {
	        this.loaded = {};
	      }
	      loadTile(t2) {
	        return e._(this, void 0, void 0, function* () {
	          const { uid: i2, encoding: o2, rawImageData: s2, redFactor: n2, greenFactor: r2, blueFactor: a2, baseShift: l2 } = t2, c2 = s2.width + 2, h2 = s2.height + 2, u2 = e.b(s2) ? new e.R({ width: c2, height: h2 }, yield e.d0(s2, -1, -1, c2, h2)) : s2, d2 = new e.d1(i2, u2, o2, n2, r2, a2, l2);
	          return this.loaded = this.loaded || {}, this.loaded[i2] = d2, d2;
	        });
	      }
	      removeTile(e2) {
	        const t2 = this.loaded, i2 = e2.uid;
	        t2 && t2[i2] && delete t2[i2];
	      }
	    }
	    var _, S, b = function() {
	      if (S) return _;
	      function e2(e3, i2) {
	        if (0 !== e3.length) {
	          t2(e3[0], i2);
	          for (var o2 = 1; o2 < e3.length; o2++) t2(e3[o2], !i2);
	        }
	      }
	      function t2(e3, t3) {
	        for (var i2 = 0, o2 = 0, s2 = 0, n2 = e3.length, r2 = n2 - 1; s2 < n2; r2 = s2++) {
	          var a2 = (e3[s2][0] - e3[r2][0]) * (e3[r2][1] + e3[s2][1]), l2 = i2 + a2;
	          o2 += Math.abs(i2) >= Math.abs(a2) ? i2 - l2 + a2 : a2 - l2 + i2, i2 = l2;
	        }
	        i2 + o2 >= 0 != !!t3 && e3.reverse();
	      }
	      return S = 1, _ = function t3(i2, o2) {
	        var s2, n2 = i2 && i2.type;
	        if ("FeatureCollection" === n2) for (s2 = 0; s2 < i2.features.length; s2++) t3(i2.features[s2], o2);
	        else if ("GeometryCollection" === n2) for (s2 = 0; s2 < i2.geometries.length; s2++) t3(i2.geometries[s2], o2);
	        else if ("Feature" === n2) t3(i2.geometry, o2);
	        else if ("Polygon" === n2) e2(i2.coordinates, o2);
	        else if ("MultiPolygon" === n2) for (s2 = 0; s2 < i2.coordinates.length; s2++) e2(i2.coordinates[s2], o2);
	        return i2;
	      };
	    }(), M = e.d2(b);
	    const I = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, P = Math.fround || (k = new Float32Array(1), (e2) => (k[0] = +e2, k[0]));
	    var k;
	    class D {
	      constructor(e2) {
	        this.options = Object.assign(Object.create(I), e2), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
	      }
	      load(e2) {
	        const { log: t2, minZoom: i2, maxZoom: o2 } = this.options;
	        t2 && console.time("total time");
	        const s2 = `prepare ${e2.length} points`;
	        t2 && console.time(s2), this.points = e2;
	        const n2 = [];
	        for (let t3 = 0; t3 < e2.length; t3++) {
	          const i3 = e2[t3];
	          if (!i3.geometry) continue;
	          const [o3, s3] = i3.geometry.coordinates, r3 = P(L(o3)), a2 = P(O(s3));
	          n2.push(r3, a2, 1 / 0, t3, -1, 1), this.options.reduce && n2.push(0);
	        }
	        let r2 = this.trees[o2 + 1] = this._createTree(n2);
	        t2 && console.timeEnd(s2);
	        for (let e3 = o2; e3 >= i2; e3--) {
	          const i3 = +Date.now();
	          r2 = this.trees[e3] = this._createTree(this._cluster(r2, e3)), t2 && console.log("z%d: %d clusters in %dms", e3, r2.numItems, +Date.now() - i3);
	        }
	        return t2 && console.timeEnd("total time"), this;
	      }
	      getClusters(e2, t2) {
	        let i2 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
	        const o2 = Math.max(-90, Math.min(90, e2[1]));
	        let s2 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
	        const n2 = Math.max(-90, Math.min(90, e2[3]));
	        if (e2[2] - e2[0] >= 360) i2 = -180, s2 = 180;
	        else if (i2 > s2) {
	          const e3 = this.getClusters([i2, o2, 180, n2], t2), r3 = this.getClusters([-180, o2, s2, n2], t2);
	          return e3.concat(r3);
	        }
	        const r2 = this.trees[this._limitZoom(t2)], a2 = r2.range(L(i2), O(n2), L(s2), O(o2)), l2 = r2.data, c2 = [];
	        for (const e3 of a2) {
	          const t3 = this.stride * e3;
	          c2.push(l2[t3 + 5] > 1 ? T(l2, t3, this.clusterProps) : this.points[l2[t3 + 3]]);
	        }
	        return c2;
	      }
	      getChildren(e2) {
	        const t2 = this._getOriginId(e2), i2 = this._getOriginZoom(e2), o2 = "No cluster with the specified id.", s2 = this.trees[i2];
	        if (!s2) throw new Error(o2);
	        const n2 = s2.data;
	        if (t2 * this.stride >= n2.length) throw new Error(o2);
	        const r2 = this.options.radius / (this.options.extent * Math.pow(2, i2 - 1)), a2 = s2.within(n2[t2 * this.stride], n2[t2 * this.stride + 1], r2), l2 = [];
	        for (const t3 of a2) {
	          const i3 = t3 * this.stride;
	          n2[i3 + 4] === e2 && l2.push(n2[i3 + 5] > 1 ? T(n2, i3, this.clusterProps) : this.points[n2[i3 + 3]]);
	        }
	        if (0 === l2.length) throw new Error(o2);
	        return l2;
	      }
	      getLeaves(e2, t2, i2) {
	        const o2 = [];
	        return this._appendLeaves(o2, e2, t2 = t2 || 10, i2 = i2 || 0, 0), o2;
	      }
	      getTile(e2, t2, i2) {
	        const o2 = this.trees[this._limitZoom(e2)], s2 = Math.pow(2, e2), { extent: n2, radius: r2 } = this.options, a2 = r2 / n2, l2 = (i2 - a2) / s2, c2 = (i2 + 1 + a2) / s2, h2 = { features: [] };
	        return this._addTileFeatures(o2.range((t2 - a2) / s2, l2, (t2 + 1 + a2) / s2, c2), o2.data, t2, i2, s2, h2), 0 === t2 && this._addTileFeatures(o2.range(1 - a2 / s2, l2, 1, c2), o2.data, s2, i2, s2, h2), t2 === s2 - 1 && this._addTileFeatures(o2.range(0, l2, a2 / s2, c2), o2.data, -1, i2, s2, h2), h2.features.length ? h2 : null;
	      }
	      getClusterExpansionZoom(e2) {
	        let t2 = this._getOriginZoom(e2) - 1;
	        for (; t2 <= this.options.maxZoom; ) {
	          const i2 = this.getChildren(e2);
	          if (t2++, 1 !== i2.length) break;
	          e2 = i2[0].properties.cluster_id;
	        }
	        return t2;
	      }
	      _appendLeaves(e2, t2, i2, o2, s2) {
	        const n2 = this.getChildren(t2);
	        for (const t3 of n2) {
	          const n3 = t3.properties;
	          if (n3 && n3.cluster ? s2 + n3.point_count <= o2 ? s2 += n3.point_count : s2 = this._appendLeaves(e2, n3.cluster_id, i2, o2, s2) : s2 < o2 ? s2++ : e2.push(t3), e2.length === i2) break;
	        }
	        return s2;
	      }
	      _createTree(t2) {
	        const i2 = new e.aS(t2.length / this.stride | 0, this.options.nodeSize, Float32Array);
	        for (let e2 = 0; e2 < t2.length; e2 += this.stride) i2.add(t2[e2], t2[e2 + 1]);
	        return i2.finish(), i2.data = t2, i2;
	      }
	      _addTileFeatures(e2, t2, i2, o2, s2, n2) {
	        for (const r2 of e2) {
	          const e3 = r2 * this.stride, a2 = t2[e3 + 5] > 1;
	          let l2, c2, h2;
	          if (a2) l2 = C(t2, e3, this.clusterProps), c2 = t2[e3], h2 = t2[e3 + 1];
	          else {
	            const i3 = this.points[t2[e3 + 3]];
	            l2 = i3.properties;
	            const [o3, s3] = i3.geometry.coordinates;
	            c2 = L(o3), h2 = O(s3);
	          }
	          const u2 = { type: 1, geometry: [[Math.round(this.options.extent * (c2 * s2 - i2)), Math.round(this.options.extent * (h2 * s2 - o2))]], tags: l2 };
	          let d2;
	          d2 = a2 || this.options.generateId ? t2[e3 + 3] : this.points[t2[e3 + 3]].id, void 0 !== d2 && (u2.id = d2), n2.features.push(u2);
	        }
	      }
	      _limitZoom(e2) {
	        return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
	      }
	      _cluster(e2, t2) {
	        const { radius: i2, extent: o2, reduce: s2, minPoints: n2 } = this.options, r2 = i2 / (o2 * Math.pow(2, t2)), a2 = e2.data, l2 = [], c2 = this.stride;
	        for (let i3 = 0; i3 < a2.length; i3 += c2) {
	          if (a2[i3 + 2] <= t2) continue;
	          a2[i3 + 2] = t2;
	          const o3 = a2[i3], h2 = a2[i3 + 1], u2 = e2.within(a2[i3], a2[i3 + 1], r2), d2 = a2[i3 + 5];
	          let f2 = d2;
	          for (const e3 of u2) {
	            const i4 = e3 * c2;
	            a2[i4 + 2] > t2 && (f2 += a2[i4 + 5]);
	          }
	          if (f2 > d2 && f2 >= n2) {
	            let e3, n3 = o3 * d2, r3 = h2 * d2, g2 = -1;
	            const p2 = (i3 / c2 << 5) + (t2 + 1) + this.points.length;
	            for (const o4 of u2) {
	              const l3 = o4 * c2;
	              if (a2[l3 + 2] <= t2) continue;
	              a2[l3 + 2] = t2;
	              const h3 = a2[l3 + 5];
	              n3 += a2[l3] * h3, r3 += a2[l3 + 1] * h3, a2[l3 + 4] = p2, s2 && (e3 || (e3 = this._map(a2, i3, true), g2 = this.clusterProps.length, this.clusterProps.push(e3)), s2(e3, this._map(a2, l3)));
	            }
	            a2[i3 + 4] = p2, l2.push(n3 / f2, r3 / f2, 1 / 0, p2, -1, f2), s2 && l2.push(g2);
	          } else {
	            for (let e3 = 0; e3 < c2; e3++) l2.push(a2[i3 + e3]);
	            if (f2 > 1) for (const e3 of u2) {
	              const i4 = e3 * c2;
	              if (!(a2[i4 + 2] <= t2)) {
	                a2[i4 + 2] = t2;
	                for (let e4 = 0; e4 < c2; e4++) l2.push(a2[i4 + e4]);
	              }
	            }
	          }
	        }
	        return l2;
	      }
	      _getOriginId(e2) {
	        return e2 - this.points.length >> 5;
	      }
	      _getOriginZoom(e2) {
	        return (e2 - this.points.length) % 32;
	      }
	      _map(e2, t2, i2) {
	        if (e2[t2 + 5] > 1) {
	          const o3 = this.clusterProps[e2[t2 + 6]];
	          return i2 ? Object.assign({}, o3) : o3;
	        }
	        const o2 = this.points[e2[t2 + 3]].properties, s2 = this.options.map(o2);
	        return i2 && s2 === o2 ? Object.assign({}, s2) : s2;
	      }
	    }
	    function T(e2, t2, i2) {
	      return { type: "Feature", id: e2[t2 + 3], properties: C(e2, t2, i2), geometry: { type: "Point", coordinates: [(o2 = e2[t2], 360 * (o2 - 0.5)), F(e2[t2 + 1])] } };
	      var o2;
	    }
	    function C(e2, t2, i2) {
	      const o2 = e2[t2 + 5], s2 = o2 >= 1e4 ? `${Math.round(o2 / 1e3)}k` : o2 >= 1e3 ? Math.round(o2 / 100) / 10 + "k" : o2, n2 = e2[t2 + 6], r2 = -1 === n2 ? {} : Object.assign({}, i2[n2]);
	      return Object.assign(r2, { cluster: true, cluster_id: e2[t2 + 3], point_count: o2, point_count_abbreviated: s2 });
	    }
	    function L(e2) {
	      return e2 / 360 + 0.5;
	    }
	    function O(e2) {
	      const t2 = Math.sin(e2 * Math.PI / 180), i2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
	      return i2 < 0 ? 0 : i2 > 1 ? 1 : i2;
	    }
	    function F(e2) {
	      const t2 = (180 - 360 * e2) * Math.PI / 180;
	      return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
	    }
	    function z(e2, t2, i2, o2) {
	      let s2 = o2;
	      const n2 = t2 + (i2 - t2 >> 1);
	      let r2, a2 = i2 - t2;
	      const l2 = e2[t2], c2 = e2[t2 + 1], h2 = e2[i2], u2 = e2[i2 + 1];
	      for (let o3 = t2 + 3; o3 < i2; o3 += 3) {
	        const t3 = G(e2[o3], e2[o3 + 1], l2, c2, h2, u2);
	        if (t3 > s2) r2 = o3, s2 = t3;
	        else if (t3 === s2) {
	          const e3 = Math.abs(o3 - n2);
	          e3 < a2 && (r2 = o3, a2 = e3);
	        }
	      }
	      s2 > o2 && (r2 - t2 > 3 && z(e2, t2, r2, o2), e2[r2 + 2] = s2, i2 - r2 > 3 && z(e2, r2, i2, o2));
	    }
	    function G(e2, t2, i2, o2, s2, n2) {
	      let r2 = s2 - i2, a2 = n2 - o2;
	      if (0 !== r2 || 0 !== a2) {
	        const l2 = ((e2 - i2) * r2 + (t2 - o2) * a2) / (r2 * r2 + a2 * a2);
	        l2 > 1 ? (i2 = s2, o2 = n2) : l2 > 0 && (i2 += r2 * l2, o2 += a2 * l2);
	      }
	      return r2 = e2 - i2, a2 = t2 - o2, r2 * r2 + a2 * a2;
	    }
	    function A(e2, t2, i2, o2) {
	      const s2 = { id: null == e2 ? null : e2, type: t2, geometry: i2, tags: o2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
	      if ("Point" === t2 || "MultiPoint" === t2 || "LineString" === t2) Z(s2, i2);
	      else if ("Polygon" === t2) Z(s2, i2[0]);
	      else if ("MultiLineString" === t2) for (const e3 of i2) Z(s2, e3);
	      else if ("MultiPolygon" === t2) for (const e3 of i2) Z(s2, e3[0]);
	      return s2;
	    }
	    function Z(e2, t2) {
	      for (let i2 = 0; i2 < t2.length; i2 += 3) e2.minX = Math.min(e2.minX, t2[i2]), e2.minY = Math.min(e2.minY, t2[i2 + 1]), e2.maxX = Math.max(e2.maxX, t2[i2]), e2.maxY = Math.max(e2.maxY, t2[i2 + 1]);
	    }
	    function N(e2, t2, i2, o2) {
	      if (!t2.geometry) return;
	      const s2 = t2.geometry.coordinates;
	      if (s2 && 0 === s2.length) return;
	      const n2 = t2.geometry.type, r2 = Math.pow(i2.tolerance / ((1 << i2.maxZoom) * i2.extent), 2);
	      let a2 = [], l2 = t2.id;
	      if (i2.promoteId ? l2 = t2.properties[i2.promoteId] : i2.generateId && (l2 = o2 || 0), "Point" === n2) R(s2, a2);
	      else if ("MultiPoint" === n2) for (const e3 of s2) R(e3, a2);
	      else if ("LineString" === n2) j(s2, a2, r2, false);
	      else if ("MultiLineString" === n2) {
	        if (i2.lineMetrics) {
	          for (const i3 of s2) a2 = [], j(i3, a2, r2, false), e2.push(A(l2, "LineString", a2, t2.properties));
	          return;
	        }
	        E(s2, a2, r2, false);
	      } else if ("Polygon" === n2) E(s2, a2, r2, true);
	      else {
	        if ("MultiPolygon" !== n2) {
	          if ("GeometryCollection" === n2) {
	            for (const s3 of t2.geometry.geometries) N(e2, { id: l2, geometry: s3, properties: t2.properties }, i2, o2);
	            return;
	          }
	          throw new Error("Input data is not a valid GeoJSON object.");
	        }
	        for (const e3 of s2) {
	          const t3 = [];
	          E(e3, t3, r2, true), a2.push(t3);
	        }
	      }
	      e2.push(A(l2, n2, a2, t2.properties));
	    }
	    function R(e2, t2) {
	      t2.push(W(e2[0]), J(e2[1]), 0);
	    }
	    function j(e2, t2, i2, o2) {
	      let s2, n2, r2 = 0;
	      for (let i3 = 0; i3 < e2.length; i3++) {
	        const a3 = W(e2[i3][0]), l2 = J(e2[i3][1]);
	        t2.push(a3, l2, 0), i3 > 0 && (r2 += o2 ? (s2 * l2 - a3 * n2) / 2 : Math.sqrt(Math.pow(a3 - s2, 2) + Math.pow(l2 - n2, 2))), s2 = a3, n2 = l2;
	      }
	      const a2 = t2.length - 3;
	      t2[2] = 1, z(t2, 0, a2, i2), t2[a2 + 2] = 1, t2.size = Math.abs(r2), t2.start = 0, t2.end = t2.size;
	    }
	    function E(e2, t2, i2, o2) {
	      for (let s2 = 0; s2 < e2.length; s2++) {
	        const n2 = [];
	        j(e2[s2], n2, i2, o2), t2.push(n2);
	      }
	    }
	    function W(e2) {
	      return e2 / 360 + 0.5;
	    }
	    function J(e2) {
	      const t2 = Math.sin(e2 * Math.PI / 180), i2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
	      return i2 < 0 ? 0 : i2 > 1 ? 1 : i2;
	    }
	    function Y(e2, t2, i2, o2, s2, n2, r2, a2) {
	      if (o2 /= t2, n2 >= (i2 /= t2) && r2 < o2) return e2;
	      if (r2 < i2 || n2 >= o2) return null;
	      const l2 = [];
	      for (const t3 of e2) {
	        const e3 = t3.geometry;
	        let n3 = t3.type;
	        const r3 = 0 === s2 ? t3.minX : t3.minY, c2 = 0 === s2 ? t3.maxX : t3.maxY;
	        if (r3 >= i2 && c2 < o2) {
	          l2.push(t3);
	          continue;
	        }
	        if (c2 < i2 || r3 >= o2) continue;
	        let h2 = [];
	        if ("Point" === n3 || "MultiPoint" === n3) V(e3, h2, i2, o2, s2);
	        else if ("LineString" === n3) H(e3, h2, i2, o2, s2, false, a2.lineMetrics);
	        else if ("MultiLineString" === n3) X(e3, h2, i2, o2, s2, false);
	        else if ("Polygon" === n3) X(e3, h2, i2, o2, s2, true);
	        else if ("MultiPolygon" === n3) for (const t4 of e3) {
	          const e4 = [];
	          X(t4, e4, i2, o2, s2, true), e4.length && h2.push(e4);
	        }
	        if (h2.length) {
	          if (a2.lineMetrics && "LineString" === n3) {
	            for (const e4 of h2) l2.push(A(t3.id, n3, e4, t3.tags));
	            continue;
	          }
	          "LineString" !== n3 && "MultiLineString" !== n3 || (1 === h2.length ? (n3 = "LineString", h2 = h2[0]) : n3 = "MultiLineString"), "Point" !== n3 && "MultiPoint" !== n3 || (n3 = 3 === h2.length ? "Point" : "MultiPoint"), l2.push(A(t3.id, n3, h2, t3.tags));
	        }
	      }
	      return l2.length ? l2 : null;
	    }
	    function V(e2, t2, i2, o2, s2) {
	      for (let n2 = 0; n2 < e2.length; n2 += 3) {
	        const r2 = e2[n2 + s2];
	        r2 >= i2 && r2 <= o2 && B(t2, e2[n2], e2[n2 + 1], e2[n2 + 2]);
	      }
	    }
	    function H(e2, t2, i2, o2, s2, n2, r2) {
	      let a2 = q(e2);
	      const l2 = 0 === s2 ? $ : U;
	      let c2, h2, u2 = e2.start;
	      for (let d3 = 0; d3 < e2.length - 3; d3 += 3) {
	        const f3 = e2[d3], g3 = e2[d3 + 1], p3 = e2[d3 + 2], m2 = e2[d3 + 3], y2 = e2[d3 + 4], v2 = 0 === s2 ? f3 : g3, w2 = 0 === s2 ? m2 : y2;
	        let x2 = false;
	        r2 && (c2 = Math.sqrt(Math.pow(f3 - m2, 2) + Math.pow(g3 - y2, 2))), v2 < i2 ? w2 > i2 && (h2 = l2(a2, f3, g3, m2, y2, i2), r2 && (a2.start = u2 + c2 * h2)) : v2 > o2 ? w2 < o2 && (h2 = l2(a2, f3, g3, m2, y2, o2), r2 && (a2.start = u2 + c2 * h2)) : B(a2, f3, g3, p3), w2 < i2 && v2 >= i2 && (h2 = l2(a2, f3, g3, m2, y2, i2), x2 = true), w2 > o2 && v2 <= o2 && (h2 = l2(a2, f3, g3, m2, y2, o2), x2 = true), !n2 && x2 && (r2 && (a2.end = u2 + c2 * h2), t2.push(a2), a2 = q(e2)), r2 && (u2 += c2);
	      }
	      let d2 = e2.length - 3;
	      const f2 = e2[d2], g2 = e2[d2 + 1], p2 = 0 === s2 ? f2 : g2;
	      p2 >= i2 && p2 <= o2 && B(a2, f2, g2, e2[d2 + 2]), d2 = a2.length - 3, n2 && d2 >= 3 && (a2[d2] !== a2[0] || a2[d2 + 1] !== a2[1]) && B(a2, a2[0], a2[1], a2[2]), a2.length && t2.push(a2);
	    }
	    function q(e2) {
	      const t2 = [];
	      return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
	    }
	    function X(e2, t2, i2, o2, s2, n2) {
	      for (const r2 of e2) H(r2, t2, i2, o2, s2, n2, false);
	    }
	    function B(e2, t2, i2, o2) {
	      e2.push(t2, i2, o2);
	    }
	    function $(e2, t2, i2, o2, s2, n2) {
	      const r2 = (n2 - t2) / (o2 - t2);
	      return B(e2, n2, i2 + (s2 - i2) * r2, 1), r2;
	    }
	    function U(e2, t2, i2, o2, s2, n2) {
	      const r2 = (n2 - i2) / (s2 - i2);
	      return B(e2, t2 + (o2 - t2) * r2, n2, 1), r2;
	    }
	    function K(e2, t2) {
	      const i2 = [];
	      for (let o2 = 0; o2 < e2.length; o2++) {
	        const s2 = e2[o2], n2 = s2.type;
	        let r2;
	        if ("Point" === n2 || "MultiPoint" === n2 || "LineString" === n2) r2 = Q(s2.geometry, t2);
	        else if ("MultiLineString" === n2 || "Polygon" === n2) {
	          r2 = [];
	          for (const e3 of s2.geometry) r2.push(Q(e3, t2));
	        } else if ("MultiPolygon" === n2) {
	          r2 = [];
	          for (const e3 of s2.geometry) {
	            const i3 = [];
	            for (const o3 of e3) i3.push(Q(o3, t2));
	            r2.push(i3);
	          }
	        }
	        i2.push(A(s2.id, n2, r2, s2.tags));
	      }
	      return i2;
	    }
	    function Q(e2, t2) {
	      const i2 = [];
	      i2.size = e2.size, void 0 !== e2.start && (i2.start = e2.start, i2.end = e2.end);
	      for (let o2 = 0; o2 < e2.length; o2 += 3) i2.push(e2[o2] + t2, e2[o2 + 1], e2[o2 + 2]);
	      return i2;
	    }
	    function ee(e2, t2) {
	      if (e2.transformed) return e2;
	      const i2 = 1 << e2.z, o2 = e2.x, s2 = e2.y;
	      for (const n2 of e2.features) {
	        const e3 = n2.geometry, r2 = n2.type;
	        if (n2.geometry = [], 1 === r2) for (let r3 = 0; r3 < e3.length; r3 += 2) n2.geometry.push(te(e3[r3], e3[r3 + 1], t2, i2, o2, s2));
	        else for (let r3 = 0; r3 < e3.length; r3++) {
	          const a2 = [];
	          for (let n3 = 0; n3 < e3[r3].length; n3 += 2) a2.push(te(e3[r3][n3], e3[r3][n3 + 1], t2, i2, o2, s2));
	          n2.geometry.push(a2);
	        }
	      }
	      return e2.transformed = true, e2;
	    }
	    function te(e2, t2, i2, o2, s2, n2) {
	      return [Math.round(i2 * (e2 * o2 - s2)), Math.round(i2 * (t2 * o2 - n2))];
	    }
	    function ie(e2, t2, i2, o2, s2) {
	      const n2 = t2 === s2.maxZoom ? 0 : s2.tolerance / ((1 << t2) * s2.extent), r2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: e2.length, source: null, x: i2, y: o2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
	      for (const t3 of e2) oe(r2, t3, n2, s2);
	      return r2;
	    }
	    function oe(e2, t2, i2, o2) {
	      const s2 = t2.geometry, n2 = t2.type, r2 = [];
	      if (e2.minX = Math.min(e2.minX, t2.minX), e2.minY = Math.min(e2.minY, t2.minY), e2.maxX = Math.max(e2.maxX, t2.maxX), e2.maxY = Math.max(e2.maxY, t2.maxY), "Point" === n2 || "MultiPoint" === n2) for (let t3 = 0; t3 < s2.length; t3 += 3) r2.push(s2[t3], s2[t3 + 1]), e2.numPoints++, e2.numSimplified++;
	      else if ("LineString" === n2) se(r2, s2, e2, i2, false, false);
	      else if ("MultiLineString" === n2 || "Polygon" === n2) for (let t3 = 0; t3 < s2.length; t3++) se(r2, s2[t3], e2, i2, "Polygon" === n2, 0 === t3);
	      else if ("MultiPolygon" === n2) for (let t3 = 0; t3 < s2.length; t3++) {
	        const o3 = s2[t3];
	        for (let t4 = 0; t4 < o3.length; t4++) se(r2, o3[t4], e2, i2, true, 0 === t4);
	      }
	      if (r2.length) {
	        let i3 = t2.tags || null;
	        if ("LineString" === n2 && o2.lineMetrics) {
	          i3 = {};
	          for (const e3 in t2.tags) i3[e3] = t2.tags[e3];
	          i3.mapbox_clip_start = s2.start / s2.size, i3.mapbox_clip_end = s2.end / s2.size;
	        }
	        const a2 = { geometry: r2, type: "Polygon" === n2 || "MultiPolygon" === n2 ? 3 : "LineString" === n2 || "MultiLineString" === n2 ? 2 : 1, tags: i3 };
	        null !== t2.id && (a2.id = t2.id), e2.features.push(a2);
	      }
	    }
	    function se(e2, t2, i2, o2, s2, n2) {
	      const r2 = o2 * o2;
	      if (o2 > 0 && t2.size < (s2 ? r2 : o2)) return void (i2.numPoints += t2.length / 3);
	      const a2 = [];
	      for (let e3 = 0; e3 < t2.length; e3 += 3) (0 === o2 || t2[e3 + 2] > r2) && (i2.numSimplified++, a2.push(t2[e3], t2[e3 + 1])), i2.numPoints++;
	      s2 && function(e3, t3) {
	        let i3 = 0;
	        for (let t4 = 0, o3 = e3.length, s3 = o3 - 2; t4 < o3; s3 = t4, t4 += 2) i3 += (e3[t4] - e3[s3]) * (e3[t4 + 1] + e3[s3 + 1]);
	        if (i3 > 0 === t3) for (let t4 = 0, i4 = e3.length; t4 < i4 / 2; t4 += 2) {
	          const o3 = e3[t4], s3 = e3[t4 + 1];
	          e3[t4] = e3[i4 - 2 - t4], e3[t4 + 1] = e3[i4 - 1 - t4], e3[i4 - 2 - t4] = o3, e3[i4 - 1 - t4] = s3;
	        }
	      }(a2, n2), e2.push(a2);
	    }
	    const ne = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };
	    class re {
	      constructor(e2, t2) {
	        const i2 = (t2 = this.options = function(e3, t3) {
	          for (const i3 in t3) e3[i3] = t3[i3];
	          return e3;
	        }(Object.create(ne), t2)).debug;
	        if (i2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
	        if (t2.promoteId && t2.generateId) throw new Error("promoteId and generateId cannot be used together.");
	        let o2 = function(e3, t3) {
	          const i3 = [];
	          if ("FeatureCollection" === e3.type) for (let o3 = 0; o3 < e3.features.length; o3++) N(i3, e3.features[o3], t3, o3);
	          else N(i3, "Feature" === e3.type ? e3 : { geometry: e3 }, t3);
	          return i3;
	        }(e2, t2);
	        this.tiles = {}, this.tileCoords = [], i2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), o2 = function(e3, t3) {
	          const i3 = t3.buffer / t3.extent;
	          let o3 = e3;
	          const s2 = Y(e3, 1, -1 - i3, i3, 0, -1, 2, t3), n2 = Y(e3, 1, 1 - i3, 2 + i3, 0, -1, 2, t3);
	          return (s2 || n2) && (o3 = Y(e3, 1, -i3, 1 + i3, 0, -1, 2, t3) || [], s2 && (o3 = K(s2, 1).concat(o3)), n2 && (o3 = o3.concat(K(n2, -1)))), o3;
	        }(o2, t2), o2.length && this.splitTile(o2, 0, 0, 0), i2 && (o2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
	      }
	      splitTile(e2, t2, i2, o2, s2, n2, r2) {
	        const a2 = [e2, t2, i2, o2], l2 = this.options, c2 = l2.debug;
	        for (; a2.length; ) {
	          o2 = a2.pop(), i2 = a2.pop(), t2 = a2.pop(), e2 = a2.pop();
	          const h2 = 1 << t2, u2 = ae(t2, i2, o2);
	          let d2 = this.tiles[u2];
	          if (!d2 && (c2 > 1 && console.time("creation"), d2 = this.tiles[u2] = ie(e2, t2, i2, o2, l2), this.tileCoords.push({ z: t2, x: i2, y: o2 }), c2)) {
	            c2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, i2, o2, d2.numFeatures, d2.numPoints, d2.numSimplified), console.timeEnd("creation"));
	            const e3 = `z${t2}`;
	            this.stats[e3] = (this.stats[e3] || 0) + 1, this.total++;
	          }
	          if (d2.source = e2, null == s2) {
	            if (t2 === l2.indexMaxZoom || d2.numPoints <= l2.indexMaxPoints) continue;
	          } else {
	            if (t2 === l2.maxZoom || t2 === s2) continue;
	            if (null != s2) {
	              const e3 = s2 - t2;
	              if (i2 !== n2 >> e3 || o2 !== r2 >> e3) continue;
	            }
	          }
	          if (d2.source = null, 0 === e2.length) continue;
	          c2 > 1 && console.time("clipping");
	          const f2 = 0.5 * l2.buffer / l2.extent, g2 = 0.5 - f2, p2 = 0.5 + f2, m2 = 1 + f2;
	          let y2 = null, v2 = null, w2 = null, x2 = null, _2 = Y(e2, h2, i2 - f2, i2 + p2, 0, d2.minX, d2.maxX, l2), S2 = Y(e2, h2, i2 + g2, i2 + m2, 0, d2.minX, d2.maxX, l2);
	          e2 = null, _2 && (y2 = Y(_2, h2, o2 - f2, o2 + p2, 1, d2.minY, d2.maxY, l2), v2 = Y(_2, h2, o2 + g2, o2 + m2, 1, d2.minY, d2.maxY, l2), _2 = null), S2 && (w2 = Y(S2, h2, o2 - f2, o2 + p2, 1, d2.minY, d2.maxY, l2), x2 = Y(S2, h2, o2 + g2, o2 + m2, 1, d2.minY, d2.maxY, l2), S2 = null), c2 > 1 && console.timeEnd("clipping"), a2.push(y2 || [], t2 + 1, 2 * i2, 2 * o2), a2.push(v2 || [], t2 + 1, 2 * i2, 2 * o2 + 1), a2.push(w2 || [], t2 + 1, 2 * i2 + 1, 2 * o2), a2.push(x2 || [], t2 + 1, 2 * i2 + 1, 2 * o2 + 1);
	        }
	      }
	      getTile(e2, t2, i2) {
	        e2 = +e2, t2 = +t2, i2 = +i2;
	        const o2 = this.options, { extent: s2, debug: n2 } = o2;
	        if (e2 < 0 || e2 > 24) return null;
	        const r2 = 1 << e2, a2 = ae(e2, t2 = t2 + r2 & r2 - 1, i2);
	        if (this.tiles[a2]) return ee(this.tiles[a2], s2);
	        n2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, i2);
	        let l2, c2 = e2, h2 = t2, u2 = i2;
	        for (; !l2 && c2 > 0; ) c2--, h2 >>= 1, u2 >>= 1, l2 = this.tiles[ae(c2, h2, u2)];
	        return l2 && l2.source ? (n2 > 1 && (console.log("found parent tile z%d-%d-%d", c2, h2, u2), console.time("drilling down")), this.splitTile(l2.source, c2, h2, u2, e2, t2, i2), n2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? ee(this.tiles[a2], s2) : null) : null;
	      }
	    }
	    function ae(e2, t2, i2) {
	      return 32 * ((1 << e2) * i2 + t2) + e2;
	    }
	    class le extends w {
	      constructor(e2, t2, i2, o2 = ce) {
	        super(e2, t2, i2), this._dataUpdateable = /* @__PURE__ */ new Map(), this._createGeoJSONIndex = o2;
	      }
	      loadVectorTile(t2, i2) {
	        return e._(this, void 0, void 0, function* () {
	          const i3 = t2.tileID.canonical;
	          if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
	          const o2 = this._geoJSONIndex.getTile(i3.z, i3.x, i3.y);
	          return o2 ? y(new r(o2.features, { version: 2, extent: e.a4 })) : null;
	        });
	      }
	      loadData(t2) {
	        return e._(this, void 0, void 0, function* () {
	          var i2;
	          null === (i2 = this._pendingRequest) || void 0 === i2 || i2.abort();
	          const o2 = this._startPerformance(t2);
	          this._pendingRequest = new AbortController();
	          try {
	            (!this._pendingData || t2.request || t2.data || t2.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON(t2, this._pendingRequest));
	            const i3 = yield this._pendingData;
	            this._geoJSONIndex = this._createGeoJSONIndex(i3, t2), this.loaded = {};
	            const s2 = t2.dataDiff && e.a6(i3) ? { applyDiff: true } : { data: i3 };
	            return this._finishPerformance(o2, t2, s2), s2;
	          } catch (t3) {
	            if (delete this._pendingRequest, e.cH(t3)) return { abandoned: true };
	            throw t3;
	          }
	        });
	      }
	      _startPerformance(t2) {
	        var i2;
	        if (null === (i2 = null == t2 ? void 0 : t2.request) || void 0 === i2 ? void 0 : i2.collectResourceTiming) return new e.c$(t2.request);
	      }
	      _finishPerformance(e2, t2, i2) {
	        if (!e2) return;
	        const o2 = e2.finish();
	        o2 && (i2.resourceTiming = {}, i2.resourceTiming[t2.source] = JSON.parse(JSON.stringify(o2)));
	      }
	      getData() {
	        return e._(this, void 0, void 0, function* () {
	          return this._pendingData;
	        });
	      }
	      reloadTile(e2) {
	        const t2 = this.loaded;
	        return t2 && t2[e2.uid] ? super.reloadTile(e2) : this.loadTile(e2);
	      }
	      loadAndProcessGeoJSON(t2, i2) {
	        return e._(this, void 0, void 0, function* () {
	          let e2;
	          if (t2.request ? e2 = yield this.loadGeoJSONFromUrl(t2.request, t2.promoteId, i2) : t2.data ? e2 = this._loadGeoJSONFromObject(t2.data, t2.promoteId) : t2.dataDiff && (e2 = this._loadGeoJSONFromDiff(t2.dataDiff, t2.promoteId, t2.source)), delete this._pendingRequest, "object" != typeof e2) throw new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`);
	          return M(e2, true), t2.filter && (e2 = this._filterGeoJSON(e2, t2.filter)), e2;
	        });
	      }
	      loadGeoJSONFromUrl(t2, i2, o2) {
	        return e._(this, void 0, void 0, function* () {
	          const s2 = yield e.j(t2, o2);
	          return this._dataUpdateable = e.a6(s2.data, i2) ? e.a7(s2.data, i2) : void 0, s2.data;
	        });
	      }
	      _loadGeoJSONFromObject(t2, i2) {
	        return this._dataUpdateable = e.a6(t2, i2) ? e.a7(t2, i2) : void 0, t2;
	      }
	      _loadGeoJSONFromDiff(t2, i2, o2) {
	        if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${o2}`);
	        e.a8(this._dataUpdateable, t2, i2);
	        const s2 = Array.from(this._dataUpdateable.values());
	        return this._toFeatureCollection(s2);
	      }
	      _filterGeoJSON(t2, i2) {
	        const o2 = e.d3(i2, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
	        if ("error" === o2.result) throw new Error(o2.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
	        const s2 = t2.features.filter((e2) => o2.value.evaluate({ zoom: 0 }, e2));
	        return this._toFeatureCollection(s2);
	      }
	      _toFeatureCollection(e2) {
	        return { type: "FeatureCollection", features: e2 };
	      }
	      removeSource(t2) {
	        return e._(this, void 0, void 0, function* () {
	          this._pendingRequest && this._pendingRequest.abort();
	        });
	      }
	      getClusterExpansionZoom(e2) {
	        return this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId);
	      }
	      getClusterChildren(e2) {
	        return this._geoJSONIndex.getChildren(e2.clusterId);
	      }
	      getClusterLeaves(e2) {
	        return this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset);
	      }
	    }
	    function ce(t2, i2) {
	      return i2.cluster ? new D(function({ superclusterOptions: t3, clusterProperties: i3 }) {
	        if (!i3 || !t3) return t3;
	        const o2 = {}, s2 = {}, n2 = { accumulated: null, zoom: 0 }, r2 = { properties: null }, a2 = Object.keys(i3);
	        for (const t4 of a2) {
	          const [n3, r3] = i3[t4], a3 = e.d3(r3), l2 = e.d3("string" == typeof n3 ? [n3, ["accumulated"], ["get", t4]] : n3);
	          o2[t4] = a3.value, s2[t4] = l2.value;
	        }
	        return t3.map = (e2) => {
	          r2.properties = e2;
	          const t4 = {};
	          for (const e3 of a2) t4[e3] = o2[e3].evaluate(n2, r2);
	          return t4;
	        }, t3.reduce = (e2, t4) => {
	          r2.properties = t4;
	          for (const t5 of a2) n2.accumulated = e2[t5], e2[t5] = s2[t5].evaluate(n2, r2);
	        }, t3;
	      }(i2)).load(t2.features) : function(e2, t3) {
	        return new re(e2, t3);
	      }(t2, i2.geojsonVtOptions);
	    }
	    class he {
	      constructor(t2) {
	        this.self = t2, this.actor = new e.L(t2), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = /* @__PURE__ */ new Map(), this.self.registerWorkerSource = (e2, t3) => {
	          if (this.externalWorkerSourceTypes[e2]) throw new Error(`Worker source with name "${e2}" already registered.`);
	          this.externalWorkerSourceTypes[e2] = t3;
	        }, this.self.addProtocol = e.cJ, this.self.removeProtocol = e.cK, this.self.registerRTLTextPlugin = (t3) => {
	          e.d4.setMethods(t3);
	        }, this.actor.registerMessageHandler("LDT", (e2, t3) => this._getDEMWorkerSource(e2, t3.source).loadTile(t3)), this.actor.registerMessageHandler("RDT", (t3, i2) => e._(this, void 0, void 0, function* () {
	          this._getDEMWorkerSource(t3, i2.source).removeTile(i2);
	        })), this.actor.registerMessageHandler("GCEZ", (t3, i2) => e._(this, void 0, void 0, function* () {
	          return this._getWorkerSource(t3, i2.type, i2.source).getClusterExpansionZoom(i2);
	        })), this.actor.registerMessageHandler("GCC", (t3, i2) => e._(this, void 0, void 0, function* () {
	          return this._getWorkerSource(t3, i2.type, i2.source).getClusterChildren(i2);
	        })), this.actor.registerMessageHandler("GCL", (t3, i2) => e._(this, void 0, void 0, function* () {
	          return this._getWorkerSource(t3, i2.type, i2.source).getClusterLeaves(i2);
	        })), this.actor.registerMessageHandler("LD", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).loadData(t3)), this.actor.registerMessageHandler("GD", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).getData()), this.actor.registerMessageHandler("LT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).loadTile(t3)), this.actor.registerMessageHandler("RT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).reloadTile(t3)), this.actor.registerMessageHandler("AT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).abortTile(t3)), this.actor.registerMessageHandler("RMT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).removeTile(t3)), this.actor.registerMessageHandler("RS", (t3, i2) => e._(this, void 0, void 0, function* () {
	          if (!this.workerSources[t3] || !this.workerSources[t3][i2.type] || !this.workerSources[t3][i2.type][i2.source]) return;
	          const e2 = this.workerSources[t3][i2.type][i2.source];
	          delete this.workerSources[t3][i2.type][i2.source], void 0 !== e2.removeSource && e2.removeSource(i2);
	        })), this.actor.registerMessageHandler("RM", (t3) => e._(this, void 0, void 0, function* () {
	          delete this.layerIndexes[t3], delete this.availableImages[t3], delete this.workerSources[t3], delete this.demWorkerSources[t3], this.globalStates.delete(t3);
	        })), this.actor.registerMessageHandler("SR", (t3, i2) => e._(this, void 0, void 0, function* () {
	          this.referrer = i2;
	        })), this.actor.registerMessageHandler("SRPS", (e2, t3) => this._syncRTLPluginState(e2, t3)), this.actor.registerMessageHandler("IS", (t3, i2) => e._(this, void 0, void 0, function* () {
	          this.self.importScripts(i2);
	        })), this.actor.registerMessageHandler("SI", (e2, t3) => this._setImages(e2, t3)), this.actor.registerMessageHandler("UL", (t3, i2) => e._(this, void 0, void 0, function* () {
	          this._getLayerIndex(t3).update(i2.layers, i2.removedIds, this._getGlobalState(t3));
	        })), this.actor.registerMessageHandler("UGS", (t3, i2) => e._(this, void 0, void 0, function* () {
	          const e2 = this._getGlobalState(t3);
	          for (const t4 in i2) e2[t4] = i2[t4];
	        })), this.actor.registerMessageHandler("SL", (t3, i2) => e._(this, void 0, void 0, function* () {
	          this._getLayerIndex(t3).replace(i2, this._getGlobalState(t3));
	        }));
	      }
	      _getGlobalState(e2) {
	        let t2 = this.globalStates.get(e2);
	        return t2 || (t2 = {}, this.globalStates.set(e2, t2)), t2;
	      }
	      _setImages(t2, i2) {
	        return e._(this, void 0, void 0, function* () {
	          this.availableImages[t2] = i2;
	          for (const e2 in this.workerSources[t2]) {
	            const o2 = this.workerSources[t2][e2];
	            for (const e3 in o2) o2[e3].availableImages = i2;
	          }
	        });
	      }
	      _syncRTLPluginState(t2, i2) {
	        return e._(this, void 0, void 0, function* () {
	          return yield e.d4.syncState(i2, this.self.importScripts);
	        });
	      }
	      _getAvailableImages(e2) {
	        let t2 = this.availableImages[e2];
	        return t2 || (t2 = []), t2;
	      }
	      _getLayerIndex(e2) {
	        let i2 = this.layerIndexes[e2];
	        return i2 || (i2 = this.layerIndexes[e2] = new t()), i2;
	      }
	      _getWorkerSource(e2, t2, i2) {
	        if (this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t2] || (this.workerSources[e2][t2] = {}), !this.workerSources[e2][t2][i2]) {
	          const o2 = { sendAsync: (t3, i3) => (t3.targetMapId = e2, this.actor.sendAsync(t3, i3)) };
	          switch (t2) {
	            case "vector":
	              this.workerSources[e2][t2][i2] = new w(o2, this._getLayerIndex(e2), this._getAvailableImages(e2));
	              break;
	            case "geojson":
	              this.workerSources[e2][t2][i2] = new le(o2, this._getLayerIndex(e2), this._getAvailableImages(e2));
	              break;
	            default:
	              this.workerSources[e2][t2][i2] = new this.externalWorkerSourceTypes[t2](o2, this._getLayerIndex(e2), this._getAvailableImages(e2));
	          }
	        }
	        return this.workerSources[e2][t2][i2];
	      }
	      _getDEMWorkerSource(e2, t2) {
	        return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t2] || (this.demWorkerSources[e2][t2] = new x()), this.demWorkerSources[e2][t2];
	      }
	    }
	    return e.i(self) && (self.worker = new he(self)), he;
	  });
	  define2("index", ["exports", "./shared"], function(e, t) {
	    var i = "5.13.0";
	    function a() {
	      var e2 = new t.A(4);
	      return t.A != Float32Array && (e2[1] = 0, e2[2] = 0), e2[0] = 1, e2[3] = 1, e2;
	    }
	    let r, o, s;
	    const n = { frame(e2, i2, a2) {
	      const r2 = requestAnimationFrame((e3) => {
	        o2(), i2(e3);
	      }), { unsubscribe: o2 } = t.s(e2.signal, "abort", () => {
	        o2(), cancelAnimationFrame(r2), a2(t.c());
	      }, false);
	    }, frameAsync(e2) {
	      return new Promise((t2, i2) => {
	        this.frame(e2, t2, i2);
	      });
	    }, getImageData(e2, t2 = 0) {
	      return this.getImageCanvasContext(e2).getImageData(-t2, -t2, e2.width + 2 * t2, e2.height + 2 * t2);
	    }, getImageCanvasContext(e2) {
	      const t2 = window.document.createElement("canvas"), i2 = t2.getContext("2d", { willReadFrequently: true });
	      if (!i2) throw new Error("failed to create canvas 2d context");
	      return t2.width = e2.width, t2.height = e2.height, i2.drawImage(e2, 0, 0, e2.width, e2.height), i2;
	    }, resolveURL: (e2) => (r || (r = document.createElement("a")), r.href = e2, r.href), hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
	      return void 0 !== s ? s : !!matchMedia && (null == o && (o = matchMedia("(prefers-reduced-motion: reduce)")), o.matches);
	    }, set prefersReducedMotion(e2) {
	      s = e2;
	    } }, l = new class {
	      constructor() {
	        this._realTime = "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null;
	      }
	      getCurrentTime() {
	        return null !== this._frozenAt ? this._frozenAt : this._realTime();
	      }
	      setNow(e2) {
	        this._frozenAt = e2;
	      }
	      restoreNow() {
	        this._frozenAt = null;
	      }
	      isFrozen() {
	        return null !== this._frozenAt;
	      }
	    }();
	    function c() {
	      return l.getCurrentTime();
	    }
	    class h {
	      static testProp(e2) {
	        if (!h.docStyle) return e2[0];
	        for (let t2 = 0; t2 < e2.length; t2++) if (e2[t2] in h.docStyle) return e2[t2];
	        return e2[0];
	      }
	      static create(e2, t2, i2) {
	        const a2 = window.document.createElement(e2);
	        return void 0 !== t2 && (a2.className = t2), i2 && i2.appendChild(a2), a2;
	      }
	      static createNS(e2, t2) {
	        return window.document.createElementNS(e2, t2);
	      }
	      static disableDrag() {
	        h.docStyle && h.selectProp && (h.userSelect = h.docStyle[h.selectProp], h.docStyle[h.selectProp] = "none");
	      }
	      static enableDrag() {
	        h.docStyle && h.selectProp && (h.docStyle[h.selectProp] = h.userSelect);
	      }
	      static setTransform(e2, t2) {
	        e2.style[h.transformProp] = t2;
	      }
	      static addEventListener(e2, t2, i2, a2 = {}) {
	        e2.addEventListener(t2, i2, "passive" in a2 ? a2 : a2.capture);
	      }
	      static removeEventListener(e2, t2, i2, a2 = {}) {
	        e2.removeEventListener(t2, i2, "passive" in a2 ? a2 : a2.capture);
	      }
	      static suppressClickInternal(e2) {
	        e2.preventDefault(), e2.stopPropagation(), window.removeEventListener("click", h.suppressClickInternal, true);
	      }
	      static suppressClick() {
	        window.addEventListener("click", h.suppressClickInternal, true), window.setTimeout(() => {
	          window.removeEventListener("click", h.suppressClickInternal, true);
	        }, 0);
	      }
	      static getScale(e2) {
	        const t2 = e2.getBoundingClientRect();
	        return { x: t2.width / e2.offsetWidth || 1, y: t2.height / e2.offsetHeight || 1, boundingClientRect: t2 };
	      }
	      static getPoint(e2, i2, a2) {
	        const r2 = i2.boundingClientRect;
	        return new t.P((a2.clientX - r2.left) / i2.x - e2.clientLeft, (a2.clientY - r2.top) / i2.y - e2.clientTop);
	      }
	      static mousePos(e2, t2) {
	        const i2 = h.getScale(e2);
	        return h.getPoint(e2, i2, t2);
	      }
	      static touchPos(e2, t2) {
	        const i2 = [], a2 = h.getScale(e2);
	        for (let r2 = 0; r2 < t2.length; r2++) i2.push(h.getPoint(e2, a2, t2[r2]));
	        return i2;
	      }
	      static mouseButton(e2) {
	        return e2.button;
	      }
	      static remove(e2) {
	        e2.parentNode && e2.parentNode.removeChild(e2);
	      }
	      static sanitize(e2) {
	        const t2 = new DOMParser().parseFromString(e2, "text/html").body || document.createElement("body"), i2 = t2.querySelectorAll("script");
	        for (const e3 of i2) e3.remove();
	        return h.clean(t2), t2.innerHTML;
	      }
	      static isPossiblyDangerous(e2, t2) {
	        const i2 = t2.replace(/\s+/g, "").toLowerCase();
	        return !(!["src", "href", "xlink:href"].includes(e2) || !i2.includes("javascript:") && !i2.includes("data:")) || !!e2.startsWith("on") || void 0;
	      }
	      static clean(e2) {
	        const t2 = e2.children;
	        for (const e3 of t2) h.removeAttributes(e3), h.clean(e3);
	      }
	      static removeAttributes(e2) {
	        for (const { name: t2, value: i2 } of e2.attributes) h.isPossiblyDangerous(t2, i2) && e2.removeAttribute(t2);
	      }
	    }
	    h.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, h.selectProp = h.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), h.transformProp = h.testProp(["transform", "WebkitTransform"]);
	    const u = { supported: false, testSupport: function(e2) {
	      !p && _ && (m ? f(e2) : d = e2);
	    } };
	    let d, _, p = false, m = false;
	    function f(e2) {
	      const t2 = e2.createTexture();
	      e2.bindTexture(e2.TEXTURE_2D, t2);
	      try {
	        if (e2.texImage2D(e2.TEXTURE_2D, 0, e2.RGBA, e2.RGBA, e2.UNSIGNED_BYTE, _), e2.isContextLost()) return;
	        u.supported = true;
	      } catch (e3) {
	      }
	      e2.deleteTexture(t2), p = true;
	    }
	    var g;
	    "undefined" != typeof document && (_ = document.createElement("img"), _.onload = () => {
	      d && f(d), d = null, m = true;
	    }, _.onerror = () => {
	      p = true, d = null;
	    }, _.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(e2) {
	      let i2, a2, r2, o2;
	      e2.resetRequestQueue = () => {
	        i2 = [], a2 = 0, r2 = 0, o2 = {};
	      }, e2.addThrottleControl = (e3) => {
	        const t2 = r2++;
	        return o2[t2] = e3, t2;
	      }, e2.removeThrottleControl = (e3) => {
	        delete o2[e3], n2();
	      }, e2.getImage = (e3, a3, r3 = true) => new Promise((o3, s3) => {
	        u.supported && (e3.headers || (e3.headers = {}), e3.headers.accept = "image/webp,*/*"), t.e(e3, { type: "image" }), i2.push({ abortController: a3, requestParameters: e3, supportImageRefresh: r3, state: "queued", onError: (e4) => {
	          s3(e4);
	        }, onSuccess: (e4) => {
	          o3(e4);
	        } }), n2();
	      });
	      const s2 = (e3) => t._(this, void 0, void 0, function* () {
	        e3.state = "running";
	        const { requestParameters: i3, supportImageRefresh: r3, onError: o3, onSuccess: s3, abortController: c2 } = e3, h2 = false === r3 && !t.i(self) && !t.g(i3.url) && (!i3.headers || Object.keys(i3.headers).reduce((e4, t2) => e4 && "accept" === t2, true));
	        a2++;
	        const u2 = h2 ? l2(i3, c2) : t.m(i3, c2);
	        try {
	          const i4 = yield u2;
	          delete e3.abortController, e3.state = "completed", i4.data instanceof HTMLImageElement || t.b(i4.data) ? s3(i4) : i4.data && s3({ data: yield (d2 = i4.data, "function" == typeof createImageBitmap ? t.f(d2) : t.h(d2)), cacheControl: i4.cacheControl, expires: i4.expires });
	        } catch (t2) {
	          delete e3.abortController, o3(t2);
	        } finally {
	          a2--, n2();
	        }
	        var d2;
	      }), n2 = () => {
	        const e3 = (() => {
	          for (const e4 of Object.keys(o2)) if (o2[e4]()) return true;
	          return false;
	        })() ? t.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : t.a.MAX_PARALLEL_IMAGE_REQUESTS;
	        for (let t2 = a2; t2 < e3 && i2.length > 0; t2++) {
	          const e4 = i2.shift();
	          e4.abortController.signal.aborted ? t2-- : s2(e4);
	        }
	      }, l2 = (e3, i3) => new Promise((a3, r3) => {
	        const o3 = new Image(), s3 = e3.url, n3 = e3.credentials;
	        n3 && "include" === n3 ? o3.crossOrigin = "use-credentials" : (n3 && "same-origin" === n3 || !t.d(s3)) && (o3.crossOrigin = "anonymous"), i3.signal.addEventListener("abort", () => {
	          o3.src = "", r3(t.c());
	        }), o3.fetchPriority = "high", o3.onload = () => {
	          o3.onerror = o3.onload = null, a3({ data: o3 });
	        }, o3.onerror = () => {
	          o3.onerror = o3.onload = null, i3.signal.aborted || r3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
	        }, o3.src = s3;
	      });
	    }(g || (g = {})), g.resetRequestQueue();
	    class v {
	      constructor(e2) {
	        this._transformRequestFn = null != e2 ? e2 : null;
	      }
	      transformRequest(e2, t2) {
	        return this._transformRequestFn && this._transformRequestFn(e2, t2) || { url: e2 };
	      }
	      setTransformRequest(e2) {
	        this._transformRequestFn = e2;
	      }
	    }
	    function x(e2) {
	      const t2 = [];
	      if ("string" == typeof e2) t2.push({ id: "default", url: e2 });
	      else if (e2 && e2.length > 0) {
	        const i2 = [];
	        for (const { id: a2, url: r2 } of e2) {
	          const e3 = `${a2}${r2}`;
	          -1 === i2.indexOf(e3) && (i2.push(e3), t2.push({ id: a2, url: r2 }));
	        }
	      }
	      return t2;
	    }
	    function b(e2, t2, i2) {
	      try {
	        const a2 = new URL(e2);
	        return a2.pathname += `${t2}${i2}`, a2.toString();
	      } catch (t3) {
	        throw new Error(`Invalid sprite URL "${e2}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
	      }
	    }
	    function y(e2) {
	      const { userImage: t2 } = e2;
	      return !!(t2 && t2.render && t2.render()) && (e2.data.replace(new Uint8Array(t2.data.buffer)), true);
	    }
	    class w extends t.E {
	      constructor() {
	        super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t.R({ width: 1, height: 1 }), this.dirty = true;
	      }
	      destroy() {
	        this.atlasTexture && (this.atlasTexture.destroy(), this.atlasTexture = null);
	        for (const e2 of Object.keys(this.images)) this.removeImage(e2);
	        this.patterns = {}, this.atlasImage = new t.R({ width: 1, height: 1 }), this.dirty = true;
	      }
	      isLoaded() {
	        return this.loaded;
	      }
	      setLoaded(e2) {
	        if (this.loaded !== e2 && (this.loaded = e2, e2)) {
	          for (const { ids: e3, promiseResolve: t2 } of this.requestors) t2(this._getImagesForIds(e3));
	          this.requestors = [];
	        }
	      }
	      getImage(e2) {
	        const i2 = this.images[e2];
	        if (i2 && !i2.data && i2.spriteData) {
	          const e3 = i2.spriteData;
	          i2.data = new t.R({ width: e3.width, height: e3.height }, e3.context.getImageData(e3.x, e3.y, e3.width, e3.height).data), i2.spriteData = null;
	        }
	        return i2;
	      }
	      addImage(e2, t2) {
	        if (this.images[e2]) throw new Error(`Image id ${e2} already exist, use updateImage instead`);
	        this._validate(e2, t2) && (this.images[e2] = t2);
	      }
	      _validate(e2, i2) {
	        let a2 = true;
	        const r2 = i2.data || i2.spriteData;
	        return this._validateStretch(i2.stretchX, r2 && r2.width) || (this.fire(new t.k(new Error(`Image "${e2}" has invalid "stretchX" value`))), a2 = false), this._validateStretch(i2.stretchY, r2 && r2.height) || (this.fire(new t.k(new Error(`Image "${e2}" has invalid "stretchY" value`))), a2 = false), this._validateContent(i2.content, i2) || (this.fire(new t.k(new Error(`Image "${e2}" has invalid "content" value`))), a2 = false), a2;
	      }
	      _validateStretch(e2, t2) {
	        if (!e2) return true;
	        let i2 = 0;
	        for (const a2 of e2) {
	          if (a2[0] < i2 || a2[1] < a2[0] || t2 < a2[1]) return false;
	          i2 = a2[1];
	        }
	        return true;
	      }
	      _validateContent(e2, t2) {
	        if (!e2) return true;
	        if (4 !== e2.length) return false;
	        const i2 = t2.spriteData, a2 = i2 && i2.width || t2.data.width, r2 = i2 && i2.height || t2.data.height;
	        return !(e2[0] < 0 || a2 < e2[0] || e2[1] < 0 || r2 < e2[1] || e2[2] < 0 || a2 < e2[2] || e2[3] < 0 || r2 < e2[3] || e2[2] < e2[0] || e2[3] < e2[1]);
	      }
	      updateImage(e2, t2, i2 = true) {
	        const a2 = this.getImage(e2);
	        if (i2 && (a2.data.width !== t2.data.width || a2.data.height !== t2.data.height)) throw new Error(`size mismatch between old image (${a2.data.width}x${a2.data.height}) and new image (${t2.data.width}x${t2.data.height}).`);
	        t2.version = a2.version + 1, this.images[e2] = t2, this.updatedImages[e2] = true;
	      }
	      removeImage(e2) {
	        const t2 = this.images[e2];
	        delete this.images[e2], delete this.patterns[e2], t2.userImage && t2.userImage.onRemove && t2.userImage.onRemove();
	      }
	      listImages() {
	        return Object.keys(this.images);
	      }
	      getImages(e2) {
	        return new Promise((t2, i2) => {
	          let a2 = true;
	          if (!this.isLoaded()) for (const t3 of e2) this.images[t3] || (a2 = false);
	          this.isLoaded() || a2 ? t2(this._getImagesForIds(e2)) : this.requestors.push({ ids: e2, promiseResolve: t2 });
	        });
	      }
	      _getImagesForIds(e2) {
	        const i2 = {};
	        for (const a2 of e2) {
	          let e3 = this.getImage(a2);
	          e3 || (this.fire(new t.l("styleimagemissing", { id: a2 })), e3 = this.getImage(a2)), e3 ? i2[a2] = { data: e3.data.clone(), pixelRatio: e3.pixelRatio, sdf: e3.sdf, version: e3.version, stretchX: e3.stretchX, stretchY: e3.stretchY, content: e3.content, textFitWidth: e3.textFitWidth, textFitHeight: e3.textFitHeight, hasRenderCallback: Boolean(e3.userImage && e3.userImage.render) } : t.w(`Image "${a2}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
	        }
	        return i2;
	      }
	      getPixelSize() {
	        const { width: e2, height: t2 } = this.atlasImage;
	        return { width: e2, height: t2 };
	      }
	      getPattern(e2) {
	        const i2 = this.patterns[e2], a2 = this.getImage(e2);
	        if (!a2) return null;
	        if (i2 && i2.position.version === a2.version) return i2.position;
	        if (i2) i2.position.version = a2.version;
	        else {
	          const i3 = { w: a2.data.width + 2, h: a2.data.height + 2, x: 0, y: 0 }, r2 = new t.I(i3, a2);
	          this.patterns[e2] = { bin: i3, position: r2 };
	        }
	        return this._updatePatternAtlas(), this.patterns[e2].position;
	      }
	      bind(e2) {
	        const i2 = e2.gl;
	        this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new t.T(e2, this.atlasImage, i2.RGBA), this.atlasTexture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
	      }
	      _updatePatternAtlas() {
	        const e2 = [];
	        for (const t2 in this.patterns) e2.push(this.patterns[t2].bin);
	        const { w: i2, h: a2 } = t.p(e2), r2 = this.atlasImage;
	        r2.resize({ width: i2 || 1, height: a2 || 1 });
	        for (const e3 in this.patterns) {
	          const { bin: i3 } = this.patterns[e3], a3 = i3.x + 1, o2 = i3.y + 1, s2 = this.getImage(e3).data, n2 = s2.width, l2 = s2.height;
	          t.R.copy(s2, r2, { x: 0, y: 0 }, { x: a3, y: o2 }, { width: n2, height: l2 }), t.R.copy(s2, r2, { x: 0, y: l2 - 1 }, { x: a3, y: o2 - 1 }, { width: n2, height: 1 }), t.R.copy(s2, r2, { x: 0, y: 0 }, { x: a3, y: o2 + l2 }, { width: n2, height: 1 }), t.R.copy(s2, r2, { x: n2 - 1, y: 0 }, { x: a3 - 1, y: o2 }, { width: 1, height: l2 }), t.R.copy(s2, r2, { x: 0, y: 0 }, { x: a3 + n2, y: o2 }, { width: 1, height: l2 });
	        }
	        this.dirty = true;
	      }
	      beginFrame() {
	        this.callbackDispatchedThisFrame = {};
	      }
	      dispatchRenderCallbacks(e2) {
	        for (const i2 of e2) {
	          if (this.callbackDispatchedThisFrame[i2]) continue;
	          this.callbackDispatchedThisFrame[i2] = true;
	          const e3 = this.getImage(i2);
	          e3 || t.w(`Image with ID: "${i2}" was not found`), y(e3) && this.updateImage(i2, e3);
	        }
	      }
	      cloneImages() {
	        const e2 = {};
	        for (const t2 in this.images) {
	          const i2 = this.images[t2];
	          e2[t2] = Object.assign(Object.assign({}, i2), { data: i2.data ? i2.data.clone() : null });
	        }
	        return e2;
	      }
	    }
	    const T = 1e20;
	    function P(e2, t2, i2, a2, r2, o2, s2, n2, l2) {
	      for (let c2 = t2; c2 < t2 + a2; c2++) C(e2, i2 * o2 + c2, o2, r2, s2, n2, l2);
	      for (let c2 = i2; c2 < i2 + r2; c2++) C(e2, c2 * o2 + t2, 1, a2, s2, n2, l2);
	    }
	    function C(e2, t2, i2, a2, r2, o2, s2) {
	      o2[0] = 0, s2[0] = -T, s2[1] = T, r2[0] = e2[t2];
	      for (let n2 = 1, l2 = 0, c2 = 0; n2 < a2; n2++) {
	        r2[n2] = e2[t2 + n2 * i2];
	        const a3 = n2 * n2;
	        do {
	          const e3 = o2[l2];
	          c2 = (r2[n2] - r2[e3] + a3 - e3 * e3) / (n2 - e3) / 2;
	        } while (c2 <= s2[l2] && --l2 > -1);
	        l2++, o2[l2] = n2, s2[l2] = c2, s2[l2 + 1] = T;
	      }
	      for (let n2 = 0, l2 = 0; n2 < a2; n2++) {
	        for (; s2[l2 + 1] < n2; ) l2++;
	        const a3 = o2[l2], c2 = n2 - a3;
	        e2[t2 + n2 * i2] = r2[a3] + c2 * c2;
	      }
	    }
	    const M = t.v.layout_symbol["text-font"].default.join(",");
	    class I {
	      constructor(e2, t2, i2) {
	        this.requestManager = e2, this.localIdeographFontFamily = t2, this.entries = {}, this.lang = i2;
	      }
	      setURL(e2) {
	        this.url = e2;
	      }
	      getGlyphs(e2) {
	        return t._(this, void 0, void 0, function* () {
	          const t2 = [];
	          for (const i3 in e2) for (const a3 of e2[i3]) t2.push(this._getAndCacheGlyphsPromise(i3, a3));
	          const i2 = yield Promise.all(t2), a2 = {};
	          for (const { stack: e3, id: t3, glyph: r2 } of i2) a2[e3] || (a2[e3] = {}), a2[e3][t3] = r2 && { id: r2.id, bitmap: r2.bitmap.clone(), metrics: r2.metrics };
	          return a2;
	        });
	      }
	      _getAndCacheGlyphsPromise(e2, i2) {
	        return t._(this, void 0, void 0, function* () {
	          let t2 = this.entries[e2];
	          t2 || (t2 = this.entries[e2] = { glyphs: {}, requests: {}, ranges: {} });
	          let a2 = t2.glyphs[i2];
	          return void 0 !== a2 ? { stack: e2, id: i2, glyph: a2 } : !this.url || this._charUsesLocalIdeographFontFamily(i2) ? (a2 = t2.glyphs[i2] = this._drawGlyph(t2, e2, i2), { stack: e2, id: i2, glyph: a2 }) : yield this._downloadAndCacheRangePromise(e2, i2);
	        });
	      }
	      _downloadAndCacheRangePromise(e2, i2) {
	        return t._(this, void 0, void 0, function* () {
	          const t2 = this.entries[e2], a2 = Math.floor(i2 / 256);
	          if (t2.ranges[a2]) return { stack: e2, id: i2, glyph: null };
	          if (!t2.requests[a2]) {
	            const i3 = I.loadGlyphRange(e2, a2, this.url, this.requestManager);
	            t2.requests[a2] = i3;
	          }
	          try {
	            const r2 = yield t2.requests[a2];
	            for (const e3 in r2) t2.glyphs[+e3] = r2[+e3];
	            return t2.ranges[a2] = true, { stack: e2, id: i2, glyph: r2[i2] || null };
	          } catch (r2) {
	            const o2 = t2.glyphs[i2] = this._drawGlyph(t2, e2, i2);
	            return this._warnOnMissingGlyphRange(o2, a2, i2, r2), { stack: e2, id: i2, glyph: o2 };
	          }
	        });
	      }
	      _warnOnMissingGlyphRange(e2, i2, a2, r2) {
	        const o2 = 256 * i2, s2 = o2 + 255, n2 = a2.toString(16).padStart(4, "0").toUpperCase();
	        t.w(`Unable to load glyph range ${i2}, ${o2}-${s2}. Rendering codepoint U+${n2} locally instead. ${r2}`);
	      }
	      _charUsesLocalIdeographFontFamily(e2) {
	        return !!this.localIdeographFontFamily && t.q(e2);
	      }
	      _drawGlyph(e2, i2, a2) {
	        const r2 = i2 === M && "" !== this.localIdeographFontFamily && this._charUsesLocalIdeographFontFamily(a2), o2 = r2 ? "ideographTinySDF" : "tinySDF";
	        e2[o2] || (e2[o2] = this._createTinySDF(r2 ? this.localIdeographFontFamily : i2));
	        const s2 = e2[o2].draw(String.fromCodePoint(a2));
	        return { id: a2, bitmap: new t.r({ width: s2.width || 60, height: s2.height || 60 }, s2.data), metrics: { width: s2.glyphWidth / 2 || 24, height: s2.glyphHeight / 2 || 24, left: s2.glyphLeft / 2 + 0.5 || 0, top: s2.glyphTop / 2 - 27.5 || -8, advance: s2.glyphAdvance / 2 || 24, isDoubleResolution: true } };
	      }
	      _createTinySDF(e2) {
	        const t2 = e2 ? e2.split(",") : [];
	        t2.push("sans-serif");
	        const i2 = t2.map((e3) => /[-\w]+/.test(e3) ? e3 : `'${CSS.escape(e3)}'`).join(",");
	        return new I.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: i2, fontWeight: this._fontWeight(t2[0]), fontStyle: this._fontStyle(t2[0]), lang: this.lang });
	      }
	      _fontStyle(e2) {
	        return /italic/i.test(e2) ? "italic" : /oblique/i.test(e2) ? "oblique" : "normal";
	      }
	      _fontWeight(e2) {
	        const t2 = { thin: 100, hairline: 100, "extra light": 200, "ultra light": 200, light: 300, normal: 400, regular: 400, medium: 500, semibold: 600, demibold: 600, bold: 700, "extra bold": 800, "ultra bold": 800, black: 900, heavy: 900, "extra black": 950, "ultra black": 950 };
	        let i2;
	        for (const [a2, r2] of Object.entries(t2)) new RegExp(`\\b${a2}\\b`, "i").test(e2) && (i2 = `${r2}`);
	        return i2;
	      }
	      destroy() {
	        for (const e2 in this.entries) {
	          const t2 = this.entries[e2];
	          t2.tinySDF && (t2.tinySDF = null), t2.ideographTinySDF && (t2.ideographTinySDF = null), t2.glyphs = {}, t2.requests = {}, t2.ranges = {};
	        }
	        this.entries = {};
	      }
	    }
	    I.loadGlyphRange = function(e2, i2, a2, r2) {
	      return t._(this, void 0, void 0, function* () {
	        const o2 = 256 * i2, s2 = o2 + 255, n2 = r2.transformRequest(a2.replace("{fontstack}", e2).replace("{range}", `${o2}-${s2}`), "Glyphs"), l2 = yield t.n(n2, new AbortController());
	        if (!l2 || !l2.data) throw new Error(`Could not load glyph range. range: ${i2}, ${o2}-${s2}`);
	        const c2 = {};
	        for (const e3 of t.o(l2.data)) c2[e3.id] = e3;
	        return c2;
	      });
	    }, I.TinySDF = class {
	      constructor({ fontSize: e2 = 24, buffer: t2 = 3, radius: i2 = 8, cutoff: a2 = 0.25, fontFamily: r2 = "sans-serif", fontWeight: o2 = "normal", fontStyle: s2 = "normal", lang: n2 = null } = {}) {
	        this.buffer = t2, this.cutoff = a2, this.radius = i2, this.lang = n2;
	        const l2 = this.size = e2 + 4 * t2, c2 = this._createCanvas(l2), h2 = this.ctx = c2.getContext("2d", { willReadFrequently: true });
	        h2.font = `${s2} ${o2} ${e2}px ${r2}`, h2.textBaseline = "alphabetic", h2.textAlign = "left", h2.fillStyle = "black", this.gridOuter = new Float64Array(l2 * l2), this.gridInner = new Float64Array(l2 * l2), this.f = new Float64Array(l2), this.z = new Float64Array(l2 + 1), this.v = new Uint16Array(l2);
	      }
	      _createCanvas(e2) {
	        const t2 = document.createElement("canvas");
	        return t2.width = t2.height = e2, t2;
	      }
	      draw(e2) {
	        const { width: t2, actualBoundingBoxAscent: i2, actualBoundingBoxDescent: a2, actualBoundingBoxLeft: r2, actualBoundingBoxRight: o2 } = this.ctx.measureText(e2), s2 = Math.ceil(i2), n2 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o2 - r2))), l2 = Math.min(this.size - this.buffer, s2 + Math.ceil(a2)), c2 = n2 + 2 * this.buffer, h2 = l2 + 2 * this.buffer, u2 = Math.max(c2 * h2, 0), d2 = new Uint8ClampedArray(u2), _2 = { data: d2, width: c2, height: h2, glyphWidth: n2, glyphHeight: l2, glyphTop: s2, glyphLeft: 0, glyphAdvance: t2 };
	        if (0 === n2 || 0 === l2) return _2;
	        const { ctx: p2, buffer: m2, gridInner: f2, gridOuter: g2 } = this;
	        this.lang && (p2.lang = this.lang), p2.clearRect(m2, m2, n2, l2), p2.fillText(e2, m2, m2 + s2);
	        const v2 = p2.getImageData(m2, m2, n2, l2);
	        g2.fill(T, 0, u2), f2.fill(0, 0, u2);
	        for (let e3 = 0; e3 < l2; e3++) for (let t3 = 0; t3 < n2; t3++) {
	          const i3 = v2.data[4 * (e3 * n2 + t3) + 3] / 255;
	          if (0 === i3) continue;
	          const a3 = (e3 + m2) * c2 + t3 + m2;
	          if (1 === i3) g2[a3] = 0, f2[a3] = T;
	          else {
	            const e4 = 0.5 - i3;
	            g2[a3] = e4 > 0 ? e4 * e4 : 0, f2[a3] = e4 < 0 ? e4 * e4 : 0;
	          }
	        }
	        P(g2, 0, 0, c2, h2, c2, this.f, this.v, this.z), P(f2, m2, m2, n2, l2, c2, this.f, this.v, this.z);
	        for (let e3 = 0; e3 < u2; e3++) {
	          const t3 = Math.sqrt(g2[e3]) - Math.sqrt(f2[e3]);
	          d2[e3] = Math.round(255 - 255 * (t3 / this.radius + this.cutoff));
	        }
	        return _2;
	      }
	    };
	    class E {
	      constructor() {
	        this.specification = t.u.light.position;
	      }
	      possiblyEvaluate(e2, i2) {
	        return t.F(e2.expression.evaluate(i2));
	      }
	      interpolate(e2, i2, a2) {
	        return { x: t.G.number(e2.x, i2.x, a2), y: t.G.number(e2.y, i2.y, a2), z: t.G.number(e2.z, i2.z, a2) };
	      }
	    }
	    let S;
	    class R extends t.E {
	      constructor(e2) {
	        super(), S = S || new t.t({ anchor: new t.D(t.u.light.anchor), position: new E(), color: new t.D(t.u.light.color), intensity: new t.D(t.u.light.intensity) }), this._transitionable = new t.x(S, void 0), this.setLight(e2), this._transitioning = this._transitionable.untransitioned();
	      }
	      getLight() {
	        return this._transitionable.serialize();
	      }
	      setLight(e2, i2 = {}) {
	        if (!this._validate(t.y, e2, i2)) for (const i3 in e2) {
	          const a2 = e2[i3];
	          i3.endsWith(t.z) ? this._transitionable.setTransition(i3.slice(0, -t.z.length), a2) : this._transitionable.setValue(i3, a2);
	        }
	      }
	      updateTransitions(e2) {
	        this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
	      }
	      hasTransition() {
	        return this._transitioning.hasTransition();
	      }
	      recalculate(e2) {
	        this.properties = this._transitioning.possiblyEvaluate(e2);
	      }
	      _validate(e2, i2, a2) {
	        return (!a2 || false !== a2.validate) && t.B(this, e2.call(t.C, { value: i2, style: { glyphs: true, sprite: true }, styleSpec: t.u }));
	      }
	    }
	    const D = new t.t({ "sky-color": new t.D(t.u.sky["sky-color"]), "horizon-color": new t.D(t.u.sky["horizon-color"]), "fog-color": new t.D(t.u.sky["fog-color"]), "fog-ground-blend": new t.D(t.u.sky["fog-ground-blend"]), "horizon-fog-blend": new t.D(t.u.sky["horizon-fog-blend"]), "sky-horizon-blend": new t.D(t.u.sky["sky-horizon-blend"]), "atmosphere-blend": new t.D(t.u.sky["atmosphere-blend"]) });
	    class z extends t.E {
	      constructor(e2) {
	        super(), this._transitionable = new t.x(D, void 0), this.setSky(e2), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.H(0));
	      }
	      setSky(e2, i2 = {}) {
	        if (!this._validate(t.J, e2, i2)) {
	          e2 || (e2 = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
	          for (const i3 in e2) {
	            const a2 = e2[i3];
	            i3.endsWith(t.z) ? this._transitionable.setTransition(i3.slice(0, -t.z.length), a2) : this._transitionable.setValue(i3, a2);
	          }
	        }
	      }
	      getSky() {
	        return this._transitionable.serialize();
	      }
	      updateTransitions(e2) {
	        this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
	      }
	      hasTransition() {
	        return this._transitioning.hasTransition();
	      }
	      recalculate(e2) {
	        this.properties = this._transitioning.possiblyEvaluate(e2);
	      }
	      _validate(e2, i2, a2 = {}) {
	        return false !== (null == a2 ? void 0 : a2.validate) && t.B(this, e2.call(t.C, t.e({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: t.u })));
	      }
	      calculateFogBlendOpacity(e2) {
	        return e2 < 60 ? 0 : e2 < 70 ? (e2 - 60) / 10 : 1;
	      }
	    }
	    class A {
	      constructor(e2, t2) {
	        this.width = e2, this.height = t2, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
	      }
	      getDash(e2, t2) {
	        const i2 = e2.join(",") + String(t2);
	        return this.dashEntry[i2] || (this.dashEntry[i2] = this.addDash(e2, t2)), this.dashEntry[i2];
	      }
	      getDashRanges(e2, t2, i2) {
	        const a2 = [];
	        let r2 = e2.length % 2 == 1 ? -e2[e2.length - 1] * i2 : 0, o2 = e2[0] * i2, s2 = true;
	        a2.push({ left: r2, right: o2, isDash: s2, zeroLength: 0 === e2[0] });
	        let n2 = e2[0];
	        for (let t3 = 1; t3 < e2.length; t3++) {
	          s2 = !s2;
	          const l2 = e2[t3];
	          r2 = n2 * i2, n2 += l2, o2 = n2 * i2, a2.push({ left: r2, right: o2, isDash: s2, zeroLength: 0 === l2 });
	        }
	        return a2;
	      }
	      addRoundDash(e2, t2, i2) {
	        const a2 = t2 / 2;
	        for (let t3 = -i2; t3 <= i2; t3++) {
	          const r2 = this.width * (this.nextRow + i2 + t3);
	          let o2 = 0, s2 = e2[o2];
	          for (let n2 = 0; n2 < this.width; n2++) {
	            n2 / s2.right > 1 && (s2 = e2[++o2]);
	            const l2 = Math.abs(n2 - s2.left), c2 = Math.abs(n2 - s2.right), h2 = Math.min(l2, c2);
	            let u2;
	            const d2 = t3 / i2 * (a2 + 1);
	            if (s2.isDash) {
	              const e3 = a2 - Math.abs(d2);
	              u2 = Math.sqrt(h2 * h2 + e3 * e3);
	            } else u2 = a2 - Math.sqrt(h2 * h2 + d2 * d2);
	            this.data[r2 + n2] = Math.max(0, Math.min(255, u2 + 128));
	          }
	        }
	      }
	      addRegularDash(e2) {
	        for (let t3 = e2.length - 1; t3 >= 0; --t3) {
	          const i3 = e2[t3], a3 = e2[t3 + 1];
	          i3.zeroLength ? e2.splice(t3, 1) : a3 && a3.isDash === i3.isDash && (a3.left = i3.left, e2.splice(t3, 1));
	        }
	        const t2 = e2[0], i2 = e2[e2.length - 1];
	        t2.isDash === i2.isDash && (t2.left = i2.left - this.width, i2.right = t2.right + this.width);
	        const a2 = this.width * this.nextRow;
	        let r2 = 0, o2 = e2[r2];
	        for (let t3 = 0; t3 < this.width; t3++) {
	          t3 / o2.right > 1 && (o2 = e2[++r2]);
	          const i3 = Math.abs(t3 - o2.left), s2 = Math.abs(t3 - o2.right), n2 = Math.min(i3, s2);
	          this.data[a2 + t3] = Math.max(0, Math.min(255, (o2.isDash ? n2 : -n2) + 128));
	        }
	      }
	      addDash(e2, i2) {
	        const a2 = i2 ? 7 : 0, r2 = 2 * a2 + 1;
	        if (this.nextRow + r2 > this.height) return t.w("LineAtlas out of space"), null;
	        let o2 = 0;
	        for (let t2 = 0; t2 < e2.length; t2++) o2 += e2[t2];
	        if (0 !== o2) {
	          const t2 = this.width / o2, r3 = this.getDashRanges(e2, this.width, t2);
	          i2 ? this.addRoundDash(r3, t2, a2) : this.addRegularDash(r3);
	        }
	        const s2 = { y: this.nextRow + a2, height: 2 * a2, width: o2 };
	        return this.nextRow += r2, this.dirty = true, s2;
	      }
	      bind(e2) {
	        const t2 = e2.gl;
	        this.texture ? (t2.bindTexture(t2.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, t2.texSubImage2D(t2.TEXTURE_2D, 0, 0, 0, this.width, this.height, t2.ALPHA, t2.UNSIGNED_BYTE, this.data))) : (this.texture = t2.createTexture(), t2.bindTexture(t2.TEXTURE_2D, this.texture), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_WRAP_S, t2.REPEAT), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_WRAP_T, t2.REPEAT), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_MIN_FILTER, t2.LINEAR), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_MAG_FILTER, t2.LINEAR), t2.texImage2D(t2.TEXTURE_2D, 0, t2.ALPHA, this.width, this.height, 0, t2.ALPHA, t2.UNSIGNED_BYTE, this.data));
	      }
	    }
	    const L = "maplibre_preloaded_worker_pool";
	    class k {
	      constructor() {
	        this.active = {};
	      }
	      acquire(e2) {
	        if (!this.workers) for (this.workers = []; this.workers.length < k.workerCount; ) this.workers.push(new Worker(t.a.WORKER_URL));
	        return this.active[e2] = true, this.workers.slice();
	      }
	      release(e2) {
	        delete this.active[e2], 0 === this.numActive() && (this.workers.forEach((e3) => {
	          e3.terminate();
	        }), this.workers = null);
	      }
	      isPreloaded() {
	        return !!this.active[L];
	      }
	      numActive() {
	        return Object.keys(this.active).length;
	      }
	    }
	    const F = Math.floor(n.hardwareConcurrency / 2);
	    let B, O;
	    function j() {
	      return B || (B = new k()), B;
	    }
	    k.workerCount = t.K(globalThis) ? Math.max(Math.min(F, 3), 1) : 1;
	    class N {
	      constructor(e2, i2) {
	        this.workerPool = e2, this.actors = [], this.currentActor = 0, this.id = i2;
	        const a2 = this.workerPool.acquire(i2);
	        for (let e3 = 0; e3 < a2.length; e3++) {
	          const r2 = new t.L(a2[e3], i2);
	          r2.name = `Worker ${e3}`, this.actors.push(r2);
	        }
	        if (!this.actors.length) throw new Error("No actors found");
	      }
	      broadcast(e2, t2) {
	        const i2 = [];
	        for (const a2 of this.actors) i2.push(a2.sendAsync({ type: e2, data: t2 }));
	        return Promise.all(i2);
	      }
	      getActor() {
	        return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
	      }
	      remove(e2 = true) {
	        this.actors.forEach((e3) => {
	          e3.remove();
	        }), this.actors = [], e2 && this.workerPool.release(this.id);
	      }
	      registerMessageHandler(e2, t2) {
	        for (const i2 of this.actors) i2.registerMessageHandler(e2, t2);
	      }
	      unregisterMessageHandler(e2) {
	        for (const t2 of this.actors) t2.unregisterMessageHandler(e2);
	      }
	    }
	    function Z() {
	      return O || (O = new N(j(), t.M), O.registerMessageHandler("GR", (e2, i2, a2) => t.m(i2, a2))), O;
	    }
	    function G(e2, i2) {
	      const a2 = t.N();
	      return t.O(a2, a2, [1, 1, 0]), t.Q(a2, a2, [0.5 * e2.width, 0.5 * e2.height, 1]), e2.calculatePosMatrix ? t.S(a2, a2, e2.calculatePosMatrix(i2.toUnwrapped())) : a2;
	    }
	    function U(e2, t2, i2, a2, r2, o2, s2) {
	      var n2;
	      const l2 = function(e3, t3, i3) {
	        if (e3) for (const a3 of e3) {
	          const e4 = t3[a3];
	          if (e4 && e4.source === i3 && "fill-extrusion" === e4.type) return true;
	        }
	        else for (const e4 in t3) {
	          const a3 = t3[e4];
	          if (a3.source === i3 && "fill-extrusion" === a3.type) return true;
	        }
	        return false;
	      }(null !== (n2 = null == r2 ? void 0 : r2.layers) && void 0 !== n2 ? n2 : null, t2, e2.id), c2 = o2.maxPitchScaleFactor(), h2 = e2.tilesIn(a2, c2, l2);
	      h2.sort(V);
	      const u2 = [];
	      for (const a3 of h2) u2.push({ wrappedTileID: a3.tileID.wrapped().key, queryResults: a3.tile.queryRenderedFeatures(t2, i2, e2.getState(), a3.queryGeometry, a3.cameraQueryGeometry, a3.scale, r2, o2, c2, G(o2, a3.tileID), s2 ? (e3, t3) => s2(a3.tileID, e3, t3) : void 0) });
	      return function(e3, t3) {
	        for (const i3 in e3) for (const a3 of e3[i3]) q(a3, t3);
	        return e3;
	      }(function(e3) {
	        const t3 = {}, i3 = {};
	        for (const a3 of e3) {
	          const e4 = a3.queryResults, r3 = a3.wrappedTileID, o3 = i3[r3] = i3[r3] || {};
	          for (const i4 in e4) {
	            const a4 = e4[i4], r4 = o3[i4] = o3[i4] || {}, s3 = t3[i4] = t3[i4] || [];
	            for (const e5 of a4) r4[e5.featureIndex] || (r4[e5.featureIndex] = true, s3.push(e5));
	          }
	        }
	        return t3;
	      }(u2), e2);
	    }
	    function V(e2, t2) {
	      const i2 = e2.tileID, a2 = t2.tileID;
	      return i2.overscaledZ - a2.overscaledZ || i2.canonical.y - a2.canonical.y || i2.wrap - a2.wrap || i2.canonical.x - a2.canonical.x;
	    }
	    function q(e2, t2) {
	      const i2 = e2.feature, a2 = t2.getFeatureState(i2.layer["source-layer"], i2.id);
	      i2.source = i2.layer.source, i2.layer["source-layer"] && (i2.sourceLayer = i2.layer["source-layer"]), i2.state = a2;
	    }
	    function W(e2, i2, a2) {
	      return t._(this, void 0, void 0, function* () {
	        let r2 = e2;
	        if (e2.url ? r2 = (yield t.j(i2.transformRequest(e2.url, "Source"), a2)).data : yield n.frameAsync(a2), !r2) return null;
	        const o2 = t.U(t.e(r2, e2), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
	        return "vector_layers" in r2 && r2.vector_layers && (o2.vectorLayerIds = r2.vector_layers.map((e3) => e3.id)), o2;
	      });
	    }
	    class $ {
	      constructor(e2, t2) {
	        e2 && (t2 ? this.setSouthWest(e2).setNorthEast(t2) : Array.isArray(e2) && (4 === e2.length ? this.setSouthWest([e2[0], e2[1]]).setNorthEast([e2[2], e2[3]]) : this.setSouthWest(e2[0]).setNorthEast(e2[1])));
	      }
	      setNorthEast(e2) {
	        return this._ne = e2 instanceof t.V ? new t.V(e2.lng, e2.lat) : t.V.convert(e2), this;
	      }
	      setSouthWest(e2) {
	        return this._sw = e2 instanceof t.V ? new t.V(e2.lng, e2.lat) : t.V.convert(e2), this;
	      }
	      extend(e2) {
	        const i2 = this._sw, a2 = this._ne;
	        let r2, o2;
	        if (e2 instanceof t.V) r2 = e2, o2 = e2;
	        else {
	          if (!(e2 instanceof $)) return Array.isArray(e2) ? 4 === e2.length || e2.every(Array.isArray) ? this.extend($.convert(e2)) : this.extend(t.V.convert(e2)) : e2 && ("lng" in e2 || "lon" in e2) && "lat" in e2 ? this.extend(t.V.convert(e2)) : this;
	          if (r2 = e2._sw, o2 = e2._ne, !r2 || !o2) return this;
	        }
	        return i2 || a2 ? (i2.lng = Math.min(r2.lng, i2.lng), i2.lat = Math.min(r2.lat, i2.lat), a2.lng = Math.max(o2.lng, a2.lng), a2.lat = Math.max(o2.lat, a2.lat)) : (this._sw = new t.V(r2.lng, r2.lat), this._ne = new t.V(o2.lng, o2.lat)), this;
	      }
	      getCenter() {
	        return new t.V((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
	      }
	      getSouthWest() {
	        return this._sw;
	      }
	      getNorthEast() {
	        return this._ne;
	      }
	      getNorthWest() {
	        return new t.V(this.getWest(), this.getNorth());
	      }
	      getSouthEast() {
	        return new t.V(this.getEast(), this.getSouth());
	      }
	      getWest() {
	        return this._sw.lng;
	      }
	      getSouth() {
	        return this._sw.lat;
	      }
	      getEast() {
	        return this._ne.lng;
	      }
	      getNorth() {
	        return this._ne.lat;
	      }
	      toArray() {
	        return [this._sw.toArray(), this._ne.toArray()];
	      }
	      toString() {
	        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
	      }
	      isEmpty() {
	        return !(this._sw && this._ne);
	      }
	      contains(e2) {
	        const { lng: i2, lat: a2 } = t.V.convert(e2);
	        let r2 = this._sw.lng <= i2 && i2 <= this._ne.lng;
	        return this._sw.lng > this._ne.lng && (r2 = this._sw.lng >= i2 && i2 >= this._ne.lng), this._sw.lat <= a2 && a2 <= this._ne.lat && r2;
	      }
	      intersects(e2) {
	        if ((e2 = $.convert(e2)).getNorth() < this.getSouth() || e2.getSouth() > this.getNorth()) return false;
	        const i2 = t.W(this.getWest(), -180, 180), a2 = t.W(this.getEast(), -180, 180), r2 = t.W(e2.getWest(), -180, 180), o2 = t.W(e2.getEast(), -180, 180), s2 = i2 > a2, n2 = r2 > o2;
	        return !(!s2 || !n2) || (s2 ? o2 >= i2 || r2 <= a2 : n2 ? a2 >= r2 || i2 <= o2 : !(r2 > a2 || o2 < i2));
	      }
	      static convert(e2) {
	        return e2 instanceof $ ? e2 : e2 ? new $(e2) : e2;
	      }
	      static fromLngLat(e2, i2 = 0) {
	        const a2 = 360 * i2 / 40075017, r2 = a2 / Math.cos(Math.PI / 180 * e2.lat);
	        return new $(new t.V(e2.lng - r2, e2.lat - a2), new t.V(e2.lng + r2, e2.lat + a2));
	      }
	      adjustAntiMeridian() {
	        const e2 = new t.V(this._sw.lng, this._sw.lat), i2 = new t.V(this._ne.lng, this._ne.lat);
	        return new $(e2, e2.lng > i2.lng ? new t.V(i2.lng + 360, i2.lat) : i2);
	      }
	    }
	    class H {
	      constructor(e2, t2, i2) {
	        this.bounds = $.convert(this.validateBounds(e2)), this.minzoom = t2 || 0, this.maxzoom = i2 || 24;
	      }
	      validateBounds(e2) {
	        return Array.isArray(e2) && 4 === e2.length ? [Math.max(-180, e2[0]), Math.max(-90, e2[1]), Math.min(180, e2[2]), Math.min(90, e2[3])] : [-180, -90, 180, 90];
	      }
	      contains(e2) {
	        const i2 = Math.pow(2, e2.z), a2 = Math.floor(t.Y(this.bounds.getWest()) * i2), r2 = Math.floor(t.X(this.bounds.getNorth()) * i2), o2 = Math.ceil(t.Y(this.bounds.getEast()) * i2), s2 = Math.ceil(t.X(this.bounds.getSouth()) * i2);
	        return e2.x >= a2 && e2.x < o2 && e2.y >= r2 && e2.y < s2;
	      }
	    }
	    class X extends t.E {
	      constructor(e2, i2, a2, r2) {
	        if (super(), this.id = e2, this.dispatcher = a2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t.e(this, t.U(i2, ["url", "scheme", "tileSize", "promoteId", "encoding"])), this._options = t.e({ type: "vector" }, i2), this._collectResourceTiming = i2.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
	        this.setEventedParent(r2);
	      }
	      load() {
	        return t._(this, void 0, void 0, function* () {
	          this._loaded = false, this.fire(new t.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
	          try {
	            const e2 = yield W(this._options, this.map._requestManager, this._tileJSONRequest);
	            this._tileJSONRequest = null, this._loaded = true, this.map.style.tileManagers[this.id].clearTiles(), e2 && (t.e(this, e2), e2.bounds && (this.tileBounds = new H(e2.bounds, this.minzoom, this.maxzoom)), this.fire(new t.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.l("data", { dataType: "source", sourceDataType: "content" })));
	          } catch (e2) {
	            this._tileJSONRequest = null, this._loaded = true, this.fire(new t.k(e2));
	          }
	        });
	      }
	      loaded() {
	        return this._loaded;
	      }
	      hasTile(e2) {
	        return !this.tileBounds || this.tileBounds.contains(e2.canonical);
	      }
	      onAdd(e2) {
	        this.map = e2, this.load();
	      }
	      setSourceProperty(e2) {
	        this._tileJSONRequest && this._tileJSONRequest.abort(), e2(), this.load();
	      }
	      setTiles(e2) {
	        return this.setSourceProperty(() => {
	          this._options.tiles = e2;
	        }), this;
	      }
	      setUrl(e2) {
	        return this.setSourceProperty(() => {
	          this.url = e2, this._options.url = e2;
	        }), this;
	      }
	      onRemove() {
	        this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
	      }
	      serialize() {
	        return t.e({}, this._options);
	      }
	      loadTile(e2) {
	        return t._(this, void 0, void 0, function* () {
	          const t2 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i2 = { request: this.map._requestManager.transformRequest(t2, "Tile"), uid: e2.uid, tileID: e2.tileID, zoom: e2.tileID.overscaledZ, tileSize: this.tileSize * e2.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, encoding: this.encoding, overzoomParameters: this._getOverzoomParameters(e2) };
	          i2.request.collectResourceTiming = this._collectResourceTiming;
	          let a2 = "RT";
	          if (e2.actor && "expired" !== e2.state) {
	            if ("loading" === e2.state) return new Promise((t3, i3) => {
	              e2.reloadPromise = { resolve: t3, reject: i3 };
	            });
	          } else e2.actor = this.dispatcher.getActor(), a2 = "LT";
	          e2.abortController = new AbortController();
	          try {
	            const t3 = yield e2.actor.sendAsync({ type: a2, data: i2 }, e2.abortController);
	            if (delete e2.abortController, e2.aborted) return;
	            this._afterTileLoadWorkerResponse(e2, t3);
	          } catch (t3) {
	            if (delete e2.abortController, e2.aborted) return;
	            if (t3 && 404 !== t3.status) throw t3;
	            this._afterTileLoadWorkerResponse(e2, null);
	          }
	        });
	      }
	      _getOverzoomParameters(e2) {
	        if (e2.tileID.canonical.z <= this.maxzoom) return;
	        if (void 0 === this.map._zoomLevelsToOverscale) return;
	        const t2 = e2.tileID.scaledTo(this.maxzoom).canonical, i2 = t2.url(this.tiles, this.map.getPixelRatio(), this.scheme);
	        return { maxZoomTileID: t2, overzoomRequest: this.map._requestManager.transformRequest(i2, "Tile") };
	      }
	      _afterTileLoadWorkerResponse(e2, t2) {
	        if (t2 && t2.resourceTiming && (e2.resourceTiming = t2.resourceTiming), t2 && this.map._refreshExpiredTiles && e2.setExpiryData(t2), e2.loadVectorData(t2, this.map.painter), e2.reloadPromise) {
	          const t3 = e2.reloadPromise;
	          e2.reloadPromise = null, this.loadTile(e2).then(t3.resolve).catch(t3.reject);
	        }
	      }
	      abortTile(e2) {
	        return t._(this, void 0, void 0, function* () {
	          e2.abortController && (e2.abortController.abort(), delete e2.abortController), e2.actor && (yield e2.actor.sendAsync({ type: "AT", data: { uid: e2.uid, type: this.type, source: this.id } }));
	        });
	      }
	      unloadTile(e2) {
	        return t._(this, void 0, void 0, function* () {
	          e2.unloadVectorData(), e2.actor && (yield e2.actor.sendAsync({ type: "RMT", data: { uid: e2.uid, type: this.type, source: this.id } }));
	        });
	      }
	      hasTransition() {
	        return false;
	      }
	    }
	    class K extends t.E {
	      constructor(e2, i2, a2, r2) {
	        super(), this.id = e2, this.dispatcher = a2, this.setEventedParent(r2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = t.e({ type: "raster" }, i2), t.e(this, t.U(i2, ["url", "scheme", "tileSize"]));
	      }
	      load() {
	        return t._(this, arguments, void 0, function* (e2 = false) {
	          this._loaded = false, this.fire(new t.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
	          try {
	            const i2 = yield W(this._options, this.map._requestManager, this._tileJSONRequest);
	            this._tileJSONRequest = null, this._loaded = true, i2 && (t.e(this, i2), i2.bounds && (this.tileBounds = new H(i2.bounds, this.minzoom, this.maxzoom)), this.fire(new t.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: e2 })));
	          } catch (e3) {
	            this._tileJSONRequest = null, this._loaded = true, this.fire(new t.k(e3));
	          }
	        });
	      }
	      loaded() {
	        return this._loaded;
	      }
	      onAdd(e2) {
	        this.map = e2, this.load();
	      }
	      onRemove() {
	        this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
	      }
	      setSourceProperty(e2) {
	        this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e2(), this.load(true);
	      }
	      setTiles(e2) {
	        return this.setSourceProperty(() => {
	          this._options.tiles = e2;
	        }), this;
	      }
	      setUrl(e2) {
	        return this.setSourceProperty(() => {
	          this.url = e2, this._options.url = e2;
	        }), this;
	      }
	      serialize() {
	        return t.e({}, this._options);
	      }
	      hasTile(e2) {
	        return !this.tileBounds || this.tileBounds.contains(e2.canonical);
	      }
	      loadTile(e2) {
	        return t._(this, void 0, void 0, function* () {
	          const i2 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
	          e2.abortController = new AbortController();
	          try {
	            const a2 = yield g.getImage(this.map._requestManager.transformRequest(i2, "Tile"), e2.abortController, this.map._refreshExpiredTiles);
	            if (delete e2.abortController, e2.aborted) return void (e2.state = "unloaded");
	            if (a2 && a2.data) {
	              this.map._refreshExpiredTiles && (a2.cacheControl || a2.expires) && e2.setExpiryData({ cacheControl: a2.cacheControl, expires: a2.expires });
	              const i3 = this.map.painter.context, r2 = i3.gl, o2 = a2.data;
	              e2.texture = this.map.painter.getTileTexture(o2.width), e2.texture ? e2.texture.update(o2, { useMipmap: true }) : (e2.texture = new t.T(i3, o2, r2.RGBA, { useMipmap: true }), e2.texture.bind(r2.LINEAR, r2.CLAMP_TO_EDGE, r2.LINEAR_MIPMAP_NEAREST)), e2.state = "loaded";
	            }
	          } catch (t2) {
	            if (delete e2.abortController, e2.aborted) e2.state = "unloaded";
	            else if (t2) throw e2.state = "errored", t2;
	          }
	        });
	      }
	      abortTile(e2) {
	        return t._(this, void 0, void 0, function* () {
	          e2.abortController && (e2.abortController.abort(), delete e2.abortController);
	        });
	      }
	      unloadTile(e2) {
	        return t._(this, void 0, void 0, function* () {
	          e2.texture && this.map.painter.saveTileTexture(e2.texture);
	        });
	      }
	      hasTransition() {
	        return false;
	      }
	    }
	    class Y extends K {
	      constructor(e2, i2, a2, r2) {
	        super(e2, i2, a2, r2), this.type = "raster-dem", this.maxzoom = 22, this._options = t.e({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox", this.redFactor = i2.redFactor, this.greenFactor = i2.greenFactor, this.blueFactor = i2.blueFactor, this.baseShift = i2.baseShift;
	      }
	      loadTile(e2) {
	        return t._(this, void 0, void 0, function* () {
	          const i2 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), a2 = this.map._requestManager.transformRequest(i2, "Tile");
	          e2.neighboringTiles = this._getNeighboringTiles(e2.tileID), e2.abortController = new AbortController();
	          try {
	            const i3 = yield g.getImage(a2, e2.abortController, this.map._refreshExpiredTiles);
	            if (delete e2.abortController, e2.aborted) return void (e2.state = "unloaded");
	            if (i3 && i3.data) {
	              const a3 = i3.data;
	              this.map._refreshExpiredTiles && (i3.cacheControl || i3.expires) && e2.setExpiryData({ cacheControl: i3.cacheControl, expires: i3.expires });
	              const r2 = t.b(a3) && t.Z() ? a3 : yield this.readImageNow(a3), o2 = { type: this.type, uid: e2.uid, source: this.id, rawImageData: r2, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
	              if (!e2.actor || "expired" === e2.state) {
	                e2.actor = this.dispatcher.getActor();
	                const t2 = yield e2.actor.sendAsync({ type: "LDT", data: o2 });
	                e2.dem = t2, e2.needsHillshadePrepare = true, e2.needsTerrainPrepare = true, e2.state = "loaded";
	              }
	            }
	          } catch (t2) {
	            if (delete e2.abortController, e2.aborted) e2.state = "unloaded";
	            else if (t2) throw e2.state = "errored", t2;
	          }
	        });
	      }
	      readImageNow(e2) {
	        return t._(this, void 0, void 0, function* () {
	          if ("undefined" != typeof VideoFrame && t.$()) {
	            const i2 = e2.width + 2, a2 = e2.height + 2;
	            try {
	              return new t.R({ width: i2, height: a2 }, yield t.a0(e2, -1, -1, i2, a2));
	            } catch (e3) {
	            }
	          }
	          return n.getImageData(e2, 1);
	        });
	      }
	      _getNeighboringTiles(e2) {
	        const i2 = e2.canonical, a2 = Math.pow(2, i2.z), r2 = (i2.x - 1 + a2) % a2, o2 = 0 === i2.x ? e2.wrap - 1 : e2.wrap, s2 = (i2.x + 1 + a2) % a2, n2 = i2.x + 1 === a2 ? e2.wrap + 1 : e2.wrap, l2 = {};
	        return l2[new t.a1(e2.overscaledZ, o2, i2.z, r2, i2.y).key] = { backfilled: false }, l2[new t.a1(e2.overscaledZ, n2, i2.z, s2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l2[new t.a1(e2.overscaledZ, o2, i2.z, r2, i2.y - 1).key] = { backfilled: false }, l2[new t.a1(e2.overscaledZ, e2.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l2[new t.a1(e2.overscaledZ, n2, i2.z, s2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < a2 && (l2[new t.a1(e2.overscaledZ, o2, i2.z, r2, i2.y + 1).key] = { backfilled: false }, l2[new t.a1(e2.overscaledZ, e2.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l2[new t.a1(e2.overscaledZ, n2, i2.z, s2, i2.y + 1).key] = { backfilled: false }), l2;
	      }
	      unloadTile(e2) {
	        return t._(this, void 0, void 0, function* () {
	          e2.demTexture && this.map.painter.saveTileTexture(e2.demTexture), e2.fbo && (e2.fbo.destroy(), delete e2.fbo), e2.dem && delete e2.dem, delete e2.neighboringTiles, e2.state = "unloaded", e2.actor && (yield e2.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e2.uid, source: this.id } }));
	        });
	      }
	    }
	    function Q(e2) {
	      return "GeometryCollection" === e2.type ? e2.geometries.map((e3) => e3.coordinates).flat(1 / 0) : e2.coordinates.flat(1 / 0);
	    }
	    function J(e2) {
	      const t2 = new $();
	      let i2;
	      switch (e2.type) {
	        case "FeatureCollection":
	          i2 = e2.features.map((e3) => Q(e3.geometry)).flat(1 / 0);
	          break;
	        case "Feature":
	          i2 = Q(e2.geometry);
	          break;
	        default:
	          i2 = Q(e2);
	      }
	      if (0 == i2.length) return t2;
	      for (let e3 = 0; e3 < i2.length - 1; e3 += 2) t2.extend([i2[e3], i2[e3 + 1]]);
	      return t2;
	    }
	    class ee extends t.E {
	      constructor(e2, i2, a2, r2) {
	        super(), this.id = e2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._isUpdatingWorker = false, this._pendingWorkerUpdate = { data: i2.data }, this.actor = a2.getActor(), this.setEventedParent(r2), this._data = "string" == typeof i2.data ? { url: i2.data } : { geojson: i2.data }, this._options = t.e({}, i2), this._collectResourceTiming = i2.collectResourceTiming, void 0 !== i2.maxzoom && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId, void 0 !== i2.clusterMaxZoom && this.maxzoom <= i2.clusterMaxZoom && t.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i2.clusterMaxZoom}".`), this.workerOptions = t.e({ source: this.id, cluster: i2.cluster || false, geojsonVtOptions: { buffer: this._pixelsToTileUnits(void 0 !== i2.buffer ? i2.buffer : 128), tolerance: this._pixelsToTileUnits(void 0 !== i2.tolerance ? i2.tolerance : 0.375), extent: t.a4, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: this._getClusterMaxZoom(i2.clusterMaxZoom), minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: t.a4, radius: this._pixelsToTileUnits(i2.clusterRadius || 50), log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter }, i2.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId);
	      }
	      _hasPendingWorkerUpdate() {
	        return void 0 !== this._pendingWorkerUpdate.data || void 0 !== this._pendingWorkerUpdate.diff || this._pendingWorkerUpdate.optionsChanged;
	      }
	      _pixelsToTileUnits(e2) {
	        return e2 * (t.a4 / this.tileSize);
	      }
	      _getClusterMaxZoom(e2) {
	        const i2 = e2 ? Math.round(e2) : this.maxzoom - 1;
	        return Number.isInteger(e2) || void 0 === e2 || t.w(`Integer expected for option 'clusterMaxZoom': provided value "${e2}" rounded to "${i2}"`), i2;
	      }
	      load() {
	        return t._(this, void 0, void 0, function* () {
	          yield this._updateWorkerData();
	        });
	      }
	      onAdd(e2) {
	        this.map = e2, this.load();
	      }
	      setData(e2, t2) {
	        this._data = "string" == typeof e2 ? { url: e2 } : { geojson: e2 }, this._pendingWorkerUpdate = { data: e2 };
	        const i2 = this._updateWorkerData();
	        return t2 ? i2 : this;
	      }
	      updateData(e2, i2) {
	        this._pendingWorkerUpdate.diff = t.a5(this._pendingWorkerUpdate.diff, e2);
	        const a2 = this._updateWorkerData();
	        return i2 ? a2 : this;
	      }
	      getData() {
	        return t._(this, void 0, void 0, function* () {
	          const e2 = t.e({ type: this.type }, this.workerOptions);
	          return this.actor.sendAsync({ type: "GD", data: e2 });
	        });
	      }
	      getBounds() {
	        return t._(this, void 0, void 0, function* () {
	          return J(yield this.getData());
	        });
	      }
	      setClusterOptions(e2) {
	        return this.workerOptions.cluster = e2.cluster, void 0 !== e2.clusterRadius && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e2.clusterRadius)), void 0 !== e2.clusterMaxZoom && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e2.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = true, this._updateWorkerData(), this;
	      }
	      getClusterExpansionZoom(e2) {
	        return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e2, source: this.id } });
	      }
	      getClusterChildren(e2) {
	        return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e2, source: this.id } });
	      }
	      getClusterLeaves(e2, t2, i2) {
	        return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e2, limit: t2, offset: i2 } });
	      }
	      _updateWorkerData() {
	        return t._(this, void 0, void 0, function* () {
	          if (this._isUpdatingWorker) return;
	          if (!this._hasPendingWorkerUpdate()) return void t.w(`No pending worker updates for GeoJSONSource ${this.id}.`);
	          const { data: e2, diff: i2 } = this._pendingWorkerUpdate, a2 = t.e({ type: this.type }, this.workerOptions);
	          e2 ? ("string" == typeof e2 ? (a2.request = this.map._requestManager.transformRequest(n.resolveURL(e2), "Source"), a2.request.collectResourceTiming = this._collectResourceTiming) : a2.data = e2, this._pendingWorkerUpdate.data = void 0) : i2 && (a2.dataDiff = i2, this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, this._isUpdatingWorker = true, this.fire(new t.l("dataloading", { dataType: "source" }));
	          try {
	            const e3 = yield this.actor.sendAsync({ type: "LD", data: a2 });
	            if (this._isUpdatingWorker = false, this._removed || e3.abandoned) return void this.fire(new t.l("dataabort", { dataType: "source" }));
	            e3.applyDiff ? this._applyDiff(i2) : this._data = { geojson: e3.data };
	            let r2 = null;
	            e3.resourceTiming && e3.resourceTiming[this.id] && (r2 = e3.resourceTiming[this.id].slice(0));
	            const o2 = { dataType: "source" };
	            this._collectResourceTiming && r2 && r2.length > 0 && t.e(o2, { resourceTiming: r2 }), this.fire(new t.l("data", Object.assign(Object.assign({}, o2), { sourceDataType: "metadata" }))), this.fire(new t.l("data", Object.assign(Object.assign({}, o2), { sourceDataType: "content", shouldReloadTileOptions: this._getShouldReloadTileOptions(i2) })));
	          } catch (e3) {
	            if (this._isUpdatingWorker = false, this._removed) return void this.fire(new t.l("dataabort", { dataType: "source" }));
	            this.fire(new t.k(e3));
	          } finally {
	            this._hasPendingWorkerUpdate() && this._updateWorkerData();
	          }
	        });
	      }
	      _applyDiff(e2) {
	        const i2 = "string" == typeof this.promoteId ? this.promoteId : void 0;
	        this._data.url || this._data.updateable || !t.a6(this._data.geojson, i2) || (this._data = { updateable: t.a7(this._data.geojson, i2) }), e2 && this._data.updateable ? t.a8(this._data.updateable, e2, i2) : t.w("Cannot apply GeoJSONSource#updateData due to internal error");
	      }
	      _getShouldReloadTileOptions(e2) {
	        if (this._options.cluster || !e2 || e2.removeAll) return;
	        const { add: i2 = [], update: a2 = [], remove: r2 = [] } = e2 || {}, o2 = /* @__PURE__ */ new Set([...a2.map((e3) => e3.id), ...r2]);
	        for (const e3 of o2.values()) if ("number" != typeof e3 && null == this.promoteId) return void t.w(`GeoJSONSource "${this.id}": updateData is slower when using string GeoJSON feature IDs (e.g. "${e3}"). Consider using promoteId or numeric IDs for better performance.`);
	        return { nextBounds: [...a2.map((e3) => e3.newGeometry), ...i2.map((e3) => e3.geometry)].filter(Boolean).map((e3) => J(e3)), prevIds: o2 };
	      }
	      shouldReloadTile(e2, { nextBounds: i2, prevIds: a2 }) {
	        if (!e2.latestFeatureIndex) return "unloaded" !== e2.state;
	        const r2 = e2.latestFeatureIndex.loadVTLayers();
	        for (let i3 = 0; i3 < e2.latestFeatureIndex.featureIndexArray.length; i3++) {
	          const o3 = e2.latestFeatureIndex.featureIndexArray.get(i3), s3 = r2[t.a9].feature(o3.featureIndex), n3 = e2.latestFeatureIndex.getId(s3, t.a9);
	          if (a2.has(n3)) return true;
	        }
	        const { buffer: o2, extent: s2 } = this.workerOptions.geojsonVtOptions, n2 = function({ x: e3, y: i3, z: a3 }, r3 = 0) {
	          const o3 = t.a2((e3 - r3) / Math.pow(2, a3)), s3 = t.a3((i3 + 1 + r3) / Math.pow(2, a3)), n3 = t.a2((e3 + 1 + r3) / Math.pow(2, a3)), l2 = t.a3((i3 - r3) / Math.pow(2, a3));
	          return new $([o3, s3], [n3, l2]);
	        }(e2.tileID.canonical, o2 / s2);
	        for (const e3 of i2) if (n2.intersects(e3)) return true;
	        return false;
	      }
	      loaded() {
	        return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate();
	      }
	      loadTile(e2) {
	        return t._(this, void 0, void 0, function* () {
	          const t2 = e2.actor ? "RT" : "LT";
	          e2.actor = this.actor;
	          const i2 = { type: this.type, uid: e2.uid, tileID: e2.tileID, zoom: e2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
	          e2.abortController = new AbortController();
	          const a2 = yield this.actor.sendAsync({ type: t2, data: i2 }, e2.abortController);
	          delete e2.abortController, e2.unloadVectorData(), e2.aborted || e2.loadVectorData(a2, this.map.painter, "RT" === t2);
	        });
	      }
	      abortTile(e2) {
	        return t._(this, void 0, void 0, function* () {
	          e2.abortController && (e2.abortController.abort(), delete e2.abortController), e2.aborted = true;
	        });
	      }
	      unloadTile(e2) {
	        return t._(this, void 0, void 0, function* () {
	          e2.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e2.uid, type: this.type, source: this.id } });
	        });
	      }
	      onRemove() {
	        this._removed = true, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
	      }
	      serialize() {
	        return t.e({}, this._options, { type: this.type, data: this._data.updateable ? { type: "FeatureCollection", features: Array.from(this._data.updateable.values()) } : this._data.url || this._data.geojson });
	      }
	      hasTransition() {
	        return false;
	      }
	    }
	    class te extends t.E {
	      constructor(e2, t2, i2, a2) {
	        super(), this.flippedWindingOrder = false, this.id = e2, this.dispatcher = i2, this.coordinates = t2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(a2), this.options = t2;
	      }
	      load(e2) {
	        return t._(this, void 0, void 0, function* () {
	          this._loaded = false, this.fire(new t.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
	          try {
	            const t2 = yield g.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
	            this._request = null, this._loaded = true, t2 && t2.data && (this.image = t2.data, e2 && (this.coordinates = e2), this._finishLoading());
	          } catch (e3) {
	            this._request = null, this._loaded = true, this.fire(new t.k(e3));
	          }
	        });
	      }
	      loaded() {
	        return this._loaded;
	      }
	      updateImage(e2) {
	        return e2.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e2.url, this.load(e2.coordinates).finally(() => {
	          this.texture = null;
	        }), this) : this;
	      }
	      _finishLoading() {
	        this.map && (this.setCoordinates(this.coordinates), this.fire(new t.l("data", { dataType: "source", sourceDataType: "metadata" })));
	      }
	      onAdd(e2) {
	        this.map = e2, this.load();
	      }
	      onRemove() {
	        this._request && (this._request.abort(), this._request = null);
	      }
	      setCoordinates(e2) {
	        this.coordinates = e2;
	        const i2 = e2.map(t.aa.fromLngLat);
	        var a2;
	        return this.tileID = function(e3) {
	          const i3 = t.ab.fromPoints(e3), a3 = i3.width(), r2 = i3.height(), o2 = Math.max(a3, r2), s2 = Math.max(0, Math.floor(-Math.log(o2) / Math.LN2)), n2 = Math.pow(2, s2);
	          return new t.ad(s2, Math.floor((i3.minX + i3.maxX) / 2 * n2), Math.floor((i3.minY + i3.maxY) / 2 * n2));
	        }(i2), this.terrainTileRanges = this._getOverlappingTileRanges(i2), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = i2.map((e3) => this.tileID.getTilePoint(e3)._round()), this.flippedWindingOrder = ((a2 = this.tileCoords)[1].x - a2[0].x) * (a2[2].y - a2[0].y) - (a2[1].y - a2[0].y) * (a2[2].x - a2[0].x) < 0, this.fire(new t.l("data", { dataType: "source", sourceDataType: "content" })), this;
	      }
	      prepare() {
	        if (0 === Object.keys(this.tiles).length || !this.image) return;
	        const e2 = this.map.painter.context, i2 = e2.gl;
	        this.texture || (this.texture = new t.T(e2, this.image, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
	        let a2 = false;
	        for (const e3 in this.tiles) {
	          const t2 = this.tiles[e3];
	          "loaded" !== t2.state && (t2.state = "loaded", t2.texture = this.texture, a2 = true);
	        }
	        a2 && this.fire(new t.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
	      }
	      loadTile(e2) {
	        return t._(this, void 0, void 0, function* () {
	          this.tileID && this.tileID.equals(e2.tileID.canonical) ? (this.tiles[String(e2.tileID.wrap)] = e2, e2.buckets = {}) : e2.state = "errored";
	        });
	      }
	      serialize() {
	        return { type: "image", url: this.options.url, coordinates: this.coordinates };
	      }
	      hasTransition() {
	        return false;
	      }
	      _getOverlappingTileRanges(e2) {
	        const { minX: i2, minY: a2, maxX: r2, maxY: o2 } = t.ab.fromPoints(e2), s2 = {};
	        for (let e3 = 0; e3 <= t.ac; e3++) {
	          const t2 = Math.pow(2, e3), n2 = Math.floor(i2 * t2), l2 = Math.floor(a2 * t2), c2 = Math.floor(r2 * t2), h2 = Math.floor(o2 * t2);
	          s2[e3] = { minTileX: n2, minTileY: l2, maxTileX: c2, maxTileY: h2 };
	        }
	        return s2;
	      }
	    }
	    class ie extends te {
	      constructor(e2, t2, i2, a2) {
	        super(e2, t2, i2, a2), this.roundZoom = true, this.type = "video", this.options = t2;
	      }
	      load() {
	        return t._(this, void 0, void 0, function* () {
	          this._loaded = false;
	          const e2 = this.options;
	          this.urls = [];
	          for (const t2 of e2.urls) this.urls.push(this.map._requestManager.transformRequest(t2, "Source").url);
	          try {
	            const e3 = yield t.ae(this.urls);
	            if (this._loaded = true, !e3) return;
	            this.video = e3, this.video.loop = true, this.video.addEventListener("playing", () => {
	              this.map.triggerRepaint();
	            }), this.map && this.video.play(), this._finishLoading();
	          } catch (e3) {
	            this.fire(new t.k(e3));
	          }
	        });
	      }
	      pause() {
	        this.video && this.video.pause();
	      }
	      play() {
	        this.video && this.video.play();
	      }
	      seek(e2) {
	        if (this.video) {
	          const i2 = this.video.seekable;
	          e2 < i2.start(0) || e2 > i2.end(0) ? this.fire(new t.k(new t.af(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = e2;
	        }
	      }
	      getVideo() {
	        return this.video;
	      }
	      onAdd(e2) {
	        this.map || (this.map = e2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
	      }
	      prepare() {
	        if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
	        const e2 = this.map.painter.context, i2 = e2.gl;
	        this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new t.T(e2, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
	        let a2 = false;
	        for (const e3 in this.tiles) {
	          const t2 = this.tiles[e3];
	          "loaded" !== t2.state && (t2.state = "loaded", t2.texture = this.texture, a2 = true);
	        }
	        a2 && this.fire(new t.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
	      }
	      serialize() {
	        return { type: "video", urls: this.urls, coordinates: this.coordinates };
	      }
	      hasTransition() {
	        return this.video && !this.video.paused;
	      }
	    }
	    class ae extends te {
	      constructor(e2, i2, a2, r2) {
	        super(e2, i2, a2, r2), i2.coordinates ? Array.isArray(i2.coordinates) && 4 === i2.coordinates.length && !i2.coordinates.some((e3) => !Array.isArray(e3) || 2 !== e3.length || e3.some((e4) => "number" != typeof e4)) || this.fire(new t.k(new t.af(`sources.${e2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.k(new t.af(`sources.${e2}`, null, 'missing required property "coordinates"'))), i2.animate && "boolean" != typeof i2.animate && this.fire(new t.k(new t.af(`sources.${e2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? "string" == typeof i2.canvas || i2.canvas instanceof HTMLCanvasElement || this.fire(new t.k(new t.af(`sources.${e2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.k(new t.af(`sources.${e2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = void 0 === i2.animate || i2.animate;
	      }
	      load() {
	        return t._(this, void 0, void 0, function* () {
	          this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
	            this._playing = true, this.map.triggerRepaint();
	          }, this.pause = function() {
	            this._playing && (this.prepare(), this._playing = false);
	          }, this._finishLoading());
	        });
	      }
	      getCanvas() {
	        return this.canvas;
	      }
	      onAdd(e2) {
	        this.map = e2, this.load(), this.canvas && this.animate && this.play();
	      }
	      onRemove() {
	        this.pause();
	      }
	      prepare() {
	        let e2 = false;
	        if (this.canvas.width !== this.width && (this.width = this.canvas.width, e2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e2 = true), this._hasInvalidDimensions()) return;
	        if (0 === Object.keys(this.tiles).length) return;
	        const i2 = this.map.painter.context, a2 = i2.gl;
	        this.texture ? (e2 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new t.T(i2, this.canvas, a2.RGBA, { premultiply: true });
	        let r2 = false;
	        for (const e3 in this.tiles) {
	          const t2 = this.tiles[e3];
	          "loaded" !== t2.state && (t2.state = "loaded", t2.texture = this.texture, r2 = true);
	        }
	        r2 && this.fire(new t.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
	      }
	      serialize() {
	        return { type: "canvas", animate: this.animate, canvas: this.options.canvas, coordinates: this.coordinates };
	      }
	      hasTransition() {
	        return this._playing;
	      }
	      _hasInvalidDimensions() {
	        for (const e2 of [this.canvas.width, this.canvas.height]) if (isNaN(e2) || e2 <= 0) return true;
	        return false;
	      }
	    }
	    const re = {}, oe = (e2) => {
	      switch (e2) {
	        case "geojson":
	          return ee;
	        case "image":
	          return te;
	        case "raster":
	          return K;
	        case "raster-dem":
	          return Y;
	        case "vector":
	          return X;
	        case "video":
	          return ie;
	        case "canvas":
	          return ae;
	      }
	      return re[e2];
	    }, se = "RTLPluginLoaded";
	    class ne extends t.E {
	      constructor() {
	        super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Z();
	      }
	      _syncState(e2) {
	        return this.status = e2, this.dispatcher.broadcast("SRPS", { pluginStatus: e2, pluginURL: this.url }).catch((e3) => {
	          throw this.status = "error", e3;
	        });
	      }
	      getRTLTextPluginStatus() {
	        return this.status;
	      }
	      clearRTLTextPlugin() {
	        this.status = "unavailable", this.url = null;
	      }
	      setRTLTextPlugin(e2) {
	        return t._(this, arguments, void 0, function* (e3, t2 = false) {
	          if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
	          if (this.url = n.resolveURL(e3), !this.url) throw new Error(`requested url ${e3} is invalid`);
	          if ("unavailable" === this.status) {
	            if (!t2) return this._requestImport();
	            this.status = "deferred", this._syncState(this.status);
	          } else if ("requested" === this.status) return this._requestImport();
	        });
	      }
	      _requestImport() {
	        return t._(this, void 0, void 0, function* () {
	          yield this._syncState("loading"), this.status = "loaded", this.fire(new t.l(se));
	        });
	      }
	      lazyLoad() {
	        "unavailable" === this.status ? this.status = "requested" : "deferred" === this.status && this._requestImport();
	      }
	    }
	    let le = null;
	    function ce() {
	      return le || (le = new ne()), le;
	    }
	    var he, ue;
	    !function(e2) {
	      e2[e2.Base = 0] = "Base", e2[e2.Parent = 1] = "Parent";
	    }(he || (he = {})), function(e2) {
	      e2[e2.Departing = 0] = "Departing", e2[e2.Incoming = 1] = "Incoming";
	    }(ue || (ue = {}));
	    class de {
	      constructor(e2, i2) {
	        this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = e2, this.uid = t.ag(), this.uses = 0, this.tileSize = i2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
	      }
	      isRenderable(e2) {
	        return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (e2 || !this.holdingForSymbolFade());
	      }
	      setCrossFadeLogic({ fadingRole: e2, fadingDirection: t2, fadingParentID: i2, fadeEndTime: a2 }) {
	        this.resetFadeLogic(), this.fadingRole = e2, this.fadingDirection = t2, this.fadingParentID = i2, this.fadeEndTime = a2;
	      }
	      setSelfFadeLogic(e2) {
	        this.resetFadeLogic(), this.selfFading = true, this.fadeEndTime = e2;
	      }
	      resetFadeLogic() {
	        this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = false, this.timeAdded = c(), this.fadeEndTime = 0, this.fadeOpacity = 1;
	      }
	      wasRequested() {
	        return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
	      }
	      clearTextures(e2) {
	        this.demTexture && e2.saveTileTexture(this.demTexture), this.demTexture = null;
	      }
	      loadVectorData(e2, i2, a2) {
	        if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e2) {
	          e2.featureIndex && (this.latestFeatureIndex = e2.featureIndex, e2.rawTileData ? (this.latestRawTileData = e2.rawTileData, this.latestFeatureIndex.rawTileData = e2.rawTileData, this.latestFeatureIndex.encoding = e2.encoding) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData, this.latestFeatureIndex.encoding = this.latestEncoding)), this.collisionBoxArray = e2.collisionBoxArray, this.buckets = function(e3, t2) {
	            const i3 = {};
	            if (!t2) return i3;
	            for (const a3 of e3) {
	              const e4 = a3.layerIds.map((e5) => t2.getLayer(e5)).filter(Boolean);
	              if (0 !== e4.length) {
	                a3.layers = e4, a3.stateDependentLayerIds && (a3.stateDependentLayers = a3.stateDependentLayerIds.map((t3) => e4.filter((e5) => e5.id === t3)[0]));
	                for (const t3 of e4) i3[t3.id] = a3;
	              }
	            }
	            return i3;
	          }(e2.buckets, null == i2 ? void 0 : i2.style), this.hasSymbolBuckets = false;
	          for (const e3 in this.buckets) {
	            const i3 = this.buckets[e3];
	            if (i3 instanceof t.ai) {
	              if (this.hasSymbolBuckets = true, !a2) break;
	              i3.justReloaded = true;
	            }
	          }
	          if (this.hasRTLText = false, this.hasSymbolBuckets) for (const e3 in this.buckets) {
	            const i3 = this.buckets[e3];
	            if (i3 instanceof t.ai && i3.hasRTLText) {
	              this.hasRTLText = true, ce().lazyLoad();
	              break;
	            }
	          }
	          this.queryPadding = 0;
	          for (const e3 in this.buckets) {
	            const t2 = this.buckets[e3];
	            this.queryPadding = Math.max(this.queryPadding, i2.style.getLayer(e3).queryRadius(t2));
	          }
	          e2.imageAtlas && (this.imageAtlas = e2.imageAtlas), e2.glyphAtlasImage && (this.glyphAtlasImage = e2.glyphAtlasImage), this.dashPositions = e2.dashPositions;
	        } else this.collisionBoxArray = new t.ah();
	      }
	      unloadVectorData() {
	        for (const e2 in this.buckets) this.buckets[e2].destroy();
	        this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded";
	      }
	      getBucket(e2) {
	        return this.buckets[e2.id];
	      }
	      upload(e2) {
	        for (const t2 in this.buckets) {
	          const i3 = this.buckets[t2];
	          i3.uploadPending() && i3.upload(e2);
	        }
	        const i2 = e2.gl;
	        this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new t.T(e2, this.imageAtlas.image, i2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new t.T(e2, this.glyphAtlasImage, i2.ALPHA), this.glyphAtlasImage = null);
	      }
	      prepare(e2) {
	        this.imageAtlas && this.imageAtlas.patchUpdatedImages(e2, this.imageAtlasTexture);
	      }
	      queryRenderedFeatures(e2, t2, i2, a2, r2, o2, s2, n2, l2, c2, h2) {
	        return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: a2, cameraQueryGeometry: r2, scale: o2, tileSize: this.tileSize, pixelPosMatrix: c2, transform: n2, params: s2, queryPadding: this.queryPadding * l2, getElevation: h2 }, e2, t2, i2) : {};
	      }
	      querySourceFeatures(e2, i2) {
	        const a2 = this.latestFeatureIndex;
	        if (!a2 || !a2.rawTileData) return;
	        const r2 = a2.loadVTLayers(), o2 = i2 && i2.sourceLayer ? i2.sourceLayer : "", s2 = r2[t.a9] || r2[o2];
	        if (!s2) return;
	        const n2 = t.aj(null == i2 ? void 0 : i2.filter, null == i2 ? void 0 : i2.globalState), { z: l2, x: c2, y: h2 } = this.tileID.canonical, u2 = { z: l2, x: c2, y: h2 };
	        for (let i3 = 0; i3 < s2.length; i3++) {
	          const r3 = s2.feature(i3);
	          if (n2.needGeometry) {
	            const e3 = t.ak(r3, true);
	            if (!n2.filter(new t.H(this.tileID.overscaledZ), e3, this.tileID.canonical)) continue;
	          } else if (!n2.filter(new t.H(this.tileID.overscaledZ), r3)) continue;
	          const d2 = a2.getId(r3, o2), _2 = new t.al(r3, l2, c2, h2, d2);
	          _2.tile = u2, e2.push(_2);
	        }
	      }
	      hasData() {
	        return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
	      }
	      patternsLoaded() {
	        return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
	      }
	      setExpiryData(e2) {
	        const i2 = this.expirationTime;
	        if (e2.cacheControl) {
	          const i3 = t.am(e2.cacheControl);
	          i3["max-age"] && (this.expirationTime = Date.now() + 1e3 * i3["max-age"]);
	        } else e2.expires && (this.expirationTime = new Date(e2.expires).getTime());
	        if (this.expirationTime) {
	          const e3 = Date.now();
	          let t2 = false;
	          if (this.expirationTime > e3) t2 = false;
	          else if (i2) if (this.expirationTime < i2) t2 = true;
	          else {
	            const a2 = this.expirationTime - i2;
	            a2 ? this.expirationTime = e3 + Math.max(a2, 3e4) : t2 = true;
	          }
	          else t2 = true;
	          t2 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
	        }
	      }
	      getExpiryTimeout() {
	        if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
	      }
	      setFeatureState(e2, i2) {
	        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(e2).length) return;
	        const a2 = this.latestFeatureIndex.loadVTLayers();
	        for (const r2 in this.buckets) {
	          if (!i2.style.hasLayer(r2)) continue;
	          const o2 = this.buckets[r2], s2 = o2.layers[0].sourceLayer || t.a9, n2 = a2[s2], l2 = e2[s2];
	          if (!n2 || !l2 || 0 === Object.keys(l2).length) continue;
	          o2.update(l2, n2, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
	          const c2 = i2 && i2.style && i2.style.getLayer(r2);
	          c2 && (this.queryPadding = Math.max(this.queryPadding, c2.queryRadius(o2)));
	        }
	      }
	      holdingForSymbolFade() {
	        return void 0 !== this.symbolFadeHoldUntil;
	      }
	      symbolFadeFinished() {
	        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < c();
	      }
	      clearSymbolFadeHold() {
	        this.symbolFadeHoldUntil = void 0;
	      }
	      setSymbolHoldDuration(e2) {
	        this.symbolFadeHoldUntil = c() + e2;
	      }
	      setDependencies(e2, t2) {
	        const i2 = {};
	        for (const e3 of t2) i2[e3] = true;
	        this.dependencies[e2] = i2;
	      }
	      hasDependency(e2, t2) {
	        for (const i2 of e2) {
	          const e3 = this.dependencies[i2];
	          if (e3) {
	            for (const i3 of t2) if (e3[i3]) return true;
	          }
	        }
	        return false;
	      }
	    }
	    class _e {
	      constructor() {
	        this.state = {}, this.stateChanges = {}, this.deletedStates = {};
	      }
	      updateState(e2, i2, a2) {
	        const r2 = String(i2);
	        if (this.stateChanges[e2] = this.stateChanges[e2] || {}, this.stateChanges[e2][r2] = this.stateChanges[e2][r2] || {}, t.e(this.stateChanges[e2][r2], a2), null === this.deletedStates[e2]) {
	          this.deletedStates[e2] = {};
	          for (const t2 in this.state[e2]) t2 !== r2 && (this.deletedStates[e2][t2] = null);
	        } else if (this.deletedStates[e2] && null === this.deletedStates[e2][r2]) {
	          this.deletedStates[e2][r2] = {};
	          for (const t2 in this.state[e2][r2]) a2[t2] || (this.deletedStates[e2][r2][t2] = null);
	        } else for (const t2 in a2) this.deletedStates[e2] && this.deletedStates[e2][r2] && null === this.deletedStates[e2][r2][t2] && delete this.deletedStates[e2][r2][t2];
	      }
	      removeFeatureState(e2, t2, i2) {
	        if (null === this.deletedStates[e2]) return;
	        const a2 = String(t2);
	        if (this.deletedStates[e2] = this.deletedStates[e2] || {}, i2 && void 0 !== t2) null !== this.deletedStates[e2][a2] && (this.deletedStates[e2][a2] = this.deletedStates[e2][a2] || {}, this.deletedStates[e2][a2][i2] = null);
	        else if (void 0 !== t2) if (this.stateChanges[e2] && this.stateChanges[e2][a2]) for (i2 in this.deletedStates[e2][a2] = {}, this.stateChanges[e2][a2]) this.deletedStates[e2][a2][i2] = null;
	        else this.deletedStates[e2][a2] = null;
	        else this.deletedStates[e2] = null;
	      }
	      getState(e2, i2) {
	        const a2 = String(i2), r2 = t.e({}, (this.state[e2] || {})[a2], (this.stateChanges[e2] || {})[a2]);
	        if (null === this.deletedStates[e2]) return {};
	        if (this.deletedStates[e2]) {
	          const t2 = this.deletedStates[e2][i2];
	          if (null === t2) return {};
	          for (const e3 in t2) delete r2[e3];
	        }
	        return r2;
	      }
	      initializeTileState(e2, t2) {
	        e2.setFeatureState(this.state, t2);
	      }
	      coalesceChanges(e2, i2) {
	        const a2 = {};
	        for (const e3 in this.stateChanges) {
	          this.state[e3] = this.state[e3] || {};
	          const i3 = {};
	          for (const a3 in this.stateChanges[e3]) this.state[e3][a3] || (this.state[e3][a3] = {}), t.e(this.state[e3][a3], this.stateChanges[e3][a3]), i3[a3] = this.state[e3][a3];
	          a2[e3] = i3;
	        }
	        for (const e3 in this.deletedStates) {
	          this.state[e3] = this.state[e3] || {};
	          const i3 = {};
	          if (null === this.deletedStates[e3]) for (const t2 in this.state[e3]) i3[t2] = {}, this.state[e3][t2] = {};
	          else for (const t2 in this.deletedStates[e3]) {
	            if (null === this.deletedStates[e3][t2]) this.state[e3][t2] = {};
	            else for (const i4 of Object.keys(this.deletedStates[e3][t2])) delete this.state[e3][t2][i4];
	            i3[t2] = this.state[e3][t2];
	          }
	          a2[e3] = a2[e3] || {}, t.e(a2[e3], i3);
	        }
	        if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(a2).length) for (const t2 in e2) e2[t2].setFeatureState(a2, i2);
	      }
	    }
	    const pe = 89.25;
	    function me(e2, i2) {
	      const a2 = t.an(i2.lat, -t.ao, t.ao);
	      return new t.P(t.Y(i2.lng) * e2, t.X(a2) * e2);
	    }
	    function fe(e2, i2) {
	      return new t.aa(i2.x / e2, i2.y / e2).toLngLat();
	    }
	    function ge(e2) {
	      return e2.cameraToCenterDistance * Math.min(0.85 * Math.tan(t.ap(90 - e2.pitch)), Math.tan(t.ap(pe - e2.pitch)));
	    }
	    function ve(e2, i2) {
	      const a2 = e2.canonical, r2 = i2 / t.aq(a2.z), o2 = a2.x + Math.pow(2, a2.z) * e2.wrap, s2 = t.ar(new Float64Array(16));
	      return t.O(s2, s2, [o2 * r2, a2.y * r2, 0]), t.Q(s2, s2, [r2 / t.a4, r2 / t.a4, 1]), s2;
	    }
	    function xe(e2, i2, a2, r2, o2) {
	      const s2 = t.aa.fromLngLat(e2, i2), n2 = o2 * t.as(1, e2.lat), l2 = n2 * Math.cos(t.ap(a2)), c2 = Math.sqrt(n2 * n2 - l2 * l2), h2 = c2 * Math.sin(t.ap(-r2)), u2 = c2 * Math.cos(t.ap(-r2));
	      return new t.aa(s2.x + h2, s2.y + u2, s2.z + l2);
	    }
	    function be(e2, t2, i2) {
	      const a2 = t2.intersectsFrustum(e2);
	      if (!i2 || 0 === a2) return a2;
	      const r2 = t2.intersectsPlane(i2);
	      return 0 === r2 ? 0 : 2 === a2 && 2 === r2 ? 2 : 1;
	    }
	    function ye(e2, t2, i2) {
	      let a2 = 0;
	      const r2 = (i2 - t2) / 10;
	      for (let o2 = 0; o2 < 10; o2++) a2 += r2 * Math.pow(Math.cos(t2 + (o2 + 0.5) / 10 * (i2 - t2)), e2);
	      return a2;
	    }
	    function we(e2, i2) {
	      return function(a2, r2, o2, s2, n2) {
	        const l2 = 2 * ((e2 - 1) / t.at(Math.cos(t.ap(pe - n2)) / Math.cos(t.ap(pe))) - 1), c2 = Math.acos(o2 / s2), h2 = 2 * ye(l2 - 1, 0, t.ap(n2 / 2)), u2 = Math.min(t.ap(pe), c2 + t.ap(n2 / 2)), d2 = ye(l2 - 1, Math.min(u2, c2 - t.ap(n2 / 2)), u2), _2 = Math.atan(r2 / o2), p2 = Math.hypot(r2, o2);
	        let m2 = a2;
	        return m2 += t.at(s2 / p2 / Math.max(0.5, Math.cos(t.ap(n2 / 2)))), m2 += l2 * t.at(Math.cos(_2)) / 2, m2 -= t.at(Math.max(1, d2 / h2 / i2)) / 2, m2;
	      };
	    }
	    const Te = we(9.314, 3);
	    function Pe(e2, i2) {
	      const a2 = (i2.roundZoom ? Math.round : Math.floor)(e2.zoom + t.at(e2.tileSize / i2.tileSize));
	      return Math.max(0, a2);
	    }
	    function Ce(e2, i2) {
	      const a2 = e2.getCameraFrustum(), r2 = e2.getClippingPlane(), o2 = e2.screenPointToMercatorCoordinate(e2.getCameraPoint()), s2 = t.aa.fromLngLat(e2.center, e2.elevation);
	      o2.z = s2.z + Math.cos(e2.pitchInRadians) * e2.cameraToCenterDistance / e2.worldSize;
	      const n2 = e2.getCoveringTilesDetailsProvider(), l2 = n2.allowVariableZoom(e2, i2), c2 = Pe(e2, i2), h2 = i2.minzoom || 0, u2 = void 0 !== i2.maxzoom ? i2.maxzoom : e2.maxZoom, d2 = Math.min(Math.max(0, c2), u2), _2 = Math.pow(2, d2), p2 = [_2 * o2.x, _2 * o2.y, 0], m2 = [_2 * s2.x, _2 * s2.y, 0], f2 = Math.hypot(s2.x - o2.x, s2.y - o2.y), g2 = Math.abs(s2.z - o2.z), v2 = Math.hypot(f2, g2), x2 = (e3) => ({ zoom: 0, x: 0, y: 0, wrap: e3, fullyVisible: false }), b2 = [], y2 = [];
	      if (e2.renderWorldCopies && n2.allowWorldCopies()) for (let e3 = 1; e3 <= 3; e3++) b2.push(x2(-e3)), b2.push(x2(e3));
	      for (b2.push(x2(0)); b2.length > 0; ) {
	        const _3 = b2.pop(), f3 = _3.x, x3 = _3.y;
	        let w2 = _3.fullyVisible;
	        const T2 = { x: f3, y: x3, z: _3.zoom }, P2 = n2.getTileBoundingVolume(T2, _3.wrap, e2.elevation, i2);
	        if (!w2) {
	          const e3 = be(a2, P2, r2);
	          if (0 === e3) continue;
	          w2 = 2 === e3;
	        }
	        const C2 = n2.distanceToTile2d(o2.x, o2.y, T2, P2);
	        let M2 = c2;
	        l2 && (M2 = (i2.calculateTileZoom || Te)(e2.zoom + t.at(e2.tileSize / i2.tileSize), C2, g2, v2, e2.fov)), M2 = (i2.roundZoom ? Math.round : Math.floor)(M2), M2 = Math.max(0, M2);
	        const I2 = Math.min(M2, u2);
	        if (_3.wrap = n2.getWrap(s2, T2, _3.wrap), _3.zoom >= I2) {
	          if (_3.zoom < h2) continue;
	          const e3 = d2 - _3.zoom, a3 = p2[0] - 0.5 - (f3 << e3), r3 = p2[1] - 0.5 - (x3 << e3), o3 = i2.reparseOverscaled ? Math.max(_3.zoom, M2) : _3.zoom;
	          y2.push({ tileID: new t.a1(_3.zoom === u2 ? o3 : _3.zoom, _3.wrap, _3.zoom, f3, x3), distanceSq: t.au([m2[0] - 0.5 - f3, m2[1] - 0.5 - x3]), tileDistanceToCamera: Math.sqrt(a3 * a3 + r3 * r3) });
	        } else for (let e3 = 0; e3 < 4; e3++) b2.push({ zoom: _3.zoom + 1, x: (f3 << 1) + e3 % 2, y: (x3 << 1) + (e3 >> 1), wrap: _3.wrap, fullyVisible: w2 });
	      }
	      return y2.sort((e3, t2) => e3.distanceSq - t2.distanceSq).map((e3) => e3.tileID);
	    }
	    const Me = t.ab.fromPoints([new t.P(0, 0), new t.P(t.a4, t.a4)]);
	    class Ie extends t.E {
	      constructor(e2, i2, a2) {
	        super(), this.id = e2, this.dispatcher = a2, this.on("data", (e3) => this._dataHandler(e3)), this.on("dataloading", () => {
	          this._sourceErrored = false;
	        }), this.on("error", () => {
	          this._sourceErrored = this._source.loaded();
	        }), this._source = ((e3, t2, i3, a3) => {
	          const r2 = new (oe(t2.type))(e3, t2, i3, a3);
	          if (r2.id !== e3) throw new Error(`Expected Source id to be ${e3} instead of ${r2.id}`);
	          return r2;
	        })(e2, i2, a2, this), this._tiles = {}, this._cache = new t.av(0, (e3) => this._unloadTile(e3)), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new _e(), this._didEmitContent = false, this._updated = false;
	      }
	      onAdd(e2) {
	        this.map = e2, this._maxTileCacheSize = e2 ? e2._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e2 ? e2._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e2);
	      }
	      onRemove(e2) {
	        this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e2);
	      }
	      loaded() {
	        if (this._sourceErrored) return true;
	        if (!this._sourceLoaded) return false;
	        if (!this._source.loaded()) return false;
	        if (!(void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain)) return true;
	        if (!this._updated) return false;
	        for (const e2 in this._tiles) {
	          const t2 = this._tiles[e2];
	          if ("loaded" !== t2.state && "errored" !== t2.state) return false;
	        }
	        return true;
	      }
	      getSource() {
	        return this._source;
	      }
	      getState() {
	        return this._state;
	      }
	      pause() {
	        this._paused = true;
	      }
	      resume() {
	        if (!this._paused) return;
	        const e2 = this._shouldReloadOnResume;
	        this._paused = false, this._shouldReloadOnResume = false, e2 && this.reload(), this.transform && this.update(this.transform, this.terrain);
	      }
	      _loadTile(e2, i2, a2) {
	        return t._(this, void 0, void 0, function* () {
	          try {
	            yield this._source.loadTile(e2), this._tileLoaded(e2, i2, a2);
	          } catch (i3) {
	            e2.state = "errored", 404 !== i3.status ? this._source.fire(new t.k(i3, { tile: e2 })) : this.update(this.transform, this.terrain);
	          }
	        });
	      }
	      _unloadTile(e2) {
	        this._source.unloadTile && this._source.unloadTile(e2);
	      }
	      _abortTile(e2) {
	        this._source.abortTile && this._source.abortTile(e2), this._source.fire(new t.l("dataabort", { tile: e2, coord: e2.tileID, dataType: "source" }));
	      }
	      serialize() {
	        return this._source.serialize();
	      }
	      prepare(e2) {
	        this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
	        for (const t2 in this._tiles) {
	          const i2 = this._tiles[t2];
	          i2.upload(e2), i2.prepare(this.map.style.imageManager);
	        }
	      }
	      getIds() {
	        return Object.values(this._tiles).map((e2) => e2.tileID).sort(Ee).map((e2) => e2.key);
	      }
	      getRenderableIds(e2) {
	        const i2 = [];
	        for (const t2 in this._tiles) this._isIdRenderable(t2, e2) && i2.push(this._tiles[t2]);
	        return e2 ? i2.sort((e3, i3) => {
	          const a2 = e3.tileID, r2 = i3.tileID, o2 = new t.P(a2.canonical.x, a2.canonical.y)._rotate(-this.transform.bearingInRadians), s2 = new t.P(r2.canonical.x, r2.canonical.y)._rotate(-this.transform.bearingInRadians);
	          return a2.overscaledZ - r2.overscaledZ || s2.y - o2.y || s2.x - o2.x;
	        }).map((e3) => e3.tileID.key) : i2.map((e3) => e3.tileID).sort(Ee).map((e3) => e3.key);
	      }
	      hasRenderableParent(e2) {
	        const t2 = e2.overscaledZ - 1;
	        if (t2 >= this._source.minzoom) {
	          const i2 = this.getLoadedTile(e2.scaledTo(t2));
	          if (i2) return this._isIdRenderable(i2.tileID.key);
	        }
	        return false;
	      }
	      _isIdRenderable(e2, t2 = false) {
	        var i2;
	        return null === (i2 = this._tiles[e2]) || void 0 === i2 ? void 0 : i2.isRenderable(t2);
	      }
	      reload(e2, t2 = void 0) {
	        if (this._paused) this._shouldReloadOnResume = true;
	        else {
	          this._cache.reset();
	          for (const i2 in this._tiles) t2 && this._source.shouldReloadTile && !this._source.shouldReloadTile(this._tiles[i2], t2) || (e2 ? this._reloadTile(i2, "expired") : "errored" !== this._tiles[i2].state && this._reloadTile(i2, "reloading"));
	        }
	      }
	      _reloadTile(e2, i2) {
	        return t._(this, void 0, void 0, function* () {
	          const t2 = this._tiles[e2];
	          t2 && ("loading" !== t2.state && (t2.state = i2), yield this._loadTile(t2, e2, i2));
	        });
	      }
	      _tileLoaded(e2, i2, a2) {
	        e2.timeAdded = c(), e2.selfFading && (e2.fadeEndTime = e2.timeAdded + this._rasterFadeDuration), "expired" === a2 && (e2.refreshedUponExpiration = true), this._setTileReloadTimer(i2, e2), "raster-dem" === this.getSource().type && e2.dem && this._backfillDEM(e2), this._state.initializeTileState(e2, this.map ? this.map.painter : null), e2.aborted || this._source.fire(new t.l("data", { dataType: "source", tile: e2, coord: e2.tileID }));
	      }
	      _backfillDEM(e2) {
	        const t2 = this.getRenderableIds();
	        for (let a2 = 0; a2 < t2.length; a2++) {
	          const r2 = t2[a2];
	          if (e2.neighboringTiles && e2.neighboringTiles[r2]) {
	            const t3 = this.getTileByID(r2);
	            i2(e2, t3), i2(t3, e2);
	          }
	        }
	        function i2(e3, t3) {
	          e3.needsHillshadePrepare = true, e3.needsTerrainPrepare = true;
	          let i3 = t3.tileID.canonical.x - e3.tileID.canonical.x;
	          const a2 = t3.tileID.canonical.y - e3.tileID.canonical.y, r2 = Math.pow(2, e3.tileID.canonical.z), o2 = t3.tileID.key;
	          0 === i3 && 0 === a2 || Math.abs(a2) > 1 || (Math.abs(i3) > 1 && (1 === Math.abs(i3 + r2) ? i3 += r2 : 1 === Math.abs(i3 - r2) && (i3 -= r2)), t3.dem && e3.dem && (e3.dem.backfillBorder(t3.dem, i3, a2), e3.neighboringTiles && e3.neighboringTiles[o2] && (e3.neighboringTiles[o2].backfilled = true)));
	        }
	      }
	      getTile(e2) {
	        return this.getTileByID(e2.key);
	      }
	      getTileByID(e2) {
	        return this._tiles[e2];
	      }
	      _retainLoadedChildren(e2, t2) {
	        const i2 = this._getLoadedDescendents(t2), a2 = /* @__PURE__ */ new Set();
	        for (const r2 of t2) {
	          const t3 = i2[r2.key];
	          if (!(null == t3 ? void 0 : t3.length)) {
	            a2.add(r2);
	            continue;
	          }
	          const o2 = r2.overscaledZ + Ie.maxOverzooming, s2 = t3.filter((e3) => e3.tileID.overscaledZ <= o2);
	          if (!s2.length) {
	            a2.add(r2);
	            continue;
	          }
	          const n2 = Math.min(...s2.map((e3) => e3.tileID.overscaledZ)), l2 = s2.filter((e3) => e3.tileID.overscaledZ === n2).map((e3) => e3.tileID);
	          for (const t4 of l2) e2[t4.key] = t4;
	          this._areDescendentsComplete(l2, n2, r2.overscaledZ) || a2.add(r2);
	        }
	        return a2;
	      }
	      _getLoadedDescendents(e2) {
	        var t2;
	        const i2 = {};
	        for (const a2 in this._tiles) {
	          const r2 = this._tiles[a2];
	          if (r2.hasData()) for (const a3 of e2) r2.tileID.isChildOf(a3) && (i2[t2 = a3.key] || (i2[t2] = [])).push(r2);
	        }
	        return i2;
	      }
	      _areDescendentsComplete(e2, t2, i2) {
	        return 1 === e2.length && e2[0].isOverscaled() ? e2[0].overscaledZ === t2 : Math.pow(4, t2 - i2) === e2.length;
	      }
	      getLoadedTile(e2) {
	        const t2 = this._tiles[e2.key];
	        return (null == t2 ? void 0 : t2.hasData()) ? t2 : null;
	      }
	      updateCacheSize(e2) {
	        const i2 = Math.ceil(e2.width / this._source.tileSize) + 1, a2 = Math.ceil(e2.height / this._source.tileSize) + 1, r2 = Math.floor(i2 * a2 * (null === this._maxTileCacheZoomLevels ? t.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), o2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, r2) : r2;
	        this._cache.setMaxSize(o2);
	      }
	      handleWrapJump(e2) {
	        const t2 = Math.round((e2 - (void 0 === this._prevLng ? e2 : this._prevLng)) / 360);
	        if (this._prevLng = e2, t2) {
	          const e3 = {};
	          for (const i2 in this._tiles) {
	            const a2 = this._tiles[i2];
	            a2.tileID = a2.tileID.unwrapTo(a2.tileID.wrap + t2), e3[a2.tileID.key] = a2;
	          }
	          this._tiles = e3, this._resetTileReloadTimers();
	        }
	      }
	      update(e2, i2) {
	        if (!this._sourceLoaded || this._paused) return;
	        let a2;
	        this.transform = e2, this.terrain = i2, this.updateCacheSize(e2), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? a2 = e2.getVisibleUnwrappedCoordinates(this._source.tileID).map((e3) => new t.a1(e3.canonical.z, e3.wrap, e3.canonical.z, e3.canonical.x, e3.canonical.y)) : (a2 = Ce(e2, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: "vector" === this._source.type && void 0 !== this.map._zoomLevelsToOverscale ? e2.maxZoom - this.map._zoomLevelsToOverscale : this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i2, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (a2 = a2.filter((e3) => this._source.hasTile(e3)))) : a2 = [], this.usedForTerrain && (a2 = this._addTerrainIdealTiles(a2));
	        const r2 = 0 === a2.length && !this._updated && this._didEmitContent;
	        this._updated = true, r2 && this.fire(new t.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
	        const o2 = Pe(e2, this._source), s2 = this._updateRetainedTiles(a2, o2), n2 = Se(this._source.type);
	        n2 && this._rasterFadeDuration > 0 && !i2 && this._updateFadingTiles(a2, s2), n2 ? this._cleanUpRasterTiles(s2) : this._cleanUpVectorTiles(s2);
	      }
	      _cleanUpRasterTiles(e2) {
	        for (const t2 in this._tiles) e2[t2] || this._removeTile(t2);
	      }
	      _cleanUpVectorTiles(e2) {
	        for (const t2 in this._tiles) {
	          const i2 = this._tiles[t2];
	          e2[t2] ? i2.clearSymbolFadeHold() : i2.hasSymbolBuckets ? i2.holdingForSymbolFade() ? i2.symbolFadeFinished() && this._removeTile(t2) : i2.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(t2);
	        }
	      }
	      _addTerrainIdealTiles(e2) {
	        const t2 = [];
	        for (const i2 of e2) if (i2.canonical.z > this._source.minzoom) {
	          const e3 = i2.scaledTo(i2.canonical.z - 1);
	          t2.push(e3);
	          const a2 = i2.scaledTo(Math.max(this._source.minzoom, Math.min(i2.canonical.z, 5)));
	          t2.push(a2);
	        }
	        return e2.concat(t2);
	      }
	      releaseSymbolFadeTiles() {
	        for (const e2 in this._tiles) this._tiles[e2].holdingForSymbolFade() && this._removeTile(e2);
	      }
	      _updateRetainedTiles(e2, t2) {
	        var i2;
	        const a2 = /* @__PURE__ */ new Set();
	        for (const t3 of e2) this._addTile(t3).hasData() || a2.add(t3);
	        const r2 = e2.reduce((e3, t3) => (e3[t3.key] = t3, e3), {}), o2 = this._retainLoadedChildren(r2, a2), s2 = {}, n2 = Math.max(t2 - Ie.maxUnderzooming, this._source.minzoom);
	        for (const e3 of o2) {
	          let t3 = this._tiles[e3.key], a3 = null == t3 ? void 0 : t3.wasRequested();
	          for (let o3 = e3.overscaledZ - 1; o3 >= n2; --o3) {
	            const n3 = e3.scaledTo(o3);
	            if (s2[n3.key]) break;
	            if (s2[n3.key] = true, t3 = this.getTile(n3), !t3 && a3 && (t3 = this._addTile(n3)), t3) {
	              const e4 = t3.hasData();
	              if ((e4 || !(null === (i2 = this.map) || void 0 === i2 ? void 0 : i2.cancelPendingTileRequestsWhileZooming) || a3) && (r2[n3.key] = n3), a3 = t3.wasRequested(), e4) break;
	            }
	          }
	        }
	        return r2;
	      }
	      _updateFadingTiles(e2, i2) {
	        const a2 = c(), r2 = t.aw(e2);
	        for (const t2 of e2) {
	          const e3 = this._tiles[t2.key];
	          e3.fadingDirection !== ue.Departing && 0 !== e3.fadeOpacity || e3.resetFadeLogic(), this._updateFadingAncestor(e3, i2, a2) || this._updateFadingDescendents(e3, i2, a2) || this._updateFadingEdge(e3, r2, a2) || e3.resetFadeLogic();
	        }
	      }
	      _updateFadingAncestor(e2, t2, i2) {
	        if (!e2.hasData()) return false;
	        const { tileID: a2, fadingRole: r2, fadingDirection: o2, fadingParentID: s2 } = e2;
	        if (r2 === he.Base && o2 === ue.Incoming && s2) return t2[s2.key] = s2, true;
	        const n2 = Math.max(a2.overscaledZ - this._maxFadingAncestorLevels, this._source.minzoom);
	        for (let r3 = a2.overscaledZ - 1; r3 >= n2; r3--) {
	          const o3 = a2.scaledTo(r3), s3 = this.getLoadedTile(o3);
	          if (s3) return e2.setCrossFadeLogic({ fadingRole: he.Base, fadingDirection: ue.Incoming, fadingParentID: s3.tileID, fadeEndTime: i2 + this._rasterFadeDuration }), s3.setCrossFadeLogic({ fadingRole: he.Parent, fadingDirection: ue.Departing, fadeEndTime: i2 + this._rasterFadeDuration }), t2[o3.key] = o3, true;
	        }
	        return false;
	      }
	      _updateFadingDescendents(e2, t2, i2) {
	        if (!e2.hasData()) return false;
	        const a2 = e2.tileID.children(this._source.maxzoom);
	        let r2 = this._updateFadingChildren(e2, a2, t2, i2);
	        if (r2) return true;
	        for (const o2 of a2) {
	          const a3 = o2.children(this._source.maxzoom);
	          this._updateFadingChildren(e2, a3, t2, i2) && (r2 = true);
	        }
	        return r2;
	      }
	      _updateFadingChildren(e2, t2, i2, a2) {
	        if (t2[0].overscaledZ >= this._source.maxzoom) return false;
	        let r2 = false;
	        for (const o2 of t2) {
	          const t3 = this.getLoadedTile(o2);
	          if (!t3) continue;
	          const { fadingRole: s2, fadingDirection: n2, fadingParentID: l2 } = t3;
	          s2 === he.Base && n2 === ue.Departing && l2 || (t3.setCrossFadeLogic({ fadingRole: he.Base, fadingDirection: ue.Departing, fadingParentID: e2.tileID, fadeEndTime: a2 + this._rasterFadeDuration }), e2.setCrossFadeLogic({ fadingRole: he.Parent, fadingDirection: ue.Incoming, fadeEndTime: a2 + this._rasterFadeDuration })), i2[o2.key] = o2, r2 = true;
	        }
	        return r2;
	      }
	      _updateFadingEdge(e2, t2, i2) {
	        const a2 = e2.tileID;
	        return !!e2.selfFading || !e2.hasData() && !!t2.has(a2) && (e2.setSelfFadeLogic(i2 + this._rasterFadeDuration), true);
	      }
	      _addTile(e2) {
	        let i2 = this._tiles[e2.key];
	        if (i2) return i2;
	        i2 = this._cache.getAndRemove(e2), i2 && (i2.resetFadeLogic(), this._setTileReloadTimer(e2.key, i2), i2.tileID = e2, this._state.initializeTileState(i2, this.map ? this.map.painter : null));
	        const a2 = i2;
	        return i2 || (i2 = new de(e2, this._source.tileSize * e2.overscaleFactor()), this._loadTile(i2, e2.key, i2.state)), i2.uses++, this._tiles[e2.key] = i2, a2 || this._source.fire(new t.l("dataloading", { tile: i2, coord: i2.tileID, dataType: "source" })), i2;
	      }
	      _setTileReloadTimer(e2, t2) {
	        this._clearTileReloadTimer(e2);
	        const i2 = t2.getExpiryTimeout();
	        i2 && (this._timers[e2] = setTimeout(() => {
	          this._reloadTile(e2, "expired"), delete this._timers[e2];
	        }, i2));
	      }
	      _clearTileReloadTimer(e2) {
	        const t2 = this._timers[e2];
	        t2 && (clearTimeout(t2), delete this._timers[e2]);
	      }
	      _resetTileReloadTimers() {
	        for (const e2 in this._timers) clearTimeout(this._timers[e2]), delete this._timers[e2];
	        for (const e2 in this._tiles) this._setTileReloadTimer(e2, this._tiles[e2]);
	      }
	      refreshTiles(e2) {
	        for (const t2 in this._tiles) (this._isIdRenderable(t2) || "errored" == this._tiles[t2].state) && e2.some((e3) => e3.equals(this._tiles[t2].tileID.canonical)) && this._reloadTile(t2, "expired");
	      }
	      _removeTile(e2) {
	        const t2 = this._tiles[e2];
	        t2 && (t2.uses--, delete this._tiles[e2], this._clearTileReloadTimer(e2), t2.uses > 0 || (t2.hasData() && "reloading" !== t2.state ? this._cache.add(t2.tileID, t2, t2.getExpiryTimeout()) : (t2.aborted = true, this._abortTile(t2), this._unloadTile(t2))));
	      }
	      _dataHandler(e2) {
	        "source" === e2.dataType && ("metadata" !== e2.sourceDataType ? "content" === e2.sourceDataType && this._sourceLoaded && !this._paused && (this.reload(e2.sourceDataChanged, e2.shouldReloadTileOptions), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true) : this._sourceLoaded = true);
	      }
	      clearTiles() {
	        this._shouldReloadOnResume = false, this._paused = false;
	        for (const e2 in this._tiles) this._removeTile(e2);
	        this._cache.reset();
	      }
	      tilesIn(e2, i2, a2) {
	        const r2 = [], o2 = this.transform;
	        if (!o2) return r2;
	        const s2 = o2.getCoveringTilesDetailsProvider().allowWorldCopies(), n2 = a2 ? o2.getCameraQueryGeometry(e2) : e2, l2 = (e3) => o2.screenPointToMercatorCoordinate(e3, this.terrain), c2 = this.transformBbox(e2, l2, !s2), h2 = this.transformBbox(n2, l2, !s2), u2 = this.getIds(), d2 = t.ab.fromPoints(h2);
	        for (let e3 = 0; e3 < u2.length; e3++) {
	          const a3 = this._tiles[u2[e3]];
	          if (a3.holdingForSymbolFade()) continue;
	          const n3 = s2 ? [a3.tileID] : [a3.tileID.unwrapTo(-1), a3.tileID.unwrapTo(0)], l3 = Math.pow(2, o2.zoom - a3.tileID.overscaledZ), _2 = i2 * a3.queryPadding * t.a4 / a3.tileSize / l3;
	          for (const e4 of n3) {
	            const i3 = d2.map((i4) => e4.getTilePoint(new t.aa(i4.x, i4.y)));
	            if (i3.expandBy(_2), i3.intersects(Me)) {
	              const t2 = c2.map((t3) => e4.getTilePoint(t3)), i4 = h2.map((t3) => e4.getTilePoint(t3));
	              r2.push({ tile: a3, tileID: s2 ? e4 : e4.unwrapTo(0), queryGeometry: t2, cameraQueryGeometry: i4, scale: l3 });
	            }
	          }
	        }
	        return r2;
	      }
	      transformBbox(e2, i2, a2) {
	        let r2 = e2.map(i2);
	        if (a2) {
	          const a3 = t.ab.fromPoints(e2);
	          a3.shrinkBy(1e-3 * Math.min(a3.width(), a3.height()));
	          const o2 = a3.map(i2);
	          t.ab.fromPoints(r2).covers(o2) || (r2 = r2.map((e3) => e3.x > 0.5 ? new t.aa(e3.x - 1, e3.y, e3.z) : e3));
	        }
	        return r2;
	      }
	      getVisibleCoordinates(e2) {
	        const t2 = this.getRenderableIds(e2).map((e3) => this._tiles[e3].tileID);
	        return this.transform && this.transform.populateCache(t2), t2;
	      }
	      hasTransition() {
	        if (this._source.hasTransition()) return true;
	        if (Se(this._source.type) && this._rasterFadeDuration > 0) {
	          const e2 = c();
	          for (const t2 in this._tiles) if (this._tiles[t2].fadeEndTime >= e2) return true;
	        }
	        return false;
	      }
	      setRasterFadeDuration(e2) {
	        this._rasterFadeDuration = e2;
	      }
	      setFeatureState(e2, i2, a2) {
	        this._state.updateState(e2 = e2 || t.a9, i2, a2);
	      }
	      removeFeatureState(e2, i2, a2) {
	        this._state.removeFeatureState(e2 = e2 || t.a9, i2, a2);
	      }
	      getFeatureState(e2, i2) {
	        return this._state.getState(e2 = e2 || t.a9, i2);
	      }
	      setDependencies(e2, t2, i2) {
	        const a2 = this._tiles[e2];
	        a2 && a2.setDependencies(t2, i2);
	      }
	      reloadTilesForDependencies(e2, t2) {
	        for (const i2 in this._tiles) this._tiles[i2].hasDependency(e2, t2) && this._reloadTile(i2, "reloading");
	        this._cache.filter((i2) => !i2.hasDependency(e2, t2));
	      }
	    }
	    function Ee(e2, t2) {
	      const i2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0), a2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0);
	      return e2.overscaledZ - t2.overscaledZ || a2 - i2 || t2.canonical.y - e2.canonical.y || t2.canonical.x - e2.canonical.x;
	    }
	    function Se(e2) {
	      return "raster" === e2 || "image" === e2 || "video" === e2;
	    }
	    Ie.maxUnderzooming = 10, Ie.maxOverzooming = 3;
	    class Re {
	      constructor(e2, t2) {
	        this.reset(e2, t2);
	      }
	      reset(e2, t2) {
	        this.points = e2 || [], this._distances = [0];
	        for (let e3 = 1; e3 < this.points.length; e3++) this._distances[e3] = this._distances[e3 - 1] + this.points[e3].dist(this.points[e3 - 1]);
	        this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
	      }
	      lerp(e2) {
	        if (1 === this.points.length) return this.points[0];
	        e2 = t.an(e2, 0, 1);
	        let i2 = 1, a2 = this._distances[i2];
	        const r2 = e2 * this.paddedLength + this.padding;
	        for (; a2 < r2 && i2 < this._distances.length; ) a2 = this._distances[++i2];
	        const o2 = i2 - 1, s2 = this._distances[o2], n2 = a2 - s2, l2 = n2 > 0 ? (r2 - s2) / n2 : 0;
	        return this.points[o2].mult(1 - l2).add(this.points[i2].mult(l2));
	      }
	    }
	    function De(e2, t2) {
	      let i2 = true;
	      return "always" === e2 || "never" !== e2 && "never" !== t2 || (i2 = false), i2;
	    }
	    class ze {
	      constructor(e2, t2, i2) {
	        const a2 = this.boxCells = [], r2 = this.circleCells = [];
	        this.xCellCount = Math.ceil(e2 / i2), this.yCellCount = Math.ceil(t2 / i2);
	        for (let e3 = 0; e3 < this.xCellCount * this.yCellCount; e3++) a2.push([]), r2.push([]);
	        this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e2, this.height = t2, this.xScale = this.xCellCount / e2, this.yScale = this.yCellCount / t2, this.boxUid = 0, this.circleUid = 0;
	      }
	      keysLength() {
	        return this.boxKeys.length + this.circleKeys.length;
	      }
	      insert(e2, t2, i2, a2, r2) {
	        this._forEachCell(t2, i2, a2, r2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e2), this.bboxes.push(t2), this.bboxes.push(i2), this.bboxes.push(a2), this.bboxes.push(r2);
	      }
	      insertCircle(e2, t2, i2, a2) {
	        this._forEachCell(t2 - a2, i2 - a2, t2 + a2, i2 + a2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e2), this.circles.push(t2), this.circles.push(i2), this.circles.push(a2);
	      }
	      _insertBoxCell(e2, t2, i2, a2, r2, o2) {
	        this.boxCells[r2].push(o2);
	      }
	      _insertCircleCell(e2, t2, i2, a2, r2, o2) {
	        this.circleCells[r2].push(o2);
	      }
	      _query(e2, t2, i2, a2, r2, o2, s2) {
	        if (i2 < 0 || e2 > this.width || a2 < 0 || t2 > this.height) return [];
	        const n2 = [];
	        if (e2 <= 0 && t2 <= 0 && this.width <= i2 && this.height <= a2) {
	          if (r2) return [{ key: null, x1: e2, y1: t2, x2: i2, y2: a2 }];
	          for (let e3 = 0; e3 < this.boxKeys.length; e3++) n2.push({ key: this.boxKeys[e3], x1: this.bboxes[4 * e3], y1: this.bboxes[4 * e3 + 1], x2: this.bboxes[4 * e3 + 2], y2: this.bboxes[4 * e3 + 3] });
	          for (let e3 = 0; e3 < this.circleKeys.length; e3++) {
	            const t3 = this.circles[3 * e3], i3 = this.circles[3 * e3 + 1], a3 = this.circles[3 * e3 + 2];
	            n2.push({ key: this.circleKeys[e3], x1: t3 - a3, y1: i3 - a3, x2: t3 + a3, y2: i3 + a3 });
	          }
	        } else this._forEachCell(e2, t2, i2, a2, this._queryCell, n2, { hitTest: r2, overlapMode: o2, seenUids: { box: {}, circle: {} } }, s2);
	        return n2;
	      }
	      query(e2, t2, i2, a2) {
	        return this._query(e2, t2, i2, a2, false, null);
	      }
	      hitTest(e2, t2, i2, a2, r2, o2) {
	        return this._query(e2, t2, i2, a2, true, r2, o2).length > 0;
	      }
	      hitTestCircle(e2, t2, i2, a2, r2) {
	        const o2 = e2 - i2, s2 = e2 + i2, n2 = t2 - i2, l2 = t2 + i2;
	        if (s2 < 0 || o2 > this.width || l2 < 0 || n2 > this.height) return false;
	        const c2 = [];
	        return this._forEachCell(o2, n2, s2, l2, this._queryCellCircle, c2, { hitTest: true, overlapMode: a2, circle: { x: e2, y: t2, radius: i2 }, seenUids: { box: {}, circle: {} } }, r2), c2.length > 0;
	      }
	      _queryCell(e2, t2, i2, a2, r2, o2, s2, n2) {
	        const { seenUids: l2, hitTest: c2, overlapMode: h2 } = s2, u2 = this.boxCells[r2];
	        if (null !== u2) {
	          const r3 = this.bboxes;
	          for (const s3 of u2) if (!l2.box[s3]) {
	            l2.box[s3] = true;
	            const u3 = 4 * s3, d3 = this.boxKeys[s3];
	            if (e2 <= r3[u3 + 2] && t2 <= r3[u3 + 3] && i2 >= r3[u3 + 0] && a2 >= r3[u3 + 1] && (!n2 || n2(d3)) && (!c2 || !De(h2, d3.overlapMode)) && (o2.push({ key: d3, x1: r3[u3], y1: r3[u3 + 1], x2: r3[u3 + 2], y2: r3[u3 + 3] }), c2)) return true;
	          }
	        }
	        const d2 = this.circleCells[r2];
	        if (null !== d2) {
	          const r3 = this.circles;
	          for (const s3 of d2) if (!l2.circle[s3]) {
	            l2.circle[s3] = true;
	            const u3 = 3 * s3, d3 = this.circleKeys[s3];
	            if (this._circleAndRectCollide(r3[u3], r3[u3 + 1], r3[u3 + 2], e2, t2, i2, a2) && (!n2 || n2(d3)) && (!c2 || !De(h2, d3.overlapMode))) {
	              const e3 = r3[u3], t3 = r3[u3 + 1], i3 = r3[u3 + 2];
	              if (o2.push({ key: d3, x1: e3 - i3, y1: t3 - i3, x2: e3 + i3, y2: t3 + i3 }), c2) return true;
	            }
	          }
	        }
	        return false;
	      }
	      _queryCellCircle(e2, t2, i2, a2, r2, o2, s2, n2) {
	        const { circle: l2, seenUids: c2, overlapMode: h2 } = s2, u2 = this.boxCells[r2];
	        if (null !== u2) {
	          const e3 = this.bboxes;
	          for (const t3 of u2) if (!c2.box[t3]) {
	            c2.box[t3] = true;
	            const i3 = 4 * t3, a3 = this.boxKeys[t3];
	            if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, e3[i3 + 0], e3[i3 + 1], e3[i3 + 2], e3[i3 + 3]) && (!n2 || n2(a3)) && !De(h2, a3.overlapMode)) return o2.push(true), true;
	          }
	        }
	        const d2 = this.circleCells[r2];
	        if (null !== d2) {
	          const e3 = this.circles;
	          for (const t3 of d2) if (!c2.circle[t3]) {
	            c2.circle[t3] = true;
	            const i3 = 3 * t3, a3 = this.circleKeys[t3];
	            if (this._circlesCollide(e3[i3], e3[i3 + 1], e3[i3 + 2], l2.x, l2.y, l2.radius) && (!n2 || n2(a3)) && !De(h2, a3.overlapMode)) return o2.push(true), true;
	          }
	        }
	      }
	      _forEachCell(e2, t2, i2, a2, r2, o2, s2, n2) {
	        const l2 = this._convertToXCellCoord(e2), c2 = this._convertToYCellCoord(t2), h2 = this._convertToXCellCoord(i2), u2 = this._convertToYCellCoord(a2);
	        for (let d2 = l2; d2 <= h2; d2++) for (let l3 = c2; l3 <= u2; l3++) if (r2.call(this, e2, t2, i2, a2, this.xCellCount * l3 + d2, o2, s2, n2)) return;
	      }
	      _convertToXCellCoord(e2) {
	        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e2 * this.xScale)));
	      }
	      _convertToYCellCoord(e2) {
	        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e2 * this.yScale)));
	      }
	      _circlesCollide(e2, t2, i2, a2, r2, o2) {
	        const s2 = a2 - e2, n2 = r2 - t2, l2 = i2 + o2;
	        return l2 * l2 > s2 * s2 + n2 * n2;
	      }
	      _circleAndRectCollide(e2, t2, i2, a2, r2, o2, s2) {
	        const n2 = (o2 - a2) / 2, l2 = Math.abs(e2 - (a2 + n2));
	        if (l2 > n2 + i2) return false;
	        const c2 = (s2 - r2) / 2, h2 = Math.abs(t2 - (r2 + c2));
	        if (h2 > c2 + i2) return false;
	        if (l2 <= n2 || h2 <= c2) return true;
	        const u2 = l2 - n2, d2 = h2 - c2;
	        return u2 * u2 + d2 * d2 <= i2 * i2;
	      }
	    }
	    function Ae(e2, i2, r2) {
	      const o2 = t.N();
	      if (!e2) {
	        const { vecSouth: e3, vecEast: t2 } = ke(i2), r3 = a();
	        r3[0] = t2[0], r3[1] = t2[1], r3[2] = e3[0], r3[3] = e3[1], s2 = r3, (d2 = (l2 = (n2 = r3)[0]) * (u2 = n2[3]) - (h2 = n2[2]) * (c2 = n2[1])) && (s2[0] = u2 * (d2 = 1 / d2), s2[1] = -c2 * d2, s2[2] = -h2 * d2, s2[3] = l2 * d2), o2[0] = r3[0], o2[1] = r3[1], o2[4] = r3[2], o2[5] = r3[3];
	      }
	      var s2, n2, l2, c2, h2, u2, d2;
	      return t.Q(o2, o2, [1 / r2, 1 / r2, 1]), o2;
	    }
	    function Le(e2, i2, a2, r2) {
	      if (e2) {
	        const e3 = t.N();
	        if (!i2) {
	          const { vecSouth: t2, vecEast: i3 } = ke(a2);
	          e3[0] = i3[0], e3[1] = i3[1], e3[4] = t2[0], e3[5] = t2[1];
	        }
	        return t.Q(e3, e3, [r2, r2, 1]), e3;
	      }
	      return a2.pixelsToClipSpaceMatrix;
	    }
	    function ke(e2) {
	      const i2 = Math.cos(e2.rollInRadians), a2 = Math.sin(e2.rollInRadians), r2 = Math.cos(e2.pitchInRadians), o2 = Math.cos(e2.bearingInRadians), s2 = Math.sin(e2.bearingInRadians), n2 = t.aB();
	      n2[0] = -o2 * r2 * a2 - s2 * i2, n2[1] = -s2 * r2 * a2 + o2 * i2;
	      const l2 = t.aC(n2);
	      l2 < 1e-9 ? t.aD(n2) : t.aE(n2, n2, 1 / l2);
	      const c2 = t.aB();
	      c2[0] = o2 * r2 * i2 - s2 * a2, c2[1] = s2 * r2 * i2 + o2 * a2;
	      const h2 = t.aC(c2);
	      return h2 < 1e-9 ? t.aD(c2) : t.aE(c2, c2, 1 / h2), { vecEast: c2, vecSouth: n2 };
	    }
	    function Fe(e2, i2, a2, r2) {
	      let o2;
	      r2 ? (o2 = [e2, i2, r2(e2, i2), 1], t.aG(o2, o2, a2)) : (o2 = [e2, i2, 0, 1], Je(o2, o2, a2));
	      const s2 = o2[3];
	      return { point: new t.P(o2[0] / s2, o2[1] / s2), signedDistanceFromCamera: s2, isOccluded: false };
	    }
	    function Be(e2, t2) {
	      return 0.5 + e2 / t2 * 0.5;
	    }
	    function Oe(e2, t2) {
	      return e2.x >= -t2[0] && e2.x <= t2[0] && e2.y >= -t2[1] && e2.y <= t2[1];
	    }
	    function je(e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2, _2) {
	      const p2 = a2 ? e2.textSizeData : e2.iconSizeData, m2 = t.ax(p2, i2.transform.zoom), f2 = [256 / i2.width * 2 + 1, 256 / i2.height * 2 + 1], g2 = a2 ? e2.text.dynamicLayoutVertexArray : e2.icon.dynamicLayoutVertexArray;
	      g2.clear();
	      const v2 = e2.lineVertexArray, x2 = a2 ? e2.text.placedSymbolArray : e2.icon.placedSymbolArray, b2 = i2.transform.width / i2.transform.height;
	      let y2 = false;
	      for (let a3 = 0; a3 < x2.length; a3++) {
	        const w2 = x2.get(a3);
	        if (w2.hidden || w2.writingMode === t.ay.vertical && !y2) {
	          Qe(w2.numGlyphs, g2);
	          continue;
	        }
	        y2 = false;
	        const T2 = new t.P(w2.anchorX, w2.anchorY), P2 = { getElevation: _2, pitchedLabelPlaneMatrix: r2, lineVertexArray: v2, pitchWithMap: s2, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: i2.transform, tileAnchorPoint: T2, unwrappedTileID: c2, width: h2, height: u2, translation: d2 }, C2 = $e(w2.anchorX, w2.anchorY, P2);
	        if (!Oe(C2.point, f2)) {
	          Qe(w2.numGlyphs, g2);
	          continue;
	        }
	        const M2 = Be(i2.transform.cameraToCenterDistance, C2.signedDistanceFromCamera), I2 = t.az(p2, m2, w2), E2 = s2 ? I2 * i2.transform.getPitchedTextCorrection(w2.anchorX, w2.anchorY, c2) / M2 : I2 * M2, S2 = Ge({ projectionContext: P2, pitchedLabelPlaneMatrixInverse: o2, symbol: w2, fontSize: E2, flip: false, keepUpright: n2, glyphOffsetArray: e2.glyphOffsetArray, dynamicLayoutVertexArray: g2, aspectRatio: b2, rotateToLine: l2 });
	        y2 = S2.useVertical, (S2.notEnoughRoom || y2 || S2.needsFlipping && Ge({ projectionContext: P2, pitchedLabelPlaneMatrixInverse: o2, symbol: w2, fontSize: E2, flip: true, keepUpright: n2, glyphOffsetArray: e2.glyphOffsetArray, dynamicLayoutVertexArray: g2, aspectRatio: b2, rotateToLine: l2 }).notEnoughRoom) && Qe(w2.numGlyphs, g2);
	      }
	      a2 ? e2.text.dynamicLayoutVertexBuffer.updateData(g2) : e2.icon.dynamicLayoutVertexBuffer.updateData(g2);
	    }
	    function Ne(e2, t2, i2, a2, r2, o2, s2, n2) {
	      const l2 = o2.glyphStartIndex + o2.numGlyphs, c2 = o2.lineStartIndex, h2 = o2.lineStartIndex + o2.lineLength, u2 = t2.getoffsetX(o2.glyphStartIndex), d2 = t2.getoffsetX(l2 - 1), _2 = Ke(e2 * u2, i2, a2, r2, o2.segment, c2, h2, n2, s2);
	      if (!_2) return null;
	      const p2 = Ke(e2 * d2, i2, a2, r2, o2.segment, c2, h2, n2, s2);
	      return p2 ? n2.projectionCache.anyProjectionOccluded ? null : { first: _2, last: p2 } : null;
	    }
	    function Ze(e2, i2, a2, r2) {
	      return e2 === t.ay.horizontal && Math.abs(a2.y - i2.y) > Math.abs(a2.x - i2.x) * r2 ? { useVertical: true } : (e2 === t.ay.vertical ? i2.y < a2.y : i2.x > a2.x) ? { needsFlipping: true } : null;
	    }
	    function Ge(e2) {
	      const { projectionContext: i2, pitchedLabelPlaneMatrixInverse: a2, symbol: r2, fontSize: o2, flip: s2, keepUpright: n2, glyphOffsetArray: l2, dynamicLayoutVertexArray: c2, aspectRatio: h2, rotateToLine: u2 } = e2, d2 = o2 / 24, _2 = r2.lineOffsetX * d2, p2 = r2.lineOffsetY * d2;
	      let m2;
	      if (r2.numGlyphs > 1) {
	        const e3 = r2.glyphStartIndex + r2.numGlyphs, t2 = r2.lineStartIndex, o3 = r2.lineStartIndex + r2.lineLength, c3 = Ne(d2, l2, _2, p2, s2, r2, u2, i2);
	        if (!c3) return { notEnoughRoom: true };
	        const f2 = We(c3.first.point.x, c3.first.point.y, i2, a2), g2 = We(c3.last.point.x, c3.last.point.y, i2, a2);
	        if (n2 && !s2) {
	          const e4 = Ze(r2.writingMode, f2, g2, h2);
	          if (e4) return e4;
	        }
	        m2 = [c3.first];
	        for (let a3 = r2.glyphStartIndex + 1; a3 < e3 - 1; a3++) {
	          const e4 = Ke(d2 * l2.getoffsetX(a3), _2, p2, s2, r2.segment, t2, o3, i2, u2);
	          if (!e4) return { notEnoughRoom: true };
	          m2.push(e4);
	        }
	        m2.push(c3.last);
	      } else {
	        if (n2 && !s2) {
	          const e4 = qe(i2.tileAnchorPoint.x, i2.tileAnchorPoint.y, i2).point, o3 = r2.lineStartIndex + r2.segment + 1, s3 = new t.P(i2.lineVertexArray.getx(o3), i2.lineVertexArray.gety(o3)), n3 = qe(s3.x, s3.y, i2), l3 = n3.signedDistanceFromCamera > 0 ? n3.point : Ue(i2.tileAnchorPoint, s3, e4, 1, i2), c3 = We(e4.x, e4.y, i2, a2), u3 = We(l3.x, l3.y, i2, a2), d3 = Ze(r2.writingMode, c3, u3, h2);
	          if (d3) return d3;
	        }
	        const e3 = Ke(d2 * l2.getoffsetX(r2.glyphStartIndex), _2, p2, s2, r2.segment, r2.lineStartIndex, r2.lineStartIndex + r2.lineLength, i2, u2);
	        if (!e3 || i2.projectionCache.anyProjectionOccluded) return { notEnoughRoom: true };
	        m2 = [e3];
	      }
	      for (const e3 of m2) t.aF(c2, e3.point, e3.angle);
	      return {};
	    }
	    function Ue(e2, t2, i2, a2, r2) {
	      const o2 = e2.add(e2.sub(t2)._unit()), s2 = qe(o2.x, o2.y, r2).point, n2 = i2.sub(s2);
	      return i2.add(n2._mult(a2 / n2.mag()));
	    }
	    function Ve(e2, i2, a2) {
	      const r2 = i2.projectionCache;
	      if (r2.projections[e2]) return r2.projections[e2];
	      const o2 = new t.P(i2.lineVertexArray.getx(e2), i2.lineVertexArray.gety(e2)), s2 = qe(o2.x, o2.y, i2);
	      if (s2.signedDistanceFromCamera > 0) return r2.projections[e2] = s2.point, r2.anyProjectionOccluded = r2.anyProjectionOccluded || s2.isOccluded, s2.point;
	      const n2 = e2 - a2.direction;
	      return Ue(0 === a2.distanceFromAnchor ? i2.tileAnchorPoint : new t.P(i2.lineVertexArray.getx(n2), i2.lineVertexArray.gety(n2)), o2, a2.previousVertex, a2.absOffsetX - a2.distanceFromAnchor + 1, i2);
	    }
	    function qe(e2, t2, i2) {
	      const a2 = e2 + i2.translation[0], r2 = t2 + i2.translation[1];
	      let o2;
	      return i2.pitchWithMap ? (o2 = Fe(a2, r2, i2.pitchedLabelPlaneMatrix, i2.getElevation), o2.isOccluded = false) : (o2 = i2.transform.projectTileCoordinates(a2, r2, i2.unwrappedTileID, i2.getElevation), o2.point.x = (0.5 * o2.point.x + 0.5) * i2.width, o2.point.y = (0.5 * -o2.point.y + 0.5) * i2.height), o2;
	    }
	    function We(e2, i2, a2, r2) {
	      if (a2.pitchWithMap) {
	        const o2 = [e2, i2, 0, 1];
	        return t.aG(o2, o2, r2), a2.transform.projectTileCoordinates(o2[0] / o2[3], o2[1] / o2[3], a2.unwrappedTileID, a2.getElevation).point;
	      }
	      return { x: e2 / a2.width * 2 - 1, y: 1 - i2 / a2.height * 2 };
	    }
	    function $e(e2, t2, i2) {
	      return i2.transform.projectTileCoordinates(e2, t2, i2.unwrappedTileID, i2.getElevation);
	    }
	    function He(e2, t2, i2) {
	      return e2._unit()._perp()._mult(t2 * i2);
	    }
	    function Xe(e2, i2, a2, r2, o2, s2, n2, l2, c2) {
	      if (l2.projectionCache.offsets[e2]) return l2.projectionCache.offsets[e2];
	      const h2 = a2.add(i2);
	      if (e2 + c2.direction < r2 || e2 + c2.direction >= o2) return l2.projectionCache.offsets[e2] = h2, h2;
	      const u2 = Ve(e2 + c2.direction, l2, c2), d2 = He(u2.sub(a2), n2, c2.direction), _2 = a2.add(d2), p2 = u2.add(d2);
	      return l2.projectionCache.offsets[e2] = t.aH(s2, h2, _2, p2) || h2, l2.projectionCache.offsets[e2];
	    }
	    function Ke(e2, t2, i2, a2, r2, o2, s2, n2, l2) {
	      const c2 = a2 ? e2 - t2 : e2 + t2;
	      let h2 = c2 > 0 ? 1 : -1, u2 = 0;
	      a2 && (h2 *= -1, u2 = Math.PI), h2 < 0 && (u2 += Math.PI);
	      let d2, _2 = h2 > 0 ? o2 + r2 : o2 + r2 + 1;
	      n2.projectionCache.cachedAnchorPoint ? d2 = n2.projectionCache.cachedAnchorPoint : (d2 = qe(n2.tileAnchorPoint.x, n2.tileAnchorPoint.y, n2).point, n2.projectionCache.cachedAnchorPoint = d2);
	      let p2, m2, f2 = d2, g2 = d2, v2 = 0, x2 = 0;
	      const b2 = Math.abs(c2), y2 = [];
	      let w2;
	      for (; v2 + x2 <= b2; ) {
	        if (_2 += h2, _2 < o2 || _2 >= s2) return null;
	        v2 += x2, g2 = f2, m2 = p2;
	        const e3 = { absOffsetX: b2, direction: h2, distanceFromAnchor: v2, previousVertex: g2 };
	        if (f2 = Ve(_2, n2, e3), 0 === i2) y2.push(g2), w2 = f2.sub(g2);
	        else {
	          let t3;
	          const a3 = f2.sub(g2);
	          t3 = 0 === a3.mag() ? He(Ve(_2 + h2, n2, e3).sub(f2), i2, h2) : He(a3, i2, h2), m2 || (m2 = g2.add(t3)), p2 = Xe(_2, t3, f2, o2, s2, m2, i2, n2, e3), y2.push(m2), w2 = p2.sub(m2);
	        }
	        x2 = w2.mag();
	      }
	      const T2 = w2._mult((b2 - v2) / x2)._add(m2 || g2), P2 = u2 + Math.atan2(f2.y - g2.y, f2.x - g2.x);
	      return y2.push(T2), { point: T2, angle: l2 ? P2 : 0, path: y2 };
	    }
	    const Ye = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
	    function Qe(e2, t2) {
	      for (let i2 = 0; i2 < e2; i2++) {
	        const e3 = t2.length;
	        t2.resize(e3 + 4), t2.float32.set(Ye, 3 * e3);
	      }
	    }
	    function Je(e2, t2, i2) {
	      const a2 = t2[0], r2 = t2[1];
	      return e2[0] = i2[0] * a2 + i2[4] * r2 + i2[12], e2[1] = i2[1] * a2 + i2[5] * r2 + i2[13], e2[3] = i2[3] * a2 + i2[7] * r2 + i2[15], e2;
	    }
	    const et = 100;
	    class tt {
	      constructor(e2, t2 = new ze(e2.width + 200, e2.height + 200, 25), i2 = new ze(e2.width + 200, e2.height + 200, 25)) {
	        this.transform = e2, this.grid = t2, this.ignoredGrid = i2, this.pitchFactor = Math.cos(e2.pitch * Math.PI / 180) * e2.cameraToCenterDistance, this.screenRightBoundary = e2.width + et, this.screenBottomBoundary = e2.height + et, this.gridRightBoundary = e2.width + 200, this.gridBottomBoundary = e2.height + 200, this.perspectiveRatioCutoff = 0.6;
	      }
	      placeCollisionBox(e2, t2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2) {
	        const d2 = this.projectAndGetPerspectiveRatio(e2.anchorPointX + n2[0], e2.anchorPointY + n2[1], r2, c2, u2), _2 = i2 * d2.perspectiveRatio;
	        let p2;
	        if (o2 || s2) p2 = this._projectCollisionBox(e2, _2, a2, r2, o2, s2, n2, d2, c2, h2, u2);
	        else {
	          const t3 = d2.x + (h2 ? h2.x * _2 : 0), i3 = d2.y + (h2 ? h2.y * _2 : 0);
	          p2 = { allPointsOccluded: false, box: [t3 + e2.x1 * _2, i3 + e2.y1 * _2, t3 + e2.x2 * _2, i3 + e2.y2 * _2] };
	        }
	        const [m2, f2, g2, v2] = p2.box, x2 = o2 ? p2.allPointsOccluded : d2.isOccluded;
	        let b2 = x2;
	        return b2 || (b2 = d2.perspectiveRatio < this.perspectiveRatioCutoff), b2 || (b2 = !this.isInsideGrid(m2, f2, g2, v2)), b2 || "always" !== t2 && this.grid.hitTest(m2, f2, g2, v2, t2, l2) ? { box: [m2, f2, g2, v2], placeable: false, offscreen: false, occluded: x2 } : { box: [m2, f2, g2, v2], placeable: true, offscreen: this.isOffscreen(m2, f2, g2, v2), occluded: x2 };
	      }
	      placeCollisionCircles(e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2, _2, p2) {
	        const m2 = [], f2 = new t.P(i2.anchorX, i2.anchorY), g2 = this.getPerspectiveRatio(f2.x, f2.y, s2, p2), v2 = (c2 ? o2 * this.transform.getPitchedTextCorrection(i2.anchorX, i2.anchorY, s2) / g2 : o2 * g2) / t.aL, x2 = { getElevation: p2, pitchedLabelPlaneMatrix: n2, lineVertexArray: a2, pitchWithMap: c2, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: this.transform, tileAnchorPoint: f2, unwrappedTileID: s2, width: this.transform.width, height: this.transform.height, translation: _2 }, b2 = Ne(v2, r2, i2.lineOffsetX * v2, i2.lineOffsetY * v2, false, i2, false, x2);
	        let y2 = false, w2 = false, T2 = true;
	        if (b2) {
	          const i3 = 0.5 * u2 * g2 + d2, a3 = new t.P(-100, -100), r3 = new t.P(this.screenRightBoundary, this.screenBottomBoundary), o3 = new Re(), s3 = b2.first, n3 = b2.last;
	          let _3 = [];
	          for (let e3 = s3.path.length - 1; e3 >= 1; e3--) _3.push(s3.path[e3]);
	          for (let e3 = 1; e3 < n3.path.length; e3++) _3.push(n3.path[e3]);
	          const p3 = 2.5 * i3;
	          if (c2) {
	            const e3 = this.projectPathToScreenSpace(_3, x2);
	            _3 = e3.some((e4) => e4.signedDistanceFromCamera <= 0) ? [] : e3.map((e4) => e4.point);
	          }
	          let f3 = [];
	          if (_3.length > 0) {
	            const e3 = _3[0].clone(), i4 = _3[0].clone();
	            for (let t2 = 1; t2 < _3.length; t2++) e3.x = Math.min(e3.x, _3[t2].x), e3.y = Math.min(e3.y, _3[t2].y), i4.x = Math.max(i4.x, _3[t2].x), i4.y = Math.max(i4.y, _3[t2].y);
	            f3 = e3.x >= a3.x && i4.x <= r3.x && e3.y >= a3.y && i4.y <= r3.y ? [_3] : i4.x < a3.x || e3.x > r3.x || i4.y < a3.y || e3.y > r3.y ? [] : t.aI([_3], a3.x, a3.y, r3.x, r3.y);
	          }
	          for (const t2 of f3) {
	            o3.reset(t2, 0.25 * i3);
	            let a4 = 0;
	            a4 = o3.length <= 0.5 * i3 ? 1 : Math.ceil(o3.paddedLength / p3) + 1;
	            for (let t3 = 0; t3 < a4; t3++) {
	              const r4 = t3 / Math.max(a4 - 1, 1), s4 = o3.lerp(r4), n4 = s4.x + et, c3 = s4.y + et;
	              m2.push(n4, c3, i3, 0);
	              const u3 = n4 - i3, d3 = c3 - i3, _4 = n4 + i3, p4 = c3 + i3;
	              if (T2 = T2 && this.isOffscreen(u3, d3, _4, p4), w2 = w2 || this.isInsideGrid(u3, d3, _4, p4), "always" !== e2 && this.grid.hitTestCircle(n4, c3, i3, e2, h2) && (y2 = true, !l2)) return { circles: [], offscreen: false, collisionDetected: y2 };
	            }
	          }
	        }
	        return { circles: !l2 && y2 || !w2 || g2 < this.perspectiveRatioCutoff ? [] : m2, offscreen: T2, collisionDetected: y2 };
	      }
	      projectPathToScreenSpace(e2, i2) {
	        const a2 = function(e3, i3) {
	          const a3 = t.N();
	          return t.aA(a3, i3.pitchedLabelPlaneMatrix), e3.map((e4) => {
	            const t2 = Fe(e4.x, e4.y, a3, i3.getElevation), r2 = i3.transform.projectTileCoordinates(t2.point.x, t2.point.y, i3.unwrappedTileID, i3.getElevation);
	            return r2.point.x = (0.5 * r2.point.x + 0.5) * i3.width, r2.point.y = (0.5 * -r2.point.y + 0.5) * i3.height, r2;
	          });
	        }(e2, i2);
	        return function(e3) {
	          let t2 = 0, i3 = 0, a3 = 0, r2 = 0;
	          for (let o2 = 0; o2 < e3.length; o2++) e3[o2].isOccluded ? (a3 = o2 + 1, r2 = 0) : (r2++, r2 > i3 && (i3 = r2, t2 = a3));
	          return e3.slice(t2, t2 + i3);
	        }(a2);
	      }
	      queryRenderedSymbols(e2) {
	        if (0 === e2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
	        const i2 = [], a2 = new t.ab();
	        for (const r3 of e2) {
	          const e3 = new t.P(r3.x + et, r3.y + et);
	          a2.extend(e3), i2.push(e3);
	        }
	        const { minX: r2, minY: o2, maxX: s2, maxY: n2 } = a2, l2 = this.grid.query(r2, o2, s2, n2).concat(this.ignoredGrid.query(r2, o2, s2, n2)), c2 = {}, h2 = {};
	        for (const e3 of l2) {
	          const a3 = e3.key;
	          if (void 0 === c2[a3.bucketInstanceId] && (c2[a3.bucketInstanceId] = {}), c2[a3.bucketInstanceId][a3.featureIndex]) continue;
	          const r3 = [new t.P(e3.x1, e3.y1), new t.P(e3.x2, e3.y1), new t.P(e3.x2, e3.y2), new t.P(e3.x1, e3.y2)];
	          t.aJ(i2, r3) && (c2[a3.bucketInstanceId][a3.featureIndex] = true, void 0 === h2[a3.bucketInstanceId] && (h2[a3.bucketInstanceId] = []), h2[a3.bucketInstanceId].push(a3.featureIndex));
	        }
	        return h2;
	      }
	      insertCollisionBox(e2, t2, i2, a2, r2, o2) {
	        (i2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: a2, featureIndex: r2, collisionGroupID: o2, overlapMode: t2 }, e2[0], e2[1], e2[2], e2[3]);
	      }
	      insertCollisionCircles(e2, t2, i2, a2, r2, o2) {
	        const s2 = i2 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: a2, featureIndex: r2, collisionGroupID: o2, overlapMode: t2 };
	        for (let t3 = 0; t3 < e2.length; t3 += 4) s2.insertCircle(n2, e2[t3], e2[t3 + 1], e2[t3 + 2]);
	      }
	      projectAndGetPerspectiveRatio(e2, i2, a2, r2, o2) {
	        if (o2) {
	          let a3;
	          r2 ? (a3 = [e2, i2, r2(e2, i2), 1], t.aG(a3, a3, o2)) : (a3 = [e2, i2, 0, 1], Je(a3, a3, o2));
	          const s2 = a3[3];
	          return { x: (a3[0] / s2 + 1) / 2 * this.transform.width + et, y: (-a3[1] / s2 + 1) / 2 * this.transform.height + et, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / s2 * 0.5, isOccluded: false, signedDistanceFromCamera: s2 };
	        }
	        {
	          const t2 = this.transform.projectTileCoordinates(e2, i2, a2, r2);
	          return { x: (t2.point.x + 1) / 2 * this.transform.width + et, y: (1 - t2.point.y) / 2 * this.transform.height + et, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / t2.signedDistanceFromCamera * 0.5, isOccluded: t2.isOccluded, signedDistanceFromCamera: t2.signedDistanceFromCamera };
	        }
	      }
	      getPerspectiveRatio(e2, t2, i2, a2) {
	        const r2 = this.transform.projectTileCoordinates(e2, t2, i2, a2);
	        return 0.5 + this.transform.cameraToCenterDistance / r2.signedDistanceFromCamera * 0.5;
	      }
	      isOffscreen(e2, t2, i2, a2) {
	        return i2 < et || e2 >= this.screenRightBoundary || a2 < et || t2 > this.screenBottomBoundary;
	      }
	      isInsideGrid(e2, t2, i2, a2) {
	        return i2 >= 0 && e2 < this.gridRightBoundary && a2 >= 0 && t2 < this.gridBottomBoundary;
	      }
	      getViewportMatrix() {
	        const e2 = t.ar([]);
	        return t.O(e2, e2, [-100, -100, 0]), e2;
	      }
	      _projectCollisionBox(e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2) {
	        let d2 = 1, _2 = 0, p2 = 0, m2 = 1;
	        const f2 = e2.anchorPointX + n2[0], g2 = e2.anchorPointY + n2[1];
	        if (s2 && !o2) {
	          const e3 = this.projectAndGetPerspectiveRatio(f2 + 1, g2, r2, c2, u2), t2 = e3.x - l2.x, i3 = Math.atan((e3.y - l2.y) / t2) + (t2 < 0 ? Math.PI : 0), a3 = Math.sin(i3), o3 = Math.cos(i3);
	          d2 = o3, _2 = a3, p2 = -a3, m2 = o3;
	        } else if (!s2 && o2) {
	          const e3 = ke(this.transform);
	          d2 = e3.vecEast[0], _2 = e3.vecEast[1], p2 = e3.vecSouth[0], m2 = e3.vecSouth[1];
	        }
	        let v2 = l2.x, x2 = l2.y, b2 = i2;
	        o2 && (v2 = f2, x2 = g2, b2 = Math.pow(2, -(this.transform.zoom - a2.overscaledZ)), b2 *= this.transform.getPitchedTextCorrection(f2, g2, r2), h2 || (b2 *= t.an(0.5 + l2.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), h2 && (v2 += d2 * h2.x * b2 + p2 * h2.y * b2, x2 += _2 * h2.x * b2 + m2 * h2.y * b2);
	        const y2 = e2.x1 * b2, w2 = e2.x2 * b2, T2 = (y2 + w2) / 2, P2 = e2.y1 * b2, C2 = e2.y2 * b2, M2 = (P2 + C2) / 2, I2 = [{ offsetX: y2, offsetY: P2 }, { offsetX: T2, offsetY: P2 }, { offsetX: w2, offsetY: P2 }, { offsetX: w2, offsetY: M2 }, { offsetX: w2, offsetY: C2 }, { offsetX: T2, offsetY: C2 }, { offsetX: y2, offsetY: C2 }, { offsetX: y2, offsetY: M2 }];
	        let E2 = [];
	        for (const { offsetX: e3, offsetY: i3 } of I2) E2.push(new t.P(v2 + d2 * e3 + p2 * i3, x2 + _2 * e3 + m2 * i3));
	        let S2 = false;
	        if (o2) {
	          const e3 = E2.map((e4) => this.projectAndGetPerspectiveRatio(e4.x, e4.y, r2, c2, u2));
	          S2 = e3.some((e4) => !e4.isOccluded), E2 = e3.map((e4) => new t.P(e4.x, e4.y));
	        } else S2 = true;
	        return { box: t.aK(E2), allPointsOccluded: !S2 };
	      }
	    }
	    class it {
	      constructor(e2, t2, i2, a2) {
	        this.opacity = e2 ? Math.max(0, Math.min(1, e2.opacity + (e2.placed ? t2 : -t2))) : a2 && i2 ? 1 : 0, this.placed = i2;
	      }
	      isHidden() {
	        return 0 === this.opacity && !this.placed;
	      }
	    }
	    class at {
	      constructor(e2, t2, i2, a2, r2) {
	        this.text = new it(e2 ? e2.text : null, t2, i2, r2), this.icon = new it(e2 ? e2.icon : null, t2, a2, r2);
	      }
	      isHidden() {
	        return this.text.isHidden() && this.icon.isHidden();
	      }
	    }
	    class rt {
	      constructor(e2, t2, i2) {
	        this.text = e2, this.icon = t2, this.skipFade = i2;
	      }
	    }
	    class ot {
	      constructor(e2, t2, i2, a2, r2) {
	        this.bucketInstanceId = e2, this.featureIndex = t2, this.sourceLayerIndex = i2, this.bucketIndex = a2, this.tileID = r2;
	      }
	    }
	    class st {
	      constructor(e2) {
	        this.crossSourceCollisions = e2, this.maxGroupID = 0, this.collisionGroups = {};
	      }
	      get(e2) {
	        if (this.crossSourceCollisions) return { ID: 0, predicate: null };
	        if (!this.collisionGroups[e2]) {
	          const t2 = ++this.maxGroupID;
	          this.collisionGroups[e2] = { ID: t2, predicate: (e3) => e3.collisionGroupID === t2 };
	        }
	        return this.collisionGroups[e2];
	      }
	    }
	    function nt(e2, i2, a2, r2, o2) {
	      const { horizontalAlign: s2, verticalAlign: n2 } = t.aR(e2);
	      return new t.P(-(s2 - 0.5) * i2 + r2[0] * o2, -(n2 - 0.5) * a2 + r2[1] * o2);
	    }
	    class lt {
	      constructor(e2, t2, i2, a2, r2) {
	        this.transform = e2.clone(), this.terrain = t2, this.collisionIndex = new tt(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = i2, this.retainedQueryData = {}, this.collisionGroups = new st(a2), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = r2, r2 && (r2.prevPlacement = void 0), this.placedOrientations = {};
	      }
	      _getTerrainElevationFunc(e2) {
	        const t2 = this.terrain;
	        return t2 ? (i2, a2) => t2.getElevation(e2, i2, a2) : null;
	      }
	      getBucketParts(e2, i2, a2, r2) {
	        const o2 = a2.getBucket(i2), s2 = a2.latestFeatureIndex;
	        if (!o2 || !s2 || i2.id !== o2.layerIds[0]) return;
	        const n2 = a2.collisionBoxArray, l2 = o2.layers[0].layout, c2 = o2.layers[0].paint, h2 = Math.pow(2, this.transform.zoom - a2.tileID.overscaledZ), u2 = a2.tileSize / t.a4, d2 = a2.tileID.toUnwrapped(), _2 = "map" === l2.get("text-rotation-alignment"), p2 = t.aM(a2, 1, this.transform.zoom), m2 = t.aN(this.collisionIndex.transform, a2, c2.get("text-translate"), c2.get("text-translate-anchor")), f2 = t.aN(this.collisionIndex.transform, a2, c2.get("icon-translate"), c2.get("icon-translate-anchor")), g2 = Ae(_2, this.transform, p2);
	        this.retainedQueryData[o2.bucketInstanceId] = new ot(o2.bucketInstanceId, s2, o2.sourceLayerIndex, o2.index, a2.tileID);
	        const v2 = { bucket: o2, layout: l2, translationText: m2, translationIcon: f2, unwrappedTileID: d2, pitchedLabelPlaneMatrix: g2, scale: h2, textPixelRatio: u2, holdingForFade: a2.holdingForSymbolFade(), collisionBoxArray: n2, partiallyEvaluatedTextSize: t.ax(o2.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(o2.sourceID) };
	        if (r2) for (const t2 of o2.sortKeyRanges) {
	          const { sortKey: i3, symbolInstanceStart: a3, symbolInstanceEnd: r3 } = t2;
	          e2.push({ sortKey: i3, symbolInstanceStart: a3, symbolInstanceEnd: r3, parameters: v2 });
	        }
	        else e2.push({ symbolInstanceStart: 0, symbolInstanceEnd: o2.symbolInstances.length, parameters: v2 });
	      }
	      attemptAnchorPlacement(e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2, _2, p2, m2, f2, g2, v2, x2, b2) {
	        const y2 = t.aO[e2.textAnchor], w2 = [e2.textOffset0, e2.textOffset1], T2 = nt(y2, a2, r2, w2, o2), P2 = this.collisionIndex.placeCollisionBox(i2, d2, l2, c2, h2, n2, s2, f2, u2.predicate, x2, T2, b2);
	        if ((!v2 || this.collisionIndex.placeCollisionBox(v2, d2, l2, c2, h2, n2, s2, g2, u2.predicate, x2, T2, b2).placeable) && P2.placeable) {
	          let e3;
	          if (this.prevPlacement && this.prevPlacement.variableOffsets[_2.crossTileID] && this.prevPlacement.placements[_2.crossTileID] && this.prevPlacement.placements[_2.crossTileID].text && (e3 = this.prevPlacement.variableOffsets[_2.crossTileID].anchor), 0 === _2.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
	          return this.variableOffsets[_2.crossTileID] = { textOffset: w2, width: a2, height: r2, anchor: y2, textBoxScale: o2, prevAnchor: e3 }, this.markUsedJustification(p2, y2, _2, m2), p2.allowVerticalPlacement && (this.markUsedOrientation(p2, m2, _2), this.placedOrientations[_2.crossTileID] = m2), { shift: T2, placedGlyphBoxes: P2 };
	        }
	      }
	      placeLayerBucketPart(e2, i2, a2) {
	        const { bucket: r2, layout: o2, translationText: s2, translationIcon: n2, unwrappedTileID: l2, pitchedLabelPlaneMatrix: c2, textPixelRatio: h2, holdingForFade: u2, collisionBoxArray: d2, partiallyEvaluatedTextSize: _2, collisionGroup: p2 } = e2.parameters, m2 = o2.get("text-optional"), f2 = o2.get("icon-optional"), g2 = t.aP(o2, "text-overlap", "text-allow-overlap"), v2 = "always" === g2, x2 = t.aP(o2, "icon-overlap", "icon-allow-overlap"), b2 = "always" === x2, y2 = "map" === o2.get("text-rotation-alignment"), w2 = "map" === o2.get("text-pitch-alignment"), T2 = "none" !== o2.get("icon-text-fit"), P2 = "viewport-y" === o2.get("symbol-z-order"), C2 = v2 && (b2 || !r2.hasIconData() || f2), M2 = b2 && (v2 || !r2.hasTextData() || m2);
	        !r2.collisionArrays && d2 && r2.deserializeCollisionBoxes(d2);
	        const I2 = this.retainedQueryData[r2.bucketInstanceId].tileID, E2 = this._getTerrainElevationFunc(I2), S2 = this.transform.getFastPathSimpleProjectionMatrix(I2), R2 = (e3, d3, b3) => {
	          var P3, R3;
	          if (i2[e3.crossTileID]) return;
	          if (u2) return void (this.placements[e3.crossTileID] = new rt(false, false, false));
	          let D2 = false, z2 = false, A2 = true, L2 = null, k2 = { box: null, placeable: false, offscreen: null, occluded: false }, F2 = { placeable: false }, B2 = null, O2 = null, j2 = null, N2 = 0, Z2 = 0, G2 = 0;
	          d3.textFeatureIndex ? N2 = d3.textFeatureIndex : e3.useRuntimeCollisionCircles && (N2 = e3.featureIndex), d3.verticalTextFeatureIndex && (Z2 = d3.verticalTextFeatureIndex);
	          const U2 = d3.textBox;
	          if (U2) {
	            const i3 = (i4) => {
	              let a3 = t.ay.horizontal;
	              if (r2.allowVerticalPlacement && !i4 && this.prevPlacement) {
	                const t2 = this.prevPlacement.placedOrientations[e3.crossTileID];
	                t2 && (this.placedOrientations[e3.crossTileID] = t2, a3 = t2, this.markUsedOrientation(r2, a3, e3));
	              }
	              return a3;
	            }, o3 = (i4, a3) => {
	              if (r2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && d3.verticalTextBox) {
	                for (const e4 of r2.writingModes) if (e4 === t.ay.vertical ? (k2 = a3(), F2 = k2) : k2 = i4(), k2 && k2.placeable) break;
	              } else k2 = i4();
	            }, c3 = e3.textAnchorOffsetStartIndex, u3 = e3.textAnchorOffsetEndIndex;
	            if (u3 === c3) {
	              const a3 = (t2, i4) => {
	                const a4 = this.collisionIndex.placeCollisionBox(t2, g2, h2, I2, l2, w2, y2, s2, p2.predicate, E2, void 0, S2);
	                return a4 && a4.placeable && (this.markUsedOrientation(r2, i4, e3), this.placedOrientations[e3.crossTileID] = i4), a4;
	              };
	              o3(() => a3(U2, t.ay.horizontal), () => {
	                const i4 = d3.verticalTextBox;
	                return r2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && i4 ? a3(i4, t.ay.vertical) : { box: null, offscreen: null };
	              }), i3(k2 && k2.placeable);
	            } else {
	              let _3 = t.aO[null === (R3 = null === (P3 = this.prevPlacement) || void 0 === P3 ? void 0 : P3.variableOffsets[e3.crossTileID]) || void 0 === R3 ? void 0 : R3.anchor];
	              const m3 = (t2, i4, o4) => {
	                const d4 = t2.x2 - t2.x1, m4 = t2.y2 - t2.y1, f4 = e3.textBoxScale, v3 = T2 && "never" === x2 ? i4 : null;
	                let b4 = null, P4 = "never" === g2 ? 1 : 2, C3 = "never";
	                _3 && P4++;
	                for (let i5 = 0; i5 < P4; i5++) {
	                  for (let i6 = c3; i6 < u3; i6++) {
	                    const a3 = r2.textAnchorOffsets.get(i6);
	                    if (_3 && a3.textAnchor !== _3) continue;
	                    const c4 = this.attemptAnchorPlacement(a3, t2, d4, m4, f4, y2, w2, h2, I2, l2, p2, C3, e3, r2, o4, s2, n2, v3, E2);
	                    if (c4 && (b4 = c4.placedGlyphBoxes, b4 && b4.placeable)) return D2 = true, L2 = c4.shift, b4;
	                  }
	                  _3 ? _3 = null : C3 = g2;
	                }
	                return a2 && !b4 && (b4 = { box: this.collisionIndex.placeCollisionBox(U2, "always", h2, I2, l2, w2, y2, s2, p2.predicate, E2, void 0, S2).box, offscreen: false, placeable: false, occluded: false }), b4;
	              };
	              o3(() => m3(U2, d3.iconBox, t.ay.horizontal), () => {
	                const i4 = d3.verticalTextBox;
	                return r2.allowVerticalPlacement && (!k2 || !k2.placeable) && e3.numVerticalGlyphVertices > 0 && i4 ? m3(i4, d3.verticalIconBox, t.ay.vertical) : { box: null, occluded: true, offscreen: null };
	              }), k2 && (D2 = k2.placeable, A2 = k2.offscreen);
	              const f3 = i3(k2 && k2.placeable);
	              if (!D2 && this.prevPlacement) {
	                const t2 = this.prevPlacement.variableOffsets[e3.crossTileID];
	                t2 && (this.variableOffsets[e3.crossTileID] = t2, this.markUsedJustification(r2, t2.anchor, e3, f3));
	              }
	            }
	          }
	          if (B2 = k2, D2 = B2 && B2.placeable, A2 = B2 && B2.offscreen, e3.useRuntimeCollisionCircles && e3.centerJustifiedTextSymbolIndex >= 0) {
	            const i3 = r2.text.placedSymbolArray.get(e3.centerJustifiedTextSymbolIndex), n3 = t.az(r2.textSizeData, _2, i3), h3 = o2.get("text-padding");
	            O2 = this.collisionIndex.placeCollisionCircles(g2, i3, r2.lineVertexArray, r2.glyphOffsetArray, n3, l2, c2, a2, w2, p2.predicate, e3.collisionCircleDiameter, h3, s2, E2), O2.circles.length && O2.collisionDetected && !a2 && t.w("Collisions detected, but collision boxes are not shown"), D2 = v2 || O2.circles.length > 0 && !O2.collisionDetected, A2 = A2 && O2.offscreen;
	          }
	          if (d3.iconFeatureIndex && (G2 = d3.iconFeatureIndex), d3.iconBox) {
	            const e4 = (e5) => this.collisionIndex.placeCollisionBox(e5, x2, h2, I2, l2, w2, y2, n2, p2.predicate, E2, T2 && L2 ? L2 : void 0, S2);
	            F2 && F2.placeable && d3.verticalIconBox ? (j2 = e4(d3.verticalIconBox), z2 = j2.placeable) : (j2 = e4(d3.iconBox), z2 = j2.placeable), A2 = A2 && j2.offscreen;
	          }
	          const V2 = m2 || 0 === e3.numHorizontalGlyphVertices && 0 === e3.numVerticalGlyphVertices, q2 = f2 || 0 === e3.numIconVertices;
	          V2 || q2 ? q2 ? V2 || (z2 = z2 && D2) : D2 = z2 && D2 : z2 = D2 = z2 && D2;
	          const W2 = z2 && j2.placeable;
	          if (D2 && B2.placeable && this.collisionIndex.insertCollisionBox(B2.box, g2, o2.get("text-ignore-placement"), r2.bucketInstanceId, F2 && F2.placeable && Z2 ? Z2 : N2, p2.ID), W2 && this.collisionIndex.insertCollisionBox(j2.box, x2, o2.get("icon-ignore-placement"), r2.bucketInstanceId, G2, p2.ID), O2 && D2 && this.collisionIndex.insertCollisionCircles(O2.circles, g2, o2.get("text-ignore-placement"), r2.bucketInstanceId, N2, p2.ID), a2 && this.storeCollisionData(r2.bucketInstanceId, b3, d3, B2, j2, O2), 0 === e3.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
	          if (0 === r2.bucketInstanceId) throw new Error("bucket.bucketInstanceId can't be 0");
	          this.placements[e3.crossTileID] = new rt((D2 || C2) && !(null == B2 ? void 0 : B2.occluded), (z2 || M2) && !(null == j2 ? void 0 : j2.occluded), A2 || r2.justReloaded), i2[e3.crossTileID] = true;
	        };
	        if (P2) {
	          if (0 !== e2.symbolInstanceStart) throw new Error("bucket.bucketInstanceId should be 0");
	          const t2 = r2.getSortedSymbolIndexes(-this.transform.bearingInRadians);
	          for (let e3 = t2.length - 1; e3 >= 0; --e3) {
	            const i3 = t2[e3];
	            R2(r2.symbolInstances.get(i3), r2.collisionArrays[i3], i3);
	          }
	        } else for (let t2 = e2.symbolInstanceStart; t2 < e2.symbolInstanceEnd; t2++) R2(r2.symbolInstances.get(t2), r2.collisionArrays[t2], t2);
	        r2.justReloaded = false;
	      }
	      storeCollisionData(e2, t2, i2, a2, r2, o2) {
	        if (i2.textBox || i2.iconBox) {
	          let o3, s2;
	          this.collisionBoxArrays.has(e2) ? o3 = this.collisionBoxArrays.get(e2) : (o3 = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e2, o3)), o3.has(t2) ? s2 = o3.get(t2) : (s2 = { text: null, icon: null }, o3.set(t2, s2)), i2.textBox && (s2.text = a2.box), i2.iconBox && (s2.icon = r2.box);
	        }
	        if (o2) {
	          let t3 = this.collisionCircleArrays[e2];
	          void 0 === t3 && (t3 = this.collisionCircleArrays[e2] = []);
	          for (let e3 = 0; e3 < o2.circles.length; e3 += 4) t3.push(o2.circles[e3 + 0] - et), t3.push(o2.circles[e3 + 1] - et), t3.push(o2.circles[e3 + 2]), t3.push(o2.collisionDetected ? 1 : 0);
	        }
	      }
	      markUsedJustification(e2, i2, a2, r2) {
	        let o2;
	        o2 = r2 === t.ay.vertical ? a2.verticalPlacedTextSymbolIndex : { left: a2.leftJustifiedTextSymbolIndex, center: a2.centerJustifiedTextSymbolIndex, right: a2.rightJustifiedTextSymbolIndex }[t.aQ(i2)];
	        const s2 = [a2.leftJustifiedTextSymbolIndex, a2.centerJustifiedTextSymbolIndex, a2.rightJustifiedTextSymbolIndex, a2.verticalPlacedTextSymbolIndex];
	        for (const t2 of s2) t2 >= 0 && (e2.text.placedSymbolArray.get(t2).crossTileID = o2 >= 0 && t2 !== o2 ? 0 : a2.crossTileID);
	      }
	      markUsedOrientation(e2, i2, a2) {
	        const r2 = i2 === t.ay.horizontal || i2 === t.ay.horizontalOnly ? i2 : 0, o2 = i2 === t.ay.vertical ? i2 : 0, s2 = [a2.leftJustifiedTextSymbolIndex, a2.centerJustifiedTextSymbolIndex, a2.rightJustifiedTextSymbolIndex];
	        for (const t2 of s2) e2.text.placedSymbolArray.get(t2).placedOrientation = r2;
	        a2.verticalPlacedTextSymbolIndex && (e2.text.placedSymbolArray.get(a2.verticalPlacedTextSymbolIndex).placedOrientation = o2);
	      }
	      commit(e2) {
	        this.commitTime = e2, this.zoomAtLastRecencyCheck = this.transform.zoom;
	        const t2 = this.prevPlacement;
	        let i2 = false;
	        this.prevZoomAdjustment = t2 ? t2.zoomAdjustment(this.transform.zoom) : 0;
	        const a2 = t2 ? t2.symbolFadeChange(e2) : 1, r2 = t2 ? t2.opacities : {}, o2 = t2 ? t2.variableOffsets : {}, s2 = t2 ? t2.placedOrientations : {};
	        for (const e3 in this.placements) {
	          const t3 = this.placements[e3], o3 = r2[e3];
	          o3 ? (this.opacities[e3] = new at(o3, a2, t3.text, t3.icon), i2 = i2 || t3.text !== o3.text.placed || t3.icon !== o3.icon.placed) : (this.opacities[e3] = new at(null, a2, t3.text, t3.icon, t3.skipFade), i2 = i2 || t3.text || t3.icon);
	        }
	        for (const e3 in r2) {
	          const t3 = r2[e3];
	          if (!this.opacities[e3]) {
	            const r3 = new at(t3, a2, false, false);
	            r3.isHidden() || (this.opacities[e3] = r3, i2 = i2 || t3.text.placed || t3.icon.placed);
	          }
	        }
	        for (const e3 in o2) this.variableOffsets[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.variableOffsets[e3] = o2[e3]);
	        for (const e3 in s2) this.placedOrientations[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.placedOrientations[e3] = s2[e3]);
	        if (t2 && void 0 === t2.lastPlacementChangeTime) throw new Error("Last placement time for previous placement is not defined");
	        i2 ? this.lastPlacementChangeTime = e2 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t2 ? t2.lastPlacementChangeTime : e2);
	      }
	      updateLayerOpacities(e2, t2) {
	        const i2 = {};
	        for (const a2 of t2) {
	          const t3 = a2.getBucket(e2);
	          t3 && a2.latestFeatureIndex && e2.id === t3.layerIds[0] && this.updateBucketOpacities(t3, a2.tileID, i2, a2.collisionBoxArray);
	        }
	      }
	      updateBucketOpacities(e2, i2, a2, r2) {
	        e2.hasTextData() && (e2.text.opacityVertexArray.clear(), e2.text.hasVisibleVertices = false), e2.hasIconData() && (e2.icon.opacityVertexArray.clear(), e2.icon.hasVisibleVertices = false), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexArray.clear(), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexArray.clear();
	        const o2 = e2.layers[0], s2 = o2.layout, n2 = new at(null, 0, false, false, true), l2 = s2.get("text-allow-overlap"), c2 = s2.get("icon-allow-overlap"), h2 = o2._unevaluatedLayout.hasValue("text-variable-anchor") || o2._unevaluatedLayout.hasValue("text-variable-anchor-offset"), u2 = "map" === s2.get("text-rotation-alignment"), d2 = "map" === s2.get("text-pitch-alignment"), _2 = "none" !== s2.get("icon-text-fit"), p2 = new at(null, 0, l2 && (c2 || !e2.hasIconData() || s2.get("icon-optional")), c2 && (l2 || !e2.hasTextData() || s2.get("text-optional")), true);
	        !e2.collisionArrays && r2 && (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) && e2.deserializeCollisionBoxes(r2);
	        const m2 = (e3, t2, i3) => {
	          for (let a3 = 0; a3 < t2 / 4; a3++) e3.opacityVertexArray.emplaceBack(i3);
	          e3.hasVisibleVertices = e3.hasVisibleVertices || i3 !== vt;
	        }, f2 = this.collisionBoxArrays.get(e2.bucketInstanceId);
	        for (let i3 = 0; i3 < e2.symbolInstances.length; i3++) {
	          const r3 = e2.symbolInstances.get(i3), { numHorizontalGlyphVertices: o3, numVerticalGlyphVertices: s3, crossTileID: l3 } = r3;
	          let c3 = this.opacities[l3];
	          a2[l3] ? c3 = n2 : c3 || (c3 = p2, this.opacities[l3] = c3), a2[l3] = true;
	          const g2 = r3.numIconVertices > 0, v2 = this.placedOrientations[r3.crossTileID], x2 = v2 === t.ay.vertical, b2 = v2 === t.ay.horizontal || v2 === t.ay.horizontalOnly;
	          if (o3 > 0 || s3 > 0) {
	            const t2 = gt(c3.text);
	            m2(e2.text, o3, x2 ? vt : t2), m2(e2.text, s3, b2 ? vt : t2);
	            const i4 = c3.text.isHidden();
	            [r3.rightJustifiedTextSymbolIndex, r3.centerJustifiedTextSymbolIndex, r3.leftJustifiedTextSymbolIndex].forEach((t3) => {
	              t3 >= 0 && (e2.text.placedSymbolArray.get(t3).hidden = i4 || x2 ? 1 : 0);
	            }), r3.verticalPlacedTextSymbolIndex >= 0 && (e2.text.placedSymbolArray.get(r3.verticalPlacedTextSymbolIndex).hidden = i4 || b2 ? 1 : 0);
	            const a3 = this.variableOffsets[r3.crossTileID];
	            a3 && this.markUsedJustification(e2, a3.anchor, r3, v2);
	            const n3 = this.placedOrientations[r3.crossTileID];
	            n3 && (this.markUsedJustification(e2, "left", r3, n3), this.markUsedOrientation(e2, n3, r3));
	          }
	          if (g2) {
	            const t2 = gt(c3.icon), i4 = !(_2 && r3.verticalPlacedIconSymbolIndex && x2);
	            r3.placedIconSymbolIndex >= 0 && (m2(e2.icon, r3.numIconVertices, i4 ? t2 : vt), e2.icon.placedSymbolArray.get(r3.placedIconSymbolIndex).hidden = c3.icon.isHidden()), r3.verticalPlacedIconSymbolIndex >= 0 && (m2(e2.icon, r3.numVerticalIconVertices, i4 ? vt : t2), e2.icon.placedSymbolArray.get(r3.verticalPlacedIconSymbolIndex).hidden = c3.icon.isHidden());
	          }
	          const y2 = f2 && f2.has(i3) ? f2.get(i3) : { text: null, icon: null };
	          if (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) {
	            const a3 = e2.collisionArrays[i3];
	            if (a3) {
	              let i4 = new t.P(0, 0);
	              if (a3.textBox || a3.verticalTextBox) {
	                let t2 = true;
	                if (h2) {
	                  const e3 = this.variableOffsets[l3];
	                  e3 ? (i4 = nt(e3.anchor, e3.width, e3.height, e3.textOffset, e3.textBoxScale), u2 && i4._rotate(d2 ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : t2 = false;
	                }
	                if (a3.textBox || a3.verticalTextBox) {
	                  let r4;
	                  a3.textBox && (r4 = x2), a3.verticalTextBox && (r4 = b2), ct(e2.textCollisionBox.collisionVertexArray, c3.text.placed, !t2 || r4, y2.text, i4.x, i4.y);
	                }
	              }
	              if (a3.iconBox || a3.verticalIconBox) {
	                const t2 = Boolean(!b2 && a3.verticalIconBox);
	                let r4;
	                a3.iconBox && (r4 = t2), a3.verticalIconBox && (r4 = !t2), ct(e2.iconCollisionBox.collisionVertexArray, c3.icon.placed, r4, y2.icon, _2 ? i4.x : 0, _2 ? i4.y : 0);
	              }
	            }
	          }
	        }
	        if (e2.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e2.bucketInstanceId] && (this.retainedQueryData[e2.bucketInstanceId].featureSortOrder = e2.featureSortOrder), e2.hasTextData() && e2.text.opacityVertexBuffer && e2.text.opacityVertexBuffer.updateData(e2.text.opacityVertexArray), e2.hasIconData() && e2.icon.opacityVertexBuffer && e2.icon.opacityVertexBuffer.updateData(e2.icon.opacityVertexArray), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexBuffer && e2.iconCollisionBox.collisionVertexBuffer.updateData(e2.iconCollisionBox.collisionVertexArray), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexBuffer && e2.textCollisionBox.collisionVertexBuffer.updateData(e2.textCollisionBox.collisionVertexArray), e2.text.opacityVertexArray.length !== e2.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e2.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e2.text.layoutVertexArray.length}) / 4`);
	        if (e2.icon.opacityVertexArray.length !== e2.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e2.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e2.icon.layoutVertexArray.length}) / 4`);
	        e2.bucketInstanceId in this.collisionCircleArrays && (e2.collisionCircleArray = this.collisionCircleArrays[e2.bucketInstanceId], delete this.collisionCircleArrays[e2.bucketInstanceId]);
	      }
	      symbolFadeChange(e2) {
	        return 0 === this.fadeDuration ? 1 : (e2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
	      }
	      zoomAdjustment(e2) {
	        return Math.max(0, (this.transform.zoom - e2) / 1.5);
	      }
	      hasTransitions(e2) {
	        return this.stale || e2 - this.lastPlacementChangeTime < this.fadeDuration;
	      }
	      stillRecent(e2, t2) {
	        const i2 = this.zoomAtLastRecencyCheck === t2 ? 1 - this.zoomAdjustment(t2) : 1;
	        return this.zoomAtLastRecencyCheck = t2, this.commitTime + this.fadeDuration * i2 > e2;
	      }
	      setStale() {
	        this.stale = true;
	      }
	    }
	    function ct(e2, t2, i2, a2, r2, o2) {
	      a2 && 0 !== a2.length || (a2 = [0, 0, 0, 0]);
	      const s2 = a2[0] - et, n2 = a2[1] - et, l2 = a2[2] - et, c2 = a2[3] - et;
	      e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, o2 || 0, s2, n2), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, o2 || 0, l2, n2), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, o2 || 0, l2, c2), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, o2 || 0, s2, c2);
	    }
	    const ht = Math.pow(2, 25), ut = Math.pow(2, 24), dt = Math.pow(2, 17), _t = Math.pow(2, 16), pt = Math.pow(2, 9), mt = Math.pow(2, 8), ft = Math.pow(2, 1);
	    function gt(e2) {
	      if (0 === e2.opacity && !e2.placed) return 0;
	      if (1 === e2.opacity && e2.placed) return 4294967295;
	      const t2 = e2.placed ? 1 : 0, i2 = Math.floor(127 * e2.opacity);
	      return i2 * ht + t2 * ut + i2 * dt + t2 * _t + i2 * pt + t2 * mt + i2 * ft + t2;
	    }
	    const vt = 0;
	    class xt {
	      constructor(e2) {
	        this._sortAcrossTiles = "viewport-y" !== e2.layout.get("symbol-z-order") && !e2.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
	      }
	      continuePlacement(e2, t2, i2, a2, r2) {
	        const o2 = this._bucketParts;
	        for (; this._currentTileIndex < e2.length; ) if (t2.getBucketParts(o2, a2, e2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r2()) return true;
	        for (this._sortAcrossTiles && (this._sortAcrossTiles = false, o2.sort((e3, t3) => e3.sortKey - t3.sortKey)); this._currentPartIndex < o2.length; ) if (t2.placeLayerBucketPart(o2[this._currentPartIndex], this._seenCrossTileIDs, i2), this._currentPartIndex++, r2()) return true;
	        return false;
	      }
	    }
	    class bt {
	      constructor(e2, t2, i2, a2, r2, o2, s2, n2) {
	        this.placement = new lt(e2, t2, o2, s2, n2), this._currentPlacementIndex = i2.length - 1, this._forceFullPlacement = a2, this._showCollisionBoxes = r2, this._done = false;
	      }
	      isDone() {
	        return this._done;
	      }
	      continuePlacement(e2, t2, i2) {
	        const a2 = c(), r2 = () => !this._forceFullPlacement && c() - a2 > 2;
	        for (; this._currentPlacementIndex >= 0; ) {
	          const a3 = t2[e2[this._currentPlacementIndex]], o2 = this.placement.collisionIndex.transform.zoom;
	          if ("symbol" === a3.type && (!a3.minzoom || a3.minzoom <= o2) && (!a3.maxzoom || a3.maxzoom > o2)) {
	            if (this._inProgressLayer || (this._inProgressLayer = new xt(a3)), this._inProgressLayer.continuePlacement(i2[a3.source], this.placement, this._showCollisionBoxes, a3, r2)) return;
	            delete this._inProgressLayer;
	          }
	          this._currentPlacementIndex--;
	        }
	        this._done = true;
	      }
	      commit(e2) {
	        return this.placement.commit(e2), this.placement;
	      }
	    }
	    const yt = 512 / t.a4 / 2;
	    class wt {
	      constructor(e2, i2, a2) {
	        this.tileID = e2, this.bucketInstanceId = a2, this._symbolsByKey = {};
	        const r2 = /* @__PURE__ */ new Map();
	        for (let e3 = 0; e3 < i2.length; e3++) {
	          const t2 = i2.get(e3), a3 = t2.key, o2 = r2.get(a3);
	          o2 ? o2.push(t2) : r2.set(a3, [t2]);
	        }
	        for (const [e3, i3] of r2) {
	          const a3 = { positions: i3.map((e4) => ({ x: Math.floor(e4.anchorX * yt), y: Math.floor(e4.anchorY * yt) })), crossTileIDs: i3.map((e4) => e4.crossTileID) };
	          if (a3.positions.length > 128) {
	            const e4 = new t.aS(a3.positions.length, 16, Uint16Array);
	            for (const { x: t2, y: i4 } of a3.positions) e4.add(t2, i4);
	            e4.finish(), delete a3.positions, a3.index = e4;
	          }
	          this._symbolsByKey[e3] = a3;
	        }
	      }
	      getScaledCoordinates(e2, i2) {
	        const { x: a2, y: r2, z: o2 } = this.tileID.canonical, { x: s2, y: n2, z: l2 } = i2.canonical, c2 = yt / Math.pow(2, l2 - o2), h2 = (n2 * t.a4 + e2.anchorY) * c2, u2 = r2 * t.a4 * yt;
	        return { x: Math.floor((s2 * t.a4 + e2.anchorX) * c2 - a2 * t.a4 * yt), y: Math.floor(h2 - u2) };
	      }
	      findMatches(e2, t2, i2) {
	        const a2 = this.tileID.canonical.z < t2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t2.canonical.z);
	        for (let r2 = 0; r2 < e2.length; r2++) {
	          const o2 = e2.get(r2);
	          if (o2.crossTileID) continue;
	          const s2 = this._symbolsByKey[o2.key];
	          if (!s2) continue;
	          const n2 = this.getScaledCoordinates(o2, t2);
	          if (s2.index) {
	            const e3 = s2.index.range(n2.x - a2, n2.y - a2, n2.x + a2, n2.y + a2).sort();
	            for (const t3 of e3) {
	              const e4 = s2.crossTileIDs[t3];
	              if (!i2[e4]) {
	                i2[e4] = true, o2.crossTileID = e4;
	                break;
	              }
	            }
	          } else if (s2.positions) for (let e3 = 0; e3 < s2.positions.length; e3++) {
	            const t3 = s2.positions[e3], r3 = s2.crossTileIDs[e3];
	            if (Math.abs(t3.x - n2.x) <= a2 && Math.abs(t3.y - n2.y) <= a2 && !i2[r3]) {
	              i2[r3] = true, o2.crossTileID = r3;
	              break;
	            }
	          }
	        }
	      }
	      getCrossTileIDsLists() {
	        return Object.values(this._symbolsByKey).map(({ crossTileIDs: e2 }) => e2);
	      }
	    }
	    class Tt {
	      constructor() {
	        this.maxCrossTileID = 0;
	      }
	      generate() {
	        return ++this.maxCrossTileID;
	      }
	    }
	    class Pt {
	      constructor() {
	        this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
	      }
	      handleWrapJump(e2) {
	        const t2 = Math.round((e2 - this.lng) / 360);
	        if (0 !== t2) for (const e3 in this.indexes) {
	          const i2 = this.indexes[e3], a2 = {};
	          for (const e4 in i2) {
	            const r2 = i2[e4];
	            r2.tileID = r2.tileID.unwrapTo(r2.tileID.wrap + t2), a2[r2.tileID.key] = r2;
	          }
	          this.indexes[e3] = a2;
	        }
	        this.lng = e2;
	      }
	      addBucket(e2, t2, i2) {
	        if (this.indexes[e2.overscaledZ] && this.indexes[e2.overscaledZ][e2.key]) {
	          if (this.indexes[e2.overscaledZ][e2.key].bucketInstanceId === t2.bucketInstanceId) return false;
	          this.removeBucketCrossTileIDs(e2.overscaledZ, this.indexes[e2.overscaledZ][e2.key]);
	        }
	        for (let e3 = 0; e3 < t2.symbolInstances.length; e3++) t2.symbolInstances.get(e3).crossTileID = 0;
	        this.usedCrossTileIDs[e2.overscaledZ] || (this.usedCrossTileIDs[e2.overscaledZ] = {});
	        const a2 = this.usedCrossTileIDs[e2.overscaledZ];
	        for (const i3 in this.indexes) {
	          const r2 = this.indexes[i3];
	          if (Number(i3) > e2.overscaledZ) for (const i4 in r2) {
	            const o2 = r2[i4];
	            o2.tileID.isChildOf(e2) && o2.findMatches(t2.symbolInstances, e2, a2);
	          }
	          else {
	            const o2 = r2[e2.scaledTo(Number(i3)).key];
	            o2 && o2.findMatches(t2.symbolInstances, e2, a2);
	          }
	        }
	        for (let e3 = 0; e3 < t2.symbolInstances.length; e3++) {
	          const r2 = t2.symbolInstances.get(e3);
	          r2.crossTileID || (r2.crossTileID = i2.generate(), a2[r2.crossTileID] = true);
	        }
	        return void 0 === this.indexes[e2.overscaledZ] && (this.indexes[e2.overscaledZ] = {}), this.indexes[e2.overscaledZ][e2.key] = new wt(e2, t2.symbolInstances, t2.bucketInstanceId), true;
	      }
	      removeBucketCrossTileIDs(e2, t2) {
	        for (const i2 of t2.getCrossTileIDsLists()) for (const t3 of i2) delete this.usedCrossTileIDs[e2][t3];
	      }
	      removeStaleBuckets(e2) {
	        let t2 = false;
	        for (const i2 in this.indexes) {
	          const a2 = this.indexes[i2];
	          for (const r2 in a2) e2[a2[r2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, a2[r2]), delete a2[r2], t2 = true);
	        }
	        return t2;
	      }
	    }
	    class Ct {
	      constructor() {
	        this.layerIndexes = {}, this.crossTileIDs = new Tt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
	      }
	      addLayer(e2, t2, i2) {
	        let a2 = this.layerIndexes[e2.id];
	        void 0 === a2 && (a2 = this.layerIndexes[e2.id] = new Pt());
	        let r2 = false;
	        const o2 = {};
	        a2.handleWrapJump(i2);
	        for (const i3 of t2) {
	          const t3 = i3.getBucket(e2);
	          t3 && e2.id === t3.layerIds[0] && (t3.bucketInstanceId || (t3.bucketInstanceId = ++this.maxBucketInstanceId), a2.addBucket(i3.tileID, t3, this.crossTileIDs) && (r2 = true), o2[t3.bucketInstanceId] = true);
	        }
	        return a2.removeStaleBuckets(o2) && (r2 = true), r2;
	      }
	      pruneUnusedLayers(e2) {
	        const t2 = {};
	        e2.forEach((e3) => {
	          t2[e3] = true;
	        });
	        for (const e3 in this.layerIndexes) t2[e3] || delete this.layerIndexes[e3];
	      }
	    }
	    var Mt = "void main() {fragColor=vec4(1.0);}";
	    const It = { prelude: Et("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nout highp vec4 fragColor;", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c\n);}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\n#ifdef GLOBE\nif ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}\n#endif\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;"), projectionMercator: Et("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: Et("", "#define GLOBE_RADIUS 6371008.8\nuniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos\n);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); \nif (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len\n);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}"), background: Et("uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: Et("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Et("in vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {\n#ifdef GLOBE\nvec3 center_vector=projectToSphere(circle_center);\n#endif\nfloat angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {\n#ifdef GLOBE\nvec4 projected_center=interpolateProjection(circle_center,center_vector,ele);\n#else\nvec4 projected_center=projectTileWithElevation(circle_center,ele);\n#endif\ncorner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}\n#ifdef GLOBE\nvec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);\n#else\ngl_Position=projectTileWithElevation(corner_position,ele);\n#endif\n} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), clippingMask: Et(Mt, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: Et("uniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);\n#ifdef GLOBE\nvec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);\n#else\ngl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));\n#endif\n}"), heatmapTexture: Et("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Et("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Et("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), colorRelief: Et("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else\n{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), debug: Et("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: Et(Mt, "in vec2 a_pos;void main() {\n#ifdef GLOBE\ngl_Position=projectTileFor3D(a_pos,0.0);\n#else\ngl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);\n#endif\n}"), fill: Et("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nfragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_fill_translate;in vec2 a_pos;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);}"), fillOutline: Et("in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"), fillOutlinePattern: Et("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"), fillPattern: Et("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), fillExtrusion: Et("in vec4 v_color;void main() {fragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\nout vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nfloat colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);\n#ifdef GLOBE\nmat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);\n#endif\ndirectional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), fillExtrusionPattern: Et("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\n#ifdef GLOBE\nout vec3 v_sphere_pos;\n#endif\nout vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nvec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), hillshadePrepare: Et("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Et("uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];\n#define PI 3.141592653589793\n#define STANDARD 0\n#define COMBINED 1\n#define IGOR 2\n#define MULTIDIRECTIONAL 3\n#define BASIC 4\nfloat get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else\n{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else\n{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: Et("uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), lineGradient: Et("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), linePattern: Et("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), lineSDF: Et("uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nfloat u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}"), lineGradientSDF: Et("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nfloat u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}"), raster: Et("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;\n#ifdef GLOBE\nif (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}\n#endif\nv_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: Et("uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"), symbolSDF: Et("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), symbolTextAndIcon: Et("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"), terrain: Et("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Et("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Et("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: Et("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: Et("in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758\n);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}", "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: Et("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
	    function Et(e2, t2) {
	      const i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, a2 = t2.match(/in ([\w]+) ([\w]+)/g), r2 = e2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o2 = t2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), s2 = o2 ? o2.concat(r2) : r2, n2 = {};
	      return { fragmentSource: e2 = e2.replace(i2, (e3, t3, i3, a3, r3) => (n2[r3] = true, "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${r3}
in ${i3} ${a3} ${r3};
#else
uniform ${i3} ${a3} u_${r3};
#endif
` : `
#ifdef HAS_UNIFORM_u_${r3}
    ${i3} ${a3} ${r3} = u_${r3};
#endif
`)), vertexSource: t2 = t2.replace(i2, (e3, t3, i3, a3, r3) => {
	        const o3 = "float" === a3 ? "vec2" : "vec4", s3 = r3.match(/color/) ? "color" : o3;
	        return n2[r3] ? "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${r3}
uniform lowp float u_${r3}_t;
in ${i3} ${o3} a_${r3};
out ${i3} ${a3} ${r3};
#else
uniform ${i3} ${a3} u_${r3};
#endif
` : "vec4" === s3 ? `
#ifndef HAS_UNIFORM_u_${r3}
    ${r3} = a_${r3};
#else
    ${i3} ${a3} ${r3} = u_${r3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${r3}
    ${r3} = unpack_mix_${s3}(a_${r3}, u_${r3}_t);
#else
    ${i3} ${a3} ${r3} = u_${r3};
#endif
` : "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${r3}
uniform lowp float u_${r3}_t;
in ${i3} ${o3} a_${r3};
#else
uniform ${i3} ${a3} u_${r3};
#endif
` : "vec4" === s3 ? `
#ifndef HAS_UNIFORM_u_${r3}
    ${i3} ${a3} ${r3} = a_${r3};
#else
    ${i3} ${a3} ${r3} = u_${r3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${r3}
    ${i3} ${a3} ${r3} = unpack_mix_${s3}(a_${r3}, u_${r3}_t);
#else
    ${i3} ${a3} ${r3} = u_${r3};
#endif
`;
	      }), staticAttributes: a2, staticUniforms: s2 };
	    }
	    class St {
	      constructor(e2, t2, i2) {
	        this.vertexBuffer = e2, this.indexBuffer = t2, this.segments = i2;
	      }
	      destroy() {
	        this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
	      }
	    }
	    var Rt = t.aT([{ name: "a_pos", type: "Int16", components: 2 }]);
	    const Dt = "#define PROJECTION_MERCATOR", zt = "mercator";
	    class At {
	      constructor() {
	        this._cachedMesh = null;
	      }
	      get name() {
	        return "mercator";
	      }
	      get useSubdivision() {
	        return false;
	      }
	      get shaderVariantName() {
	        return zt;
	      }
	      get shaderDefine() {
	        return Dt;
	      }
	      get shaderPreludeCode() {
	        return It.projectionMercator;
	      }
	      get vertexShaderPreludeCode() {
	        return It.projectionMercator.vertexSource;
	      }
	      get subdivisionGranularity() {
	        return t.aU.noSubdivision;
	      }
	      get useGlobeControls() {
	        return false;
	      }
	      get transitionState() {
	        return 0;
	      }
	      get latitudeErrorCorrectionRadians() {
	        return 0;
	      }
	      destroy() {
	      }
	      updateGPUdependent(e2) {
	      }
	      getMeshFromTileID(e2, i2, a2, r2, o2) {
	        if (this._cachedMesh) return this._cachedMesh;
	        const s2 = new t.aV();
	        s2.emplaceBack(0, 0), s2.emplaceBack(t.a4, 0), s2.emplaceBack(0, t.a4), s2.emplaceBack(t.a4, t.a4);
	        const n2 = e2.createVertexBuffer(s2, Rt.members), l2 = t.aW.simpleSegment(0, 0, 4, 2), c2 = new t.aX();
	        c2.emplaceBack(1, 0, 2), c2.emplaceBack(1, 2, 3);
	        const h2 = e2.createIndexBuffer(c2);
	        return this._cachedMesh = new St(n2, h2, l2), this._cachedMesh;
	      }
	      recalculate() {
	      }
	      hasTransition() {
	        return false;
	      }
	      setErrorQueryLatitudeDegrees(e2) {
	      }
	    }
	    class Lt {
	      constructor(e2 = 0, t2 = 0, i2 = 0, a2 = 0) {
	        if (isNaN(e2) || e2 < 0 || isNaN(t2) || t2 < 0 || isNaN(i2) || i2 < 0 || isNaN(a2) || a2 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
	        this.top = e2, this.bottom = t2, this.left = i2, this.right = a2;
	      }
	      interpolate(e2, i2, a2) {
	        return null != i2.top && null != e2.top && (this.top = t.G.number(e2.top, i2.top, a2)), null != i2.bottom && null != e2.bottom && (this.bottom = t.G.number(e2.bottom, i2.bottom, a2)), null != i2.left && null != e2.left && (this.left = t.G.number(e2.left, i2.left, a2)), null != i2.right && null != e2.right && (this.right = t.G.number(e2.right, i2.right, a2)), this;
	      }
	      getCenter(e2, i2) {
	        const a2 = t.an((this.left + e2 - this.right) / 2, 0, e2), r2 = t.an((this.top + i2 - this.bottom) / 2, 0, i2);
	        return new t.P(a2, r2);
	      }
	      equals(e2) {
	        return this.top === e2.top && this.bottom === e2.bottom && this.left === e2.left && this.right === e2.right;
	      }
	      clone() {
	        return new Lt(this.top, this.bottom, this.left, this.right);
	      }
	      toJSON() {
	        return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
	      }
	    }
	    function kt(e2, t2) {
	      if (!e2.renderWorldCopies || e2.lngRange) return;
	      const i2 = t2.lng - e2.center.lng;
	      t2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
	    }
	    function Ft(e2) {
	      return Math.max(0, Math.floor(e2));
	    }
	    class Bt {
	      constructor(e2, i2) {
	        var a2;
	        this.applyConstrain = (e3, t2) => null !== this._constrainOverride ? this._constrainOverride(e3, t2) : this._callbacks.defaultConstrain(e3, t2), this._callbacks = e2, this._tileSize = 512, this._renderWorldCopies = void 0 === (null == i2 ? void 0 : i2.renderWorldCopies) || !!(null == i2 ? void 0 : i2.renderWorldCopies), this._minZoom = (null == i2 ? void 0 : i2.minZoom) || 0, this._maxZoom = (null == i2 ? void 0 : i2.maxZoom) || 22, this._minPitch = null == (null == i2 ? void 0 : i2.minPitch) ? 0 : null == i2 ? void 0 : i2.minPitch, this._maxPitch = null == (null == i2 ? void 0 : i2.maxPitch) ? 60 : null == i2 ? void 0 : i2.maxPitch, this._constrainOverride = null !== (a2 = null == i2 ? void 0 : i2.constrainOverride) && void 0 !== a2 ? a2 : null, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new t.V(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Ft(this._zoom), this._scale = t.aq(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = true, this._edgeInsets = new Lt(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = true;
	      }
	      apply(e2, i2, a2) {
	        this._constrainOverride = e2.constrainOverride, this._latRange = e2.latRange, this._lngRange = e2.lngRange, this._width = e2.width, this._height = e2.height, this._center = e2.center, this._elevation = e2.elevation, this._minElevationForCurrentTile = e2.minElevationForCurrentTile, this._zoom = e2.zoom, this._tileZoom = Ft(this._zoom), this._scale = t.aq(this._zoom), this._bearingInRadians = e2.bearingInRadians, this._fovInRadians = e2.fovInRadians, this._pitchInRadians = e2.pitchInRadians, this._rollInRadians = e2.rollInRadians, this._unmodified = e2.unmodified, this._edgeInsets = new Lt(e2.padding.top, e2.padding.bottom, e2.padding.left, e2.padding.right), this._minZoom = e2.minZoom, this._maxZoom = e2.maxZoom, this._minPitch = e2.minPitch, this._maxPitch = e2.maxPitch, this._renderWorldCopies = e2.renderWorldCopies, this._cameraToCenterDistance = e2.cameraToCenterDistance, this._nearZ = e2.nearZ, this._farZ = e2.farZ, this._autoCalculateNearFarZ = !a2 && e2.autoCalculateNearFarZ, i2 && this.constrainInternal(), this._calcMatrices();
	      }
	      get pixelsToClipSpaceMatrix() {
	        return this._pixelsToClipSpaceMatrix;
	      }
	      get clipSpaceToPixelsMatrix() {
	        return this._clipSpaceToPixelsMatrix;
	      }
	      get minElevationForCurrentTile() {
	        return this._minElevationForCurrentTile;
	      }
	      setMinElevationForCurrentTile(e2) {
	        this._minElevationForCurrentTile = e2;
	      }
	      get tileSize() {
	        return this._tileSize;
	      }
	      get tileZoom() {
	        return this._tileZoom;
	      }
	      get scale() {
	        return this._scale;
	      }
	      get width() {
	        return this._width;
	      }
	      get height() {
	        return this._height;
	      }
	      get bearingInRadians() {
	        return this._bearingInRadians;
	      }
	      get lngRange() {
	        return this._lngRange;
	      }
	      get latRange() {
	        return this._latRange;
	      }
	      get pixelsToGLUnits() {
	        return this._pixelsToGLUnits;
	      }
	      get minZoom() {
	        return this._minZoom;
	      }
	      setMinZoom(e2) {
	        this._minZoom !== e2 && (this._minZoom = e2, this.setZoom(this.applyConstrain(this._center, this.zoom).zoom));
	      }
	      get maxZoom() {
	        return this._maxZoom;
	      }
	      setMaxZoom(e2) {
	        this._maxZoom !== e2 && (this._maxZoom = e2, this.setZoom(this.applyConstrain(this._center, this.zoom).zoom));
	      }
	      get minPitch() {
	        return this._minPitch;
	      }
	      setMinPitch(e2) {
	        this._minPitch !== e2 && (this._minPitch = e2, this.setPitch(Math.max(this.pitch, e2)));
	      }
	      get maxPitch() {
	        return this._maxPitch;
	      }
	      setMaxPitch(e2) {
	        this._maxPitch !== e2 && (this._maxPitch = e2, this.setPitch(Math.min(this.pitch, e2)));
	      }
	      get renderWorldCopies() {
	        return this._renderWorldCopies;
	      }
	      setRenderWorldCopies(e2) {
	        void 0 === e2 ? e2 = true : null === e2 && (e2 = false), this._renderWorldCopies = e2;
	      }
	      get constrainOverride() {
	        return this._constrainOverride;
	      }
	      setConstrainOverride(e2) {
	        void 0 === e2 && (e2 = null), this._constrainOverride !== e2 && (this._constrainOverride = e2, this.constrainInternal(), this._calcMatrices());
	      }
	      get worldSize() {
	        return this._tileSize * this._scale;
	      }
	      get centerOffset() {
	        return this.centerPoint._sub(this.size._div(2));
	      }
	      get size() {
	        return new t.P(this._width, this._height);
	      }
	      get bearing() {
	        return this._bearingInRadians / Math.PI * 180;
	      }
	      setBearing(e2) {
	        const i2 = t.W(e2, -180, 180) * Math.PI / 180;
	        var r2, o2, s2, n2, l2, c2, h2, u2, d2;
	        this._bearingInRadians !== i2 && (this._unmodified = false, this._bearingInRadians = i2, this._calcMatrices(), this._rotationMatrix = a(), r2 = this._rotationMatrix, s2 = -this._bearingInRadians, n2 = (o2 = this._rotationMatrix)[0], l2 = o2[1], c2 = o2[2], h2 = o2[3], u2 = Math.sin(s2), d2 = Math.cos(s2), r2[0] = n2 * d2 + c2 * u2, r2[1] = l2 * d2 + h2 * u2, r2[2] = n2 * -u2 + c2 * d2, r2[3] = l2 * -u2 + h2 * d2);
	      }
	      get rotationMatrix() {
	        return this._rotationMatrix;
	      }
	      get pitchInRadians() {
	        return this._pitchInRadians;
	      }
	      get pitch() {
	        return this._pitchInRadians / Math.PI * 180;
	      }
	      setPitch(e2) {
	        const i2 = t.an(e2, this.minPitch, this.maxPitch) / 180 * Math.PI;
	        this._pitchInRadians !== i2 && (this._unmodified = false, this._pitchInRadians = i2, this._calcMatrices());
	      }
	      get rollInRadians() {
	        return this._rollInRadians;
	      }
	      get roll() {
	        return this._rollInRadians / Math.PI * 180;
	      }
	      setRoll(e2) {
	        const t2 = e2 / 180 * Math.PI;
	        this._rollInRadians !== t2 && (this._unmodified = false, this._rollInRadians = t2, this._calcMatrices());
	      }
	      get fovInRadians() {
	        return this._fovInRadians;
	      }
	      get fov() {
	        return t.aY(this._fovInRadians);
	      }
	      setFov(e2) {
	        e2 = t.an(e2, 0.1, 150), this.fov !== e2 && (this._unmodified = false, this._fovInRadians = t.ap(e2), this._calcMatrices());
	      }
	      get zoom() {
	        return this._zoom;
	      }
	      setZoom(e2) {
	        const i2 = this.applyConstrain(this._center, e2).zoom;
	        this._zoom !== i2 && (this._unmodified = false, this._zoom = i2, this._tileZoom = Math.max(0, Math.floor(i2)), this._scale = t.aq(i2), this.constrainInternal(), this._calcMatrices());
	      }
	      get center() {
	        return this._center;
	      }
	      setCenter(e2) {
	        e2.lat === this._center.lat && e2.lng === this._center.lng || (this._unmodified = false, this._center = e2, this.constrainInternal(), this._calcMatrices());
	      }
	      get elevation() {
	        return this._elevation;
	      }
	      setElevation(e2) {
	        e2 !== this._elevation && (this._elevation = e2, this.constrainInternal(), this._calcMatrices());
	      }
	      get padding() {
	        return this._edgeInsets.toJSON();
	      }
	      setPadding(e2) {
	        this._edgeInsets.equals(e2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e2, 1), this._calcMatrices());
	      }
	      get centerPoint() {
	        return this._edgeInsets.getCenter(this._width, this._height);
	      }
	      get pixelsPerMeter() {
	        return this._pixelPerMeter;
	      }
	      get unmodified() {
	        return this._unmodified;
	      }
	      get cameraToCenterDistance() {
	        return this._cameraToCenterDistance;
	      }
	      get nearZ() {
	        return this._nearZ;
	      }
	      get farZ() {
	        return this._farZ;
	      }
	      get autoCalculateNearFarZ() {
	        return this._autoCalculateNearFarZ;
	      }
	      overrideNearFarZ(e2, t2) {
	        this._autoCalculateNearFarZ = false, this._nearZ = e2, this._farZ = t2, this._calcMatrices();
	      }
	      clearNearFarZOverride() {
	        this._autoCalculateNearFarZ = true, this._calcMatrices();
	      }
	      isPaddingEqual(e2) {
	        return this._edgeInsets.equals(e2);
	      }
	      interpolatePadding(e2, t2, i2) {
	        this._unmodified = false, this._edgeInsets.interpolate(e2, t2, i2), this.constrainInternal(), this._calcMatrices();
	      }
	      resize(e2, t2, i2 = true) {
	        this._width = e2, this._height = t2, i2 && this.constrainInternal(), this._calcMatrices();
	      }
	      getMaxBounds() {
	        return this._latRange && 2 === this._latRange.length && this._lngRange && 2 === this._lngRange.length ? new $([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
	      }
	      setMaxBounds(e2) {
	        e2 ? (this._lngRange = [e2.getWest(), e2.getEast()], this._latRange = [e2.getSouth(), e2.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-t.ao, t.ao]);
	      }
	      getCameraQueryGeometry(e2, i2) {
	        if (1 === i2.length) return [i2[0], e2];
	        {
	          const { minX: a2, minY: r2, maxX: o2, maxY: s2 } = t.ab.fromPoints(i2).extend(e2);
	          return [new t.P(a2, r2), new t.P(o2, r2), new t.P(o2, s2), new t.P(a2, s2), new t.P(a2, r2)];
	        }
	      }
	      constrainInternal() {
	        if (!this.center || !this._width || !this._height || this._constraining) return;
	        this._constraining = true;
	        const e2 = this._unmodified, { center: t2, zoom: i2 } = this.applyConstrain(this.center, this.zoom);
	        this.setCenter(t2), this.setZoom(i2), this._unmodified = e2, this._constraining = false;
	      }
	      _calcMatrices() {
	        if (this._width && this._height) {
	          this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
	          let e2 = t.ar(new Float64Array(16));
	          t.Q(e2, e2, [this._width / 2, -this._height / 2, 1]), t.O(e2, e2, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e2, e2 = t.ar(new Float64Array(16)), t.Q(e2, e2, [1, -1, 1]), t.O(e2, e2, [-1, -1, 0]), t.Q(e2, e2, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e2, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
	        }
	        this._callbacks.calcMatrices();
	      }
	      calculateCenterFromCameraLngLatAlt(e2, i2, a2, r2) {
	        const o2 = void 0 !== a2 ? a2 : this.bearing, s2 = r2 = void 0 !== r2 ? r2 : this.pitch, n2 = t.aa.fromLngLat(e2, i2), l2 = -Math.cos(t.ap(s2)), c2 = Math.sin(t.ap(s2)), h2 = c2 * Math.sin(t.ap(o2)), u2 = -c2 * Math.cos(t.ap(o2));
	        let d2 = this.elevation;
	        const _2 = i2 - d2;
	        let p2;
	        l2 * _2 >= 0 || Math.abs(l2) < 0.1 ? (p2 = 1e4, d2 = i2 + p2 * l2) : p2 = -_2 / l2;
	        let m2, f2, g2 = t.aZ(1, n2.y), v2 = 0;
	        do {
	          if (v2 += 1, v2 > 10) break;
	          f2 = p2 / g2, m2 = new t.aa(n2.x + h2 * f2, n2.y + u2 * f2), g2 = 1 / m2.meterInMercatorCoordinateUnits();
	        } while (Math.abs(p2 - f2 * g2) > 1e-12);
	        return { center: m2.toLngLat(), elevation: d2, zoom: t.at(this.height / 2 / Math.tan(this.fovInRadians / 2) / f2 / this.tileSize) };
	      }
	      recalculateZoomAndCenter(e2) {
	        if (this.elevation - e2 == 0) return;
	        const i2 = t.as(1, this.center.lat) * this.worldSize, a2 = this.cameraToCenterDistance / i2, r2 = t.aa.fromLngLat(this.center, this.elevation), o2 = xe(this.center, this.elevation, this.pitch, this.bearing, a2);
	        this._elevation = e2;
	        const s2 = this.calculateCenterFromCameraLngLatAlt(o2.toLngLat(), t.aZ(o2.z, r2.y), this.bearing, this.pitch);
	        this._elevation = s2.elevation, this._center = s2.center, this.setZoom(s2.zoom);
	      }
	      getCameraPoint() {
	        const e2 = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
	        return this.centerPoint.add(new t.P(e2 * Math.sin(this.rollInRadians), e2 * Math.cos(this.rollInRadians)));
	      }
	      getCameraAltitude() {
	        return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
	      }
	      getCameraLngLat() {
	        const e2 = t.as(1, this.center.lat) * this.worldSize;
	        return xe(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e2).toLngLat();
	      }
	      getMercatorTileCoordinates(e2) {
	        if (!e2) return [0, 0, 1, 1];
	        const i2 = e2.canonical.z >= 0 ? 1 << e2.canonical.z : Math.pow(2, e2.canonical.z);
	        return [e2.canonical.x / i2, e2.canonical.y / i2, 1 / i2 / t.a4, 1 / i2 / t.a4];
	      }
	    }
	    class Ot {
	      constructor(e2, i2) {
	        this.min = e2, this.max = i2, this.center = t.a_([], t.a$([], this.min, this.max), 0.5);
	      }
	      quadrant(e2) {
	        const i2 = [e2 % 2 == 0, e2 < 2], a2 = t.b0(this.min), r2 = t.b0(this.max);
	        for (let e3 = 0; e3 < i2.length; e3++) a2[e3] = i2[e3] ? this.min[e3] : this.center[e3], r2[e3] = i2[e3] ? this.center[e3] : this.max[e3];
	        return r2[2] = this.max[2], new Ot(a2, r2);
	      }
	      distanceX(e2) {
	        return Math.max(Math.min(this.max[0], e2[0]), this.min[0]) - e2[0];
	      }
	      distanceY(e2) {
	        return Math.max(Math.min(this.max[1], e2[1]), this.min[1]) - e2[1];
	      }
	      intersectsFrustum(e2) {
	        let t2 = true;
	        for (let i2 = 0; i2 < e2.planes.length; i2++) {
	          const a2 = this.intersectsPlane(e2.planes[i2]);
	          if (0 === a2) return 0;
	          1 === a2 && (t2 = false);
	        }
	        return t2 ? 2 : e2.aabb.min[0] > this.max[0] || e2.aabb.min[1] > this.max[1] || e2.aabb.min[2] > this.max[2] || e2.aabb.max[0] < this.min[0] || e2.aabb.max[1] < this.min[1] || e2.aabb.max[2] < this.min[2] ? 0 : 1;
	      }
	      intersectsPlane(e2) {
	        let t2 = e2[3], i2 = e2[3];
	        for (let a2 = 0; a2 < 3; a2++) e2[a2] > 0 ? (t2 += e2[a2] * this.min[a2], i2 += e2[a2] * this.max[a2]) : (i2 += e2[a2] * this.min[a2], t2 += e2[a2] * this.max[a2]);
	        return t2 >= 0 ? 2 : i2 < 0 ? 0 : 1;
	      }
	    }
	    class jt {
	      distanceToTile2d(e2, t2, i2, a2) {
	        const r2 = a2.distanceX([e2, t2]), o2 = a2.distanceY([e2, t2]);
	        return Math.hypot(r2, o2);
	      }
	      getWrap(e2, t2, i2) {
	        return i2;
	      }
	      getTileBoundingVolume(e2, i2, a2, r2) {
	        var o2, s2;
	        let n2 = 0, l2 = 0;
	        if (null == r2 ? void 0 : r2.terrain) {
	          const c3 = new t.a1(e2.z, i2, e2.z, e2.x, e2.y), h2 = r2.terrain.getMinMaxElevation(c3);
	          n2 = null !== (o2 = h2.minElevation) && void 0 !== o2 ? o2 : Math.min(0, a2), l2 = null !== (s2 = h2.maxElevation) && void 0 !== s2 ? s2 : Math.max(0, a2);
	        }
	        const c2 = 1 << e2.z;
	        return new Ot([i2 + e2.x / c2, e2.y / c2, n2], [i2 + (e2.x + 1) / c2, (e2.y + 1) / c2, l2]);
	      }
	      allowVariableZoom(e2, i2) {
	        const a2 = e2.fov * (Math.abs(Math.cos(e2.rollInRadians)) * e2.height + Math.abs(Math.sin(e2.rollInRadians)) * e2.width) / e2.height, r2 = t.an(78.5 - a2 / 2, 0, 60);
	        return !!i2.terrain || e2.pitch > r2;
	      }
	      allowWorldCopies() {
	        return true;
	      }
	      prepareNextFrame() {
	      }
	    }
	    class Nt {
	      constructor(e2, t2, i2) {
	        this.points = e2, this.planes = t2, this.aabb = i2;
	      }
	      static fromInvProjectionMatrix(e2, i2 = 1, a2 = 0, r2, o2) {
	        const s2 = o2 ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]], n2 = Math.pow(2, a2), l2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((a3) => function(e3, i3, a4, r3) {
	          const o3 = t.aG([], e3, i3), s3 = 1 / o3[3] / a4 * r3;
	          return t.b5(o3, o3, [s3, s3, 1 / o3[3], s3]);
	        }(a3, e2, i2, n2));
	        r2 && function(e3, i3, a3, r3) {
	          const o3 = r3 ? 4 : 0, s3 = r3 ? 0 : 4;
	          let n3 = 0;
	          const l3 = [], c3 = [];
	          for (let i4 = 0; i4 < 4; i4++) {
	            const a4 = t.b1([], e3[i4 + s3], e3[i4 + o3]), r4 = t.b6(a4);
	            t.a_(a4, a4, 1 / r4), l3.push(r4), c3.push(a4);
	          }
	          for (let i4 = 0; i4 < 4; i4++) {
	            const r4 = t.b7(e3[i4 + o3], c3[i4], a3);
	            n3 = null !== r4 && r4 >= 0 ? Math.max(n3, r4) : Math.max(n3, l3[i4]);
	          }
	          const h3 = function(e4, i4) {
	            const a4 = t.b1([], e4[i4[0]], e4[i4[1]]), r4 = t.b1([], e4[i4[2]], e4[i4[1]]), o4 = [0, 0, 0, 0];
	            return t.b2(o4, t.b3([], a4, r4)), o4[3] = -t.b4(o4, e4[i4[0]]), o4;
	          }(e3, i3), u3 = function(e4, i4) {
	            const a4 = t.b8(e4), r4 = t.b9([], e4, 1 / a4), o4 = t.b1([], i4, t.a_([], r4, t.b4(i4, r4))), s4 = t.b8(o4);
	            if (s4 > 0) {
	              const e5 = Math.sqrt(1 - r4[3] * r4[3]), a5 = t.a_([], r4, -r4[3]), n4 = t.a$([], a5, t.a_([], o4, e5 / s4));
	              return t.ba(i4, n4);
	            }
	            return null;
	          }(a3, h3);
	          if (null !== u3) {
	            const e4 = u3 / t.b4(c3[0], h3);
	            n3 = Math.min(n3, e4);
	          }
	          for (let t2 = 0; t2 < 4; t2++) {
	            const i4 = Math.min(n3, l3[t2]);
	            e3[t2 + s3] = [e3[t2 + o3][0] + c3[t2][0] * i4, e3[t2 + o3][1] + c3[t2][1] * i4, e3[t2 + o3][2] + c3[t2][2] * i4, 1];
	          }
	        }(l2, s2[0], r2, o2);
	        const c2 = s2.map((e3) => {
	          const i3 = t.b1([], l2[e3[0]], l2[e3[1]]), a3 = t.b1([], l2[e3[2]], l2[e3[1]]), r3 = t.b2([], t.b3([], i3, a3)), o3 = -t.b4(r3, l2[e3[1]]);
	          return r3.concat(o3);
	        }), h2 = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], u2 = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
	        for (const e3 of l2) for (let t2 = 0; t2 < 3; t2++) h2[t2] = Math.min(h2[t2], e3[t2]), u2[t2] = Math.max(u2[t2], e3[t2]);
	        return new Nt(l2, c2, new Ot(h2, u2));
	      }
	    }
	    class Zt {
	      get pixelsToClipSpaceMatrix() {
	        return this._helper.pixelsToClipSpaceMatrix;
	      }
	      get clipSpaceToPixelsMatrix() {
	        return this._helper.clipSpaceToPixelsMatrix;
	      }
	      get pixelsToGLUnits() {
	        return this._helper.pixelsToGLUnits;
	      }
	      get centerOffset() {
	        return this._helper.centerOffset;
	      }
	      get size() {
	        return this._helper.size;
	      }
	      get rotationMatrix() {
	        return this._helper.rotationMatrix;
	      }
	      get centerPoint() {
	        return this._helper.centerPoint;
	      }
	      get pixelsPerMeter() {
	        return this._helper.pixelsPerMeter;
	      }
	      setMinZoom(e2) {
	        this._helper.setMinZoom(e2);
	      }
	      setMaxZoom(e2) {
	        this._helper.setMaxZoom(e2);
	      }
	      setMinPitch(e2) {
	        this._helper.setMinPitch(e2);
	      }
	      setMaxPitch(e2) {
	        this._helper.setMaxPitch(e2);
	      }
	      setRenderWorldCopies(e2) {
	        this._helper.setRenderWorldCopies(e2);
	      }
	      setBearing(e2) {
	        this._helper.setBearing(e2);
	      }
	      setPitch(e2) {
	        this._helper.setPitch(e2);
	      }
	      setRoll(e2) {
	        this._helper.setRoll(e2);
	      }
	      setFov(e2) {
	        this._helper.setFov(e2);
	      }
	      setZoom(e2) {
	        this._helper.setZoom(e2);
	      }
	      setCenter(e2) {
	        this._helper.setCenter(e2);
	      }
	      setElevation(e2) {
	        this._helper.setElevation(e2);
	      }
	      setMinElevationForCurrentTile(e2) {
	        this._helper.setMinElevationForCurrentTile(e2);
	      }
	      setPadding(e2) {
	        this._helper.setPadding(e2);
	      }
	      interpolatePadding(e2, t2, i2) {
	        return this._helper.interpolatePadding(e2, t2, i2);
	      }
	      isPaddingEqual(e2) {
	        return this._helper.isPaddingEqual(e2);
	      }
	      resize(e2, t2, i2 = true) {
	        this._helper.resize(e2, t2, i2);
	      }
	      getMaxBounds() {
	        return this._helper.getMaxBounds();
	      }
	      setMaxBounds(e2) {
	        this._helper.setMaxBounds(e2);
	      }
	      setConstrainOverride(e2) {
	        this._helper.setConstrainOverride(e2);
	      }
	      overrideNearFarZ(e2, t2) {
	        this._helper.overrideNearFarZ(e2, t2);
	      }
	      clearNearFarZOverride() {
	        this._helper.clearNearFarZOverride();
	      }
	      getCameraQueryGeometry(e2) {
	        return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e2);
	      }
	      get tileSize() {
	        return this._helper.tileSize;
	      }
	      get tileZoom() {
	        return this._helper.tileZoom;
	      }
	      get scale() {
	        return this._helper.scale;
	      }
	      get worldSize() {
	        return this._helper.worldSize;
	      }
	      get width() {
	        return this._helper.width;
	      }
	      get height() {
	        return this._helper.height;
	      }
	      get lngRange() {
	        return this._helper.lngRange;
	      }
	      get latRange() {
	        return this._helper.latRange;
	      }
	      get minZoom() {
	        return this._helper.minZoom;
	      }
	      get maxZoom() {
	        return this._helper.maxZoom;
	      }
	      get zoom() {
	        return this._helper.zoom;
	      }
	      get center() {
	        return this._helper.center;
	      }
	      get minPitch() {
	        return this._helper.minPitch;
	      }
	      get maxPitch() {
	        return this._helper.maxPitch;
	      }
	      get pitch() {
	        return this._helper.pitch;
	      }
	      get pitchInRadians() {
	        return this._helper.pitchInRadians;
	      }
	      get roll() {
	        return this._helper.roll;
	      }
	      get rollInRadians() {
	        return this._helper.rollInRadians;
	      }
	      get bearing() {
	        return this._helper.bearing;
	      }
	      get bearingInRadians() {
	        return this._helper.bearingInRadians;
	      }
	      get fov() {
	        return this._helper.fov;
	      }
	      get fovInRadians() {
	        return this._helper.fovInRadians;
	      }
	      get elevation() {
	        return this._helper.elevation;
	      }
	      get minElevationForCurrentTile() {
	        return this._helper.minElevationForCurrentTile;
	      }
	      get padding() {
	        return this._helper.padding;
	      }
	      get unmodified() {
	        return this._helper.unmodified;
	      }
	      get renderWorldCopies() {
	        return this._helper.renderWorldCopies;
	      }
	      get cameraToCenterDistance() {
	        return this._helper.cameraToCenterDistance;
	      }
	      get constrainOverride() {
	        return this._helper.constrainOverride;
	      }
	      get nearZ() {
	        return this._helper.nearZ;
	      }
	      get farZ() {
	        return this._helper.farZ;
	      }
	      get autoCalculateNearFarZ() {
	        return this._helper.autoCalculateNearFarZ;
	      }
	      setTransitionState(e2, t2) {
	      }
	      constructor(e2) {
	        this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this.defaultConstrain = (e3, i2) => {
	          i2 = t.an(+i2, this.minZoom, this.maxZoom);
	          const a2 = { center: new t.V(e3.lng, e3.lat), zoom: i2 };
	          let r2 = this._helper._lngRange;
	          if (!this._helper._renderWorldCopies && null === r2) {
	            const e4 = 180 - 1e-10;
	            r2 = [-e4, e4];
	          }
	          const o2 = this.tileSize * t.aq(a2.zoom);
	          let s2 = 0, n2 = o2, l2 = 0, c2 = o2, h2 = 0, u2 = 0;
	          const { x: d2, y: _2 } = this.size;
	          if (this._helper._latRange) {
	            const e4 = this._helper._latRange;
	            s2 = t.X(e4[1]) * o2, n2 = t.X(e4[0]) * o2, n2 - s2 < _2 && (h2 = _2 / (n2 - s2));
	          }
	          r2 && (l2 = t.W(t.Y(r2[0]) * o2, 0, o2), c2 = t.W(t.Y(r2[1]) * o2, 0, o2), c2 < l2 && (c2 += o2), c2 - l2 < d2 && (u2 = d2 / (c2 - l2)));
	          const { x: p2, y: m2 } = me(o2, e3);
	          let f2, g2;
	          const v2 = Math.max(u2 || 0, h2 || 0);
	          if (v2) {
	            const e4 = new t.P(u2 ? (c2 + l2) / 2 : p2, h2 ? (n2 + s2) / 2 : m2);
	            return a2.center = fe(o2, e4).wrap(), a2.zoom += t.at(v2), a2;
	          }
	          if (this._helper._latRange) {
	            const e4 = _2 / 2;
	            m2 - e4 < s2 && (g2 = s2 + e4), m2 + e4 > n2 && (g2 = n2 - e4);
	          }
	          if (r2) {
	            const e4 = (l2 + c2) / 2;
	            let i3 = p2;
	            this._helper._renderWorldCopies && (i3 = t.W(p2, e4 - o2 / 2, e4 + o2 / 2));
	            const a3 = d2 / 2;
	            i3 - a3 < l2 && (f2 = l2 + a3), i3 + a3 > c2 && (f2 = c2 - a3);
	          }
	          if (void 0 !== f2 || void 0 !== g2) {
	            const e4 = new t.P(null != f2 ? f2 : p2, null != g2 ? g2 : m2);
	            a2.center = fe(o2, e4).wrap();
	          }
	          return a2;
	        }, this.applyConstrain = (e3, t2) => this._helper.applyConstrain(e3, t2), this._helper = new Bt({ calcMatrices: () => {
	          this._calcMatrices();
	        }, defaultConstrain: (e3, t2) => this.defaultConstrain(e3, t2) }, e2), this._coveringTilesDetailsProvider = new jt();
	      }
	      clone() {
	        const e2 = new Zt();
	        return e2.apply(this), e2;
	      }
	      apply(e2, t2, i2) {
	        this._helper.apply(e2, t2, i2);
	      }
	      get cameraPosition() {
	        return this._cameraPosition;
	      }
	      get projectionMatrix() {
	        return this._projectionMatrix;
	      }
	      get modelViewProjectionMatrix() {
	        return this._viewProjMatrix;
	      }
	      get inverseProjectionMatrix() {
	        return this._invProjMatrix;
	      }
	      get mercatorMatrix() {
	        return this._mercatorMatrix;
	      }
	      getVisibleUnwrappedCoordinates(e2) {
	        const i2 = [new t.bb(0, e2)];
	        if (this._helper._renderWorldCopies) {
	          const a2 = this.screenPointToMercatorCoordinate(new t.P(0, 0)), r2 = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, 0)), o2 = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, this._helper._height)), s2 = this.screenPointToMercatorCoordinate(new t.P(0, this._helper._height)), n2 = Math.floor(Math.min(a2.x, r2.x, o2.x, s2.x)), l2 = Math.floor(Math.max(a2.x, r2.x, o2.x, s2.x)), c2 = 1;
	          for (let a3 = n2 - c2; a3 <= l2 + c2; a3++) 0 !== a3 && i2.push(new t.bb(a3, e2));
	        }
	        return i2;
	      }
	      getCameraFrustum() {
	        return Nt.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
	      }
	      getClippingPlane() {
	        return null;
	      }
	      getCoveringTilesDetailsProvider() {
	        return this._coveringTilesDetailsProvider;
	      }
	      recalculateZoomAndCenter(e2) {
	        const t2 = this.screenPointToLocation(this.centerPoint, e2), i2 = e2 ? e2.getElevationForLngLatZoom(t2, this._helper._tileZoom) : 0;
	        this._helper.recalculateZoomAndCenter(i2);
	      }
	      setLocationAtPoint(e2, i2) {
	        const a2 = t.as(this.elevation, this.center.lat), r2 = this.screenPointToMercatorCoordinateAtZ(i2, a2), o2 = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, a2), s2 = t.aa.fromLngLat(e2), n2 = new t.aa(s2.x - (r2.x - o2.x), s2.y - (r2.y - o2.y));
	        this.setCenter(null == n2 ? void 0 : n2.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
	      }
	      locationToScreenPoint(e2, i2) {
	        return i2 ? this.coordinatePoint(t.aa.fromLngLat(e2), i2.getElevationForLngLatZoom(e2, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(t.aa.fromLngLat(e2));
	      }
	      screenPointToLocation(e2, t2) {
	        var i2;
	        return null === (i2 = this.screenPointToMercatorCoordinate(e2, t2)) || void 0 === i2 ? void 0 : i2.toLngLat();
	      }
	      screenPointToMercatorCoordinate(e2, t2) {
	        if (t2) {
	          const i2 = t2.pointCoordinate(e2);
	          if (null != i2) return i2;
	        }
	        return this.screenPointToMercatorCoordinateAtZ(e2);
	      }
	      screenPointToMercatorCoordinateAtZ(e2, i2) {
	        const a2 = i2 || 0, r2 = [e2.x, e2.y, 0, 1], o2 = [e2.x, e2.y, 1, 1];
	        t.aG(r2, r2, this._pixelMatrixInverse), t.aG(o2, o2, this._pixelMatrixInverse);
	        const s2 = r2[3], n2 = o2[3], l2 = r2[1] / s2, c2 = o2[1] / n2, h2 = r2[2] / s2, u2 = o2[2] / n2, d2 = h2 === u2 ? 0 : (a2 - h2) / (u2 - h2);
	        return new t.aa(t.G.number(r2[0] / s2, o2[0] / n2, d2) / this.worldSize, t.G.number(l2, c2, d2) / this.worldSize, a2);
	      }
	      coordinatePoint(e2, i2 = 0, a2 = this._pixelMatrix) {
	        const r2 = [e2.x * this.worldSize, e2.y * this.worldSize, i2, 1];
	        return t.aG(r2, r2, a2), new t.P(r2[0] / r2[3], r2[1] / r2[3]);
	      }
	      getBounds() {
	        const e2 = Math.max(0, this._helper._height / 2 - ge(this));
	        return new $().extend(this.screenPointToLocation(new t.P(0, e2))).extend(this.screenPointToLocation(new t.P(this._helper._width, e2))).extend(this.screenPointToLocation(new t.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new t.P(0, this._helper._height)));
	      }
	      isPointOnMapSurface(e2, t2) {
	        return t2 ? null != t2.pointCoordinate(e2) : e2.y > this.height / 2 - ge(this);
	      }
	      calculatePosMatrix(e2, i2 = false, a2) {
	        var r2;
	        const o2 = null !== (r2 = e2.key) && void 0 !== r2 ? r2 : t.bc(e2.wrap, e2.canonical.z, e2.canonical.z, e2.canonical.x, e2.canonical.y), s2 = i2 ? this._alignedPosMatrixCache : this._posMatrixCache;
	        if (s2.has(o2)) {
	          const e3 = s2.get(o2);
	          return a2 ? e3.f32 : e3.f64;
	        }
	        const n2 = ve(e2, this.worldSize);
	        t.S(n2, i2 ? this._alignedProjMatrix : this._viewProjMatrix, n2);
	        const l2 = { f64: n2, f32: new Float32Array(n2) };
	        return s2.set(o2, l2), a2 ? l2.f32 : l2.f64;
	      }
	      calculateFogMatrix(e2) {
	        const i2 = e2.key, a2 = this._fogMatrixCacheF32;
	        if (a2.has(i2)) return a2.get(i2);
	        const r2 = ve(e2, this.worldSize);
	        return t.S(r2, this._fogMatrix, r2), a2.set(i2, new Float32Array(r2)), a2.get(i2);
	      }
	      calculateCenterFromCameraLngLatAlt(e2, t2, i2, a2) {
	        return this._helper.calculateCenterFromCameraLngLatAlt(e2, t2, i2, a2);
	      }
	      _calculateNearFarZIfNeeded(e2, i2, a2) {
	        if (!this._helper.autoCalculateNearFarZ) return;
	        const r2 = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), o2 = e2 - r2 * this._helper._pixelPerMeter / Math.cos(i2), s2 = r2 < 0 ? o2 : e2, n2 = Math.PI / 2 + this.pitchInRadians, l2 = t.ap(this.fov) * (Math.abs(Math.cos(t.ap(this.roll))) * this.height + Math.abs(Math.sin(t.ap(this.roll))) * this.width) / this.height * (0.5 + a2.y / this.height), c2 = Math.sin(l2) * s2 / Math.sin(t.an(Math.PI - n2 - l2, 0.01, Math.PI - 0.01)), h2 = ge(this), u2 = Math.atan(h2 / this._helper.cameraToCenterDistance), d2 = t.ap(0.75), _2 = u2 > d2 ? 2 * u2 * (0.5 + a2.y / (2 * h2)) : d2, p2 = Math.sin(_2) * s2 / Math.sin(t.an(Math.PI - n2 - _2, 0.01, Math.PI - 0.01)), m2 = Math.min(c2, p2);
	        this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i2) * m2 + s2), this._helper._nearZ = this._helper._height / 50;
	      }
	      _calcMatrices() {
	        if (!this._helper._height) return;
	        const e2 = this.centerOffset, i2 = me(this.worldSize, this.center), a2 = i2.x, r2 = i2.y;
	        this._helper._pixelPerMeter = t.as(1, this.center.lat) * this.worldSize;
	        const o2 = t.ap(Math.min(this.pitch, pe)), s2 = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(o2));
	        let n2;
	        this._calculateNearFarZIfNeeded(s2, o2, e2), n2 = new Float64Array(16), t.bd(n2, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), t.aA(this._invProjMatrix, n2), n2[8] = 2 * -e2.x / this._helper._width, n2[9] = 2 * e2.y / this._helper._height, this._projectionMatrix = t.be(n2), t.Q(n2, n2, [1, -1, 1]), t.O(n2, n2, [0, 0, -this._helper.cameraToCenterDistance]), t.bf(n2, n2, -this.rollInRadians), t.bg(n2, n2, this.pitchInRadians), t.bf(n2, n2, -this.bearingInRadians), t.O(n2, n2, [-a2, -r2, 0]), this._mercatorMatrix = t.Q([], n2, [this.worldSize, this.worldSize, this.worldSize]), t.Q(n2, n2, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = t.S(new Float64Array(16), this.clipSpaceToPixelsMatrix, n2), t.O(n2, n2, [0, 0, -this.elevation]), this._viewProjMatrix = n2, this._invViewProjMatrix = t.aA([], n2);
	        const l2 = [0, 0, -1, 1];
	        t.aG(l2, l2, this._invViewProjMatrix), this._cameraPosition = [l2[0] / l2[3], l2[1] / l2[3], l2[2] / l2[3]], this._fogMatrix = new Float64Array(16), t.bd(this._fogMatrix, this.fovInRadians, this.width / this.height, s2, this._helper._farZ), this._fogMatrix[8] = 2 * -e2.x / this.width, this._fogMatrix[9] = 2 * e2.y / this.height, t.Q(this._fogMatrix, this._fogMatrix, [1, -1, 1]), t.O(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), t.bf(this._fogMatrix, this._fogMatrix, -this.rollInRadians), t.bg(this._fogMatrix, this._fogMatrix, this.pitchInRadians), t.bf(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), t.O(this._fogMatrix, this._fogMatrix, [-a2, -r2, 0]), t.Q(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), t.O(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = t.S(new Float64Array(16), this.clipSpaceToPixelsMatrix, n2);
	        const c2 = this._helper._width % 2 / 2, h2 = this._helper._height % 2 / 2, u2 = Math.cos(this.bearingInRadians), d2 = Math.sin(-this.bearingInRadians), _2 = a2 - Math.round(a2) + u2 * c2 + d2 * h2, p2 = r2 - Math.round(r2) + u2 * h2 + d2 * c2, m2 = new Float64Array(n2);
	        if (t.O(m2, m2, [_2 > 0.5 ? _2 - 1 : _2, p2 > 0.5 ? p2 - 1 : p2, 0]), this._alignedProjMatrix = m2, n2 = t.aA(new Float64Array(16), this._pixelMatrix), !n2) throw new Error("failed to invert matrix");
	        this._pixelMatrixInverse = n2, this._clearMatrixCaches();
	      }
	      _clearMatrixCaches() {
	        this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
	      }
	      maxPitchScaleFactor() {
	        if (!this._pixelMatrixInverse) return 1;
	        const e2 = this.screenPointToMercatorCoordinate(new t.P(0, 0)), i2 = [e2.x * this.worldSize, e2.y * this.worldSize, 0, 1];
	        return t.aG(i2, i2, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
	      }
	      getCameraPoint() {
	        return this._helper.getCameraPoint();
	      }
	      getCameraAltitude() {
	        return this._helper.getCameraAltitude();
	      }
	      getCameraLngLat() {
	        const e2 = t.as(1, this.center.lat) * this.worldSize;
	        return xe(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e2).toLngLat();
	      }
	      lngLatToCameraDepth(e2, i2) {
	        const a2 = t.aa.fromLngLat(e2), r2 = [a2.x * this.worldSize, a2.y * this.worldSize, i2, 1];
	        return t.aG(r2, r2, this._viewProjMatrix), r2[2] / r2[3];
	      }
	      getProjectionData(e2) {
	        const { overscaledTileID: i2, aligned: a2, applyTerrainMatrix: r2 } = e2, o2 = this._helper.getMercatorTileCoordinates(i2), s2 = i2 ? this.calculatePosMatrix(i2, a2, true) : null;
	        let n2;
	        return n2 = i2 && i2.terrainRttPosMatrix32f && r2 ? i2.terrainRttPosMatrix32f : s2 || t.bh(), { mainMatrix: n2, tileMercatorCoords: o2, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: n2 };
	      }
	      isLocationOccluded(e2) {
	        return false;
	      }
	      getPixelScale() {
	        return 1;
	      }
	      getCircleRadiusCorrection() {
	        return 1;
	      }
	      getPitchedTextCorrection(e2, t2, i2) {
	        return 1;
	      }
	      transformLightDirection(e2) {
	        return t.b0(e2);
	      }
	      getRayDirectionFromPixel(e2) {
	        throw new Error("Not implemented.");
	      }
	      projectTileCoordinates(e2, i2, a2, r2) {
	        const o2 = this.calculatePosMatrix(a2);
	        let s2;
	        r2 ? (s2 = [e2, i2, r2(e2, i2), 1], t.aG(s2, s2, o2)) : (s2 = [e2, i2, 0, 1], Je(s2, s2, o2));
	        const n2 = s2[3];
	        return { point: new t.P(s2[0] / n2, s2[1] / n2), signedDistanceFromCamera: n2, isOccluded: false };
	      }
	      populateCache(e2) {
	        for (const t2 of e2) this.calculatePosMatrix(t2);
	      }
	      getMatrixForModel(e2, i2) {
	        const a2 = t.aa.fromLngLat(e2, i2), r2 = a2.meterInMercatorCoordinateUnits(), o2 = t.bi();
	        return t.O(o2, o2, [a2.x, a2.y, a2.z]), t.bf(o2, o2, Math.PI), t.bg(o2, o2, Math.PI / 2), t.Q(o2, o2, [-r2, r2, r2]), o2;
	      }
	      getProjectionDataForCustomLayer(e2 = true) {
	        const i2 = new t.a1(0, 0, 0, 0, 0), a2 = this.getProjectionData({ overscaledTileID: i2, applyGlobeMatrix: e2 }), r2 = ve(i2, this.worldSize);
	        t.S(r2, this._viewProjMatrix, r2), a2.tileMercatorCoords = [0, 0, 1, 1];
	        const o2 = [t.a4, t.a4, this.worldSize / this._helper.pixelsPerMeter], s2 = t.bj();
	        return t.Q(s2, r2, o2), a2.fallbackMatrix = s2, a2.mainMatrix = s2, a2;
	      }
	      getFastPathSimpleProjectionMatrix(e2) {
	        return this.calculatePosMatrix(e2);
	      }
	    }
	    function Gt() {
	      t.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
	    }
	    function Ut(e2) {
	      if (e2.useSlerp) if (e2.k < 1) {
	        const i2 = t.bk(e2.startEulerAngles.roll, e2.startEulerAngles.pitch, e2.startEulerAngles.bearing), a2 = t.bk(e2.endEulerAngles.roll, e2.endEulerAngles.pitch, e2.endEulerAngles.bearing), r2 = new Float64Array(4);
	        t.bl(r2, i2, a2, e2.k);
	        const o2 = t.bm(r2);
	        e2.tr.setRoll(o2.roll), e2.tr.setPitch(o2.pitch), e2.tr.setBearing(o2.bearing);
	      } else e2.tr.setRoll(e2.endEulerAngles.roll), e2.tr.setPitch(e2.endEulerAngles.pitch), e2.tr.setBearing(e2.endEulerAngles.bearing);
	      else e2.tr.setRoll(t.G.number(e2.startEulerAngles.roll, e2.endEulerAngles.roll, e2.k)), e2.tr.setPitch(t.G.number(e2.startEulerAngles.pitch, e2.endEulerAngles.pitch, e2.k)), e2.tr.setBearing(t.G.number(e2.startEulerAngles.bearing, e2.endEulerAngles.bearing, e2.k));
	    }
	    function Vt(e2, i2, a2, r2, o2) {
	      const s2 = o2.padding, n2 = me(o2.worldSize, a2.getNorthWest()), l2 = me(o2.worldSize, a2.getNorthEast()), c2 = me(o2.worldSize, a2.getSouthEast()), h2 = me(o2.worldSize, a2.getSouthWest()), u2 = t.ap(-r2), d2 = n2.rotate(u2), _2 = l2.rotate(u2), p2 = c2.rotate(u2), m2 = h2.rotate(u2), f2 = new t.P(Math.max(d2.x, _2.x, m2.x, p2.x), Math.max(d2.y, _2.y, m2.y, p2.y)), g2 = new t.P(Math.min(d2.x, _2.x, m2.x, p2.x), Math.min(d2.y, _2.y, m2.y, p2.y)), v2 = f2.sub(g2), x2 = (o2.width - (s2.left + s2.right + i2.left + i2.right)) / v2.x, b2 = (o2.height - (s2.top + s2.bottom + i2.top + i2.bottom)) / v2.y;
	      if (b2 < 0 || x2 < 0) return void Gt();
	      const y2 = Math.min(t.at(o2.scale * Math.min(x2, b2)), e2.maxZoom), w2 = t.P.convert(e2.offset), T2 = new t.P((i2.left - i2.right) / 2, (i2.top - i2.bottom) / 2).rotate(t.ap(r2)), P2 = w2.add(T2).mult(o2.scale / t.aq(y2));
	      return { center: fe(o2.worldSize, n2.add(c2).div(2).sub(P2)), zoom: y2, bearing: r2 };
	    }
	    class qt {
	      get useGlobeControls() {
	        return false;
	      }
	      handlePanInertia(e2, t2) {
	        const i2 = e2.mag(), a2 = Math.abs(ge(t2));
	        return { easingOffset: e2.mult(Math.min(0.75 * a2 / i2, 1)), easingCenter: t2.center };
	      }
	      handleMapControlsRollPitchBearingZoom(e2, t2) {
	        e2.bearingDelta && t2.setBearing(t2.bearing + e2.bearingDelta), e2.pitchDelta && t2.setPitch(t2.pitch + e2.pitchDelta), e2.rollDelta && t2.setRoll(t2.roll + e2.rollDelta), e2.zoomDelta && t2.setZoom(t2.zoom + e2.zoomDelta);
	      }
	      handleMapControlsPan(e2, t2, i2) {
	        e2.around.distSqr(t2.centerPoint) < 0.01 || t2.setLocationAtPoint(i2, e2.around);
	      }
	      cameraForBoxAndBearing(e2, t2, i2, a2, r2) {
	        return Vt(e2, t2, i2, a2, r2);
	      }
	      handleJumpToCenterZoom(e2, i2) {
	        e2.zoom !== (void 0 !== i2.zoom ? +i2.zoom : e2.zoom) && e2.setZoom(+i2.zoom), void 0 !== i2.center && e2.setCenter(t.V.convert(i2.center));
	      }
	      handleEaseTo(e2, i2) {
	        const a2 = e2.zoom, r2 = e2.padding, o2 = { roll: e2.roll, pitch: e2.pitch, bearing: e2.bearing }, s2 = { roll: void 0 === i2.roll ? e2.roll : i2.roll, pitch: void 0 === i2.pitch ? e2.pitch : i2.pitch, bearing: void 0 === i2.bearing ? e2.bearing : i2.bearing }, n2 = void 0 !== i2.zoom, l2 = !e2.isPaddingEqual(i2.padding);
	        let c2 = false;
	        const h2 = n2 ? +i2.zoom : e2.zoom;
	        let u2 = e2.centerPoint.add(i2.offsetAsPoint);
	        const d2 = e2.screenPointToLocation(u2), { center: _2, zoom: p2 } = e2.applyConstrain(t.V.convert(i2.center || d2), null != h2 ? h2 : a2);
	        kt(e2, _2);
	        const m2 = me(e2.worldSize, d2), f2 = me(e2.worldSize, _2).sub(m2), g2 = t.aq(p2 - a2);
	        return c2 = p2 !== a2, { easeFunc: (n3) => {
	          if (c2 && e2.setZoom(t.G.number(a2, p2, n3)), t.bn(o2, s2) || Ut({ startEulerAngles: o2, endEulerAngles: s2, tr: e2, k: n3, useSlerp: o2.roll != s2.roll }), l2 && (e2.interpolatePadding(r2, i2.padding, n3), u2 = e2.centerPoint.add(i2.offsetAsPoint)), i2.around) e2.setLocationAtPoint(i2.around, i2.aroundPoint);
	          else {
	            const i3 = t.aq(e2.zoom - a2), r3 = p2 > a2 ? Math.min(2, g2) : Math.max(0.5, g2), o3 = Math.pow(r3, 1 - n3), s3 = fe(e2.worldSize, m2.add(f2.mult(n3 * o3)).mult(i3));
	            e2.setLocationAtPoint(e2.renderWorldCopies ? s3.wrap() : s3, u2);
	          }
	        }, isZooming: c2, elevationCenter: _2 };
	      }
	      handleFlyTo(e2, i2) {
	        const a2 = void 0 !== i2.zoom, r2 = e2.zoom, o2 = e2.applyConstrain(t.V.convert(i2.center || i2.locationAtOffset), a2 ? +i2.zoom : r2), s2 = o2.center, n2 = o2.zoom;
	        kt(e2, s2);
	        const l2 = me(e2.worldSize, i2.locationAtOffset), c2 = me(e2.worldSize, s2).sub(l2), h2 = c2.mag(), u2 = t.aq(n2 - r2);
	        let d2;
	        if (void 0 !== i2.minZoom) {
	          const a3 = Math.min(+i2.minZoom, r2, n2), o3 = e2.applyConstrain(s2, a3).zoom;
	          d2 = t.aq(o3 - r2);
	        }
	        return { easeFunc: (i3, a3, o3, h3) => {
	          e2.setZoom(1 === i3 ? n2 : r2 + t.at(a3));
	          const u3 = 1 === i3 ? s2 : fe(e2.worldSize, l2.add(c2.mult(o3)).mult(a3));
	          e2.setLocationAtPoint(e2.renderWorldCopies ? u3.wrap() : u3, h3);
	        }, scaleOfZoom: u2, targetCenter: s2, scaleOfMinZoom: d2, pixelPathLength: h2 };
	      }
	    }
	    class Wt {
	      constructor(e2, t2, i2) {
	        this.blendFunction = e2, this.blendColor = t2, this.mask = i2;
	      }
	    }
	    Wt.Replace = [1, 0], Wt.disabled = new Wt(Wt.Replace, t.bo.transparent, [false, false, false, false]), Wt.unblended = new Wt(Wt.Replace, t.bo.transparent, [true, true, true, true]), Wt.alphaBlended = new Wt([1, 771], t.bo.transparent, [true, true, true, true]);
	    const $t = 2305;
	    class Ht {
	      constructor(e2, t2, i2) {
	        this.enable = e2, this.mode = t2, this.frontFace = i2;
	      }
	    }
	    Ht.disabled = new Ht(false, 1029, $t), Ht.backCCW = new Ht(true, 1029, $t), Ht.frontCCW = new Ht(true, 1028, $t);
	    class Xt {
	      constructor(e2, t2, i2) {
	        this.func = e2, this.mask = t2, this.range = i2;
	      }
	    }
	    Xt.ReadOnly = false, Xt.ReadWrite = true, Xt.disabled = new Xt(519, Xt.ReadOnly, [0, 1]);
	    const Kt = 7680;
	    class Yt {
	      constructor(e2, t2, i2, a2, r2, o2) {
	        this.test = e2, this.ref = t2, this.mask = i2, this.fail = a2, this.depthFail = r2, this.pass = o2;
	      }
	    }
	    Yt.disabled = new Yt({ func: 519, mask: 0 }, 0, 0, Kt, Kt, Kt);
	    const Qt = /* @__PURE__ */ new WeakMap();
	    function Jt(e2) {
	      var t2;
	      if (Qt.has(e2)) return Qt.get(e2);
	      {
	        const i2 = null === (t2 = e2.getParameter(e2.VERSION)) || void 0 === t2 ? void 0 : t2.startsWith("WebGL 2.0");
	        return Qt.set(e2, i2), i2;
	      }
	    }
	    class ei {
	      get awaitingQuery() {
	        return !!this._readbackQueue;
	      }
	      constructor(e2) {
	        this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e2;
	        const i2 = e2.context, a2 = i2.gl;
	        this._texFormat = a2.RGBA, this._texType = a2.UNSIGNED_BYTE;
	        const r2 = new t.aV();
	        r2.emplaceBack(-1, -1), r2.emplaceBack(2, -1), r2.emplaceBack(-1, 2);
	        const o2 = new t.aX();
	        o2.emplaceBack(0, 1, 2), this._fullscreenTriangle = new St(i2.createVertexBuffer(r2, Rt.members), i2.createIndexBuffer(o2), t.aW.simpleSegment(0, 0, r2.length, o2.length)), this._resultBuffer = new Uint8Array(4), i2.activeTexture.set(a2.TEXTURE1);
	        const s2 = a2.createTexture();
	        a2.bindTexture(a2.TEXTURE_2D, s2), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_S, a2.CLAMP_TO_EDGE), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_T, a2.CLAMP_TO_EDGE), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MIN_FILTER, a2.NEAREST), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MAG_FILTER, a2.NEAREST), a2.texImage2D(a2.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = i2.createFramebuffer(this._texWidth, this._texHeight, false, false), this._fbo.colorAttachment.set(s2), Jt(a2) && (this._pbo = a2.createBuffer(), a2.bindBuffer(a2.PIXEL_PACK_BUFFER, this._pbo), a2.bufferData(a2.PIXEL_PACK_BUFFER, 4, a2.STREAM_READ), a2.bindBuffer(a2.PIXEL_PACK_BUFFER, null));
	      }
	      destroy() {
	        const e2 = this._cachedRenderContext.context.gl;
	        this._fullscreenTriangle.destroy(), this._fbo.destroy(), e2.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
	      }
	      updateErrorLoop(e2, t2) {
	        const i2 = this._updateCount;
	        return this._readbackQueue ? i2 >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : i2 >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e2, t2), this._updateCount++, this._measuredError;
	      }
	      _bindFramebuffer() {
	        const e2 = this._cachedRenderContext.context, t2 = e2.gl;
	        e2.activeTexture.set(t2.TEXTURE1), t2.bindTexture(t2.TEXTURE_2D, this._fbo.colorAttachment.get()), e2.bindFramebuffer.set(this._fbo.framebuffer);
	      }
	      _renderErrorTexture(e2, i2) {
	        const a2 = this._cachedRenderContext.context, r2 = a2.gl;
	        if (this._bindFramebuffer(), a2.viewport.set([0, 0, this._texWidth, this._texHeight]), a2.clear({ color: t.bo.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(a2, r2.TRIANGLES, Xt.disabled, Yt.disabled, Wt.unblended, Ht.disabled, /* @__PURE__ */ ((e3, t2) => ({ u_input: e3, u_output_expected: t2 }))(e2, i2), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && Jt(r2)) {
	          r2.bindBuffer(r2.PIXEL_PACK_BUFFER, this._pbo), r2.readBuffer(r2.COLOR_ATTACHMENT0), r2.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), r2.bindBuffer(r2.PIXEL_PACK_BUFFER, null);
	          const e3 = r2.fenceSync(r2.SYNC_GPU_COMMANDS_COMPLETE, 0);
	          r2.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: e3 };
	        } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
	      }
	      _tryReadback() {
	        const e2 = this._cachedRenderContext.context.gl;
	        if (this._pbo && this._readbackQueue && Jt(e2)) {
	          const i2 = e2.clientWaitSync(this._readbackQueue.sync, 0, 0);
	          if (i2 === e2.WAIT_FAILED) return t.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
	          if (i2 === e2.TIMEOUT_EXPIRED) return;
	          e2.bindBuffer(e2.PIXEL_PACK_BUFFER, this._pbo), e2.getBufferSubData(e2.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e2.bindBuffer(e2.PIXEL_PACK_BUFFER, null);
	        } else this._bindFramebuffer(), e2.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
	        this._readbackQueue = null, this._measuredError = ei._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
	      }
	      static _parseRGBA8float(e2) {
	        let t2 = 0;
	        return t2 += e2[0] / 256, t2 += e2[1] / 65536, t2 += e2[2] / 16777216, e2[3] < 127 && (t2 = -t2), t2 / 128;
	      }
	    }
	    const ti = t.a4 / 128;
	    function ii(e2, i2) {
	      const a2 = void 0 !== e2.granularity ? Math.max(e2.granularity, 1) : 1, r2 = a2 + (e2.generateBorders ? 2 : 0), o2 = a2 + (e2.extendToNorthPole || e2.generateBorders ? 1 : 0) + (e2.extendToSouthPole || e2.generateBorders ? 1 : 0), s2 = r2 + 1, n2 = o2 + 1, l2 = e2.generateBorders ? -1 : 0, c2 = e2.generateBorders || e2.extendToNorthPole ? -1 : 0, h2 = a2 + (e2.generateBorders ? 1 : 0), u2 = a2 + (e2.generateBorders || e2.extendToSouthPole ? 1 : 0), d2 = s2 * n2, _2 = r2 * o2 * 6, p2 = s2 * n2 > 65536;
	      if (p2 && "16bit" === i2) throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
	      const m2 = p2 || "32bit" === i2, f2 = new Int16Array(2 * d2);
	      let g2 = 0;
	      for (let i3 = c2; i3 <= u2; i3++) for (let r3 = l2; r3 <= h2; r3++) {
	        let o3 = r3 / a2 * t.a4;
	        -1 === r3 && (o3 = -ti), r3 === a2 + 1 && (o3 = t.a4 + ti);
	        let s3 = i3 / a2 * t.a4;
	        -1 === i3 && (s3 = e2.extendToNorthPole ? t.bq : -ti), i3 === a2 + 1 && (s3 = e2.extendToSouthPole ? t.br : t.a4 + ti), f2[g2++] = o3, f2[g2++] = s3;
	      }
	      const v2 = m2 ? new Uint32Array(_2) : new Uint16Array(_2);
	      let x2 = 0;
	      for (let e3 = 0; e3 < o2; e3++) for (let t2 = 0; t2 < r2; t2++) {
	        const i3 = t2 + 1 + e3 * s2, a3 = t2 + (e3 + 1) * s2, r3 = t2 + 1 + (e3 + 1) * s2;
	        v2[x2++] = t2 + e3 * s2, v2[x2++] = a3, v2[x2++] = i3, v2[x2++] = i3, v2[x2++] = a3, v2[x2++] = r3;
	      }
	      return { vertices: f2.buffer.slice(0), indices: v2.buffer.slice(0), uses32bitIndices: m2 };
	    }
	    const ai = new t.aU({ fill: new t.bs(128, 2), line: new t.bs(512, 0), tile: new t.bs(128, 32), stencil: new t.bs(128, 1), circle: 3 });
	    class ri {
	      constructor() {
	        this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
	      }
	      get name() {
	        return "vertical-perspective";
	      }
	      get transitionState() {
	        return 1;
	      }
	      get useSubdivision() {
	        return true;
	      }
	      get shaderVariantName() {
	        return "globe";
	      }
	      get shaderDefine() {
	        return "#define GLOBE";
	      }
	      get shaderPreludeCode() {
	        return It.projectionGlobe;
	      }
	      get vertexShaderPreludeCode() {
	        return It.projectionMercator.vertexSource;
	      }
	      get subdivisionGranularity() {
	        return ai;
	      }
	      get useGlobeControls() {
	        return true;
	      }
	      get latitudeErrorCorrectionRadians() {
	        return this._errorCorrectionUsable;
	      }
	      destroy() {
	        this._errorMeasurement && this._errorMeasurement.destroy();
	      }
	      updateGPUdependent(e2) {
	        this._errorMeasurement || (this._errorMeasurement = new ei(e2));
	        const i2 = t.X(this._errorQueryLatitudeDegrees), a2 = 2 * Math.atan(Math.exp(Math.PI - i2 * Math.PI * 2)) - 0.5 * Math.PI, r2 = this._errorMeasurement.updateErrorLoop(i2, a2), o2 = c();
	        r2 !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = r2, this._errorMeasurementLastChangeTime = o2);
	        const s2 = Math.min(Math.max((o2 - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
	        this._errorCorrectionUsable = t.bt(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, t.bu(s2));
	      }
	      _getMeshKey(e2) {
	        return `${e2.granularity.toString(36)}_${e2.generateBorders ? "b" : ""}${e2.extendToNorthPole ? "n" : ""}${e2.extendToSouthPole ? "s" : ""}`;
	      }
	      getMeshFromTileID(e2, t2, i2, a2, r2) {
	        const o2 = ("stencil" === r2 ? ai.stencil : ai.tile).getGranularityForZoomLevel(t2.z);
	        return this._getMesh(e2, { granularity: o2, generateBorders: i2, extendToNorthPole: 0 === t2.y && a2, extendToSouthPole: t2.y === (1 << t2.z) - 1 && a2 });
	      }
	      _getMesh(e2, i2) {
	        const a2 = this._getMeshKey(i2);
	        if (a2 in this._tileMeshCache) return this._tileMeshCache[a2];
	        const r2 = function(e3, i3) {
	          const a3 = ii(i3, "16bit"), r3 = t.aV.deserialize({ arrayBuffer: a3.vertices, length: a3.vertices.byteLength / 2 / 2 }), o2 = t.aX.deserialize({ arrayBuffer: a3.indices, length: a3.indices.byteLength / 2 / 3 });
	          return new St(e3.createVertexBuffer(r3, Rt.members), e3.createIndexBuffer(o2), t.aW.simpleSegment(0, 0, r3.length, o2.length));
	        }(e2, i2);
	        return this._tileMeshCache[a2] = r2, r2;
	      }
	      recalculate(e2) {
	      }
	      hasTransition() {
	        const e2 = c();
	        let t2 = false;
	        return t2 = t2 || (e2 - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, t2 = t2 || this._errorMeasurement && this._errorMeasurement.awaitingQuery, t2;
	      }
	      setErrorQueryLatitudeDegrees(e2) {
	        this._errorQueryLatitudeDegrees = e2;
	      }
	    }
	    const oi = new t.t({ type: new t.D(t.u.projection.type) });
	    class si extends t.E {
	      constructor(e2) {
	        super(), this._transitionable = new t.x(oi, void 0), this.setProjection(e2), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.H(0)), this._mercatorProjection = new At(), this._verticalPerspectiveProjection = new ri();
	      }
	      get transitionState() {
	        const e2 = this.properties.get("type");
	        if ("string" == typeof e2 && "mercator" === e2) return 0;
	        if ("string" == typeof e2 && "vertical-perspective" === e2) return 1;
	        if (e2 instanceof t.bv) {
	          if ("vertical-perspective" === e2.from && "mercator" === e2.to) return 1 - e2.transition;
	          if ("mercator" === e2.from && "vertical-perspective" === e2.to) return e2.transition;
	        }
	        return 1;
	      }
	      get useGlobeRendering() {
	        return this.transitionState > 0;
	      }
	      get latitudeErrorCorrectionRadians() {
	        return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
	      }
	      get currentProjection() {
	        return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
	      }
	      get name() {
	        return "globe";
	      }
	      get useSubdivision() {
	        return this.currentProjection.useSubdivision;
	      }
	      get shaderVariantName() {
	        return this.currentProjection.shaderVariantName;
	      }
	      get shaderDefine() {
	        return this.currentProjection.shaderDefine;
	      }
	      get shaderPreludeCode() {
	        return this.currentProjection.shaderPreludeCode;
	      }
	      get vertexShaderPreludeCode() {
	        return this.currentProjection.vertexShaderPreludeCode;
	      }
	      get subdivisionGranularity() {
	        return this.currentProjection.subdivisionGranularity;
	      }
	      get useGlobeControls() {
	        return this.transitionState > 0;
	      }
	      destroy() {
	        this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
	      }
	      updateGPUdependent(e2) {
	        this._mercatorProjection.updateGPUdependent(e2), this._verticalPerspectiveProjection.updateGPUdependent(e2);
	      }
	      getMeshFromTileID(e2, t2, i2, a2, r2) {
	        return this.currentProjection.getMeshFromTileID(e2, t2, i2, a2, r2);
	      }
	      setProjection(e2) {
	        this._transitionable.setValue("type", (null == e2 ? void 0 : e2.type) || "mercator");
	      }
	      updateTransitions(e2) {
	        this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
	      }
	      hasTransition() {
	        return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
	      }
	      recalculate(e2) {
	        this.properties = this._transitioning.possiblyEvaluate(e2);
	      }
	      setErrorQueryLatitudeDegrees(e2) {
	        this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e2), this._mercatorProjection.setErrorQueryLatitudeDegrees(e2);
	      }
	    }
	    function ni(e2) {
	      const t2 = hi(e2.worldSize, e2.center.lat);
	      return 2 * Math.PI * t2;
	    }
	    function li(e2, i2, a2, r2, o2) {
	      const s2 = 1 / (1 << o2), n2 = i2 / t.a4 * s2 + r2 * s2, l2 = t.bx((e2 / t.a4 * s2 + a2 * s2) * Math.PI * 2 + Math.PI, 2 * Math.PI), c2 = 2 * Math.atan(Math.exp(Math.PI - n2 * Math.PI * 2)) - 0.5 * Math.PI, h2 = Math.cos(c2), u2 = new Float64Array(3);
	      return u2[0] = Math.sin(l2) * h2, u2[1] = Math.sin(c2), u2[2] = Math.cos(l2) * h2, u2;
	    }
	    function ci(e2) {
	      return function(e3, t2) {
	        const i2 = Math.cos(t2), a2 = new Float64Array(3);
	        return a2[0] = Math.sin(e3) * i2, a2[1] = Math.sin(t2), a2[2] = Math.cos(e3) * i2, a2;
	      }(e2.lng * Math.PI / 180, e2.lat * Math.PI / 180);
	    }
	    function hi(e2, t2) {
	      return e2 / (2 * Math.PI) / Math.cos(t2 * Math.PI / 180);
	    }
	    function ui(e2) {
	      const i2 = Math.asin(e2[1]) / Math.PI * 180, a2 = Math.sqrt(e2[0] * e2[0] + e2[2] * e2[2]);
	      if (a2 > 1e-6) {
	        const r2 = e2[0] / a2, o2 = Math.acos(e2[2] / a2), s2 = (r2 > 0 ? o2 : -o2) / Math.PI * 180;
	        return new t.V(t.W(s2, -180, 180), i2);
	      }
	      return new t.V(0, i2);
	    }
	    function di(e2) {
	      return Math.cos(e2 * Math.PI / 180);
	    }
	    function _i(e2, i2) {
	      const a2 = di(e2), r2 = di(i2);
	      return t.at(r2 / a2);
	    }
	    function pi(e2, i2) {
	      const a2 = e2.rotate(i2.bearingInRadians), r2 = i2.zoom + _i(i2.center.lat, 0), o2 = t.bt(1 / di(i2.center.lat), 1 / di(Math.min(Math.abs(i2.center.lat), 60)), t.bw(r2, 7, 3, 0, 1)), s2 = 360 / ni({ worldSize: i2.worldSize, center: { lat: i2.center.lat } });
	      return new t.V(i2.center.lng - a2.x * s2 * o2, t.an(i2.center.lat + a2.y * s2, -t.ao, t.ao));
	    }
	    function mi(e2) {
	      const t2 = 0.5 * e2, i2 = Math.sin(t2), a2 = Math.cos(t2);
	      return Math.log(i2 + a2) - Math.log(a2 - i2);
	    }
	    function fi(e2, i2, a2, r2) {
	      const o2 = e2.lat + a2 * r2;
	      if (Math.abs(a2) > 1) {
	        const s2 = (Math.sign(e2.lat + a2) !== Math.sign(e2.lat) ? -Math.abs(e2.lat) : Math.abs(e2.lat)) * Math.PI / 180, n2 = Math.abs(e2.lat + a2) * Math.PI / 180, l2 = mi(s2 + r2 * (n2 - s2)), c2 = mi(s2), h2 = mi(n2);
	        return new t.V(e2.lng + i2 * ((l2 - c2) / (h2 - c2)), o2);
	      }
	      return new t.V(e2.lng + i2 * r2, o2);
	    }
	    class gi {
	      constructor(e2) {
	        this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = false, this._boundingVolumeFactory = e2;
	      }
	      swapBuffers() {
	        if (!this._hadAnyChanges) return;
	        const e2 = this._cachePrevious;
	        this._cachePrevious = this._cache, this._cache = e2, this._cache.clear(), this._hadAnyChanges = false;
	      }
	      getTileBoundingVolume(e2, t2, i2, a2) {
	        const r2 = `${e2.z}_${e2.x}_${e2.y}_${(null == a2 ? void 0 : a2.terrain) ? "t" : ""}`, o2 = this._cache.get(r2);
	        if (o2) return o2;
	        const s2 = this._cachePrevious.get(r2);
	        if (s2) return this._cache.set(r2, s2), s2;
	        const n2 = this._boundingVolumeFactory(e2, t2, i2, a2);
	        return this._cache.set(r2, n2), this._hadAnyChanges = true, n2;
	      }
	    }
	    class vi {
	      constructor(e2, t2, i2, a2) {
	        this.min = i2, this.max = a2, this.points = e2, this.planes = t2;
	      }
	      static fromAabb(e2, t2) {
	        const i2 = [];
	        for (let a2 = 0; a2 < 8; a2++) i2.push([1 & ~a2 ? e2[0] : t2[0], 1 == (a2 >> 1 & 1) ? t2[1] : e2[1], 1 == (a2 >> 2 & 1) ? t2[2] : e2[2]]);
	        return new vi(i2, [[-1, 0, 0, t2[0]], [1, 0, 0, -e2[0]], [0, -1, 0, t2[1]], [0, 1, 0, -e2[1]], [0, 0, -1, t2[2]], [0, 0, 1, -e2[2]]], e2, t2);
	      }
	      static fromCenterSizeAngles(e2, i2, a2) {
	        const r2 = t.bA([], a2[0], a2[1], a2[2]), o2 = t.bB([], [i2[0], 0, 0], r2), s2 = t.bB([], [0, i2[1], 0], r2), n2 = t.bB([], [0, 0, i2[2]], r2), l2 = [...e2], c2 = [...e2];
	        for (let t2 = 0; t2 < 8; t2++) for (let i3 = 0; i3 < 3; i3++) {
	          const a3 = e2[i3] + o2[i3] * (1 & ~t2 ? -1 : 1) + s2[i3] * (1 == (t2 >> 1 & 1) ? 1 : -1) + n2[i3] * (1 == (t2 >> 2 & 1) ? 1 : -1);
	          l2[i3] = Math.min(l2[i3], a3), c2[i3] = Math.max(c2[i3], a3);
	        }
	        const h2 = [];
	        for (let i3 = 0; i3 < 8; i3++) {
	          const a3 = [...e2];
	          t.a$(a3, a3, t.a_([], o2, 1 & ~i3 ? -1 : 1)), t.a$(a3, a3, t.a_([], s2, 1 == (i3 >> 1 & 1) ? 1 : -1)), t.a$(a3, a3, t.a_([], n2, 1 == (i3 >> 2 & 1) ? 1 : -1)), h2.push(a3);
	        }
	        return new vi(h2, [[...o2, -t.b4(o2, h2[0])], [...s2, -t.b4(s2, h2[0])], [...n2, -t.b4(n2, h2[0])], [-o2[0], -o2[1], -o2[2], -t.b4(o2, h2[7])], [-s2[0], -s2[1], -s2[2], -t.b4(s2, h2[7])], [-n2[0], -n2[1], -n2[2], -t.b4(n2, h2[7])]], l2, c2);
	      }
	      intersectsFrustum(e2) {
	        let t2 = true;
	        const i2 = this.points.length, a2 = this.planes.length, r2 = e2.planes.length, o2 = e2.points.length;
	        for (let a3 = 0; a3 < r2; a3++) {
	          const r3 = e2.planes[a3];
	          let o3 = 0;
	          for (let e3 = 0; e3 < i2; e3++) {
	            const t3 = this.points[e3];
	            r3[0] * t3[0] + r3[1] * t3[1] + r3[2] * t3[2] + r3[3] >= 0 && o3++;
	          }
	          if (0 === o3) return 0;
	          o3 < i2 && (t2 = false);
	        }
	        if (t2) return 2;
	        for (let t3 = 0; t3 < a2; t3++) {
	          const i3 = this.planes[t3];
	          let a3 = 0;
	          for (let t4 = 0; t4 < o2; t4++) {
	            const r3 = e2.points[t4];
	            i3[0] * r3[0] + i3[1] * r3[1] + i3[2] * r3[2] + i3[3] >= 0 && a3++;
	          }
	          if (0 === a3) return 0;
	        }
	        return 1;
	      }
	      intersectsPlane(e2) {
	        const t2 = this.points.length;
	        let i2 = 0;
	        for (let a2 = 0; a2 < t2; a2++) {
	          const t3 = this.points[a2];
	          e2[0] * t3[0] + e2[1] * t3[1] + e2[2] * t3[2] + e2[3] >= 0 && i2++;
	        }
	        return i2 === t2 ? 2 : 0 === i2 ? 0 : 1;
	      }
	    }
	    function xi(e2, t2, i2) {
	      const a2 = e2 - t2;
	      return a2 < 0 ? -a2 : Math.max(0, a2 - i2);
	    }
	    function bi(e2, t2, i2, a2, r2) {
	      const o2 = e2 - i2;
	      let s2;
	      return s2 = o2 < 0 ? Math.min(-o2, 1 + o2 - r2) : o2 > 1 ? Math.min(Math.max(o2 - r2, 0), 1 - o2) : 0, Math.max(s2, xi(t2, a2, r2));
	    }
	    class yi {
	      constructor() {
	        this._boundingVolumeCache = new gi(this._computeTileBoundingVolume);
	      }
	      prepareNextFrame() {
	        this._boundingVolumeCache.swapBuffers();
	      }
	      distanceToTile2d(e2, t2, i2, a2) {
	        const r2 = 1 << i2.z, o2 = 1 / r2, s2 = i2.x / r2, n2 = i2.y / r2;
	        let l2 = 2;
	        return l2 = Math.min(l2, bi(e2, t2, s2, n2, o2)), l2 = Math.min(l2, bi(e2, t2, s2 + 0.5, -n2 - o2, o2)), l2 = Math.min(l2, bi(e2, t2, s2 + 0.5, 2 - n2 - o2, o2)), l2;
	      }
	      getWrap(e2, t2, i2) {
	        const a2 = 1 << t2.z, r2 = 1 / a2, o2 = t2.x / a2, s2 = xi(e2.x, o2, r2), n2 = xi(e2.x, o2 - 1, r2), l2 = xi(e2.x, o2 + 1, r2), c2 = Math.min(s2, n2, l2);
	        return c2 === l2 ? 1 : c2 === n2 ? -1 : 0;
	      }
	      allowVariableZoom(e2, t2) {
	        return Pe(e2, t2) > 4;
	      }
	      allowWorldCopies() {
	        return false;
	      }
	      getTileBoundingVolume(e2, t2, i2, a2) {
	        return this._boundingVolumeCache.getTileBoundingVolume(e2, t2, i2, a2);
	      }
	      _computeTileBoundingVolume(e2, i2, a2, r2) {
	        var o2, s2;
	        let n2 = 0, l2 = 0;
	        if (null == r2 ? void 0 : r2.terrain) {
	          const c2 = new t.a1(e2.z, i2, e2.z, e2.x, e2.y), h2 = r2.terrain.getMinMaxElevation(c2);
	          n2 = null !== (o2 = h2.minElevation) && void 0 !== o2 ? o2 : Math.min(0, a2), l2 = null !== (s2 = h2.maxElevation) && void 0 !== s2 ? s2 : Math.max(0, a2);
	        }
	        if (n2 /= t.bD, l2 /= t.bD, n2 += 1, l2 += 1, e2.z <= 0) return vi.fromAabb([-l2, -l2, -l2], [l2, l2, l2]);
	        if (1 === e2.z) return vi.fromAabb([0 === e2.x ? -l2 : 0, 0 === e2.y ? 0 : -l2, -l2], [0 === e2.x ? 0 : l2, 0 === e2.y ? l2 : 0, l2]);
	        {
	          const i3 = [li(0, 0, e2.x, e2.y, e2.z), li(t.a4, 0, e2.x, e2.y, e2.z), li(t.a4, t.a4, e2.x, e2.y, e2.z), li(0, t.a4, e2.x, e2.y, e2.z)], a3 = [];
	          for (const e3 of i3) a3.push(t.a_([], e3, l2));
	          if (l2 !== n2) for (const e3 of i3) a3.push(t.a_([], e3, n2));
	          0 === e2.y && a3.push([0, 1, 0]), e2.y === (1 << e2.z) - 1 && a3.push([0, -1, 0]);
	          const r3 = [1, 1, 1], o3 = [-1, -1, -1];
	          for (const e3 of a3) for (let t2 = 0; t2 < 3; t2++) r3[t2] = Math.min(r3[t2], e3[t2]), o3[t2] = Math.max(o3[t2], e3[t2]);
	          const s3 = li(t.a4 / 2, t.a4 / 2, e2.x, e2.y, e2.z), c2 = t.b3([], [0, 1, 0], s3);
	          t.b2(c2, c2);
	          const h2 = t.b3([], s3, c2);
	          t.b2(h2, h2);
	          const u2 = t.b3([], i3[2], i3[1]);
	          t.b2(u2, u2);
	          const d2 = t.b3([], i3[0], i3[3]);
	          t.b2(d2, d2), a3.push(t.a_([], s3, l2)), e2.y >= (1 << e2.z) / 2 && a3.push(t.a_([], li(t.a4 / 2, 0, e2.x, e2.y, e2.z), l2)), e2.y < (1 << e2.z) / 2 && a3.push(t.a_([], li(t.a4 / 2, t.a4, e2.x, e2.y, e2.z), l2));
	          const _2 = wi(s3, a3), p2 = wi(h2, a3), m2 = [-s3[0], -s3[1], -s3[2], _2.max], f2 = [s3[0], s3[1], s3[2], -_2.min], g2 = [-h2[0], -h2[1], -h2[2], p2.max], v2 = [h2[0], h2[1], h2[2], -p2.min], x2 = [...u2, 0], b2 = [...d2, 0], y2 = [];
	          return 0 === e2.y ? y2.push(t.bC(b2, x2, m2), t.bC(b2, x2, f2)) : y2.push(t.bC(g2, x2, m2), t.bC(g2, x2, f2), t.bC(g2, b2, m2), t.bC(g2, b2, f2)), e2.y === (1 << e2.z) - 1 ? y2.push(t.bC(b2, x2, m2), t.bC(b2, x2, f2)) : y2.push(t.bC(v2, x2, m2), t.bC(v2, x2, f2), t.bC(v2, b2, m2), t.bC(v2, b2, f2)), new vi(y2, [m2, f2, g2, v2, x2, b2], r3, o3);
	        }
	      }
	    }
	    function wi(e2, i2) {
	      let a2 = 1 / 0, r2 = -1 / 0;
	      for (const o2 of i2) {
	        const i3 = t.b4(e2, o2);
	        a2 = Math.min(a2, i3), r2 = Math.max(r2, i3);
	      }
	      return { min: a2, max: r2 };
	    }
	    class Ti {
	      get pixelsToClipSpaceMatrix() {
	        return this._helper.pixelsToClipSpaceMatrix;
	      }
	      get clipSpaceToPixelsMatrix() {
	        return this._helper.clipSpaceToPixelsMatrix;
	      }
	      get pixelsToGLUnits() {
	        return this._helper.pixelsToGLUnits;
	      }
	      get centerOffset() {
	        return this._helper.centerOffset;
	      }
	      get size() {
	        return this._helper.size;
	      }
	      get rotationMatrix() {
	        return this._helper.rotationMatrix;
	      }
	      get centerPoint() {
	        return this._helper.centerPoint;
	      }
	      get pixelsPerMeter() {
	        return this._helper.pixelsPerMeter;
	      }
	      setMinZoom(e2) {
	        this._helper.setMinZoom(e2);
	      }
	      setMaxZoom(e2) {
	        this._helper.setMaxZoom(e2);
	      }
	      setMinPitch(e2) {
	        this._helper.setMinPitch(e2);
	      }
	      setMaxPitch(e2) {
	        this._helper.setMaxPitch(e2);
	      }
	      setRenderWorldCopies(e2) {
	        this._helper.setRenderWorldCopies(e2);
	      }
	      setBearing(e2) {
	        this._helper.setBearing(e2);
	      }
	      setPitch(e2) {
	        this._helper.setPitch(e2);
	      }
	      setRoll(e2) {
	        this._helper.setRoll(e2);
	      }
	      setFov(e2) {
	        this._helper.setFov(e2);
	      }
	      setZoom(e2) {
	        this._helper.setZoom(e2);
	      }
	      setCenter(e2) {
	        this._helper.setCenter(e2);
	      }
	      setElevation(e2) {
	        this._helper.setElevation(e2);
	      }
	      setMinElevationForCurrentTile(e2) {
	        this._helper.setMinElevationForCurrentTile(e2);
	      }
	      setPadding(e2) {
	        this._helper.setPadding(e2);
	      }
	      interpolatePadding(e2, t2, i2) {
	        return this._helper.interpolatePadding(e2, t2, i2);
	      }
	      isPaddingEqual(e2) {
	        return this._helper.isPaddingEqual(e2);
	      }
	      resize(e2, t2) {
	        this._helper.resize(e2, t2);
	      }
	      getMaxBounds() {
	        return this._helper.getMaxBounds();
	      }
	      setMaxBounds(e2) {
	        this._helper.setMaxBounds(e2);
	      }
	      setConstrainOverride(e2) {
	        this._helper.setConstrainOverride(e2);
	      }
	      overrideNearFarZ(e2, t2) {
	        this._helper.overrideNearFarZ(e2, t2);
	      }
	      clearNearFarZOverride() {
	        this._helper.clearNearFarZOverride();
	      }
	      getCameraQueryGeometry(e2) {
	        return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e2);
	      }
	      get tileSize() {
	        return this._helper.tileSize;
	      }
	      get tileZoom() {
	        return this._helper.tileZoom;
	      }
	      get scale() {
	        return this._helper.scale;
	      }
	      get worldSize() {
	        return this._helper.worldSize;
	      }
	      get width() {
	        return this._helper.width;
	      }
	      get height() {
	        return this._helper.height;
	      }
	      get lngRange() {
	        return this._helper.lngRange;
	      }
	      get latRange() {
	        return this._helper.latRange;
	      }
	      get minZoom() {
	        return this._helper.minZoom;
	      }
	      get maxZoom() {
	        return this._helper.maxZoom;
	      }
	      get zoom() {
	        return this._helper.zoom;
	      }
	      get center() {
	        return this._helper.center;
	      }
	      get minPitch() {
	        return this._helper.minPitch;
	      }
	      get maxPitch() {
	        return this._helper.maxPitch;
	      }
	      get pitch() {
	        return this._helper.pitch;
	      }
	      get pitchInRadians() {
	        return this._helper.pitchInRadians;
	      }
	      get roll() {
	        return this._helper.roll;
	      }
	      get rollInRadians() {
	        return this._helper.rollInRadians;
	      }
	      get bearing() {
	        return this._helper.bearing;
	      }
	      get bearingInRadians() {
	        return this._helper.bearingInRadians;
	      }
	      get fov() {
	        return this._helper.fov;
	      }
	      get fovInRadians() {
	        return this._helper.fovInRadians;
	      }
	      get elevation() {
	        return this._helper.elevation;
	      }
	      get minElevationForCurrentTile() {
	        return this._helper.minElevationForCurrentTile;
	      }
	      get padding() {
	        return this._helper.padding;
	      }
	      get unmodified() {
	        return this._helper.unmodified;
	      }
	      get renderWorldCopies() {
	        return this._helper.renderWorldCopies;
	      }
	      get constrainOverride() {
	        return this._helper.constrainOverride;
	      }
	      get nearZ() {
	        return this._helper.nearZ;
	      }
	      get farZ() {
	        return this._helper.farZ;
	      }
	      get autoCalculateNearFarZ() {
	        return this._helper.autoCalculateNearFarZ;
	      }
	      setTransitionState(e2) {
	      }
	      constructor(e2) {
	        this._cachedClippingPlane = t.bE(), this._projectionMatrix = t.bi(), this._globeViewProjMatrix32f = t.bh(), this._globeViewProjMatrixNoCorrection = t.bi(), this._globeViewProjMatrixNoCorrectionInverted = t.bi(), this._globeProjMatrixInverted = t.bi(), this._cameraPosition = t.by(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (e3, i2) => {
	          const a2 = t.an(e3.lat, -t.ao, t.ao), r2 = t.an(+i2, this.minZoom + _i(0, a2), this.maxZoom);
	          return { center: new t.V(e3.lng, a2), zoom: r2 };
	        }, this.applyConstrain = (e3, t2) => this._helper.applyConstrain(e3, t2), this._helper = new Bt({ calcMatrices: () => {
	          this._calcMatrices();
	        }, defaultConstrain: (e3, t2) => this.defaultConstrain(e3, t2) }, e2), this._coveringTilesDetailsProvider = new yi();
	      }
	      clone() {
	        const e2 = new Ti();
	        return e2.apply(this), e2;
	      }
	      apply(e2, t2) {
	        this._globeLatitudeErrorCorrectionRadians = t2 || 0, this._helper.apply(e2);
	      }
	      get projectionMatrix() {
	        return this._projectionMatrix;
	      }
	      get modelViewProjectionMatrix() {
	        return this._globeViewProjMatrixNoCorrection;
	      }
	      get inverseProjectionMatrix() {
	        return this._globeProjMatrixInverted;
	      }
	      get cameraPosition() {
	        const e2 = t.by();
	        return e2[0] = this._cameraPosition[0], e2[1] = this._cameraPosition[1], e2[2] = this._cameraPosition[2], e2;
	      }
	      get cameraToCenterDistance() {
	        return this._helper.cameraToCenterDistance;
	      }
	      getProjectionData(e2) {
	        const { overscaledTileID: t2, applyGlobeMatrix: i2 } = e2, a2 = this._helper.getMercatorTileCoordinates(t2);
	        return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: a2, clippingPlane: this._cachedClippingPlane, projectionTransition: i2 ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
	      }
	      _computeClippingPlane(e2) {
	        const i2 = this.pitchInRadians, a2 = this.cameraToCenterDistance / e2, r2 = Math.sin(i2) * a2, o2 = Math.cos(i2) * a2 + 1, s2 = 1 / Math.sqrt(r2 * r2 + o2 * o2) * 1;
	        let n2 = -r2, l2 = o2;
	        const c2 = Math.sqrt(n2 * n2 + l2 * l2);
	        n2 /= c2, l2 /= c2;
	        const h2 = [0, n2, l2];
	        t.bF(h2, h2, [0, 0, 0], -this.bearingInRadians), t.bG(h2, h2, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), t.bH(h2, h2, [0, 0, 0], this.center.lng * Math.PI / 180);
	        const u2 = 1 / t.b6(h2);
	        return t.a_(h2, h2, u2), [...h2, -s2 * u2];
	      }
	      isLocationOccluded(e2) {
	        return !this.isSurfacePointVisible(ci(e2));
	      }
	      transformLightDirection(e2) {
	        const i2 = this._helper._center.lng * Math.PI / 180, a2 = this._helper._center.lat * Math.PI / 180, r2 = Math.cos(a2), o2 = [Math.sin(i2) * r2, Math.sin(a2), Math.cos(i2) * r2], s2 = [o2[2], 0, -o2[0]], n2 = [0, 0, 0];
	        t.b3(n2, s2, o2), t.b2(s2, s2), t.b2(n2, n2);
	        const l2 = [0, 0, 0];
	        return t.b2(l2, [s2[0] * e2[0] + n2[0] * e2[1] + o2[0] * e2[2], s2[1] * e2[0] + n2[1] * e2[1] + o2[1] * e2[2], s2[2] * e2[0] + n2[2] * e2[1] + o2[2] * e2[2]]), l2;
	      }
	      getPixelScale() {
	        return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
	      }
	      getCircleRadiusCorrection() {
	        return Math.cos(this._helper._center.lat * Math.PI / 180);
	      }
	      getPitchedTextCorrection(e2, i2, a2) {
	        const r2 = function(e3, i3, a3) {
	          const r3 = 1 / (1 << a3.z);
	          return new t.aa(e3 / t.a4 * r3 + a3.x * r3, i3 / t.a4 * r3 + a3.y * r3);
	        }(e2, i2, a2.canonical), o2 = (s2 = r2.y, [t.bx(r2.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - s2 * Math.PI * 2)) - 0.5 * Math.PI]);
	        var s2;
	        return this.getCircleRadiusCorrection() / Math.cos(o2[1]);
	      }
	      projectTileCoordinates(e2, i2, a2, r2) {
	        const o2 = a2.canonical, s2 = li(e2, i2, o2.x, o2.y, o2.z), n2 = 1 + (r2 ? r2(e2, i2) : 0) / t.bD, l2 = [s2[0] * n2, s2[1] * n2, s2[2] * n2, 1];
	        t.aG(l2, l2, this._globeViewProjMatrixNoCorrection);
	        const c2 = this._cachedClippingPlane, h2 = c2[0] * s2[0] + c2[1] * s2[1] + c2[2] * s2[2] + c2[3] < 0;
	        return { point: new t.P(l2[0] / l2[3], l2[1] / l2[3]), signedDistanceFromCamera: l2[3], isOccluded: h2 };
	      }
	      _calcMatrices() {
	        if (!this._helper._width || !this._helper._height) return;
	        const e2 = hi(this.worldSize, this.center.lat), i2 = t.bj(), a2 = t.bj();
	        this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * e2), t.bd(i2, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
	        const r2 = this.centerOffset;
	        i2[8] = 2 * -r2.x / this._helper._width, i2[9] = 2 * r2.y / this._helper._height, this._projectionMatrix = t.be(i2), this._globeProjMatrixInverted = t.bj(), t.aA(this._globeProjMatrixInverted, i2), t.O(i2, i2, [0, 0, -this.cameraToCenterDistance]), t.bf(i2, i2, this.rollInRadians), t.bg(i2, i2, -this.pitchInRadians), t.bf(i2, i2, this.bearingInRadians), t.O(i2, i2, [0, 0, -e2]);
	        const o2 = t.by();
	        o2[0] = e2, o2[1] = e2, o2[2] = e2, t.bg(a2, i2, this.center.lat * Math.PI / 180), t.bI(a2, a2, -this.center.lng * Math.PI / 180), t.Q(a2, a2, o2), this._globeViewProjMatrixNoCorrection = a2, t.bg(i2, i2, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), t.bI(i2, i2, -this.center.lng * Math.PI / 180), t.Q(i2, i2, o2), this._globeViewProjMatrix32f = new Float32Array(i2), this._globeViewProjMatrixNoCorrectionInverted = t.bj(), t.aA(this._globeViewProjMatrixNoCorrectionInverted, a2);
	        const s2 = t.by();
	        this._cameraPosition = t.by(), this._cameraPosition[2] = this.cameraToCenterDistance / e2, t.bF(this._cameraPosition, this._cameraPosition, s2, -this.rollInRadians), t.bG(this._cameraPosition, this._cameraPosition, s2, this.pitchInRadians), t.bF(this._cameraPosition, this._cameraPosition, s2, -this.bearingInRadians), t.a$(this._cameraPosition, this._cameraPosition, [0, 0, 1]), t.bG(this._cameraPosition, this._cameraPosition, s2, -this.center.lat * Math.PI / 180), t.bH(this._cameraPosition, this._cameraPosition, s2, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e2);
	        const n2 = t.be(this._globeViewProjMatrixNoCorrectionInverted);
	        t.Q(n2, n2, [1, 1, -1]), this._cachedFrustum = Nt.fromInvProjectionMatrix(n2, 1, 0, this._cachedClippingPlane, true);
	      }
	      calculateFogMatrix(e2) {
	        t.w("calculateFogMatrix is not supported on globe projection.");
	        const i2 = t.bj();
	        return t.ar(i2), i2;
	      }
	      getVisibleUnwrappedCoordinates(e2) {
	        return [new t.bb(0, e2)];
	      }
	      getCameraFrustum() {
	        return this._cachedFrustum;
	      }
	      getClippingPlane() {
	        return this._cachedClippingPlane;
	      }
	      getCoveringTilesDetailsProvider() {
	        return this._coveringTilesDetailsProvider;
	      }
	      recalculateZoomAndCenter(e2) {
	        e2 && t.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
	      }
	      maxPitchScaleFactor() {
	        return 1;
	      }
	      getCameraPoint() {
	        return this._helper.getCameraPoint();
	      }
	      getCameraAltitude() {
	        return this._helper.getCameraAltitude();
	      }
	      getCameraLngLat() {
	        return this._helper.getCameraLngLat();
	      }
	      lngLatToCameraDepth(e2, i2) {
	        if (!this._globeViewProjMatrixNoCorrection) return 1;
	        const a2 = ci(e2);
	        t.a_(a2, a2, 1 + i2 / t.bD);
	        const r2 = t.bE();
	        return t.aG(r2, [a2[0], a2[1], a2[2], 1], this._globeViewProjMatrixNoCorrection), r2[2] / r2[3];
	      }
	      populateCache(e2) {
	      }
	      getBounds() {
	        const e2 = 0.5 * this.width, i2 = 0.5 * this.height, a2 = [new t.P(0, 0), new t.P(e2, 0), new t.P(this.width, 0), new t.P(this.width, i2), new t.P(this.width, this.height), new t.P(e2, this.height), new t.P(0, this.height), new t.P(0, i2)], r2 = [];
	        for (const e3 of a2) r2.push(this.unprojectScreenPoint(e3));
	        let o2 = 0, s2 = 0, n2 = 0, l2 = 0;
	        const c2 = this.center;
	        for (const e3 of r2) {
	          const i3 = t.bJ(c2.lng, e3.lng), a3 = t.bJ(c2.lat, e3.lat);
	          i3 < s2 && (s2 = i3), i3 > o2 && (o2 = i3), a3 < l2 && (l2 = a3), a3 > n2 && (n2 = a3);
	        }
	        const h2 = [c2.lng + s2, c2.lat + l2, c2.lng + o2, c2.lat + n2];
	        return this.isSurfacePointOnScreen([0, 1, 0]) && (h2[3] = 90, h2[0] = -180, h2[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (h2[1] = -90, h2[0] = -180, h2[2] = 180), new $(h2);
	      }
	      calculateCenterFromCameraLngLatAlt(e2, t2, i2, a2) {
	        return this._helper.calculateCenterFromCameraLngLatAlt(e2, t2, i2, a2);
	      }
	      setLocationAtPoint(e2, i2) {
	        const a2 = ci(this.unprojectScreenPoint(i2)), r2 = ci(e2), o2 = t.by();
	        t.bK(o2);
	        const s2 = t.by();
	        t.bH(s2, a2, o2, -this.center.lng * Math.PI / 180), t.bG(s2, s2, o2, this.center.lat * Math.PI / 180);
	        const n2 = r2[0] * r2[0] + r2[2] * r2[2], l2 = s2[0] * s2[0];
	        if (n2 < l2) return;
	        const c2 = Math.sqrt(n2 - l2), h2 = -c2, u2 = t.bL(r2[0], r2[2], s2[0], c2), d2 = t.bL(r2[0], r2[2], s2[0], h2), _2 = t.by();
	        t.bH(_2, r2, o2, -u2);
	        const p2 = t.bL(_2[1], _2[2], s2[1], s2[2]), m2 = t.by();
	        t.bH(m2, r2, o2, -d2);
	        const f2 = t.bL(m2[1], m2[2], s2[1], s2[2]), g2 = 0.5 * Math.PI, v2 = p2 >= -g2 && p2 <= g2, x2 = f2 >= -g2 && f2 <= g2;
	        let b2, y2;
	        if (v2 && x2) {
	          const e3 = this.center.lng * Math.PI / 180, i3 = this.center.lat * Math.PI / 180;
	          t.bM(u2, e3) + t.bM(p2, i3) < t.bM(d2, e3) + t.bM(f2, i3) ? (b2 = u2, y2 = p2) : (b2 = d2, y2 = f2);
	        } else if (v2) b2 = u2, y2 = p2;
	        else {
	          if (!x2) return;
	          b2 = d2, y2 = f2;
	        }
	        const w2 = b2 / Math.PI * 180, T2 = y2 / Math.PI * 180, P2 = this.center.lat;
	        this.setCenter(new t.V(w2, t.an(T2, -90, 90))), this.setZoom(this.zoom + _i(P2, this.center.lat));
	      }
	      locationToScreenPoint(e2, i2) {
	        const a2 = ci(e2);
	        if (i2) {
	          const r2 = i2.getElevationForLngLatZoom(e2, this._helper._tileZoom);
	          t.a_(a2, a2, 1 + r2 / t.bD);
	        }
	        return this._projectSurfacePointToScreen(a2);
	      }
	      _projectSurfacePointToScreen(e2) {
	        const i2 = t.bE();
	        return t.aG(i2, [...e2, 1], this._globeViewProjMatrixNoCorrection), i2[0] /= i2[3], i2[1] /= i2[3], new t.P((0.5 * i2[0] + 0.5) * this.width, (0.5 * -i2[1] + 0.5) * this.height);
	      }
	      screenPointToMercatorCoordinate(e2, i2) {
	        if (i2) {
	          const t2 = i2.pointCoordinate(e2);
	          if (t2) return t2;
	        }
	        return t.aa.fromLngLat(this.unprojectScreenPoint(e2));
	      }
	      screenPointToLocation(e2, t2) {
	        var i2;
	        return null === (i2 = this.screenPointToMercatorCoordinate(e2, t2)) || void 0 === i2 ? void 0 : i2.toLngLat();
	      }
	      isPointOnMapSurface(e2, t2) {
	        const i2 = this._cameraPosition, a2 = this.getRayDirectionFromPixel(e2);
	        return !!this.rayPlanetIntersection(i2, a2);
	      }
	      getRayDirectionFromPixel(e2) {
	        const i2 = t.bE();
	        i2[0] = e2.x / this.width * 2 - 1, i2[1] = -1 * (e2.y / this.height * 2 - 1), i2[2] = 1, i2[3] = 1, t.aG(i2, i2, this._globeViewProjMatrixNoCorrectionInverted), i2[0] /= i2[3], i2[1] /= i2[3], i2[2] /= i2[3];
	        const a2 = t.by();
	        a2[0] = i2[0] - this._cameraPosition[0], a2[1] = i2[1] - this._cameraPosition[1], a2[2] = i2[2] - this._cameraPosition[2];
	        const r2 = t.by();
	        return t.b2(r2, a2), r2;
	      }
	      isSurfacePointVisible(e2) {
	        const t2 = this._cachedClippingPlane;
	        return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2] + t2[3] >= 0;
	      }
	      isSurfacePointOnScreen(e2) {
	        if (!this.isSurfacePointVisible(e2)) return false;
	        const i2 = t.bE();
	        return t.aG(i2, [...e2, 1], this._globeViewProjMatrixNoCorrection), i2[0] /= i2[3], i2[1] /= i2[3], i2[2] /= i2[3], i2[0] > -1 && i2[0] < 1 && i2[1] > -1 && i2[1] < 1 && i2[2] > -1 && i2[2] < 1;
	      }
	      rayPlanetIntersection(e2, i2) {
	        const a2 = t.b4(e2, i2), r2 = t.by(), o2 = t.by();
	        t.a_(o2, i2, a2), t.b1(r2, e2, o2);
	        const s2 = 1 - t.b4(r2, r2);
	        if (s2 < 0) return null;
	        const n2 = t.b4(e2, e2) - 1, l2 = -a2 + (a2 < 0 ? 1 : -1) * Math.sqrt(s2), c2 = n2 / l2, h2 = l2;
	        return { tMin: Math.min(c2, h2), tMax: Math.max(c2, h2) };
	      }
	      unprojectScreenPoint(e2) {
	        const i2 = this._cameraPosition, a2 = this.getRayDirectionFromPixel(e2), r2 = this.rayPlanetIntersection(i2, a2);
	        if (r2) {
	          const e3 = t.by();
	          t.a$(e3, i2, [a2[0] * r2.tMin, a2[1] * r2.tMin, a2[2] * r2.tMin]);
	          const o3 = t.by();
	          return t.b2(o3, e3), ui(o3);
	        }
	        const o2 = this._cachedClippingPlane, s2 = o2[0] * a2[0] + o2[1] * a2[1] + o2[2] * a2[2], n2 = -t.ba(o2, i2) / s2, l2 = t.by();
	        if (n2 > 0) t.a$(l2, i2, [a2[0] * n2, a2[1] * n2, a2[2] * n2]);
	        else {
	          const e3 = t.by();
	          t.a$(e3, i2, [2 * a2[0], 2 * a2[1], 2 * a2[2]]);
	          const r3 = t.ba(this._cachedClippingPlane, e3);
	          t.b1(l2, e3, [this._cachedClippingPlane[0] * r3, this._cachedClippingPlane[1] * r3, this._cachedClippingPlane[2] * r3]);
	        }
	        const c2 = function(e3) {
	          const i3 = t.by();
	          return i3[0] = e3[0] * -e3[3], i3[1] = e3[1] * -e3[3], i3[2] = e3[2] * -e3[3], { center: i3, radius: Math.sqrt(1 - e3[3] * e3[3]) };
	        }(o2);
	        return ui(function(e3, i3, a3) {
	          const r3 = t.by();
	          t.b1(r3, a3, e3);
	          const o3 = t.by();
	          return t.bz(o3, e3, r3, i3 / t.b8(r3)), o3;
	        }(c2.center, c2.radius, l2));
	      }
	      getMatrixForModel(e2, i2) {
	        const a2 = t.V.convert(e2), r2 = 1 / t.bD, o2 = t.bi();
	        return t.bI(o2, o2, a2.lng / 180 * Math.PI), t.bg(o2, o2, -a2.lat / 180 * Math.PI), t.O(o2, o2, [0, 0, 1 + i2 / t.bD]), t.bg(o2, o2, 0.5 * Math.PI), t.Q(o2, o2, [r2, r2, r2]), o2;
	      }
	      getProjectionDataForCustomLayer(e2 = true) {
	        const i2 = this.getProjectionData({ overscaledTileID: new t.a1(0, 0, 0, 0, 0), applyGlobeMatrix: e2 });
	        return i2.tileMercatorCoords = [0, 0, 1, 1], i2;
	      }
	      getFastPathSimpleProjectionMatrix(e2) {
	      }
	    }
	    class Pi {
	      get pixelsToClipSpaceMatrix() {
	        return this._helper.pixelsToClipSpaceMatrix;
	      }
	      get clipSpaceToPixelsMatrix() {
	        return this._helper.clipSpaceToPixelsMatrix;
	      }
	      get pixelsToGLUnits() {
	        return this._helper.pixelsToGLUnits;
	      }
	      get centerOffset() {
	        return this._helper.centerOffset;
	      }
	      get size() {
	        return this._helper.size;
	      }
	      get rotationMatrix() {
	        return this._helper.rotationMatrix;
	      }
	      get centerPoint() {
	        return this._helper.centerPoint;
	      }
	      get pixelsPerMeter() {
	        return this._helper.pixelsPerMeter;
	      }
	      setMinZoom(e2) {
	        this._helper.setMinZoom(e2);
	      }
	      setMaxZoom(e2) {
	        this._helper.setMaxZoom(e2);
	      }
	      setMinPitch(e2) {
	        this._helper.setMinPitch(e2);
	      }
	      setMaxPitch(e2) {
	        this._helper.setMaxPitch(e2);
	      }
	      setRenderWorldCopies(e2) {
	        this._helper.setRenderWorldCopies(e2);
	      }
	      setBearing(e2) {
	        this._helper.setBearing(e2);
	      }
	      setPitch(e2) {
	        this._helper.setPitch(e2);
	      }
	      setRoll(e2) {
	        this._helper.setRoll(e2);
	      }
	      setFov(e2) {
	        this._helper.setFov(e2);
	      }
	      setZoom(e2) {
	        this._helper.setZoom(e2);
	      }
	      setCenter(e2) {
	        this._helper.setCenter(e2);
	      }
	      setElevation(e2) {
	        this._helper.setElevation(e2);
	      }
	      setMinElevationForCurrentTile(e2) {
	        this._helper.setMinElevationForCurrentTile(e2);
	      }
	      setPadding(e2) {
	        this._helper.setPadding(e2);
	      }
	      interpolatePadding(e2, t2, i2) {
	        return this._helper.interpolatePadding(e2, t2, i2);
	      }
	      isPaddingEqual(e2) {
	        return this._helper.isPaddingEqual(e2);
	      }
	      resize(e2, t2, i2 = true) {
	        this._helper.resize(e2, t2, i2);
	      }
	      getMaxBounds() {
	        return this._helper.getMaxBounds();
	      }
	      setMaxBounds(e2) {
	        this._helper.setMaxBounds(e2);
	      }
	      setConstrainOverride(e2) {
	        this._helper.setConstrainOverride(e2);
	      }
	      overrideNearFarZ(e2, t2) {
	        this._helper.overrideNearFarZ(e2, t2);
	      }
	      clearNearFarZOverride() {
	        this._helper.clearNearFarZOverride();
	      }
	      getCameraQueryGeometry(e2) {
	        return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e2);
	      }
	      get tileSize() {
	        return this._helper.tileSize;
	      }
	      get tileZoom() {
	        return this._helper.tileZoom;
	      }
	      get scale() {
	        return this._helper.scale;
	      }
	      get worldSize() {
	        return this._helper.worldSize;
	      }
	      get width() {
	        return this._helper.width;
	      }
	      get height() {
	        return this._helper.height;
	      }
	      get lngRange() {
	        return this._helper.lngRange;
	      }
	      get latRange() {
	        return this._helper.latRange;
	      }
	      get minZoom() {
	        return this._helper.minZoom;
	      }
	      get maxZoom() {
	        return this._helper.maxZoom;
	      }
	      get zoom() {
	        return this._helper.zoom;
	      }
	      get center() {
	        return this._helper.center;
	      }
	      get minPitch() {
	        return this._helper.minPitch;
	      }
	      get maxPitch() {
	        return this._helper.maxPitch;
	      }
	      get pitch() {
	        return this._helper.pitch;
	      }
	      get pitchInRadians() {
	        return this._helper.pitchInRadians;
	      }
	      get roll() {
	        return this._helper.roll;
	      }
	      get rollInRadians() {
	        return this._helper.rollInRadians;
	      }
	      get bearing() {
	        return this._helper.bearing;
	      }
	      get bearingInRadians() {
	        return this._helper.bearingInRadians;
	      }
	      get fov() {
	        return this._helper.fov;
	      }
	      get fovInRadians() {
	        return this._helper.fovInRadians;
	      }
	      get elevation() {
	        return this._helper.elevation;
	      }
	      get minElevationForCurrentTile() {
	        return this._helper.minElevationForCurrentTile;
	      }
	      get padding() {
	        return this._helper.padding;
	      }
	      get unmodified() {
	        return this._helper.unmodified;
	      }
	      get renderWorldCopies() {
	        return this._helper.renderWorldCopies;
	      }
	      get cameraToCenterDistance() {
	        return this._helper.cameraToCenterDistance;
	      }
	      get constrainOverride() {
	        return this._helper.constrainOverride;
	      }
	      get nearZ() {
	        return this._helper.nearZ;
	      }
	      get farZ() {
	        return this._helper.farZ;
	      }
	      get autoCalculateNearFarZ() {
	        return this._helper.autoCalculateNearFarZ;
	      }
	      get isGlobeRendering() {
	        return this._globeness > 0;
	      }
	      setTransitionState(e2, t2) {
	        this._globeness = e2, this._globeLatitudeErrorCorrectionRadians = t2, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
	      }
	      get currentTransform() {
	        return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
	      }
	      constructor(e2) {
	        this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (e3, t2) => this.currentTransform.defaultConstrain(e3, t2), this.applyConstrain = (e3, t2) => this._helper.applyConstrain(e3, t2), this._helper = new Bt({ calcMatrices: () => {
	          this._calcMatrices();
	        }, defaultConstrain: (e3, t2) => this.defaultConstrain(e3, t2) }, e2), this._globeness = 1, this._mercatorTransform = new Zt(), this._verticalPerspectiveTransform = new Ti();
	      }
	      clone() {
	        const e2 = new Pi();
	        return e2._globeness = this._globeness, e2._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e2.apply(this), e2;
	      }
	      apply(e2) {
	        this._helper.apply(e2), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
	      }
	      get projectionMatrix() {
	        return this.currentTransform.projectionMatrix;
	      }
	      get modelViewProjectionMatrix() {
	        return this.currentTransform.modelViewProjectionMatrix;
	      }
	      get inverseProjectionMatrix() {
	        return this.currentTransform.inverseProjectionMatrix;
	      }
	      get cameraPosition() {
	        return this.currentTransform.cameraPosition;
	      }
	      getProjectionData(e2) {
	        const t2 = this._mercatorTransform.getProjectionData(e2), i2 = this._verticalPerspectiveTransform.getProjectionData(e2);
	        return { mainMatrix: this.isGlobeRendering ? i2.mainMatrix : t2.mainMatrix, clippingPlane: i2.clippingPlane, tileMercatorCoords: i2.tileMercatorCoords, projectionTransition: e2.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: t2.fallbackMatrix };
	      }
	      isLocationOccluded(e2) {
	        return this.currentTransform.isLocationOccluded(e2);
	      }
	      transformLightDirection(e2) {
	        return this.currentTransform.transformLightDirection(e2);
	      }
	      getPixelScale() {
	        return t.bt(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
	      }
	      getCircleRadiusCorrection() {
	        return t.bt(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
	      }
	      getPitchedTextCorrection(e2, i2, a2) {
	        const r2 = this._mercatorTransform.getPitchedTextCorrection(e2, i2, a2), o2 = this._verticalPerspectiveTransform.getPitchedTextCorrection(e2, i2, a2);
	        return t.bt(r2, o2, this._globeness);
	      }
	      projectTileCoordinates(e2, t2, i2, a2) {
	        return this.currentTransform.projectTileCoordinates(e2, t2, i2, a2);
	      }
	      _calcMatrices() {
	        this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, true, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
	      }
	      calculateFogMatrix(e2) {
	        return this.currentTransform.calculateFogMatrix(e2);
	      }
	      getVisibleUnwrappedCoordinates(e2) {
	        return this.currentTransform.getVisibleUnwrappedCoordinates(e2);
	      }
	      getCameraFrustum() {
	        return this.currentTransform.getCameraFrustum();
	      }
	      getClippingPlane() {
	        return this.currentTransform.getClippingPlane();
	      }
	      getCoveringTilesDetailsProvider() {
	        return this.currentTransform.getCoveringTilesDetailsProvider();
	      }
	      recalculateZoomAndCenter(e2) {
	        this._mercatorTransform.recalculateZoomAndCenter(e2), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e2);
	      }
	      maxPitchScaleFactor() {
	        return this._mercatorTransform.maxPitchScaleFactor();
	      }
	      getCameraPoint() {
	        return this._helper.getCameraPoint();
	      }
	      getCameraAltitude() {
	        return this._helper.getCameraAltitude();
	      }
	      getCameraLngLat() {
	        return this._helper.getCameraLngLat();
	      }
	      lngLatToCameraDepth(e2, t2) {
	        return this.currentTransform.lngLatToCameraDepth(e2, t2);
	      }
	      populateCache(e2) {
	        this._mercatorTransform.populateCache(e2), this._verticalPerspectiveTransform.populateCache(e2);
	      }
	      getBounds() {
	        return this.currentTransform.getBounds();
	      }
	      calculateCenterFromCameraLngLatAlt(e2, t2, i2, a2) {
	        return this._helper.calculateCenterFromCameraLngLatAlt(e2, t2, i2, a2);
	      }
	      setLocationAtPoint(e2, t2) {
	        if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e2, t2), void this.apply(this._mercatorTransform);
	        this._verticalPerspectiveTransform.setLocationAtPoint(e2, t2), this.apply(this._verticalPerspectiveTransform);
	      }
	      locationToScreenPoint(e2, t2) {
	        return this.currentTransform.locationToScreenPoint(e2, t2);
	      }
	      screenPointToMercatorCoordinate(e2, t2) {
	        return this.currentTransform.screenPointToMercatorCoordinate(e2, t2);
	      }
	      screenPointToLocation(e2, t2) {
	        return this.currentTransform.screenPointToLocation(e2, t2);
	      }
	      isPointOnMapSurface(e2, t2) {
	        return this.currentTransform.isPointOnMapSurface(e2, t2);
	      }
	      getRayDirectionFromPixel(e2) {
	        return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e2);
	      }
	      getMatrixForModel(e2, t2) {
	        return this.currentTransform.getMatrixForModel(e2, t2);
	      }
	      getProjectionDataForCustomLayer(e2 = true) {
	        const t2 = this._mercatorTransform.getProjectionDataForCustomLayer(e2);
	        if (!this.isGlobeRendering) return t2;
	        const i2 = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e2);
	        return i2.fallbackMatrix = t2.mainMatrix, i2;
	      }
	      getFastPathSimpleProjectionMatrix(e2) {
	        return this.currentTransform.getFastPathSimpleProjectionMatrix(e2);
	      }
	    }
	    class Ci {
	      get useGlobeControls() {
	        return true;
	      }
	      handlePanInertia(e2, i2) {
	        const a2 = pi(e2, i2);
	        return Math.abs(a2.lng - i2.center.lng) > 180 && (a2.lng = i2.center.lng + 179.5 * Math.sign(a2.lng - i2.center.lng)), { easingCenter: a2, easingOffset: new t.P(0, 0) };
	      }
	      handleMapControlsRollPitchBearingZoom(e2, i2) {
	        const a2 = e2.around, r2 = i2.screenPointToLocation(a2);
	        e2.bearingDelta && i2.setBearing(i2.bearing + e2.bearingDelta), e2.pitchDelta && i2.setPitch(i2.pitch + e2.pitchDelta), e2.rollDelta && i2.setRoll(i2.roll + e2.rollDelta);
	        const o2 = i2.zoom;
	        e2.zoomDelta && i2.setZoom(i2.zoom + e2.zoomDelta);
	        const s2 = i2.zoom - o2;
	        if (0 === s2) return;
	        const n2 = t.bJ(i2.center.lng, r2.lng), l2 = n2 / (Math.abs(n2 / 180) + 1), c2 = t.bJ(i2.center.lat, r2.lat), h2 = i2.getRayDirectionFromPixel(a2), u2 = i2.cameraPosition, d2 = -1 * t.b4(u2, h2), _2 = t.by();
	        t.a$(_2, u2, [h2[0] * d2, h2[1] * d2, h2[2] * d2]);
	        const p2 = t.b6(_2) - 1, m2 = Math.exp(0.5 * -Math.max(p2 - 0.3, 0)), f2 = hi(i2.worldSize, i2.center.lat) / Math.min(i2.width, i2.height), g2 = t.bw(f2, 0.9, 0.5, 1, 0.25), v2 = (1 - t.aq(-s2)) * Math.min(m2, g2), x2 = i2.center.lat, b2 = i2.zoom, y2 = new t.V(i2.center.lng + l2 * v2, t.an(i2.center.lat + c2 * v2, -t.ao, t.ao));
	        i2.setLocationAtPoint(r2, a2);
	        const w2 = i2.center, T2 = t.bw(Math.abs(n2), 45, 85, 0, 1), P2 = t.bw(f2, 0.75, 0.35, 0, 1), C2 = Math.pow(Math.max(T2, P2), 0.25), M2 = t.bJ(w2.lng, y2.lng), I2 = t.bJ(w2.lat, y2.lat);
	        i2.setCenter(new t.V(w2.lng + M2 * C2, w2.lat + I2 * C2).wrap()), i2.setZoom(b2 + _i(x2, i2.center.lat));
	      }
	      handleMapControlsPan(e2, t2, i2) {
	        if (!e2.panDelta) return;
	        const a2 = t2.center.lat, r2 = t2.zoom;
	        t2.setCenter(pi(e2.panDelta, t2).wrap()), t2.setZoom(r2 + _i(a2, t2.center.lat));
	      }
	      cameraForBoxAndBearing(e2, i2, a2, r2, o2) {
	        const s2 = Vt(e2, i2, a2, r2, o2), n2 = i2.left / o2.width * 2 - 1, l2 = (o2.width - i2.right) / o2.width * 2 - 1, c2 = i2.top / o2.height * -2 + 1, h2 = (o2.height - i2.bottom) / o2.height * -2 + 1, u2 = t.bJ(a2.getWest(), a2.getEast()) < 0, d2 = u2 ? a2.getEast() : a2.getWest(), _2 = u2 ? a2.getWest() : a2.getEast(), p2 = Math.max(a2.getNorth(), a2.getSouth()), m2 = Math.min(a2.getNorth(), a2.getSouth()), f2 = d2 + 0.5 * t.bJ(d2, _2), g2 = p2 + 0.5 * t.bJ(p2, m2), v2 = o2.clone();
	        v2.setCenter(s2.center), v2.setBearing(s2.bearing), v2.setPitch(0), v2.setRoll(0), v2.setZoom(s2.zoom);
	        const x2 = v2.modelViewProjectionMatrix, b2 = [ci(a2.getNorthWest()), ci(a2.getNorthEast()), ci(a2.getSouthWest()), ci(a2.getSouthEast()), ci(new t.V(_2, g2)), ci(new t.V(d2, g2)), ci(new t.V(f2, p2)), ci(new t.V(f2, m2))], y2 = ci(s2.center);
	        let w2 = Number.POSITIVE_INFINITY;
	        for (const e3 of b2) n2 < 0 && (w2 = Ci.getLesserNonNegativeNonNull(w2, Ci.solveVectorScale(e3, y2, x2, "x", n2))), l2 > 0 && (w2 = Ci.getLesserNonNegativeNonNull(w2, Ci.solveVectorScale(e3, y2, x2, "x", l2))), c2 > 0 && (w2 = Ci.getLesserNonNegativeNonNull(w2, Ci.solveVectorScale(e3, y2, x2, "y", c2))), h2 < 0 && (w2 = Ci.getLesserNonNegativeNonNull(w2, Ci.solveVectorScale(e3, y2, x2, "y", h2)));
	        if (Number.isFinite(w2) && 0 !== w2) return s2.zoom = v2.zoom + t.at(w2), s2;
	        Gt();
	      }
	      handleJumpToCenterZoom(e2, i2) {
	        const a2 = e2.center.lat, r2 = e2.applyConstrain(i2.center ? t.V.convert(i2.center) : e2.center, e2.zoom).center;
	        e2.setCenter(r2.wrap());
	        const o2 = void 0 !== i2.zoom ? +i2.zoom : e2.zoom + _i(a2, r2.lat);
	        e2.zoom !== o2 && e2.setZoom(o2);
	      }
	      handleEaseTo(e2, i2) {
	        const a2 = e2.zoom, r2 = e2.center, o2 = e2.padding, s2 = { roll: e2.roll, pitch: e2.pitch, bearing: e2.bearing }, n2 = { roll: void 0 === i2.roll ? e2.roll : i2.roll, pitch: void 0 === i2.pitch ? e2.pitch : i2.pitch, bearing: void 0 === i2.bearing ? e2.bearing : i2.bearing }, l2 = void 0 !== i2.zoom, c2 = !e2.isPaddingEqual(i2.padding);
	        let h2 = false;
	        const u2 = i2.center ? t.V.convert(i2.center) : r2, d2 = e2.applyConstrain(u2, a2).center;
	        kt(e2, d2);
	        const _2 = e2.clone();
	        _2.setCenter(d2), _2.setZoom(l2 ? +i2.zoom : a2 + _i(r2.lat, u2.lat)), _2.setBearing(i2.bearing);
	        const p2 = new t.P(t.an(e2.centerPoint.x + i2.offsetAsPoint.x, 0, e2.width), t.an(e2.centerPoint.y + i2.offsetAsPoint.y, 0, e2.height));
	        _2.setLocationAtPoint(d2, p2);
	        const m2 = (i2.offset && i2.offsetAsPoint.mag()) > 0 ? _2.center : d2, f2 = l2 ? +i2.zoom : a2 + _i(r2.lat, m2.lat), g2 = a2 + _i(r2.lat, 0), v2 = f2 + _i(m2.lat, 0), x2 = t.bJ(r2.lng, m2.lng), b2 = t.bJ(r2.lat, m2.lat), y2 = t.aq(v2 - g2);
	        return h2 = f2 !== a2, { easeFunc: (a3) => {
	          if (t.bn(s2, n2) || Ut({ startEulerAngles: s2, endEulerAngles: n2, tr: e2, k: a3, useSlerp: s2.roll != n2.roll }), c2 && e2.interpolatePadding(o2, i2.padding, a3), i2.around) t.w("Easing around a point is not supported under globe projection."), e2.setLocationAtPoint(i2.around, i2.aroundPoint);
	          else {
	            const t2 = v2 > g2 ? Math.min(2, y2) : Math.max(0.5, y2), i3 = Math.pow(t2, 1 - a3), o3 = fi(r2, x2, b2, a3 * i3);
	            e2.setCenter(o3.wrap());
	          }
	          if (h2) {
	            const i3 = t.G.number(g2, v2, a3) + _i(0, e2.center.lat);
	            e2.setZoom(i3);
	          }
	        }, isZooming: h2, elevationCenter: m2 };
	      }
	      handleFlyTo(e2, i2) {
	        const a2 = void 0 !== i2.zoom, r2 = e2.center, o2 = e2.zoom, s2 = e2.padding, n2 = !e2.isPaddingEqual(i2.padding), l2 = e2.applyConstrain(t.V.convert(i2.center || i2.locationAtOffset), o2).center, c2 = a2 ? +i2.zoom : e2.zoom + _i(e2.center.lat, l2.lat), h2 = e2.clone();
	        h2.setCenter(l2), h2.setZoom(c2), h2.setBearing(i2.bearing);
	        const u2 = new t.P(t.an(e2.centerPoint.x + i2.offsetAsPoint.x, 0, e2.width), t.an(e2.centerPoint.y + i2.offsetAsPoint.y, 0, e2.height));
	        h2.setLocationAtPoint(l2, u2);
	        const d2 = h2.center;
	        kt(e2, d2);
	        const _2 = function(e3, i3, a3) {
	          const r3 = ci(i3), o3 = ci(a3), s3 = t.b4(r3, o3), n3 = Math.acos(s3), l3 = ni(e3);
	          return n3 / (2 * Math.PI) * l3;
	        }(e2, r2, d2), p2 = o2 + _i(r2.lat, 0), m2 = c2 + _i(d2.lat, 0), f2 = t.aq(m2 - p2);
	        let g2;
	        if ("number" == typeof i2.minZoom) {
	          const a3 = +i2.minZoom + _i(d2.lat, 0), r3 = Math.min(a3, p2, m2) + _i(0, d2.lat), o3 = e2.applyConstrain(d2, r3).zoom + _i(d2.lat, 0);
	          g2 = t.aq(o3 - p2);
	        }
	        const v2 = t.bJ(r2.lng, d2.lng), x2 = t.bJ(r2.lat, d2.lat);
	        return { easeFunc: (a3, o3, l3, h3) => {
	          const u3 = fi(r2, v2, x2, l3);
	          n2 && e2.interpolatePadding(s2, i2.padding, a3);
	          const _3 = 1 === a3 ? d2 : u3;
	          e2.setCenter(_3.wrap());
	          const m3 = p2 + t.at(o3);
	          e2.setZoom(1 === a3 ? c2 : m3 + _i(0, _3.lat));
	        }, scaleOfZoom: f2, targetCenter: d2, scaleOfMinZoom: g2, pixelPathLength: _2 };
	      }
	      static solveVectorScale(e2, t2, i2, a2, r2) {
	        const o2 = "x" === a2 ? [i2[0], i2[4], i2[8], i2[12]] : [i2[1], i2[5], i2[9], i2[13]], s2 = [i2[3], i2[7], i2[11], i2[15]], n2 = e2[0] * o2[0] + e2[1] * o2[1] + e2[2] * o2[2], l2 = e2[0] * s2[0] + e2[1] * s2[1] + e2[2] * s2[2], c2 = t2[0] * o2[0] + t2[1] * o2[1] + t2[2] * o2[2], h2 = t2[0] * s2[0] + t2[1] * s2[1] + t2[2] * s2[2];
	        return c2 + r2 * l2 === n2 + r2 * h2 || s2[3] * (n2 - c2) + o2[3] * (h2 - l2) + n2 * h2 == c2 * l2 ? null : (c2 + o2[3] - r2 * h2 - r2 * s2[3]) / (c2 - n2 - r2 * h2 + r2 * l2);
	      }
	      static getLesserNonNegativeNonNull(e2, t2) {
	        return null !== t2 && t2 >= 0 && t2 < e2 ? t2 : e2;
	      }
	    }
	    class Mi {
	      constructor(e2) {
	        this._globe = e2, this._mercatorCameraHelper = new qt(), this._verticalPerspectiveCameraHelper = new Ci();
	      }
	      get useGlobeControls() {
	        return this._globe.useGlobeRendering;
	      }
	      get currentHelper() {
	        return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
	      }
	      handlePanInertia(e2, t2) {
	        return this.currentHelper.handlePanInertia(e2, t2);
	      }
	      handleMapControlsRollPitchBearingZoom(e2, t2) {
	        return this.currentHelper.handleMapControlsRollPitchBearingZoom(e2, t2);
	      }
	      handleMapControlsPan(e2, t2, i2) {
	        this.currentHelper.handleMapControlsPan(e2, t2, i2);
	      }
	      cameraForBoxAndBearing(e2, t2, i2, a2, r2) {
	        return this.currentHelper.cameraForBoxAndBearing(e2, t2, i2, a2, r2);
	      }
	      handleJumpToCenterZoom(e2, t2) {
	        this.currentHelper.handleJumpToCenterZoom(e2, t2);
	      }
	      handleEaseTo(e2, t2) {
	        return this.currentHelper.handleEaseTo(e2, t2);
	      }
	      handleFlyTo(e2, t2) {
	        return this.currentHelper.handleFlyTo(e2, t2);
	      }
	    }
	    const Ii = (e2, i2) => t.B(e2, i2 && i2.filter((e3) => "source.canvas" !== e3.identifier)), Ei = t.bN();
	    class Si extends t.E {
	      constructor(e2, i2 = {}) {
	        var a2, r2;
	        super(), this._rtlPluginLoaded = () => {
	          for (const e3 in this.tileManagers) {
	            const t2 = this.tileManagers[e3].getSource().type;
	            "vector" !== t2 && "geojson" !== t2 || this.tileManagers[e3].reload();
	          }
	        }, this.map = e2, this.dispatcher = new N(j(), e2._getMapId()), this.dispatcher.registerMessageHandler("GG", (e3, t2) => this.getGlyphs(e3, t2)), this.dispatcher.registerMessageHandler("GI", (e3, t2) => this.getImages(e3, t2)), this.dispatcher.registerMessageHandler("GDA", (e3, t2) => this.getDashes(e3, t2)), this.imageManager = new w(), this.imageManager.setEventedParent(this);
	        const o2 = (null === (a2 = e2._container) || void 0 === a2 ? void 0 : a2.lang) || "undefined" != typeof document && (null === (r2 = document.documentElement) || void 0 === r2 ? void 0 : r2.lang) || void 0;
	        this.glyphManager = new I(e2._requestManager, i2.localIdeographFontFamily, o2), this.lineAtlas = new A(256, 512), this.crossTileSymbolIndex = new Ct(), this._setInitialValues(), this._resetUpdates(), this.dispatcher.broadcast("SR", t.bO()), ce().on(se, this._rtlPluginLoaded), this.on("data", (e3) => {
	          if ("source" !== e3.dataType || "metadata" !== e3.sourceDataType) return;
	          const t2 = this.tileManagers[e3.sourceId];
	          if (!t2) return;
	          const i3 = t2.getSource();
	          if (i3 && i3.vectorLayerIds) for (const e4 in this._layers) {
	            const t3 = this._layers[e4];
	            t3.source === i3.id && this._validateLayer(t3);
	          }
	        });
	      }
	      _setInitialValues() {
	        var e2;
	        this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.tileManagers = {}, this.zoomHistory = new t.bP(), this._availableImages = [], this._globalState = {}, this._serializedLayers = {}, this.stylesheet = null, this.light = null, this.sky = null, this.projection && (this.projection.destroy(), delete this.projection), this._loaded = false, this._changed = false, this._updatedLayers = {}, this._updatedSources = {}, this._changedImages = {}, this._glyphsDidChange = false, this._updatedPaintProps = {}, this._layerOrderChanged = false, this.crossTileSymbolIndex = new ((null === (e2 = this.crossTileSymbolIndex) || void 0 === e2 ? void 0 : e2.constructor) || Object)(), this.pauseablePlacement = void 0, this.placement = void 0, this.z = 0;
	      }
	      setGlobalStateProperty(e2, i2) {
	        var a2, r2, o2;
	        this._checkLoaded();
	        const s2 = null === i2 ? null !== (o2 = null === (r2 = null === (a2 = this.stylesheet.state) || void 0 === a2 ? void 0 : a2[e2]) || void 0 === r2 ? void 0 : r2.default) && void 0 !== o2 ? o2 : null : i2;
	        if (t.bQ(s2, this._globalState[e2])) return this;
	        this._globalState[e2] = s2, this._applyGlobalStateChanges([e2]);
	      }
	      getGlobalState() {
	        return this._globalState;
	      }
	      setGlobalState(e2) {
	        this._checkLoaded();
	        const i2 = [];
	        for (const a2 in e2) !t.bQ(this._globalState[a2], e2[a2].default) && (i2.push(a2), this._globalState[a2] = e2[a2].default);
	        this._applyGlobalStateChanges(i2);
	      }
	      _applyGlobalStateChanges(e2) {
	        if (0 === e2.length) return;
	        const t2 = /* @__PURE__ */ new Set(), i2 = {};
	        for (const a2 of e2) {
	          i2[a2] = this._globalState[a2];
	          for (const e3 in this._layers) {
	            const i3 = this._layers[e3], r2 = i3.getLayoutAffectingGlobalStateRefs(), o2 = i3.getPaintAffectingGlobalStateRefs();
	            if (r2.has(a2) && t2.add(i3.source), o2.has(a2)) for (const { name: e4, value: t3 } of o2.get(a2)) this._updatePaintProperty(i3, e4, t3);
	          }
	        }
	        this.dispatcher.broadcast("UGS", i2);
	        for (const e3 in this.tileManagers) t2.has(e3) && (this._reloadSource(e3), this._changed = true);
	      }
	      loadURL(e2, i2 = {}, a2) {
	        this.fire(new t.l("dataloading", { dataType: "style" })), i2.validate = "boolean" != typeof i2.validate || i2.validate;
	        const r2 = this.map._requestManager.transformRequest(e2, "Style");
	        this._loadStyleRequest = new AbortController();
	        const o2 = this._loadStyleRequest;
	        t.j(r2, this._loadStyleRequest).then((e3) => {
	          this._loadStyleRequest = null, this._load(e3.data, i2, a2);
	        }).catch((e3) => {
	          this._loadStyleRequest = null, e3 && !o2.signal.aborted && this.fire(new t.k(e3));
	        });
	      }
	      loadJSON(e2, i2 = {}, a2) {
	        this.fire(new t.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), n.frameAsync(this._frameRequest).then(() => {
	          this._frameRequest = null, i2.validate = false !== i2.validate, this._load(e2, i2, a2);
	        }).catch(() => {
	        });
	      }
	      loadEmpty() {
	        this.fire(new t.l("dataloading", { dataType: "style" })), this._load(Ei, { validate: false });
	      }
	      _load(e2, i2, a2) {
	        var r2, o2;
	        let s2 = i2.transformStyle ? i2.transformStyle(a2, e2) : e2;
	        if (!i2.validate || !Ii(this, t.C(s2))) {
	          s2 = Object.assign({}, s2), this._loaded = true, this.stylesheet = s2;
	          for (const e3 in s2.sources) this.addSource(e3, s2.sources[e3], { validate: false });
	          s2.sprite ? this._loadSprite(s2.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(s2.glyphs), this._createLayers(), this.light = new R(this.stylesheet.light), this._setProjectionInternal((null === (r2 = this.stylesheet.projection) || void 0 === r2 ? void 0 : r2.type) || "mercator"), this.sky = new z(this.stylesheet.sky), this.map.setTerrain(null !== (o2 = this.stylesheet.terrain) && void 0 !== o2 ? o2 : null), this.fire(new t.l("data", { dataType: "style" })), this.fire(new t.l("style.load"));
	        }
	      }
	      _createLayers() {
	        var e2, i2, a2;
	        const r2 = t.bR(this.stylesheet.layers);
	        this.setGlobalState(null !== (e2 = this.stylesheet.state) && void 0 !== e2 ? e2 : null), this.dispatcher.broadcast("SL", r2), this._order = r2.map((e3) => e3.id), this._layers = {}, this._serializedLayers = null;
	        for (const e3 of r2) {
	          const r3 = t.bS(e3, this._globalState);
	          if (r3.setEventedParent(this, { layer: { id: e3.id } }), this._layers[e3.id] = r3, t.bT(r3) && this.tileManagers[r3.source]) {
	            const t2 = null !== (a2 = null === (i2 = e3.paint) || void 0 === i2 ? void 0 : i2["raster-fade-duration"]) && void 0 !== a2 ? a2 : r3.paint.get("raster-fade-duration");
	            this.tileManagers[r3.source].setRasterFadeDuration(t2);
	          }
	        }
	      }
	      _loadSprite(e2, i2 = false, a2 = void 0) {
	        let r2;
	        this.imageManager.setLoaded(false), this._spriteRequest = new AbortController(), function(e3, i3, a3, r3) {
	          return t._(this, void 0, void 0, function* () {
	            const o2 = x(e3), s2 = a3 > 1 ? "@2x" : "", l2 = {}, c2 = {};
	            for (const { id: e4, url: a4 } of o2) {
	              const o3 = i3.transformRequest(b(a4, s2, ".json"), "SpriteJSON");
	              l2[e4] = t.j(o3, r3);
	              const n2 = i3.transformRequest(b(a4, s2, ".png"), "SpriteImage");
	              c2[e4] = g.getImage(n2, r3);
	            }
	            return yield Promise.all([...Object.values(l2), ...Object.values(c2)]), function(e4, i4) {
	              return t._(this, void 0, void 0, function* () {
	                const t2 = {};
	                for (const a4 in e4) {
	                  t2[a4] = {};
	                  const r4 = n.getImageCanvasContext((yield i4[a4]).data), o3 = (yield e4[a4]).data;
	                  for (const e5 in o3) {
	                    const { width: i5, height: s3, x: n2, y: l3, sdf: c3, pixelRatio: h2, stretchX: u2, stretchY: d2, content: _2, textFitWidth: p2, textFitHeight: m2 } = o3[e5];
	                    t2[a4][e5] = { data: null, pixelRatio: h2, sdf: c3, stretchX: u2, stretchY: d2, content: _2, textFitWidth: p2, textFitHeight: m2, spriteData: { width: i5, height: s3, x: n2, y: l3, context: r4 } };
	                  }
	                }
	                return t2;
	              });
	            }(l2, c2);
	          });
	        }(e2, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((e3) => {
	          if (this._spriteRequest = null, e3) for (const t2 in e3) {
	            this._spritesImagesIds[t2] = [];
	            const a3 = this._spritesImagesIds[t2] ? this._spritesImagesIds[t2].filter((t3) => !(t3 in e3)) : [];
	            for (const e4 of a3) this.imageManager.removeImage(e4), this._changedImages[e4] = true;
	            for (const a4 in e3[t2]) {
	              const r3 = "default" === t2 ? a4 : `${t2}:${a4}`;
	              this._spritesImagesIds[t2].push(r3), r3 in this.imageManager.images ? this.imageManager.updateImage(r3, e3[t2][a4], false) : this.imageManager.addImage(r3, e3[t2][a4]), i2 && (this._changedImages[r3] = true);
	            }
	          }
	        }).catch((e3) => {
	          this._spriteRequest = null, r2 = e3, this.fire(new t.k(r2));
	        }).finally(() => {
	          this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), i2 && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" })), a2 && a2(r2);
	        });
	      }
	      _unloadSprite() {
	        for (const e2 of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e2), this._changedImages[e2] = true;
	        this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
	      }
	      _validateLayer(e2) {
	        const i2 = this.tileManagers[e2.source];
	        if (!i2) return;
	        const a2 = e2.sourceLayer;
	        if (!a2) return;
	        const r2 = i2.getSource();
	        ("geojson" === r2.type || r2.vectorLayerIds && -1 === r2.vectorLayerIds.indexOf(a2)) && this.fire(new t.k(new Error(`Source layer "${a2}" does not exist on source "${r2.id}" as specified by style layer "${e2.id}".`)));
	      }
	      loaded() {
	        if (!this._loaded) return false;
	        if (Object.keys(this._updatedSources).length) return false;
	        for (const e2 in this.tileManagers) if (!this.tileManagers[e2].loaded()) return false;
	        return !!this.imageManager.isLoaded();
	      }
	      _serializeByIds(e2, i2 = false) {
	        const a2 = this._serializedAllLayers();
	        if (!e2 || 0 === e2.length) return Object.values(i2 ? t.bU(a2) : a2);
	        const r2 = [];
	        for (const o2 of e2) if (a2[o2]) {
	          const e3 = i2 ? t.bU(a2[o2]) : a2[o2];
	          r2.push(e3);
	        }
	        return r2;
	      }
	      _serializedAllLayers() {
	        let e2 = this._serializedLayers;
	        if (e2) return e2;
	        e2 = this._serializedLayers = {};
	        const t2 = Object.keys(this._layers);
	        for (const i2 of t2) {
	          const t3 = this._layers[i2];
	          "custom" !== t3.type && (e2[i2] = t3.serialize());
	        }
	        return e2;
	      }
	      hasTransitions() {
	        var e2, t2, i2;
	        if (null === (e2 = this.light) || void 0 === e2 ? void 0 : e2.hasTransition()) return true;
	        if (null === (t2 = this.sky) || void 0 === t2 ? void 0 : t2.hasTransition()) return true;
	        if (null === (i2 = this.projection) || void 0 === i2 ? void 0 : i2.hasTransition()) return true;
	        for (const e3 in this.tileManagers) if (this.tileManagers[e3].hasTransition()) return true;
	        for (const e3 in this._layers) if (this._layers[e3].hasTransition()) return true;
	        return false;
	      }
	      _checkLoaded() {
	        if (!this._loaded) throw new Error("Style is not done loading.");
	      }
	      update(e2) {
	        if (!this._loaded) return;
	        const i2 = this._changed;
	        if (i2) {
	          const t2 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
	          (t2.length || i3.length) && this._updateWorkerLayers(t2, i3);
	          for (const e3 in this._updatedSources) {
	            const t3 = this._updatedSources[e3];
	            if ("reload" === t3) this._reloadSource(e3);
	            else {
	              if ("clear" !== t3) throw new Error(`Invalid action ${t3}`);
	              this._clearSource(e3);
	            }
	          }
	          this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
	          for (const t3 in this._updatedPaintProps) this._layers[t3].updateTransitions(e2);
	          this.light.updateTransitions(e2), this.sky.updateTransitions(e2), this._resetUpdates();
	        }
	        const a2 = {};
	        for (const e3 in this.tileManagers) {
	          const t2 = this.tileManagers[e3];
	          a2[e3] = t2.used, t2.used = false;
	        }
	        for (const t2 of this._order) {
	          const i3 = this._layers[t2];
	          i3.recalculate(e2, this._availableImages), !i3.isHidden(e2.zoom) && i3.source && (this.tileManagers[i3.source].used = true);
	        }
	        for (const e3 in a2) {
	          const i3 = this.tileManagers[e3];
	          !!a2[e3] != !!i3.used && i3.fire(new t.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: e3 }));
	        }
	        this.light.recalculate(e2), this.sky.recalculate(e2), this.projection.recalculate(e2), this.z = e2.zoom, i2 && this.fire(new t.l("data", { dataType: "style" }));
	      }
	      _updateTilesForChangedImages() {
	        const e2 = Object.keys(this._changedImages);
	        if (e2.length) {
	          for (const t2 in this.tileManagers) this.tileManagers[t2].reloadTilesForDependencies(["icons", "patterns"], e2);
	          this._changedImages = {};
	        }
	      }
	      _updateTilesForChangedGlyphs() {
	        if (this._glyphsDidChange) {
	          for (const e2 in this.tileManagers) this.tileManagers[e2].reloadTilesForDependencies(["glyphs"], [""]);
	          this._glyphsDidChange = false;
	        }
	      }
	      _updateWorkerLayers(e2, t2) {
	        this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e2, false), removedIds: t2 });
	      }
	      _resetUpdates() {
	        this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
	      }
	      setState(e2, i2 = {}) {
	        var a2;
	        this._checkLoaded();
	        const r2 = this.serialize();
	        if (e2 = i2.transformStyle ? i2.transformStyle(r2, e2) : e2, (null === (a2 = i2.validate) || void 0 === a2 || a2) && Ii(this, t.C(e2))) return false;
	        (e2 = t.bU(e2)).layers = t.bR(e2.layers);
	        const o2 = t.bV(r2, e2), s2 = this._getOperationsToPerform(o2);
	        if (s2.unimplemented.length > 0) throw new Error(`Unimplemented: ${s2.unimplemented.join(", ")}.`);
	        if (0 === s2.operations.length) return false;
	        for (const e3 of s2.operations) e3();
	        return this.stylesheet = e2, this._serializedLayers = null, true;
	      }
	      _getOperationsToPerform(e2) {
	        const t2 = [], i2 = [];
	        for (const a2 of e2) switch (a2.command) {
	          case "setCenter":
	          case "setZoom":
	          case "setBearing":
	          case "setPitch":
	          case "setRoll":
	            continue;
	          case "addLayer":
	            t2.push(() => this.addLayer.apply(this, a2.args));
	            break;
	          case "removeLayer":
	            t2.push(() => this.removeLayer.apply(this, a2.args));
	            break;
	          case "setPaintProperty":
	            t2.push(() => this.setPaintProperty.apply(this, a2.args));
	            break;
	          case "setLayoutProperty":
	            t2.push(() => this.setLayoutProperty.apply(this, a2.args));
	            break;
	          case "setFilter":
	            t2.push(() => this.setFilter.apply(this, a2.args));
	            break;
	          case "addSource":
	            t2.push(() => this.addSource.apply(this, a2.args));
	            break;
	          case "removeSource":
	            t2.push(() => this.removeSource.apply(this, a2.args));
	            break;
	          case "setLayerZoomRange":
	            t2.push(() => this.setLayerZoomRange.apply(this, a2.args));
	            break;
	          case "setLight":
	            t2.push(() => this.setLight.apply(this, a2.args));
	            break;
	          case "setGeoJSONSourceData":
	            t2.push(() => this.setGeoJSONSourceData.apply(this, a2.args));
	            break;
	          case "setGlyphs":
	            t2.push(() => this.setGlyphs.apply(this, a2.args));
	            break;
	          case "setSprite":
	            t2.push(() => this.setSprite.apply(this, a2.args));
	            break;
	          case "setTerrain":
	            t2.push(() => this.map.setTerrain.apply(this, a2.args));
	            break;
	          case "setSky":
	            t2.push(() => this.setSky.apply(this, a2.args));
	            break;
	          case "setProjection":
	            this.setProjection.apply(this, a2.args);
	            break;
	          case "setGlobalState":
	            t2.push(() => this.setGlobalState.apply(this, a2.args));
	            break;
	          case "setTransition":
	            t2.push(() => {
	            });
	            break;
	          default:
	            i2.push(a2.command);
	        }
	        return { operations: t2, unimplemented: i2 };
	      }
	      addImage(e2, i2) {
	        if (this.getImage(e2)) return this.fire(new t.k(new Error(`An image named "${e2}" already exists.`)));
	        this.imageManager.addImage(e2, i2), this._afterImageUpdated(e2);
	      }
	      updateImage(e2, t2) {
	        this.imageManager.updateImage(e2, t2);
	      }
	      getImage(e2) {
	        return this.imageManager.getImage(e2);
	      }
	      removeImage(e2) {
	        if (!this.getImage(e2)) return this.fire(new t.k(new Error(`An image named "${e2}" does not exist.`)));
	        this.imageManager.removeImage(e2), this._afterImageUpdated(e2);
	      }
	      _afterImageUpdated(e2) {
	        this._availableImages = this.imageManager.listImages(), this._changedImages[e2] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
	      }
	      listImages() {
	        return this._checkLoaded(), this.imageManager.listImages();
	      }
	      addSource(e2, i2, a2 = {}) {
	        if (this._checkLoaded(), void 0 !== this.tileManagers[e2]) throw new Error(`Source "${e2}" already exists.`);
	        if (!i2.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
	        if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(t.C.source, `sources.${e2}`, i2, null, a2)) return;
	        this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
	        const r2 = this.tileManagers[e2] = new Ie(e2, i2, this.dispatcher);
	        r2.style = this, r2.setEventedParent(this, () => ({ isSourceLoaded: r2.loaded(), source: r2.serialize(), sourceId: e2 })), r2.onAdd(this.map), this._changed = true;
	      }
	      removeSource(e2) {
	        if (this._checkLoaded(), void 0 === this.tileManagers[e2]) throw new Error("There is no source with this ID");
	        for (const i3 in this._layers) if (this._layers[i3].source === e2) return this.fire(new t.k(new Error(`Source "${e2}" cannot be removed while layer "${i3}" is using it.`)));
	        const i2 = this.tileManagers[e2];
	        delete this.tileManagers[e2], delete this._updatedSources[e2], i2.fire(new t.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: e2 })), i2.setEventedParent(null), i2.onRemove(this.map), this._changed = true;
	      }
	      setGeoJSONSourceData(e2, t2) {
	        if (this._checkLoaded(), void 0 === this.tileManagers[e2]) throw new Error(`There is no source with this ID=${e2}`);
	        const i2 = this.tileManagers[e2].getSource();
	        if ("geojson" !== i2.type) throw new Error(`geojsonSource.type is ${i2.type}, which is !== 'geojson`);
	        i2.setData(t2), this._changed = true;
	      }
	      getSource(e2) {
	        return this.tileManagers[e2] && this.tileManagers[e2].getSource();
	      }
	      addLayer(e2, i2, a2 = {}) {
	        this._checkLoaded();
	        const r2 = e2.id;
	        if (this.getLayer(r2)) return void this.fire(new t.k(new Error(`Layer "${r2}" already exists on this map.`)));
	        let o2;
	        if ("custom" === e2.type) {
	          if (Ii(this, t.bW(e2))) return;
	          o2 = t.bS(e2, this._globalState);
	        } else {
	          if ("source" in e2 && "object" == typeof e2.source && (this.addSource(r2, e2.source), e2 = t.bU(e2), e2 = t.e(e2, { source: r2 })), this._validate(t.C.layer, `layers.${r2}`, e2, { arrayIndex: -1 }, a2)) return;
	          o2 = t.bS(e2, this._globalState), this._validateLayer(o2), o2.setEventedParent(this, { layer: { id: r2 } });
	        }
	        const s2 = i2 ? this._order.indexOf(i2) : this._order.length;
	        if (i2 && -1 === s2) this.fire(new t.k(new Error(`Cannot add layer "${r2}" before non-existing layer "${i2}".`)));
	        else {
	          if (this._order.splice(s2, 0, r2), this._layerOrderChanged = true, this._layers[r2] = o2, this._removedLayers[r2] && o2.source && "custom" !== o2.type) {
	            const e3 = this._removedLayers[r2];
	            delete this._removedLayers[r2], e3.type !== o2.type ? this._updatedSources[o2.source] = "clear" : (this._updatedSources[o2.source] = "reload", this.tileManagers[o2.source].pause());
	          }
	          this._updateLayer(o2), o2.onAdd && o2.onAdd(this.map);
	        }
	      }
	      moveLayer(e2, i2) {
	        if (this._checkLoaded(), this._changed = true, !this._layers[e2]) return void this.fire(new t.k(new Error(`The layer '${e2}' does not exist in the map's style and cannot be moved.`)));
	        if (e2 === i2) return;
	        const a2 = this._order.indexOf(e2);
	        this._order.splice(a2, 1);
	        const r2 = i2 ? this._order.indexOf(i2) : this._order.length;
	        i2 && -1 === r2 ? this.fire(new t.k(new Error(`Cannot move layer "${e2}" before non-existing layer "${i2}".`))) : (this._order.splice(r2, 0, e2), this._layerOrderChanged = true);
	      }
	      removeLayer(e2) {
	        this._checkLoaded();
	        const i2 = this._layers[e2];
	        if (!i2) return void this.fire(new t.k(new Error(`Cannot remove non-existing layer "${e2}".`)));
	        i2.setEventedParent(null);
	        const a2 = this._order.indexOf(e2);
	        this._order.splice(a2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e2] = i2, delete this._layers[e2], this._serializedLayers && delete this._serializedLayers[e2], delete this._updatedLayers[e2], delete this._updatedPaintProps[e2], i2.onRemove && i2.onRemove(this.map);
	      }
	      getLayer(e2) {
	        return this._layers[e2];
	      }
	      getLayersOrder() {
	        return [...this._order];
	      }
	      hasLayer(e2) {
	        return e2 in this._layers;
	      }
	      setLayerZoomRange(e2, i2, a2) {
	        this._checkLoaded();
	        const r2 = this.getLayer(e2);
	        r2 ? r2.minzoom === i2 && r2.maxzoom === a2 || (null != i2 && (r2.minzoom = i2), null != a2 && (r2.maxzoom = a2), this._updateLayer(r2)) : this.fire(new t.k(new Error(`Cannot set the zoom range of non-existing layer "${e2}".`)));
	      }
	      setFilter(e2, i2, a2 = {}) {
	        this._checkLoaded();
	        const r2 = this.getLayer(e2);
	        if (r2) {
	          if (!t.bQ(r2.filter, i2)) return null == i2 ? (r2.setFilter(void 0), void this._updateLayer(r2)) : void (this._validate(t.C.filter, `layers.${r2.id}.filter`, i2, null, a2) || (r2.setFilter(t.bU(i2)), this._updateLayer(r2)));
	        } else this.fire(new t.k(new Error(`Cannot filter non-existing layer "${e2}".`)));
	      }
	      getFilter(e2) {
	        return t.bU(this.getLayer(e2).filter);
	      }
	      setLayoutProperty(e2, i2, a2, r2 = {}) {
	        this._checkLoaded();
	        const o2 = this.getLayer(e2);
	        o2 ? t.bQ(o2.getLayoutProperty(i2), a2) || (o2.setLayoutProperty(i2, a2, r2), this._updateLayer(o2)) : this.fire(new t.k(new Error(`Cannot style non-existing layer "${e2}".`)));
	      }
	      getLayoutProperty(e2, i2) {
	        const a2 = this.getLayer(e2);
	        if (a2) return a2.getLayoutProperty(i2);
	        this.fire(new t.k(new Error(`Cannot get style of non-existing layer "${e2}".`)));
	      }
	      setPaintProperty(e2, i2, a2, r2 = {}) {
	        this._checkLoaded();
	        const o2 = this.getLayer(e2);
	        o2 ? t.bQ(o2.getPaintProperty(i2), a2) || this._updatePaintProperty(o2, i2, a2, r2) : this.fire(new t.k(new Error(`Cannot style non-existing layer "${e2}".`)));
	      }
	      _updatePaintProperty(e2, i2, a2, r2 = {}) {
	        e2.setPaintProperty(i2, a2, r2) && this._updateLayer(e2), t.bT(e2) && "raster-fade-duration" === i2 && this.tileManagers[e2.source].setRasterFadeDuration(a2), this._changed = true, this._updatedPaintProps[e2.id] = true, this._serializedLayers = null;
	      }
	      getPaintProperty(e2, t2) {
	        return this.getLayer(e2).getPaintProperty(t2);
	      }
	      setFeatureState(e2, i2) {
	        this._checkLoaded();
	        const a2 = e2.source, r2 = e2.sourceLayer, o2 = this.tileManagers[a2];
	        if (void 0 === o2) return void this.fire(new t.k(new Error(`The source '${a2}' does not exist in the map's style.`)));
	        const s2 = o2.getSource().type;
	        "geojson" === s2 && r2 ? this.fire(new t.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== s2 || r2 ? (void 0 === e2.id && this.fire(new t.k(new Error("The feature id parameter must be provided."))), o2.setFeatureState(r2, e2.id, i2)) : this.fire(new t.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
	      }
	      removeFeatureState(e2, i2) {
	        this._checkLoaded();
	        const a2 = e2.source, r2 = this.tileManagers[a2];
	        if (void 0 === r2) return void this.fire(new t.k(new Error(`The source '${a2}' does not exist in the map's style.`)));
	        const o2 = r2.getSource().type, s2 = "vector" === o2 ? e2.sourceLayer : void 0;
	        "vector" !== o2 || s2 ? i2 && "string" != typeof e2.id && "number" != typeof e2.id ? this.fire(new t.k(new Error("A feature id is required to remove its specific state property."))) : r2.removeFeatureState(s2, e2.id, i2) : this.fire(new t.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
	      }
	      getFeatureState(e2) {
	        this._checkLoaded();
	        const i2 = e2.source, a2 = e2.sourceLayer, r2 = this.tileManagers[i2];
	        if (void 0 !== r2) return "vector" !== r2.getSource().type || a2 ? (void 0 === e2.id && this.fire(new t.k(new Error("The feature id parameter must be provided."))), r2.getFeatureState(a2, e2.id)) : void this.fire(new t.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
	        this.fire(new t.k(new Error(`The source '${i2}' does not exist in the map's style.`)));
	      }
	      getTransition() {
	        return t.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
	      }
	      serialize() {
	        if (!this._loaded) return;
	        const e2 = t.bX(this.tileManagers, (e3) => e3.serialize()), i2 = this._serializeByIds(this._order, true), a2 = this.map.getTerrain() || void 0, r2 = this.stylesheet;
	        return t.bY({ version: r2.version, name: r2.name, metadata: r2.metadata, light: r2.light, sky: r2.sky, center: r2.center, zoom: r2.zoom, bearing: r2.bearing, pitch: r2.pitch, sprite: r2.sprite, glyphs: r2.glyphs, transition: r2.transition, projection: r2.projection, sources: e2, layers: i2, terrain: a2 }, (e3) => void 0 !== e3);
	      }
	      _updateLayer(e2) {
	        this._updatedLayers[e2.id] = true, e2.source && !this._updatedSources[e2.source] && "raster" !== this.tileManagers[e2.source].getSource().type && (this._updatedSources[e2.source] = "reload", this.tileManagers[e2.source].pause()), this._serializedLayers = null, this._changed = true;
	      }
	      _flattenAndSortRenderedFeatures(e2) {
	        const t2 = (e3) => "fill-extrusion" === this._layers[e3].type, i2 = {}, a2 = [];
	        for (let r3 = this._order.length - 1; r3 >= 0; r3--) {
	          const o2 = this._order[r3];
	          if (t2(o2)) {
	            i2[o2] = r3;
	            for (const t3 of e2) {
	              const e3 = t3[o2];
	              if (e3) for (const t4 of e3) a2.push(t4);
	            }
	          }
	        }
	        a2.sort((e3, t3) => t3.intersectionZ - e3.intersectionZ);
	        const r2 = [];
	        for (let o2 = this._order.length - 1; o2 >= 0; o2--) {
	          const s2 = this._order[o2];
	          if (t2(s2)) for (let e3 = a2.length - 1; e3 >= 0; e3--) {
	            const t3 = a2[e3].feature;
	            if (i2[t3.layer.id] < o2) break;
	            r2.push(t3), a2.pop();
	          }
	          else for (const t3 of e2) {
	            const e3 = t3[s2];
	            if (e3) for (const t4 of e3) r2.push(t4.feature);
	          }
	        }
	        return r2;
	      }
	      queryRenderedFeatures(e2, i2, a2) {
	        i2 && i2.filter && this._validate(t.C.filter, "queryRenderedFeatures.filter", i2.filter, null, i2);
	        const r2 = {};
	        if (i2 && i2.layers) {
	          if (!(Array.isArray(i2.layers) || i2.layers instanceof Set)) return this.fire(new t.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
	          for (const e3 of i2.layers) {
	            const i3 = this._layers[e3];
	            if (!i3) return this.fire(new t.k(new Error(`The layer '${e3}' does not exist in the map's style and cannot be queried for features.`))), [];
	            r2[i3.source] = true;
	          }
	        }
	        const o2 = [];
	        i2.availableImages = this._availableImages;
	        const s2 = this._serializedAllLayers(), n2 = i2.layers instanceof Set ? i2.layers : Array.isArray(i2.layers) ? new Set(i2.layers) : null, l2 = Object.assign(Object.assign({}, i2), { layers: n2, globalState: this._globalState });
	        for (const t2 in this.tileManagers) i2.layers && !r2[t2] || o2.push(U(this.tileManagers[t2], this._layers, s2, e2, l2, a2, this.map.terrain ? (e3, t3, i3) => this.map.terrain.getElevation(e3, t3, i3) : void 0));
	        return this.placement && o2.push(function(e3, t2, i3, a3, r3, o3, s3) {
	          const n3 = {}, l3 = o3.queryRenderedSymbols(a3), c2 = [];
	          for (const e4 of Object.keys(l3).map(Number)) c2.push(s3[e4]);
	          c2.sort(V);
	          for (const i4 of c2) {
	            const a4 = i4.featureIndex.lookupSymbolFeatures(l3[i4.bucketInstanceId], t2, i4.bucketIndex, i4.sourceLayerIndex, { filterSpec: r3.filter, globalState: r3.globalState }, r3.layers, r3.availableImages, e3);
	            for (const e4 in a4) {
	              const t3 = n3[e4] = n3[e4] || [], r4 = a4[e4];
	              r4.sort((e5, t4) => {
	                const a5 = i4.featureSortOrder;
	                if (a5) {
	                  const i5 = a5.indexOf(e5.featureIndex);
	                  return a5.indexOf(t4.featureIndex) - i5;
	                }
	                return t4.featureIndex - e5.featureIndex;
	              });
	              for (const e5 of r4) t3.push(e5);
	            }
	          }
	          return function(e4, t3, i4) {
	            for (const a4 in e4) for (const r4 of e4[a4]) q(r4, i4[t3[a4].source]);
	            return e4;
	          }(n3, e3, i3);
	        }(this._layers, s2, this.tileManagers, e2, l2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(o2);
	      }
	      querySourceFeatures(e2, i2) {
	        (null == i2 ? void 0 : i2.filter) && this._validate(t.C.filter, "querySourceFeatures.filter", i2.filter, null, i2);
	        const a2 = this.tileManagers[e2];
	        return a2 ? function(e3, t2) {
	          const i3 = e3.getRenderableIds().map((t3) => e3.getTileByID(t3)), a3 = [], r2 = {};
	          for (let e4 = 0; e4 < i3.length; e4++) {
	            const o2 = i3[e4], s2 = o2.tileID.canonical.key;
	            r2[s2] || (r2[s2] = true, o2.querySourceFeatures(a3, t2));
	          }
	          return a3;
	        }(a2, i2 ? Object.assign(Object.assign({}, i2), { globalState: this._globalState }) : { globalState: this._globalState }) : [];
	      }
	      getLight() {
	        return this.light.getLight();
	      }
	      setLight(e2, i2 = {}) {
	        this._checkLoaded();
	        const a2 = this.light.getLight();
	        let r2 = false;
	        for (const i3 in e2) if (!t.bQ(e2[i3], a2[i3])) {
	          r2 = true;
	          break;
	        }
	        if (!r2) return;
	        const o2 = { now: c(), transition: t.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
	        this.light.setLight(e2, i2), this.light.updateTransitions(o2);
	      }
	      getProjection() {
	        var e2;
	        return null === (e2 = this.stylesheet) || void 0 === e2 ? void 0 : e2.projection;
	      }
	      setProjection(e2) {
	        if (this._checkLoaded(), this.projection) {
	          if (this.projection.name === e2.type) return;
	          this.projection.destroy(), delete this.projection;
	        }
	        this.stylesheet.projection = e2, this._setProjectionInternal(e2.type);
	      }
	      getSky() {
	        var e2;
	        return null === (e2 = this.stylesheet) || void 0 === e2 ? void 0 : e2.sky;
	      }
	      setSky(e2, i2 = {}) {
	        this._checkLoaded();
	        const a2 = this.getSky();
	        let r2 = false;
	        if (!e2 && !a2) return;
	        if (e2 && !a2) r2 = true;
	        else if (!e2 && a2) r2 = true;
	        else for (const i3 in e2) if (!t.bQ(e2[i3], a2[i3])) {
	          r2 = true;
	          break;
	        }
	        if (!r2) return;
	        const o2 = { now: c(), transition: t.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
	        this.stylesheet.sky = e2, this.sky.setSky(e2, i2), this.sky.updateTransitions(o2);
	      }
	      _setProjectionInternal(e2) {
	        const i2 = function(e3, i3) {
	          const a2 = { constrainOverride: i3 };
	          if (Array.isArray(e3)) {
	            const t2 = new si({ type: e3 });
	            return { projection: t2, transform: new Pi(a2), cameraHelper: new Mi(t2) };
	          }
	          switch (e3) {
	            case "mercator":
	              return { projection: new At(), transform: new Zt(a2), cameraHelper: new qt() };
	            case "globe": {
	              const e4 = new si({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
	              return { projection: e4, transform: new Pi(a2), cameraHelper: new Mi(e4) };
	            }
	            case "vertical-perspective":
	              return { projection: new ri(), transform: new Ti(a2), cameraHelper: new Ci() };
	            default:
	              return t.w(`Unknown projection name: ${e3}. Falling back to mercator projection.`), { projection: new At(), transform: new Zt(a2), cameraHelper: new qt() };
	          }
	        }(e2, this.map.transformConstrain);
	        this.projection = i2.projection, this.map.migrateProjection(i2.transform, i2.cameraHelper);
	        for (const e3 in this.tileManagers) this.tileManagers[e3].reload();
	      }
	      _validate(e2, i2, a2, r2, o2 = {}) {
	        return (!o2 || false !== o2.validate) && Ii(this, e2.call(t.C, t.e({ key: i2, style: this.serialize(), value: a2, styleSpec: t.u }, r2)));
	      }
	      _remove(e2 = true) {
	        this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), ce().off(se, this._rtlPluginLoaded);
	        for (const e3 in this._layers) this._layers[e3].setEventedParent(null);
	        for (const e3 in this.tileManagers) {
	          const t2 = this.tileManagers[e3];
	          t2.setEventedParent(null), t2.onRemove(this.map);
	        }
	        this.imageManager.setEventedParent(null), this.setEventedParent(null), e2 && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e2);
	      }
	      _clearSource(e2) {
	        this.tileManagers[e2].clearTiles();
	      }
	      _reloadSource(e2) {
	        this.tileManagers[e2].resume(), this.tileManagers[e2].reload();
	      }
	      _updateSources(e2) {
	        for (const t2 in this.tileManagers) this.tileManagers[t2].update(e2, this.map.terrain);
	      }
	      _generateCollisionBoxes() {
	        for (const e2 in this.tileManagers) this._reloadSource(e2);
	      }
	      _updatePlacement(e2, t2, i2, a2, r2 = false) {
	        let o2 = false, s2 = false;
	        const n2 = {};
	        for (const t3 of this._order) {
	          const i3 = this._layers[t3];
	          if ("symbol" !== i3.type) continue;
	          if (!n2[i3.source]) {
	            const e3 = this.tileManagers[i3.source];
	            n2[i3.source] = e3.getRenderableIds(true).map((t4) => e3.getTileByID(t4)).sort((e4, t4) => t4.tileID.overscaledZ - e4.tileID.overscaledZ || (e4.tileID.isLessThan(t4.tileID) ? -1 : 1));
	          }
	          const a3 = this.crossTileSymbolIndex.addLayer(i3, n2[i3.source], e2.center.lng);
	          o2 = o2 || a3;
	        }
	        if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((r2 = r2 || this._layerOrderChanged || 0 === i2) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(c(), e2.zoom)) && (this.pauseablePlacement = new bt(e2, this.map.terrain, this._order, r2, t2, i2, a2, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, n2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(c()), s2 = true), o2 && this.pauseablePlacement.placement.setStale()), s2 || o2) for (const e3 of this._order) {
	          const t3 = this._layers[e3];
	          "symbol" === t3.type && this.placement.updateLayerOpacities(t3, n2[t3.source]);
	        }
	        return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(c());
	      }
	      _releaseSymbolFadeTiles() {
	        for (const e2 in this.tileManagers) this.tileManagers[e2].releaseSymbolFadeTiles();
	      }
	      getImages(e2, i2) {
	        return t._(this, void 0, void 0, function* () {
	          const e3 = yield this.imageManager.getImages(i2.icons);
	          this._updateTilesForChangedImages();
	          const t2 = this.tileManagers[i2.source];
	          return t2 && t2.setDependencies(i2.tileID.key, i2.type, i2.icons), e3;
	        });
	      }
	      getGlyphs(e2, i2) {
	        return t._(this, void 0, void 0, function* () {
	          const e3 = yield this.glyphManager.getGlyphs(i2.stacks), t2 = this.tileManagers[i2.source];
	          return t2 && t2.setDependencies(i2.tileID.key, i2.type, [""]), e3;
	        });
	      }
	      getGlyphsUrl() {
	        return this.stylesheet.glyphs || null;
	      }
	      setGlyphs(e2, i2 = {}) {
	        this._checkLoaded(), e2 && this._validate(t.C.glyphs, "glyphs", e2, null, i2) || (this._glyphsDidChange = true, this.stylesheet.glyphs = e2, this.glyphManager.entries = {}, this.glyphManager.setURL(e2));
	      }
	      getDashes(e2, i2) {
	        return t._(this, void 0, void 0, function* () {
	          const e3 = {};
	          for (const [t2, a2] of Object.entries(i2.dashes)) e3[t2] = this.lineAtlas.getDash(a2.dasharray, a2.round);
	          return e3;
	        });
	      }
	      addSprite(e2, i2, a2 = {}, r2) {
	        this._checkLoaded();
	        const o2 = [{ id: e2, url: i2 }], s2 = [...x(this.stylesheet.sprite), ...o2];
	        this._validate(t.C.sprite, "sprite", s2, null, a2) || (this.stylesheet.sprite = s2, this._loadSprite(o2, true, r2));
	      }
	      removeSprite(e2) {
	        this._checkLoaded();
	        const i2 = x(this.stylesheet.sprite);
	        if (i2.find((t2) => t2.id === e2)) {
	          if (this._spritesImagesIds[e2]) for (const t2 of this._spritesImagesIds[e2]) this.imageManager.removeImage(t2), this._changedImages[t2] = true;
	          i2.splice(i2.findIndex((t2) => t2.id === e2), 1), this.stylesheet.sprite = i2.length > 0 ? i2 : void 0, delete this._spritesImagesIds[e2], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
	        } else this.fire(new t.k(new Error(`Sprite "${e2}" doesn't exists on this map.`)));
	      }
	      getSprite() {
	        return x(this.stylesheet.sprite);
	      }
	      setSprite(e2, i2 = {}, a2) {
	        this._checkLoaded(), e2 && this._validate(t.C.sprite, "sprite", e2, null, i2) || (this.stylesheet.sprite = e2, e2 ? this._loadSprite(e2, true, a2) : (this._unloadSprite(), a2 && a2(null)));
	      }
	      destroy() {
	        this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null);
	        for (const e2 in this.tileManagers) {
	          const t2 = this.tileManagers[e2];
	          if (t2.setEventedParent(null), t2._tiles) {
	            for (const e3 in t2._tiles) t2._tiles[e3].unloadVectorData();
	            t2._tiles = {};
	          }
	          t2._cache.reset(), t2.onRemove(this.map);
	        }
	        this.tileManagers = {}, this.imageManager && (this.imageManager.setEventedParent(null), this.imageManager.destroy(), this._availableImages = [], this._spritesImagesIds = {}), this.glyphManager && this.glyphManager.destroy();
	        for (const e2 in this._layers) {
	          const t2 = this._layers[e2];
	          t2.setEventedParent(null), t2.onRemove && t2.onRemove(this.map);
	        }
	        this._setInitialValues(), this.setEventedParent(null), this.dispatcher.unregisterMessageHandler("GG"), this.dispatcher.unregisterMessageHandler("GI"), this.dispatcher.unregisterMessageHandler("GDA"), this.dispatcher.remove(true), this._listeners = {}, this._oneTimeListeners = {};
	      }
	    }
	    var Ri = t.aT([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
	    class Di {
	      constructor() {
	        this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
	      }
	      bind(e2, t2, i2, a2, r2, o2, s2, n2, l2) {
	        this.context = e2;
	        let c2 = this.boundPaintVertexBuffers.length !== a2.length;
	        for (let e3 = 0; !c2 && e3 < a2.length; e3++) this.boundPaintVertexBuffers[e3] !== a2[e3] && (c2 = true);
	        !this.vao || this.boundProgram !== t2 || this.boundLayoutVertexBuffer !== i2 || c2 || this.boundIndexBuffer !== r2 || this.boundVertexOffset !== o2 || this.boundDynamicVertexBuffer !== s2 || this.boundDynamicVertexBuffer2 !== n2 || this.boundDynamicVertexBuffer3 !== l2 ? this.freshBind(t2, i2, a2, r2, o2, s2, n2, l2) : (e2.bindVertexArray.set(this.vao), s2 && s2.bind(), r2 && r2.dynamicDraw && r2.bind(), n2 && n2.bind(), l2 && l2.bind());
	      }
	      freshBind(e2, t2, i2, a2, r2, o2, s2, n2) {
	        const l2 = e2.numAttributes, c2 = this.context, h2 = c2.gl;
	        this.vao && this.destroy(), this.vao = c2.createVertexArray(), c2.bindVertexArray.set(this.vao), this.boundProgram = e2, this.boundLayoutVertexBuffer = t2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = a2, this.boundVertexOffset = r2, this.boundDynamicVertexBuffer = o2, this.boundDynamicVertexBuffer2 = s2, this.boundDynamicVertexBuffer3 = n2, t2.enableAttributes(h2, e2);
	        for (const t3 of i2) t3.enableAttributes(h2, e2);
	        o2 && o2.enableAttributes(h2, e2), s2 && s2.enableAttributes(h2, e2), n2 && n2.enableAttributes(h2, e2), t2.bind(), t2.setVertexAttribPointers(h2, e2, r2);
	        for (const t3 of i2) t3.bind(), t3.setVertexAttribPointers(h2, e2, r2);
	        o2 && (o2.bind(), o2.setVertexAttribPointers(h2, e2, r2)), a2 && a2.bind(), s2 && (s2.bind(), s2.setVertexAttribPointers(h2, e2, r2)), n2 && (n2.bind(), n2.setVertexAttribPointers(h2, e2, r2)), c2.currentNumAttributes = l2;
	      }
	      destroy() {
	        this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
	      }
	    }
	    const zi = (e2, i2, a2, r2, o2) => ({ u_texture: 0, u_ele_delta: e2, u_fog_matrix: i2, u_fog_color: a2 ? a2.properties.get("fog-color") : t.bo.white, u_fog_ground_blend: a2 ? a2.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: o2 ? 0 : a2 ? a2.calculateFogBlendOpacity(r2) : 0, u_horizon_color: a2 ? a2.properties.get("horizon-color") : t.bo.white, u_horizon_fog_blend: a2 ? a2.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: o2 ? 1 : 0 }), Ai = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
	    function Li(e2) {
	      const t2 = [];
	      for (let i2 = 0; i2 < e2.length; i2++) {
	        if (null === e2[i2]) continue;
	        const a2 = e2[i2].split(" ");
	        t2.push(a2.pop());
	      }
	      return t2;
	    }
	    class ki {
	      constructor(e2, i2, a2, r2, o2, s2, n2, l2, c2 = []) {
	        const h2 = e2.gl;
	        this.program = h2.createProgram();
	        const u2 = Li(i2.staticAttributes), d2 = a2 ? a2.getBinderAttributes() : [], _2 = u2.concat(d2), p2 = It.prelude.staticUniforms ? Li(It.prelude.staticUniforms) : [], m2 = n2.staticUniforms ? Li(n2.staticUniforms) : [], f2 = i2.staticUniforms ? Li(i2.staticUniforms) : [], g2 = a2 ? a2.getBinderUniforms() : [], v2 = p2.concat(m2).concat(f2).concat(g2), x2 = [];
	        for (const e3 of v2) x2.indexOf(e3) < 0 && x2.push(e3);
	        const b2 = a2 ? a2.defines() : [];
	        Jt(h2) && b2.unshift("#version 300 es"), o2 && b2.push("#define OVERDRAW_INSPECTOR;"), s2 && b2.push("#define TERRAIN3D;"), l2 && b2.push(l2), c2 && b2.push(...c2);
	        let y2 = b2.concat(It.prelude.fragmentSource, n2.fragmentSource, i2.fragmentSource).join("\n"), w2 = b2.concat(It.prelude.vertexSource, n2.vertexSource, i2.vertexSource).join("\n");
	        Jt(h2) || (y2 = function(e3) {
	          return e3.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
	        }(y2), w2 = function(e3) {
	          return e3.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
	        }(w2));
	        const T2 = h2.createShader(h2.FRAGMENT_SHADER);
	        if (h2.isContextLost()) return void (this.failedToCreate = true);
	        if (h2.shaderSource(T2, y2), h2.compileShader(T2), !h2.getShaderParameter(T2, h2.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${h2.getShaderInfoLog(T2)}`);
	        h2.attachShader(this.program, T2);
	        const P2 = h2.createShader(h2.VERTEX_SHADER);
	        if (h2.isContextLost()) return void (this.failedToCreate = true);
	        if (h2.shaderSource(P2, w2), h2.compileShader(P2), !h2.getShaderParameter(P2, h2.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${h2.getShaderInfoLog(P2)}`);
	        h2.attachShader(this.program, P2), this.attributes = {};
	        const C2 = {};
	        this.numAttributes = _2.length;
	        for (let e3 = 0; e3 < this.numAttributes; e3++) _2[e3] && (h2.bindAttribLocation(this.program, e3, _2[e3]), this.attributes[_2[e3]] = e3);
	        if (h2.linkProgram(this.program), !h2.getProgramParameter(this.program, h2.LINK_STATUS)) throw new Error(`Program failed to link: ${h2.getProgramInfoLog(this.program)}`);
	        h2.deleteShader(P2), h2.deleteShader(T2);
	        for (let e3 = 0; e3 < x2.length; e3++) {
	          const t2 = x2[e3];
	          if (t2 && !C2[t2]) {
	            const e4 = h2.getUniformLocation(this.program, t2);
	            e4 && (C2[t2] = e4);
	          }
	        }
	        this.fixedUniforms = r2(e2, C2), this.terrainUniforms = ((e3, i3) => ({ u_depth: new t.bZ(e3, i3.u_depth), u_terrain: new t.bZ(e3, i3.u_terrain), u_terrain_dim: new t.bp(e3, i3.u_terrain_dim), u_terrain_matrix: new t.b$(e3, i3.u_terrain_matrix), u_terrain_unpack: new t.c0(e3, i3.u_terrain_unpack), u_terrain_exaggeration: new t.bp(e3, i3.u_terrain_exaggeration) }))(e2, C2), this.projectionUniforms = ((e3, i3) => ({ u_projection_matrix: new t.b$(e3, i3.u_projection_matrix), u_projection_tile_mercator_coords: new t.c0(e3, i3.u_projection_tile_mercator_coords), u_projection_clipping_plane: new t.c0(e3, i3.u_projection_clipping_plane), u_projection_transition: new t.bp(e3, i3.u_projection_transition), u_projection_fallback_matrix: new t.b$(e3, i3.u_projection_fallback_matrix) }))(e2, C2), this.binderUniforms = a2 ? a2.getUniforms(e2, C2) : [];
	      }
	      draw(e2, t2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2, _2, p2, m2, f2, g2, v2) {
	        const x2 = e2.gl;
	        if (this.failedToCreate) return;
	        if (e2.program.set(this.program), e2.setDepthMode(i2), e2.setStencilMode(a2), e2.setColorMode(r2), e2.setCullFace(o2), n2) {
	          e2.activeTexture.set(x2.TEXTURE2), x2.bindTexture(x2.TEXTURE_2D, n2.depthTexture), e2.activeTexture.set(x2.TEXTURE3), x2.bindTexture(x2.TEXTURE_2D, n2.texture);
	          for (const e3 in this.terrainUniforms) this.terrainUniforms[e3].set(n2[e3]);
	        }
	        if (l2) for (const e3 in l2) this.projectionUniforms[Ai[e3]].set(l2[e3]);
	        if (s2) for (const e3 in this.fixedUniforms) this.fixedUniforms[e3].set(s2[e3]);
	        m2 && m2.setUniforms(e2, this.binderUniforms, _2, { zoom: p2 });
	        let b2 = 0;
	        switch (t2) {
	          case x2.LINES:
	            b2 = 2;
	            break;
	          case x2.TRIANGLES:
	            b2 = 3;
	            break;
	          case x2.LINE_STRIP:
	            b2 = 1;
	        }
	        for (const i3 of d2.get()) {
	          const a3 = i3.vaos || (i3.vaos = {});
	          (a3[c2] || (a3[c2] = new Di())).bind(e2, this, h2, m2 ? m2.getPaintVertexBuffers() : [], u2, i3.vertexOffset, f2, g2, v2), x2.drawElements(t2, i3.primitiveLength * b2, x2.UNSIGNED_SHORT, i3.primitiveOffset * b2 * 2);
	        }
	      }
	    }
	    function Fi(e2, i2, a2) {
	      const r2 = 1 / t.aM(a2, 1, i2.transform.tileZoom), o2 = Math.pow(2, a2.tileID.overscaledZ), s2 = a2.tileSize * Math.pow(2, i2.transform.tileZoom) / o2, n2 = s2 * (a2.tileID.canonical.x + a2.tileID.wrap * o2), l2 = s2 * a2.tileID.canonical.y;
	      return { u_image: 0, u_texsize: a2.imageAtlasTexture.size, u_scale: [r2, e2.fromScale, e2.toScale], u_fade: e2.t, u_pixel_coord_upper: [n2 >> 16, l2 >> 16], u_pixel_coord_lower: [65535 & n2, 65535 & l2] };
	    }
	    const Bi = (e2, i2, a2, r2) => {
	      const o2 = e2.style.light, s2 = o2.properties.get("position"), n2 = [s2.x, s2.y, s2.z], l2 = t.c3();
	      "viewport" === o2.properties.get("anchor") && t.c4(l2, e2.transform.bearingInRadians), t.c5(n2, n2, l2);
	      const c2 = e2.transform.transformLightDirection(n2), h2 = o2.properties.get("color");
	      return { u_lightpos: n2, u_lightpos_globe: c2, u_lightintensity: o2.properties.get("intensity"), u_lightcolor: [h2.r, h2.g, h2.b], u_vertical_gradient: +i2, u_opacity: a2, u_fill_translate: r2 };
	    }, Oi = (e2, i2, a2, r2, o2, s2, n2) => t.e(Bi(e2, i2, a2, r2), Fi(s2, e2, n2), { u_height_factor: -Math.pow(2, o2.overscaledZ) / n2.tileSize / 8 }), ji = (e2, i2, a2, r2) => t.e(Fi(i2, e2, a2), { u_fill_translate: r2 }), Ni = (e2, t2) => ({ u_world: e2, u_fill_translate: t2 }), Zi = (e2, i2, a2, r2, o2) => t.e(ji(e2, i2, a2, o2), { u_world: r2 }), Gi = (e2, i2, a2, r2, o2) => {
	      const s2 = e2.transform;
	      let n2, l2, c2 = 0;
	      if ("map" === a2.paint.get("circle-pitch-alignment")) {
	        const e3 = t.aM(i2, 1, s2.zoom);
	        n2 = true, l2 = [e3, e3], c2 = e3 / (t.a4 * Math.pow(2, i2.tileID.overscaledZ)) * 2 * Math.PI * o2;
	      } else n2 = false, l2 = s2.pixelsToGLUnits;
	      return { u_camera_to_center_distance: s2.cameraToCenterDistance, u_scale_with_map: +("map" === a2.paint.get("circle-pitch-scale")), u_pitch_with_map: +n2, u_device_pixel_ratio: e2.pixelRatio, u_extrude_scale: l2, u_globe_extrude_scale: c2, u_translate: r2 };
	    }, Ui = (e2) => ({ u_pixel_extrude_scale: [1 / e2.width, 1 / e2.height] }), Vi = (e2) => ({ u_viewport_size: [e2.width, e2.height] }), qi = (e2, t2 = 1) => ({ u_color: e2, u_overlay: 0, u_overlay_scale: t2 }), Wi = (e2, i2, a2, r2) => {
	      const o2 = t.aM(e2, 1, i2) / (t.a4 * Math.pow(2, e2.tileID.overscaledZ)) * 2 * Math.PI * r2;
	      return { u_extrude_scale: t.aM(e2, 1, i2), u_intensity: a2, u_globe_extrude_scale: o2 };
	    }, $i = (e2, i2, a2, r2) => {
	      const o2 = t.N();
	      t.c6(o2, 0, e2.width, e2.height, 0, 0, 1);
	      const s2 = e2.context.gl;
	      return { u_matrix: o2, u_world: [s2.drawingBufferWidth, s2.drawingBufferHeight], u_image: a2, u_color_ramp: r2, u_opacity: i2.paint.get("heatmap-opacity") };
	    }, Hi = (e2, t2, i2) => {
	      const a2 = i2.paint.get("hillshade-accent-color");
	      let r2;
	      switch (i2.paint.get("hillshade-method")) {
	        case "basic":
	          r2 = 4;
	          break;
	        case "combined":
	          r2 = 1;
	          break;
	        case "igor":
	          r2 = 2;
	          break;
	        case "multidirectional":
	          r2 = 3;
	          break;
	        default:
	          r2 = 0;
	      }
	      const o2 = i2.getIlluminationProperties();
	      for (let t3 = 0; t3 < o2.directionRadians.length; t3++) "viewport" === i2.paint.get("hillshade-illumination-anchor") && (o2.directionRadians[t3] += e2.transform.bearingInRadians);
	      return { u_image: 0, u_latrange: Ki(0, t2.tileID), u_exaggeration: i2.paint.get("hillshade-exaggeration"), u_altitudes: o2.altitudeRadians, u_azimuths: o2.directionRadians, u_accent: a2, u_method: r2, u_highlights: o2.highlightColor, u_shadows: o2.shadowColor };
	    }, Xi = (e2, i2) => {
	      const a2 = i2.stride, r2 = t.N();
	      return t.c6(r2, 0, t.a4, -t.a4, 0, 0, 1), t.O(r2, r2, [0, -t.a4, 0]), { u_matrix: r2, u_image: 1, u_dimension: [a2, a2], u_zoom: e2.overscaledZ, u_unpack: i2.getUnpackVector() };
	    };
	    function Ki(e2, i2) {
	      const a2 = Math.pow(2, i2.canonical.z), r2 = i2.canonical.y;
	      return [new t.aa(0, r2 / a2).toLngLat().lat, new t.aa(0, (r2 + 1) / a2).toLngLat().lat];
	    }
	    const Yi = (e2, t2, i2 = 0) => ({ u_image: 0, u_unpack: t2.getUnpackVector(), u_dimension: [t2.stride, t2.stride], u_elevation_stops: 1, u_color_stops: 4, u_color_ramp_size: i2, u_opacity: e2.paint.get("color-relief-opacity") }), Qi = (e2, i2, a2, r2) => {
	      const o2 = e2.transform;
	      return { u_translation: ra(e2, i2, a2), u_ratio: r2 / t.aM(i2, 1, o2.zoom), u_device_pixel_ratio: e2.pixelRatio, u_units_to_pixels: [1 / o2.pixelsToGLUnits[0], 1 / o2.pixelsToGLUnits[1]] };
	    }, Ji = (e2, i2, a2, r2, o2) => t.e(Qi(e2, i2, a2, r2), { u_image: 0, u_image_height: o2 }), ea = (e2, i2, a2, r2, o2) => {
	      const s2 = e2.transform, n2 = aa(i2, s2);
	      return { u_translation: ra(e2, i2, a2), u_texsize: i2.imageAtlasTexture.size, u_ratio: r2 / t.aM(i2, 1, s2.zoom), u_device_pixel_ratio: e2.pixelRatio, u_image: 0, u_scale: [n2, o2.fromScale, o2.toScale], u_fade: o2.t, u_units_to_pixels: [1 / s2.pixelsToGLUnits[0], 1 / s2.pixelsToGLUnits[1]] };
	    }, ta = (e2, i2, a2, r2, o2) => {
	      const s2 = aa(i2, e2.transform);
	      return t.e(Qi(e2, i2, a2, r2), { u_tileratio: s2, u_crossfade_from: o2.fromScale, u_crossfade_to: o2.toScale, u_image: 0, u_mix: o2.t, u_lineatlas_width: e2.lineAtlas.width, u_lineatlas_height: e2.lineAtlas.height });
	    }, ia = (e2, i2, a2, r2, o2, s2) => {
	      const n2 = aa(i2, e2.transform);
	      return t.e(Qi(e2, i2, a2, r2), { u_image: 0, u_image_height: s2, u_tileratio: n2, u_crossfade_from: o2.fromScale, u_crossfade_to: o2.toScale, u_image_dash: 1, u_mix: o2.t, u_lineatlas_width: e2.lineAtlas.width, u_lineatlas_height: e2.lineAtlas.height });
	    };
	    function aa(e2, i2) {
	      return 1 / t.aM(e2, 1, i2.tileZoom);
	    }
	    function ra(e2, i2, a2) {
	      return t.aN(e2.transform, i2, a2.paint.get("line-translate"), a2.paint.get("line-translate-anchor"));
	    }
	    const oa = (e2, t2, i2, a2, r2) => {
	      return { u_tl_parent: e2, u_scale_parent: t2, u_buffer_scale: 1, u_fade_t: i2.mix, u_opacity: i2.opacity * a2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: a2.paint.get("raster-brightness-min"), u_brightness_high: a2.paint.get("raster-brightness-max"), u_saturation_factor: (s2 = a2.paint.get("raster-saturation"), s2 > 0 ? 1 - 1 / (1.001 - s2) : -s2), u_contrast_factor: (o2 = a2.paint.get("raster-contrast"), o2 > 0 ? 1 / (1 - o2) : 1 + o2), u_spin_weights: sa(a2.paint.get("raster-hue-rotate")), u_coords_top: [r2[0].x, r2[0].y, r2[1].x, r2[1].y], u_coords_bottom: [r2[3].x, r2[3].y, r2[2].x, r2[2].y] };
	      var o2, s2;
	    };
	    function sa(e2) {
	      e2 *= Math.PI / 180;
	      const t2 = Math.sin(e2), i2 = Math.cos(e2);
	      return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * t2 - i2 + 1) / 3, (Math.sqrt(3) * t2 - i2 + 1) / 3];
	    }
	    const na = (e2, t2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2) => {
	      const _2 = s2.transform;
	      return { u_is_size_zoom_constant: +("constant" === e2 || "source" === e2), u_is_size_feature_constant: +("constant" === e2 || "camera" === e2), u_size_t: t2 ? t2.uSizeT : 0, u_size: t2 ? t2.uSize : 0, u_camera_to_center_distance: _2.cameraToCenterDistance, u_pitch: _2.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i2, u_aspect_ratio: _2.width / _2.height, u_fade_change: s2.options.fadeDuration ? s2.symbolFadeChange : 1, u_label_plane_matrix: n2, u_coord_matrix: l2, u_is_text: +h2, u_pitch_with_map: +a2, u_is_along_line: r2, u_is_variable_anchor: o2, u_texsize: u2, u_texture: 0, u_translation: c2, u_pitched_scale: d2 };
	    }, la = (e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2, _2, p2) => {
	      const m2 = n2.transform;
	      return t.e(na(e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2, p2), { u_gamma_scale: r2 ? Math.cos(m2.pitch * Math.PI / 180) * m2.cameraToCenterDistance : 1, u_device_pixel_ratio: n2.pixelRatio, u_is_halo: 1 });
	    }, ca = (e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2, _2) => t.e(la(e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, true, u2, 0, _2), { u_texsize_icon: d2, u_texture_icon: 1 }), ha = (e2, t2) => ({ u_opacity: e2, u_color: t2 }), ua = (e2, i2, a2, r2, o2) => t.e(function(e3, i3, a3, r3) {
	      const o3 = a3.imageManager.getPattern(e3.from.toString()), s2 = a3.imageManager.getPattern(e3.to.toString()), { width: n2, height: l2 } = a3.imageManager.getPixelSize(), c2 = Math.pow(2, r3.tileID.overscaledZ), h2 = r3.tileSize * Math.pow(2, a3.transform.tileZoom) / c2, u2 = h2 * (r3.tileID.canonical.x + r3.tileID.wrap * c2), d2 = h2 * r3.tileID.canonical.y;
	      return { u_image: 0, u_pattern_tl_a: o3.tl, u_pattern_br_a: o3.br, u_pattern_tl_b: s2.tl, u_pattern_br_b: s2.br, u_texsize: [n2, l2], u_mix: i3.t, u_pattern_size_a: o3.displaySize, u_pattern_size_b: s2.displaySize, u_scale_a: i3.fromScale, u_scale_b: i3.toScale, u_tile_units_to_pixels: 1 / t.aM(r3, 1, a3.transform.tileZoom), u_pixel_coord_upper: [u2 >> 16, d2 >> 16], u_pixel_coord_lower: [65535 & u2, 65535 & d2] };
	    }(a2, o2, i2, r2), { u_opacity: e2 }), da = (e2, t2) => {
	    }, _a = { fillExtrusion: (e2, i2) => ({ u_lightpos: new t.c1(e2, i2.u_lightpos), u_lightpos_globe: new t.c1(e2, i2.u_lightpos_globe), u_lightintensity: new t.bp(e2, i2.u_lightintensity), u_lightcolor: new t.c1(e2, i2.u_lightcolor), u_vertical_gradient: new t.bp(e2, i2.u_vertical_gradient), u_opacity: new t.bp(e2, i2.u_opacity), u_fill_translate: new t.c2(e2, i2.u_fill_translate) }), fillExtrusionPattern: (e2, i2) => ({ u_lightpos: new t.c1(e2, i2.u_lightpos), u_lightpos_globe: new t.c1(e2, i2.u_lightpos_globe), u_lightintensity: new t.bp(e2, i2.u_lightintensity), u_lightcolor: new t.c1(e2, i2.u_lightcolor), u_vertical_gradient: new t.bp(e2, i2.u_vertical_gradient), u_height_factor: new t.bp(e2, i2.u_height_factor), u_opacity: new t.bp(e2, i2.u_opacity), u_fill_translate: new t.c2(e2, i2.u_fill_translate), u_image: new t.bZ(e2, i2.u_image), u_texsize: new t.c2(e2, i2.u_texsize), u_pixel_coord_upper: new t.c2(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.c2(e2, i2.u_pixel_coord_lower), u_scale: new t.c1(e2, i2.u_scale), u_fade: new t.bp(e2, i2.u_fade) }), fill: (e2, i2) => ({ u_fill_translate: new t.c2(e2, i2.u_fill_translate) }), fillPattern: (e2, i2) => ({ u_image: new t.bZ(e2, i2.u_image), u_texsize: new t.c2(e2, i2.u_texsize), u_pixel_coord_upper: new t.c2(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.c2(e2, i2.u_pixel_coord_lower), u_scale: new t.c1(e2, i2.u_scale), u_fade: new t.bp(e2, i2.u_fade), u_fill_translate: new t.c2(e2, i2.u_fill_translate) }), fillOutline: (e2, i2) => ({ u_world: new t.c2(e2, i2.u_world), u_fill_translate: new t.c2(e2, i2.u_fill_translate) }), fillOutlinePattern: (e2, i2) => ({ u_world: new t.c2(e2, i2.u_world), u_image: new t.bZ(e2, i2.u_image), u_texsize: new t.c2(e2, i2.u_texsize), u_pixel_coord_upper: new t.c2(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.c2(e2, i2.u_pixel_coord_lower), u_scale: new t.c1(e2, i2.u_scale), u_fade: new t.bp(e2, i2.u_fade), u_fill_translate: new t.c2(e2, i2.u_fill_translate) }), circle: (e2, i2) => ({ u_camera_to_center_distance: new t.bp(e2, i2.u_camera_to_center_distance), u_scale_with_map: new t.bZ(e2, i2.u_scale_with_map), u_pitch_with_map: new t.bZ(e2, i2.u_pitch_with_map), u_extrude_scale: new t.c2(e2, i2.u_extrude_scale), u_device_pixel_ratio: new t.bp(e2, i2.u_device_pixel_ratio), u_globe_extrude_scale: new t.bp(e2, i2.u_globe_extrude_scale), u_translate: new t.c2(e2, i2.u_translate) }), collisionBox: (e2, i2) => ({ u_pixel_extrude_scale: new t.c2(e2, i2.u_pixel_extrude_scale) }), collisionCircle: (e2, i2) => ({ u_viewport_size: new t.c2(e2, i2.u_viewport_size) }), debug: (e2, i2) => ({ u_color: new t.b_(e2, i2.u_color), u_overlay: new t.bZ(e2, i2.u_overlay), u_overlay_scale: new t.bp(e2, i2.u_overlay_scale) }), depth: da, clippingMask: da, heatmap: (e2, i2) => ({ u_extrude_scale: new t.bp(e2, i2.u_extrude_scale), u_intensity: new t.bp(e2, i2.u_intensity), u_globe_extrude_scale: new t.bp(e2, i2.u_globe_extrude_scale) }), heatmapTexture: (e2, i2) => ({ u_matrix: new t.b$(e2, i2.u_matrix), u_world: new t.c2(e2, i2.u_world), u_image: new t.bZ(e2, i2.u_image), u_color_ramp: new t.bZ(e2, i2.u_color_ramp), u_opacity: new t.bp(e2, i2.u_opacity) }), hillshade: (e2, i2) => ({ u_image: new t.bZ(e2, i2.u_image), u_latrange: new t.c2(e2, i2.u_latrange), u_exaggeration: new t.bp(e2, i2.u_exaggeration), u_altitudes: new t.c8(e2, i2.u_altitudes), u_azimuths: new t.c8(e2, i2.u_azimuths), u_accent: new t.b_(e2, i2.u_accent), u_method: new t.bZ(e2, i2.u_method), u_shadows: new t.c7(e2, i2.u_shadows), u_highlights: new t.c7(e2, i2.u_highlights) }), hillshadePrepare: (e2, i2) => ({ u_matrix: new t.b$(e2, i2.u_matrix), u_image: new t.bZ(e2, i2.u_image), u_dimension: new t.c2(e2, i2.u_dimension), u_zoom: new t.bp(e2, i2.u_zoom), u_unpack: new t.c0(e2, i2.u_unpack) }), colorRelief: (e2, i2) => ({ u_image: new t.bZ(e2, i2.u_image), u_unpack: new t.c0(e2, i2.u_unpack), u_dimension: new t.c2(e2, i2.u_dimension), u_elevation_stops: new t.bZ(e2, i2.u_elevation_stops), u_color_stops: new t.bZ(e2, i2.u_color_stops), u_color_ramp_size: new t.bZ(e2, i2.u_color_ramp_size), u_opacity: new t.bp(e2, i2.u_opacity) }), line: (e2, i2) => ({ u_translation: new t.c2(e2, i2.u_translation), u_ratio: new t.bp(e2, i2.u_ratio), u_device_pixel_ratio: new t.bp(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.c2(e2, i2.u_units_to_pixels) }), lineGradient: (e2, i2) => ({ u_translation: new t.c2(e2, i2.u_translation), u_ratio: new t.bp(e2, i2.u_ratio), u_device_pixel_ratio: new t.bp(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.c2(e2, i2.u_units_to_pixels), u_image: new t.bZ(e2, i2.u_image), u_image_height: new t.bp(e2, i2.u_image_height) }), linePattern: (e2, i2) => ({ u_translation: new t.c2(e2, i2.u_translation), u_texsize: new t.c2(e2, i2.u_texsize), u_ratio: new t.bp(e2, i2.u_ratio), u_device_pixel_ratio: new t.bp(e2, i2.u_device_pixel_ratio), u_image: new t.bZ(e2, i2.u_image), u_units_to_pixels: new t.c2(e2, i2.u_units_to_pixels), u_scale: new t.c1(e2, i2.u_scale), u_fade: new t.bp(e2, i2.u_fade) }), lineSDF: (e2, i2) => ({ u_translation: new t.c2(e2, i2.u_translation), u_ratio: new t.bp(e2, i2.u_ratio), u_device_pixel_ratio: new t.bp(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.c2(e2, i2.u_units_to_pixels), u_image: new t.bZ(e2, i2.u_image), u_mix: new t.bp(e2, i2.u_mix), u_tileratio: new t.bp(e2, i2.u_tileratio), u_crossfade_from: new t.bp(e2, i2.u_crossfade_from), u_crossfade_to: new t.bp(e2, i2.u_crossfade_to), u_lineatlas_width: new t.bp(e2, i2.u_lineatlas_width), u_lineatlas_height: new t.bp(e2, i2.u_lineatlas_height) }), lineGradientSDF: (e2, i2) => ({ u_translation: new t.c2(e2, i2.u_translation), u_ratio: new t.bp(e2, i2.u_ratio), u_device_pixel_ratio: new t.bp(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.c2(e2, i2.u_units_to_pixels), u_image: new t.bZ(e2, i2.u_image), u_image_height: new t.bp(e2, i2.u_image_height), u_tileratio: new t.bp(e2, i2.u_tileratio), u_crossfade_from: new t.bp(e2, i2.u_crossfade_from), u_crossfade_to: new t.bp(e2, i2.u_crossfade_to), u_image_dash: new t.bZ(e2, i2.u_image_dash), u_mix: new t.bp(e2, i2.u_mix), u_lineatlas_width: new t.bp(e2, i2.u_lineatlas_width), u_lineatlas_height: new t.bp(e2, i2.u_lineatlas_height) }), raster: (e2, i2) => ({ u_tl_parent: new t.c2(e2, i2.u_tl_parent), u_scale_parent: new t.bp(e2, i2.u_scale_parent), u_buffer_scale: new t.bp(e2, i2.u_buffer_scale), u_fade_t: new t.bp(e2, i2.u_fade_t), u_opacity: new t.bp(e2, i2.u_opacity), u_image0: new t.bZ(e2, i2.u_image0), u_image1: new t.bZ(e2, i2.u_image1), u_brightness_low: new t.bp(e2, i2.u_brightness_low), u_brightness_high: new t.bp(e2, i2.u_brightness_high), u_saturation_factor: new t.bp(e2, i2.u_saturation_factor), u_contrast_factor: new t.bp(e2, i2.u_contrast_factor), u_spin_weights: new t.c1(e2, i2.u_spin_weights), u_coords_top: new t.c0(e2, i2.u_coords_top), u_coords_bottom: new t.c0(e2, i2.u_coords_bottom) }), symbolIcon: (e2, i2) => ({ u_is_size_zoom_constant: new t.bZ(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.bZ(e2, i2.u_is_size_feature_constant), u_size_t: new t.bp(e2, i2.u_size_t), u_size: new t.bp(e2, i2.u_size), u_camera_to_center_distance: new t.bp(e2, i2.u_camera_to_center_distance), u_pitch: new t.bp(e2, i2.u_pitch), u_rotate_symbol: new t.bZ(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.bp(e2, i2.u_aspect_ratio), u_fade_change: new t.bp(e2, i2.u_fade_change), u_label_plane_matrix: new t.b$(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.b$(e2, i2.u_coord_matrix), u_is_text: new t.bZ(e2, i2.u_is_text), u_pitch_with_map: new t.bZ(e2, i2.u_pitch_with_map), u_is_along_line: new t.bZ(e2, i2.u_is_along_line), u_is_variable_anchor: new t.bZ(e2, i2.u_is_variable_anchor), u_texsize: new t.c2(e2, i2.u_texsize), u_texture: new t.bZ(e2, i2.u_texture), u_translation: new t.c2(e2, i2.u_translation), u_pitched_scale: new t.bp(e2, i2.u_pitched_scale) }), symbolSDF: (e2, i2) => ({ u_is_size_zoom_constant: new t.bZ(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.bZ(e2, i2.u_is_size_feature_constant), u_size_t: new t.bp(e2, i2.u_size_t), u_size: new t.bp(e2, i2.u_size), u_camera_to_center_distance: new t.bp(e2, i2.u_camera_to_center_distance), u_pitch: new t.bp(e2, i2.u_pitch), u_rotate_symbol: new t.bZ(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.bp(e2, i2.u_aspect_ratio), u_fade_change: new t.bp(e2, i2.u_fade_change), u_label_plane_matrix: new t.b$(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.b$(e2, i2.u_coord_matrix), u_is_text: new t.bZ(e2, i2.u_is_text), u_pitch_with_map: new t.bZ(e2, i2.u_pitch_with_map), u_is_along_line: new t.bZ(e2, i2.u_is_along_line), u_is_variable_anchor: new t.bZ(e2, i2.u_is_variable_anchor), u_texsize: new t.c2(e2, i2.u_texsize), u_texture: new t.bZ(e2, i2.u_texture), u_gamma_scale: new t.bp(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.bp(e2, i2.u_device_pixel_ratio), u_is_halo: new t.bZ(e2, i2.u_is_halo), u_translation: new t.c2(e2, i2.u_translation), u_pitched_scale: new t.bp(e2, i2.u_pitched_scale) }), symbolTextAndIcon: (e2, i2) => ({ u_is_size_zoom_constant: new t.bZ(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.bZ(e2, i2.u_is_size_feature_constant), u_size_t: new t.bp(e2, i2.u_size_t), u_size: new t.bp(e2, i2.u_size), u_camera_to_center_distance: new t.bp(e2, i2.u_camera_to_center_distance), u_pitch: new t.bp(e2, i2.u_pitch), u_rotate_symbol: new t.bZ(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.bp(e2, i2.u_aspect_ratio), u_fade_change: new t.bp(e2, i2.u_fade_change), u_label_plane_matrix: new t.b$(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.b$(e2, i2.u_coord_matrix), u_is_text: new t.bZ(e2, i2.u_is_text), u_pitch_with_map: new t.bZ(e2, i2.u_pitch_with_map), u_is_along_line: new t.bZ(e2, i2.u_is_along_line), u_is_variable_anchor: new t.bZ(e2, i2.u_is_variable_anchor), u_texsize: new t.c2(e2, i2.u_texsize), u_texsize_icon: new t.c2(e2, i2.u_texsize_icon), u_texture: new t.bZ(e2, i2.u_texture), u_texture_icon: new t.bZ(e2, i2.u_texture_icon), u_gamma_scale: new t.bp(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.bp(e2, i2.u_device_pixel_ratio), u_is_halo: new t.bZ(e2, i2.u_is_halo), u_translation: new t.c2(e2, i2.u_translation), u_pitched_scale: new t.bp(e2, i2.u_pitched_scale) }), background: (e2, i2) => ({ u_opacity: new t.bp(e2, i2.u_opacity), u_color: new t.b_(e2, i2.u_color) }), backgroundPattern: (e2, i2) => ({ u_opacity: new t.bp(e2, i2.u_opacity), u_image: new t.bZ(e2, i2.u_image), u_pattern_tl_a: new t.c2(e2, i2.u_pattern_tl_a), u_pattern_br_a: new t.c2(e2, i2.u_pattern_br_a), u_pattern_tl_b: new t.c2(e2, i2.u_pattern_tl_b), u_pattern_br_b: new t.c2(e2, i2.u_pattern_br_b), u_texsize: new t.c2(e2, i2.u_texsize), u_mix: new t.bp(e2, i2.u_mix), u_pattern_size_a: new t.c2(e2, i2.u_pattern_size_a), u_pattern_size_b: new t.c2(e2, i2.u_pattern_size_b), u_scale_a: new t.bp(e2, i2.u_scale_a), u_scale_b: new t.bp(e2, i2.u_scale_b), u_pixel_coord_upper: new t.c2(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.c2(e2, i2.u_pixel_coord_lower), u_tile_units_to_pixels: new t.bp(e2, i2.u_tile_units_to_pixels) }), terrain: (e2, i2) => ({ u_texture: new t.bZ(e2, i2.u_texture), u_ele_delta: new t.bp(e2, i2.u_ele_delta), u_fog_matrix: new t.b$(e2, i2.u_fog_matrix), u_fog_color: new t.b_(e2, i2.u_fog_color), u_fog_ground_blend: new t.bp(e2, i2.u_fog_ground_blend), u_fog_ground_blend_opacity: new t.bp(e2, i2.u_fog_ground_blend_opacity), u_horizon_color: new t.b_(e2, i2.u_horizon_color), u_horizon_fog_blend: new t.bp(e2, i2.u_horizon_fog_blend), u_is_globe_mode: new t.bp(e2, i2.u_is_globe_mode) }), terrainDepth: (e2, i2) => ({ u_ele_delta: new t.bp(e2, i2.u_ele_delta) }), terrainCoords: (e2, i2) => ({ u_texture: new t.bZ(e2, i2.u_texture), u_terrain_coords_id: new t.bp(e2, i2.u_terrain_coords_id), u_ele_delta: new t.bp(e2, i2.u_ele_delta) }), projectionErrorMeasurement: (e2, i2) => ({ u_input: new t.bp(e2, i2.u_input), u_output_expected: new t.bp(e2, i2.u_output_expected) }), atmosphere: (e2, i2) => ({ u_sun_pos: new t.c1(e2, i2.u_sun_pos), u_atmosphere_blend: new t.bp(e2, i2.u_atmosphere_blend), u_globe_position: new t.c1(e2, i2.u_globe_position), u_globe_radius: new t.bp(e2, i2.u_globe_radius), u_inv_proj_matrix: new t.b$(e2, i2.u_inv_proj_matrix) }), sky: (e2, i2) => ({ u_sky_color: new t.b_(e2, i2.u_sky_color), u_horizon_color: new t.b_(e2, i2.u_horizon_color), u_horizon: new t.c2(e2, i2.u_horizon), u_horizon_normal: new t.c2(e2, i2.u_horizon_normal), u_sky_horizon_blend: new t.bp(e2, i2.u_sky_horizon_blend), u_sky_blend: new t.bp(e2, i2.u_sky_blend) }) };
	    class pa {
	      constructor(e2, t2, i2) {
	        this.context = e2;
	        const a2 = e2.gl;
	        this.buffer = a2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), e2.bindElementBuffer.set(this.buffer), a2.bufferData(a2.ELEMENT_ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? a2.DYNAMIC_DRAW : a2.STATIC_DRAW), this.dynamicDraw || delete t2.arrayBuffer;
	      }
	      bind() {
	        this.context.bindElementBuffer.set(this.buffer);
	      }
	      updateData(e2) {
	        const t2 = this.context.gl;
	        if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
	        this.context.unbindVAO(), this.bind(), t2.bufferSubData(t2.ELEMENT_ARRAY_BUFFER, 0, e2.arrayBuffer);
	      }
	      destroy() {
	        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
	      }
	    }
	    const ma = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
	    class fa {
	      constructor(e2, t2, i2, a2) {
	        this.length = t2.length, this.attributes = i2, this.itemSize = t2.bytesPerElement, this.dynamicDraw = a2, this.context = e2;
	        const r2 = e2.gl;
	        this.buffer = r2.createBuffer(), e2.bindVertexBuffer.set(this.buffer), r2.bufferData(r2.ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? r2.DYNAMIC_DRAW : r2.STATIC_DRAW), this.dynamicDraw || delete t2.arrayBuffer;
	      }
	      bind() {
	        this.context.bindVertexBuffer.set(this.buffer);
	      }
	      updateData(e2) {
	        if (e2.length !== this.length) throw new Error(`Length of new data is ${e2.length}, which doesn't match current length of ${this.length}`);
	        const t2 = this.context.gl;
	        this.bind(), t2.bufferSubData(t2.ARRAY_BUFFER, 0, e2.arrayBuffer);
	      }
	      enableAttributes(e2, t2) {
	        for (let i2 = 0; i2 < this.attributes.length; i2++) {
	          const a2 = t2.attributes[this.attributes[i2].name];
	          void 0 !== a2 && e2.enableVertexAttribArray(a2);
	        }
	      }
	      setVertexAttribPointers(e2, t2, i2) {
	        for (let a2 = 0; a2 < this.attributes.length; a2++) {
	          const r2 = this.attributes[a2], o2 = t2.attributes[r2.name];
	          void 0 !== o2 && e2.vertexAttribPointer(o2, r2.components, e2[ma[r2.type]], false, this.itemSize, r2.offset + this.itemSize * (i2 || 0));
	        }
	      }
	      destroy() {
	        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
	      }
	    }
	    class ga {
	      constructor(e2) {
	        this.gl = e2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
	      }
	      get() {
	        return this.current;
	      }
	      set(e2) {
	      }
	      getDefault() {
	        return this.default;
	      }
	      setDefault() {
	        this.set(this.default);
	      }
	    }
	    class va extends ga {
	      getDefault() {
	        return t.bo.transparent;
	      }
	      set(e2) {
	        const t2 = this.current;
	        (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.clearColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
	      }
	    }
	    class xa extends ga {
	      getDefault() {
	        return 1;
	      }
	      set(e2) {
	        (e2 !== this.current || this.dirty) && (this.gl.clearDepth(e2), this.current = e2, this.dirty = false);
	      }
	    }
	    class ba extends ga {
	      getDefault() {
	        return 0;
	      }
	      set(e2) {
	        (e2 !== this.current || this.dirty) && (this.gl.clearStencil(e2), this.current = e2, this.dirty = false);
	      }
	    }
	    class ya extends ga {
	      getDefault() {
	        return [true, true, true, true];
	      }
	      set(e2) {
	        const t2 = this.current;
	        (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.colorMask(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
	      }
	    }
	    class wa extends ga {
	      getDefault() {
	        return true;
	      }
	      set(e2) {
	        (e2 !== this.current || this.dirty) && (this.gl.depthMask(e2), this.current = e2, this.dirty = false);
	      }
	    }
	    class Ta extends ga {
	      getDefault() {
	        return 255;
	      }
	      set(e2) {
	        (e2 !== this.current || this.dirty) && (this.gl.stencilMask(e2), this.current = e2, this.dirty = false);
	      }
	    }
	    class Pa extends ga {
	      getDefault() {
	        return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
	      }
	      set(e2) {
	        const t2 = this.current;
	        (e2.func !== t2.func || e2.ref !== t2.ref || e2.mask !== t2.mask || this.dirty) && (this.gl.stencilFunc(e2.func, e2.ref, e2.mask), this.current = e2, this.dirty = false);
	      }
	    }
	    class Ca extends ga {
	      getDefault() {
	        const e2 = this.gl;
	        return [e2.KEEP, e2.KEEP, e2.KEEP];
	      }
	      set(e2) {
	        const t2 = this.current;
	        (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || this.dirty) && (this.gl.stencilOp(e2[0], e2[1], e2[2]), this.current = e2, this.dirty = false);
	      }
	    }
	    class Ma extends ga {
	      getDefault() {
	        return false;
	      }
	      set(e2) {
	        if (e2 === this.current && !this.dirty) return;
	        const t2 = this.gl;
	        e2 ? t2.enable(t2.STENCIL_TEST) : t2.disable(t2.STENCIL_TEST), this.current = e2, this.dirty = false;
	      }
	    }
	    class Ia extends ga {
	      getDefault() {
	        return [0, 1];
	      }
	      set(e2) {
	        const t2 = this.current;
	        (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.depthRange(e2[0], e2[1]), this.current = e2, this.dirty = false);
	      }
	    }
	    class Ea extends ga {
	      getDefault() {
	        return false;
	      }
	      set(e2) {
	        if (e2 === this.current && !this.dirty) return;
	        const t2 = this.gl;
	        e2 ? t2.enable(t2.DEPTH_TEST) : t2.disable(t2.DEPTH_TEST), this.current = e2, this.dirty = false;
	      }
	    }
	    class Sa extends ga {
	      getDefault() {
	        return this.gl.LESS;
	      }
	      set(e2) {
	        (e2 !== this.current || this.dirty) && (this.gl.depthFunc(e2), this.current = e2, this.dirty = false);
	      }
	    }
	    class Ra extends ga {
	      getDefault() {
	        return false;
	      }
	      set(e2) {
	        if (e2 === this.current && !this.dirty) return;
	        const t2 = this.gl;
	        e2 ? t2.enable(t2.BLEND) : t2.disable(t2.BLEND), this.current = e2, this.dirty = false;
	      }
	    }
	    class Da extends ga {
	      getDefault() {
	        const e2 = this.gl;
	        return [e2.ONE, e2.ZERO];
	      }
	      set(e2) {
	        const t2 = this.current;
	        (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.blendFunc(e2[0], e2[1]), this.current = e2, this.dirty = false);
	      }
	    }
	    class za extends ga {
	      getDefault() {
	        return t.bo.transparent;
	      }
	      set(e2) {
	        const t2 = this.current;
	        (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.blendColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
	      }
	    }
	    class Aa extends ga {
	      getDefault() {
	        return this.gl.FUNC_ADD;
	      }
	      set(e2) {
	        (e2 !== this.current || this.dirty) && (this.gl.blendEquation(e2), this.current = e2, this.dirty = false);
	      }
	    }
	    class La extends ga {
	      getDefault() {
	        return false;
	      }
	      set(e2) {
	        if (e2 === this.current && !this.dirty) return;
	        const t2 = this.gl;
	        e2 ? t2.enable(t2.CULL_FACE) : t2.disable(t2.CULL_FACE), this.current = e2, this.dirty = false;
	      }
	    }
	    class ka extends ga {
	      getDefault() {
	        return this.gl.BACK;
	      }
	      set(e2) {
	        (e2 !== this.current || this.dirty) && (this.gl.cullFace(e2), this.current = e2, this.dirty = false);
	      }
	    }
	    class Fa extends ga {
	      getDefault() {
	        return this.gl.CCW;
	      }
	      set(e2) {
	        (e2 !== this.current || this.dirty) && (this.gl.frontFace(e2), this.current = e2, this.dirty = false);
	      }
	    }
	    class Ba extends ga {
	      getDefault() {
	        return null;
	      }
	      set(e2) {
	        (e2 !== this.current || this.dirty) && (this.gl.useProgram(e2), this.current = e2, this.dirty = false);
	      }
	    }
	    class Oa extends ga {
	      getDefault() {
	        return this.gl.TEXTURE0;
	      }
	      set(e2) {
	        (e2 !== this.current || this.dirty) && (this.gl.activeTexture(e2), this.current = e2, this.dirty = false);
	      }
	    }
	    class ja extends ga {
	      getDefault() {
	        const e2 = this.gl;
	        return [0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight];
	      }
	      set(e2) {
	        const t2 = this.current;
	        (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.viewport(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
	      }
	    }
	    class Na extends ga {
	      getDefault() {
	        return null;
	      }
	      set(e2) {
	        if (e2 === this.current && !this.dirty) return;
	        const t2 = this.gl;
	        t2.bindFramebuffer(t2.FRAMEBUFFER, e2), this.current = e2, this.dirty = false;
	      }
	    }
	    class Za extends ga {
	      getDefault() {
	        return null;
	      }
	      set(e2) {
	        if (e2 === this.current && !this.dirty) return;
	        const t2 = this.gl;
	        t2.bindRenderbuffer(t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
	      }
	    }
	    class Ga extends ga {
	      getDefault() {
	        return null;
	      }
	      set(e2) {
	        if (e2 === this.current && !this.dirty) return;
	        const t2 = this.gl;
	        t2.bindTexture(t2.TEXTURE_2D, e2), this.current = e2, this.dirty = false;
	      }
	    }
	    class Ua extends ga {
	      getDefault() {
	        return null;
	      }
	      set(e2) {
	        if (e2 === this.current && !this.dirty) return;
	        const t2 = this.gl;
	        t2.bindBuffer(t2.ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
	      }
	    }
	    class Va extends ga {
	      getDefault() {
	        return null;
	      }
	      set(e2) {
	        const t2 = this.gl;
	        t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
	      }
	    }
	    class qa extends ga {
	      getDefault() {
	        return null;
	      }
	      set(e2) {
	        var t2;
	        if (e2 === this.current && !this.dirty) return;
	        const i2 = this.gl;
	        Jt(i2) ? i2.bindVertexArray(e2) : null === (t2 = i2.getExtension("OES_vertex_array_object")) || void 0 === t2 || t2.bindVertexArrayOES(e2), this.current = e2, this.dirty = false;
	      }
	    }
	    class Wa extends ga {
	      getDefault() {
	        return 4;
	      }
	      set(e2) {
	        if (e2 === this.current && !this.dirty) return;
	        const t2 = this.gl;
	        t2.pixelStorei(t2.UNPACK_ALIGNMENT, e2), this.current = e2, this.dirty = false;
	      }
	    }
	    class $a extends ga {
	      getDefault() {
	        return false;
	      }
	      set(e2) {
	        if (e2 === this.current && !this.dirty) return;
	        const t2 = this.gl;
	        t2.pixelStorei(t2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e2), this.current = e2, this.dirty = false;
	      }
	    }
	    class Ha extends ga {
	      getDefault() {
	        return false;
	      }
	      set(e2) {
	        if (e2 === this.current && !this.dirty) return;
	        const t2 = this.gl;
	        t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, e2), this.current = e2, this.dirty = false;
	      }
	    }
	    class Xa extends ga {
	      constructor(e2, t2) {
	        super(e2), this.context = e2, this.parent = t2;
	      }
	      getDefault() {
	        return null;
	      }
	    }
	    class Ka extends Xa {
	      setDirty() {
	        this.dirty = true;
	      }
	      set(e2) {
	        if (e2 === this.current && !this.dirty) return;
	        this.context.bindFramebuffer.set(this.parent);
	        const t2 = this.gl;
	        t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e2, 0), this.current = e2, this.dirty = false;
	      }
	    }
	    class Ya extends Xa {
	      set(e2) {
	        if (e2 === this.current && !this.dirty) return;
	        this.context.bindFramebuffer.set(this.parent);
	        const t2 = this.gl;
	        t2.framebufferRenderbuffer(t2.FRAMEBUFFER, t2.DEPTH_ATTACHMENT, t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
	      }
	    }
	    class Qa extends Xa {
	      set(e2) {
	        if (e2 === this.current && !this.dirty) return;
	        this.context.bindFramebuffer.set(this.parent);
	        const t2 = this.gl;
	        t2.framebufferRenderbuffer(t2.FRAMEBUFFER, t2.DEPTH_STENCIL_ATTACHMENT, t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
	      }
	    }
	    const Ja = "Framebuffer is not complete";
	    class er {
	      constructor(e2, t2, i2, a2, r2) {
	        this.context = e2, this.width = t2, this.height = i2;
	        const o2 = e2.gl, s2 = this.framebuffer = o2.createFramebuffer();
	        if (this.colorAttachment = new Ka(e2, s2), a2) this.depthAttachment = r2 ? new Qa(e2, s2) : new Ya(e2, s2);
	        else if (r2) throw new Error("Stencil cannot be set without depth");
	        if (o2.checkFramebufferStatus(o2.FRAMEBUFFER) !== o2.FRAMEBUFFER_COMPLETE) throw new Error(Ja);
	      }
	      destroy() {
	        const e2 = this.context.gl, t2 = this.colorAttachment.get();
	        if (t2 && e2.deleteTexture(t2), this.depthAttachment) {
	          const t3 = this.depthAttachment.get();
	          t3 && e2.deleteRenderbuffer(t3);
	        }
	        e2.deleteFramebuffer(this.framebuffer);
	      }
	    }
	    class tr {
	      constructor(e2) {
	        var t2, i2;
	        if (this.gl = e2, this.clearColor = new va(this), this.clearDepth = new xa(this), this.clearStencil = new ba(this), this.colorMask = new ya(this), this.depthMask = new wa(this), this.stencilMask = new Ta(this), this.stencilFunc = new Pa(this), this.stencilOp = new Ca(this), this.stencilTest = new Ma(this), this.depthRange = new Ia(this), this.depthTest = new Ea(this), this.depthFunc = new Sa(this), this.blend = new Ra(this), this.blendFunc = new Da(this), this.blendColor = new za(this), this.blendEquation = new Aa(this), this.cullFace = new La(this), this.cullFaceSide = new ka(this), this.frontFace = new Fa(this), this.program = new Ba(this), this.activeTexture = new Oa(this), this.viewport = new ja(this), this.bindFramebuffer = new Na(this), this.bindRenderbuffer = new Za(this), this.bindTexture = new Ga(this), this.bindVertexBuffer = new Ua(this), this.bindElementBuffer = new Va(this), this.bindVertexArray = new qa(this), this.pixelStoreUnpack = new Wa(this), this.pixelStoreUnpackPremultiplyAlpha = new $a(this), this.pixelStoreUnpackFlipY = new Ha(this), this.extTextureFilterAnisotropic = e2.getExtension("EXT_texture_filter_anisotropic") || e2.getExtension("MOZ_EXT_texture_filter_anisotropic") || e2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e2.getParameter(e2.MAX_TEXTURE_SIZE), Jt(e2)) {
	          this.HALF_FLOAT = e2.HALF_FLOAT;
	          const a2 = e2.getExtension("EXT_color_buffer_half_float");
	          this.RGBA16F = null !== (t2 = e2.RGBA16F) && void 0 !== t2 ? t2 : null == a2 ? void 0 : a2.RGBA16F_EXT, this.RGB16F = null !== (i2 = e2.RGB16F) && void 0 !== i2 ? i2 : null == a2 ? void 0 : a2.RGB16F_EXT, e2.getExtension("EXT_color_buffer_float");
	        } else {
	          e2.getExtension("EXT_color_buffer_half_float"), e2.getExtension("OES_texture_half_float_linear");
	          const t3 = e2.getExtension("OES_texture_half_float");
	          this.HALF_FLOAT = null == t3 ? void 0 : t3.HALF_FLOAT_OES;
	        }
	      }
	      setDefault() {
	        this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
	      }
	      setDirty() {
	        this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
	      }
	      createIndexBuffer(e2, t2) {
	        return new pa(this, e2, t2);
	      }
	      createVertexBuffer(e2, t2, i2) {
	        return new fa(this, e2, t2, i2);
	      }
	      createRenderbuffer(e2, t2, i2) {
	        const a2 = this.gl, r2 = a2.createRenderbuffer();
	        return this.bindRenderbuffer.set(r2), a2.renderbufferStorage(a2.RENDERBUFFER, e2, t2, i2), this.bindRenderbuffer.set(null), r2;
	      }
	      createFramebuffer(e2, t2, i2, a2) {
	        return new er(this, e2, t2, i2, a2);
	      }
	      clear({ color: e2, depth: t2, stencil: i2 }) {
	        const a2 = this.gl;
	        let r2 = 0;
	        e2 && (r2 |= a2.COLOR_BUFFER_BIT, this.clearColor.set(e2), this.colorMask.set([true, true, true, true])), void 0 !== t2 && (r2 |= a2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t2), this.depthMask.set(true)), void 0 !== i2 && (r2 |= a2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), a2.clear(r2);
	      }
	      setCullFace(e2) {
	        false === e2.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e2.mode), this.frontFace.set(e2.frontFace));
	      }
	      setDepthMode(e2) {
	        e2.func !== this.gl.ALWAYS || e2.mask ? (this.depthTest.set(true), this.depthFunc.set(e2.func), this.depthMask.set(e2.mask), this.depthRange.set(e2.range)) : this.depthTest.set(false);
	      }
	      setStencilMode(e2) {
	        e2.test.func !== this.gl.ALWAYS || e2.mask ? (this.stencilTest.set(true), this.stencilMask.set(e2.mask), this.stencilOp.set([e2.fail, e2.depthFail, e2.pass]), this.stencilFunc.set({ func: e2.test.func, ref: e2.ref, mask: e2.test.mask })) : this.stencilTest.set(false);
	      }
	      setColorMode(e2) {
	        t.bQ(e2.blendFunction, Wt.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e2.blendFunction), this.blendColor.set(e2.blendColor)), this.colorMask.set(e2.mask);
	      }
	      createVertexArray() {
	        var e2;
	        return Jt(this.gl) ? this.gl.createVertexArray() : null === (e2 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === e2 ? void 0 : e2.createVertexArrayOES();
	      }
	      deleteVertexArray(e2) {
	        var t2;
	        return Jt(this.gl) ? this.gl.deleteVertexArray(e2) : null === (t2 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === t2 ? void 0 : t2.deleteVertexArrayOES(e2);
	      }
	      unbindVAO() {
	        this.bindVertexArray.set(null);
	      }
	    }
	    let ir;
	    function ar(e2, i2, a2, r2, o2) {
	      const s2 = e2.context, n2 = e2.transform, l2 = s2.gl, c2 = e2.useProgram("collisionBox"), h2 = [];
	      let u2 = 0, d2 = 0;
	      for (let t2 = 0; t2 < r2.length; t2++) {
	        const _3 = r2[t2], p3 = i2.getTile(_3).getBucket(a2);
	        if (!p3) continue;
	        const m3 = o2 ? p3.textCollisionBox : p3.iconCollisionBox, f3 = p3.collisionCircleArray;
	        f3.length > 0 && (h2.push({ circleArray: f3, circleOffset: d2, coord: _3 }), u2 += f3.length / 4, d2 = u2), m3 && c2.draw(s2, l2.LINES, Xt.disabled, Yt.disabled, e2.colorModeForRenderPass(), Ht.disabled, Ui(e2.transform), e2.style.map.terrain && e2.style.map.terrain.getTerrainData(_3), n2.getProjectionData({ overscaledTileID: _3, applyGlobeMatrix: true, applyTerrainMatrix: true }), a2.id, m3.layoutVertexBuffer, m3.indexBuffer, m3.segments, null, e2.transform.zoom, null, null, m3.collisionVertexBuffer);
	      }
	      if (!o2 || !h2.length) return;
	      const _2 = e2.useProgram("collisionCircle"), p2 = new t.c9();
	      p2.resize(4 * u2), p2._trim();
	      let m2 = 0;
	      for (const e3 of h2) for (let t2 = 0; t2 < e3.circleArray.length / 4; t2++) {
	        const i3 = 4 * t2, a3 = e3.circleArray[i3 + 0], r3 = e3.circleArray[i3 + 1], o3 = e3.circleArray[i3 + 2], s3 = e3.circleArray[i3 + 3];
	        p2.emplace(m2++, a3, r3, o3, s3, 0), p2.emplace(m2++, a3, r3, o3, s3, 1), p2.emplace(m2++, a3, r3, o3, s3, 2), p2.emplace(m2++, a3, r3, o3, s3, 3);
	      }
	      (!ir || ir.length < 2 * u2) && (ir = function(e3) {
	        const i3 = 2 * e3, a3 = new t.cb();
	        a3.resize(i3), a3._trim();
	        for (let e4 = 0; e4 < i3; e4++) {
	          const t2 = 6 * e4;
	          a3.uint16[t2 + 0] = 4 * e4 + 0, a3.uint16[t2 + 1] = 4 * e4 + 1, a3.uint16[t2 + 2] = 4 * e4 + 2, a3.uint16[t2 + 3] = 4 * e4 + 2, a3.uint16[t2 + 4] = 4 * e4 + 3, a3.uint16[t2 + 5] = 4 * e4 + 0;
	        }
	        return a3;
	      }(u2));
	      const f2 = s2.createIndexBuffer(ir, true), g2 = s2.createVertexBuffer(p2, t.ca.members, true);
	      for (const i3 of h2) {
	        const r3 = Vi(e2.transform);
	        _2.draw(s2, l2.TRIANGLES, Xt.disabled, Yt.disabled, e2.colorModeForRenderPass(), Ht.disabled, r3, e2.style.map.terrain && e2.style.map.terrain.getTerrainData(i3.coord), null, a2.id, g2, f2, t.aW.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, e2.transform.zoom, null, null, null);
	      }
	      g2.destroy(), f2.destroy();
	    }
	    const rr = t.ar(new Float32Array(16));
	    function or(e2, i2, a2, r2, o2, s2) {
	      const { horizontalAlign: n2, verticalAlign: l2 } = t.aR(e2);
	      return new t.P((-(n2 - 0.5) * i2 / o2 + r2[0]) * s2, (-(l2 - 0.5) * a2 / o2 + r2[1]) * s2);
	    }
	    function sr(e2, i2, a2, r2, o2, s2) {
	      const n2 = i2.tileAnchorPoint.add(new t.P(i2.translation[0], i2.translation[1]));
	      if (i2.pitchWithMap) {
	        let e3 = r2.mult(s2);
	        a2 || (e3 = e3.rotate(-o2));
	        const t2 = n2.add(e3);
	        return Fe(t2.x, t2.y, i2.pitchedLabelPlaneMatrix, i2.getElevation).point;
	      }
	      if (a2) {
	        const t2 = qe(i2.tileAnchorPoint.x + 1, i2.tileAnchorPoint.y, i2).point.sub(e2), a3 = Math.atan(t2.y / t2.x) + (t2.x < 0 ? Math.PI : 0);
	        return e2.add(r2.rotate(a3));
	      }
	      return e2.add(r2);
	    }
	    function nr(e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2) {
	      const _2 = e2.text.placedSymbolArray, p2 = e2.text.dynamicLayoutVertexArray, m2 = e2.icon.dynamicLayoutVertexArray, f2 = {};
	      p2.clear();
	      for (let m3 = 0; m3 < _2.length; m3++) {
	        const g2 = _2.get(m3), v2 = g2.hidden || !g2.crossTileID || e2.allowVerticalPlacement && !g2.placedOrientation ? null : r2[g2.crossTileID];
	        if (v2) {
	          const r3 = new t.P(g2.anchorX, g2.anchorY), _3 = { getElevation: d2, width: o2.width, height: o2.height, pitchedLabelPlaneMatrix: s2, pitchWithMap: a2, transform: o2, tileAnchorPoint: r3, translation: h2, unwrappedTileID: u2 }, m4 = a2 ? $e(r3.x, r3.y, _3) : qe(r3.x, r3.y, _3), x2 = Be(o2.cameraToCenterDistance, m4.signedDistanceFromCamera);
	          let b2 = t.az(e2.textSizeData, l2, g2) * x2 / t.aL;
	          a2 && (b2 *= e2.tilePixelRatio / n2);
	          const { width: y2, height: w2, anchor: T2, textOffset: P2, textBoxScale: C2 } = v2, M2 = or(T2, y2, w2, P2, C2, b2), I2 = o2.getPitchedTextCorrection(r3.x + h2[0], r3.y + h2[1], u2), E2 = sr(m4.point, _3, i2, M2, -o2.bearingInRadians, I2), S2 = e2.allowVerticalPlacement && g2.placedOrientation === t.ay.vertical ? Math.PI / 2 : 0;
	          for (let e3 = 0; e3 < g2.numGlyphs; e3++) t.aF(p2, E2, S2);
	          c2 && g2.associatedIconIndex >= 0 && (f2[g2.associatedIconIndex] = { shiftedAnchor: E2, angle: S2 });
	        } else Qe(g2.numGlyphs, p2);
	      }
	      if (c2) {
	        m2.clear();
	        const i3 = e2.icon.placedSymbolArray;
	        for (let e3 = 0; e3 < i3.length; e3++) {
	          const a3 = i3.get(e3);
	          if (a3.hidden) Qe(a3.numGlyphs, m2);
	          else {
	            const i4 = f2[e3];
	            if (i4) for (let e4 = 0; e4 < a3.numGlyphs; e4++) t.aF(m2, i4.shiftedAnchor, i4.angle);
	            else Qe(a3.numGlyphs, m2);
	          }
	        }
	        e2.icon.dynamicLayoutVertexBuffer.updateData(m2);
	      }
	      e2.text.dynamicLayoutVertexBuffer.updateData(p2);
	    }
	    function lr(e2, t2, i2) {
	      return i2.iconsInText && t2 ? "symbolTextAndIcon" : e2 ? "symbolSDF" : "symbolIcon";
	    }
	    function cr(e2, i2, a2, r2, o2, s2, n2, l2, c2, h2, u2, d2, _2) {
	      const p2 = e2.context, m2 = p2.gl, f2 = e2.transform, g2 = "map" === l2, v2 = "map" === c2, x2 = "viewport" !== l2 && "point" !== a2.layout.get("symbol-placement"), b2 = g2 && !v2 && !x2, y2 = !a2.layout.get("symbol-sort-key").isConstant();
	      let w2 = false;
	      const T2 = e2.getDepthModeForSublayer(0, Xt.ReadOnly), P2 = a2._unevaluatedLayout.hasValue("text-variable-anchor") || a2._unevaluatedLayout.hasValue("text-variable-anchor-offset"), C2 = [], M2 = f2.getCircleRadiusCorrection();
	      for (const l3 of r2) {
	        const r3 = i2.getTile(l3), c3 = r3.getBucket(a2);
	        if (!c3) continue;
	        const u3 = o2 ? c3.text : c3.icon;
	        if (!u3 || !u3.segments.get().length || !u3.hasVisibleVertices) continue;
	        const d3 = u3.programConfigurations.get(a2.id), p3 = o2 || c3.sdfIcons, T3 = o2 ? c3.textSizeData : c3.iconSizeData, I2 = v2 || 0 !== f2.pitch, E2 = e2.useProgram(lr(p3, o2, c3), d3), S2 = t.ax(T3, f2.zoom), R2 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(l3);
	        let D2, z2, A2, L2, k2 = [0, 0], F2 = null;
	        if (o2) z2 = r3.glyphAtlasTexture, A2 = m2.LINEAR, D2 = r3.glyphAtlasTexture.size, c3.iconsInText && (k2 = r3.imageAtlasTexture.size, F2 = r3.imageAtlasTexture, L2 = I2 || e2.options.rotating || e2.options.zooming || "composite" === T3.kind || "camera" === T3.kind ? m2.LINEAR : m2.NEAREST);
	        else {
	          const t2 = 1 !== a2.layout.get("icon-size").constantOr(0) || c3.iconsNeedLinear;
	          z2 = r3.imageAtlasTexture, A2 = p3 || e2.options.rotating || e2.options.zooming || t2 || I2 ? m2.LINEAR : m2.NEAREST, D2 = r3.imageAtlasTexture.size;
	        }
	        const B2 = t.aM(r3, 1, e2.transform.zoom), O2 = Ae(g2, e2.transform, B2), j2 = t.N();
	        t.aA(j2, O2);
	        const N2 = Le(v2, g2, e2.transform, B2), Z2 = t.aN(f2, r3, s2, n2), G2 = f2.getProjectionData({ overscaledTileID: l3, applyGlobeMatrix: !_2, applyTerrainMatrix: true }), U2 = P2 && c3.hasTextData(), V2 = "none" !== a2.layout.get("icon-text-fit") && U2 && c3.hasIconData();
	        if (x2) {
	          const t2 = e2.style.map.terrain ? (t3, i4) => e2.style.map.terrain.getElevation(l3, t3, i4) : null, i3 = "map" === a2.layout.get("text-rotation-alignment");
	          je(c3, e2, o2, O2, j2, v2, h2, i3, l3.toUnwrapped(), f2.width, f2.height, Z2, t2);
	        }
	        const q2 = o2 && P2 || V2, W2 = x2 || q2 ? rr : v2 ? O2 : e2.transform.clipSpaceToPixelsMatrix, $2 = p3 && 0 !== a2.paint.get(o2 ? "text-halo-width" : "icon-halo-width").constantOr(1);
	        let H2;
	        H2 = p3 ? c3.iconsInText ? ca(T3.kind, S2, b2, v2, x2, q2, e2, W2, N2, Z2, D2, k2, M2) : la(T3.kind, S2, b2, v2, x2, q2, e2, W2, N2, Z2, o2, D2, 0, M2) : na(T3.kind, S2, b2, v2, x2, q2, e2, W2, N2, Z2, o2, D2, M2);
	        const X2 = { program: E2, buffers: u3, uniformValues: H2, projectionData: G2, atlasTexture: z2, atlasTextureIcon: F2, atlasInterpolation: A2, atlasInterpolationIcon: L2, isSDF: p3, hasHalo: $2 };
	        if (y2 && c3.canOverlap) {
	          w2 = true;
	          const e3 = u3.segments.get();
	          for (const i3 of e3) C2.push({ segments: new t.aW([i3]), sortKey: i3.sortKey, state: X2, terrainData: R2 });
	        } else C2.push({ segments: u3.segments, sortKey: 0, state: X2, terrainData: R2 });
	      }
	      w2 && C2.sort((e3, t2) => e3.sortKey - t2.sortKey);
	      for (const t2 of C2) {
	        const i3 = t2.state;
	        if (p2.activeTexture.set(m2.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, m2.CLAMP_TO_EDGE), i3.atlasTextureIcon && (p2.activeTexture.set(m2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, m2.CLAMP_TO_EDGE)), i3.isSDF) {
	          const r3 = i3.uniformValues;
	          i3.hasHalo && (r3.u_is_halo = 1, hr(i3.buffers, t2.segments, a2, e2, i3.program, T2, u2, d2, r3, i3.projectionData, t2.terrainData)), r3.u_is_halo = 0;
	        }
	        hr(i3.buffers, t2.segments, a2, e2, i3.program, T2, u2, d2, i3.uniformValues, i3.projectionData, t2.terrainData);
	      }
	    }
	    function hr(e2, t2, i2, a2, r2, o2, s2, n2, l2, c2, h2) {
	      const u2 = a2.context;
	      r2.draw(u2, u2.gl.TRIANGLES, o2, s2, n2, Ht.backCCW, l2, h2, c2, i2.id, e2.layoutVertexBuffer, e2.indexBuffer, t2, i2.paint, a2.transform.zoom, e2.programConfigurations.get(i2.id), e2.dynamicLayoutVertexBuffer, e2.opacityVertexBuffer);
	    }
	    function ur(e2, i2, a2, r2, o2) {
	      const s2 = e2.context, n2 = s2.gl, l2 = Yt.disabled, c2 = new Wt([n2.ONE, n2.ONE], t.bo.transparent, [true, true, true, true]), h2 = i2.getBucket(a2);
	      if (!h2) return;
	      const u2 = r2.key;
	      let d2 = a2.heatmapFbos.get(u2);
	      d2 || (d2 = _r(s2, i2.tileSize, i2.tileSize), a2.heatmapFbos.set(u2, d2)), s2.bindFramebuffer.set(d2.framebuffer), s2.viewport.set([0, 0, i2.tileSize, i2.tileSize]), s2.clear({ color: t.bo.transparent });
	      const _2 = h2.programConfigurations.get(a2.id), p2 = e2.useProgram("heatmap", _2, !o2), m2 = e2.transform.getProjectionData({ overscaledTileID: i2.tileID, applyGlobeMatrix: true, applyTerrainMatrix: true }), f2 = e2.style.map.terrain.getTerrainData(r2);
	      p2.draw(s2, n2.TRIANGLES, Xt.disabled, l2, c2, Ht.disabled, Wi(i2, e2.transform.zoom, a2.paint.get("heatmap-intensity"), 1), f2, m2, a2.id, h2.layoutVertexBuffer, h2.indexBuffer, h2.segments, a2.paint, e2.transform.zoom, _2);
	    }
	    function dr(e2, t2, i2, a2, r2) {
	      const o2 = e2.context, s2 = o2.gl, n2 = e2.transform;
	      o2.setColorMode(e2.colorModeForRenderPass());
	      const l2 = pr(o2, t2), c2 = i2.key, h2 = t2.heatmapFbos.get(c2);
	      if (!h2) return;
	      o2.activeTexture.set(s2.TEXTURE0), s2.bindTexture(s2.TEXTURE_2D, h2.colorAttachment.get()), o2.activeTexture.set(s2.TEXTURE1), l2.bind(s2.LINEAR, s2.CLAMP_TO_EDGE);
	      const u2 = n2.getProjectionData({ overscaledTileID: i2, applyTerrainMatrix: r2, applyGlobeMatrix: !a2 });
	      e2.useProgram("heatmapTexture").draw(o2, s2.TRIANGLES, Xt.disabled, Yt.disabled, e2.colorModeForRenderPass(), Ht.disabled, $i(e2, t2, 0, 1), null, u2, t2.id, e2.rasterBoundsBuffer, e2.quadTriangleIndexBuffer, e2.rasterBoundsSegments, t2.paint, n2.zoom), h2.destroy(), t2.heatmapFbos.delete(c2);
	    }
	    function _r(e2, t2, i2) {
	      var a2, r2;
	      const o2 = e2.gl, s2 = o2.createTexture();
	      o2.bindTexture(o2.TEXTURE_2D, s2), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_S, o2.CLAMP_TO_EDGE), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_T, o2.CLAMP_TO_EDGE), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MIN_FILTER, o2.LINEAR), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MAG_FILTER, o2.LINEAR);
	      const n2 = null !== (a2 = e2.HALF_FLOAT) && void 0 !== a2 ? a2 : o2.UNSIGNED_BYTE, l2 = null !== (r2 = e2.RGBA16F) && void 0 !== r2 ? r2 : o2.RGBA;
	      o2.texImage2D(o2.TEXTURE_2D, 0, l2, t2, i2, 0, o2.RGBA, n2, null);
	      const c2 = e2.createFramebuffer(t2, i2, false, false);
	      return c2.colorAttachment.set(s2), c2;
	    }
	    function pr(e2, i2) {
	      return i2.colorRampTexture || (i2.colorRampTexture = new t.T(e2, i2.colorRamp, e2.gl.RGBA)), i2.colorRampTexture;
	    }
	    function mr(e2, i2, a2, r2, o2, s2, n2, l2) {
	      let c2 = 256;
	      if (o2.stepInterpolant) {
	        const r3 = i2.getSource().maxzoom, o3 = n2.canonical.z === r3 ? Math.ceil(1 << e2.transform.maxZoom - n2.canonical.z) : 1;
	        c2 = t.an(t.cd(s2.maxLineLength / t.a4 * 1024 * o3), 256, a2.maxTextureSize);
	      }
	      return l2.gradient = t.ce({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: c2, image: l2.gradient || void 0, clips: s2.lineClipsArray }), l2.texture ? l2.texture.update(l2.gradient) : l2.texture = new t.T(a2, l2.gradient, r2.RGBA), l2.version = o2.gradientVersion, l2.texture;
	    }
	    function fr(e2, t2, i2, a2, r2) {
	      e2.activeTexture.set(t2.TEXTURE0), i2.imageAtlasTexture.bind(t2.LINEAR, t2.CLAMP_TO_EDGE), a2.updatePaintBuffers(r2);
	    }
	    function gr(e2, t2, i2, a2, r2, o2) {
	      (r2 || e2.lineAtlas.dirty) && (t2.activeTexture.set(i2.TEXTURE0), e2.lineAtlas.bind(t2)), a2.updatePaintBuffers(o2);
	    }
	    function vr(e2, t2, i2, a2, r2, o2, s2) {
	      const n2 = o2.gradients[r2.id];
	      let l2 = n2.texture;
	      r2.gradientVersion !== n2.version && (l2 = mr(e2, t2, i2, a2, r2, o2, s2, n2)), i2.activeTexture.set(a2.TEXTURE0), l2.bind(r2.stepInterpolant ? a2.NEAREST : a2.LINEAR, a2.CLAMP_TO_EDGE);
	    }
	    function xr(e2, t2, i2, a2, r2, o2, s2, n2, l2) {
	      const c2 = o2.gradients[r2.id];
	      let h2 = c2.texture;
	      r2.gradientVersion !== c2.version && (h2 = mr(e2, t2, i2, a2, r2, o2, s2, c2)), i2.activeTexture.set(a2.TEXTURE0), h2.bind(r2.stepInterpolant ? a2.NEAREST : a2.LINEAR, a2.CLAMP_TO_EDGE), i2.activeTexture.set(a2.TEXTURE1), e2.lineAtlas.bind(i2), n2.updatePaintBuffers(l2);
	    }
	    function br(e2, t2, i2, a2, r2) {
	      if (!i2 || !a2 || !a2.imageAtlas) return;
	      const o2 = a2.imageAtlas.patternPositions;
	      let s2 = o2[i2.to.toString()], n2 = o2[i2.from.toString()];
	      if (!s2 && n2 && (s2 = n2), !n2 && s2 && (n2 = s2), !s2 || !n2) {
	        const e3 = r2.getPaintProperty(t2);
	        s2 = o2[e3], n2 = o2[e3];
	      }
	      s2 && n2 && e2.setConstantPatternPositions(s2, n2);
	    }
	    function yr(e2, i2, a2, r2, o2, s2, n2, l2) {
	      const c2 = e2.context.gl, h2 = "fill-pattern", u2 = a2.paint.get(h2), d2 = u2 && u2.constantOr(1), _2 = a2.getCrossfadeParameters();
	      let p2, m2, f2, g2, v2;
	      const x2 = e2.transform, b2 = a2.paint.get("fill-translate"), y2 = a2.paint.get("fill-translate-anchor");
	      n2 ? (m2 = d2 && !a2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", p2 = c2.LINES) : (m2 = d2 ? "fillPattern" : "fill", p2 = c2.TRIANGLES);
	      const w2 = u2.constantOr(null);
	      for (const u3 of r2) {
	        const r3 = i2.getTile(u3);
	        if (d2 && !r3.patternsLoaded()) continue;
	        const T2 = r3.getBucket(a2);
	        if (!T2) continue;
	        const P2 = T2.programConfigurations.get(a2.id), C2 = e2.useProgram(m2, P2), M2 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(u3);
	        d2 && (e2.context.activeTexture.set(c2.TEXTURE0), r3.imageAtlasTexture.bind(c2.LINEAR, c2.CLAMP_TO_EDGE), P2.updatePaintBuffers(_2)), br(P2, h2, w2, r3, a2);
	        const I2 = x2.getProjectionData({ overscaledTileID: u3, applyGlobeMatrix: !l2, applyTerrainMatrix: true }), E2 = t.aN(x2, r3, b2, y2);
	        if (n2) {
	          g2 = T2.indexBuffer2, v2 = T2.segments2;
	          const t2 = [c2.drawingBufferWidth, c2.drawingBufferHeight];
	          f2 = "fillOutlinePattern" === m2 && d2 ? Zi(e2, _2, r3, t2, E2) : Ni(t2, E2);
	        } else g2 = T2.indexBuffer, v2 = T2.segments, f2 = d2 ? ji(e2, _2, r3, E2) : { u_fill_translate: E2 };
	        const S2 = e2.stencilModeForClipping(u3);
	        C2.draw(e2.context, p2, o2, S2, s2, Ht.backCCW, f2, M2, I2, a2.id, T2.layoutVertexBuffer, g2, v2, a2.paint, e2.transform.zoom, P2);
	      }
	    }
	    function wr(e2, i2, a2, r2, o2, s2, n2, l2) {
	      const c2 = e2.context, h2 = c2.gl, u2 = "fill-extrusion-pattern", d2 = a2.paint.get(u2), _2 = d2.constantOr(1), p2 = a2.getCrossfadeParameters(), m2 = a2.paint.get("fill-extrusion-opacity"), f2 = d2.constantOr(null), g2 = e2.transform;
	      for (const d3 of r2) {
	        const r3 = i2.getTile(d3), v2 = r3.getBucket(a2);
	        if (!v2) continue;
	        const x2 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(d3), b2 = v2.programConfigurations.get(a2.id), y2 = e2.useProgram(_2 ? "fillExtrusionPattern" : "fillExtrusion", b2);
	        _2 && (e2.context.activeTexture.set(h2.TEXTURE0), r3.imageAtlasTexture.bind(h2.LINEAR, h2.CLAMP_TO_EDGE), b2.updatePaintBuffers(p2));
	        const w2 = g2.getProjectionData({ overscaledTileID: d3, applyGlobeMatrix: !l2, applyTerrainMatrix: true });
	        br(b2, u2, f2, r3, a2);
	        const T2 = t.aN(g2, r3, a2.paint.get("fill-extrusion-translate"), a2.paint.get("fill-extrusion-translate-anchor")), P2 = a2.paint.get("fill-extrusion-vertical-gradient"), C2 = _2 ? Oi(e2, P2, m2, T2, d3, p2, r3) : Bi(e2, P2, m2, T2);
	        y2.draw(c2, c2.gl.TRIANGLES, o2, s2, n2, Ht.backCCW, C2, x2, w2, a2.id, v2.layoutVertexBuffer, v2.indexBuffer, v2.segments, a2.paint, e2.transform.zoom, b2, e2.style.map.terrain && v2.centroidVertexBuffer);
	      }
	    }
	    function Tr(e2, t2, i2, a2, r2, o2, s2, n2, l2) {
	      var c2;
	      const h2 = e2.style.projection, u2 = e2.context, d2 = e2.transform, _2 = u2.gl, p2 = [`#define NUM_ILLUMINATION_SOURCES ${i2.paint.get("hillshade-highlight-color").values.length}`], m2 = e2.useProgram("hillshade", null, false, p2), f2 = !e2.options.moving;
	      for (const p3 of a2) {
	        const a3 = t2.getTile(p3), g2 = a3.fbo;
	        if (!g2) continue;
	        const v2 = h2.getMeshFromTileID(u2, p3.canonical, n2, true, "raster"), x2 = null === (c2 = e2.style.map.terrain) || void 0 === c2 ? void 0 : c2.getTerrainData(p3);
	        u2.activeTexture.set(_2.TEXTURE0), _2.bindTexture(_2.TEXTURE_2D, g2.colorAttachment.get());
	        const b2 = d2.getProjectionData({ overscaledTileID: p3, aligned: f2, applyGlobeMatrix: !l2, applyTerrainMatrix: true });
	        m2.draw(u2, _2.TRIANGLES, o2, r2[p3.overscaledZ], s2, Ht.backCCW, Hi(e2, a3, i2), x2, b2, i2.id, v2.vertexBuffer, v2.indexBuffer, v2.segments);
	      }
	    }
	    function Pr(e2, i2, a2, r2, o2, s2, n2, l2, c2) {
	      var h2;
	      const u2 = e2.style.projection, d2 = e2.context, _2 = e2.transform, p2 = d2.gl, m2 = e2.useProgram("colorRelief"), f2 = !e2.options.moving;
	      let g2 = true, v2 = 0;
	      for (const x2 of r2) {
	        const r3 = i2.getTile(x2), b2 = r3.dem;
	        if (g2) {
	          const e3 = p2.getParameter(p2.MAX_TEXTURE_SIZE), { elevationTexture: t2, colorTexture: i3 } = a2.getColorRampTextures(d2, e3, b2.getUnpackVector());
	          d2.activeTexture.set(p2.TEXTURE1), t2.bind(p2.NEAREST, p2.CLAMP_TO_EDGE), d2.activeTexture.set(p2.TEXTURE4), i3.bind(p2.LINEAR, p2.CLAMP_TO_EDGE), g2 = false, v2 = t2.size[0];
	        }
	        if (!b2 || !b2.data) continue;
	        const y2 = b2.stride, w2 = b2.getPixels();
	        if (d2.activeTexture.set(p2.TEXTURE0), d2.pixelStoreUnpackPremultiplyAlpha.set(false), r3.demTexture = r3.demTexture || e2.getTileTexture(y2), r3.demTexture) {
	          const e3 = r3.demTexture;
	          e3.update(w2, { premultiply: false }), e3.bind(p2.LINEAR, p2.CLAMP_TO_EDGE);
	        } else r3.demTexture = new t.T(d2, w2, p2.RGBA, { premultiply: false }), r3.demTexture.bind(p2.LINEAR, p2.CLAMP_TO_EDGE);
	        const T2 = u2.getMeshFromTileID(d2, x2.canonical, l2, true, "raster"), P2 = null === (h2 = e2.style.map.terrain) || void 0 === h2 ? void 0 : h2.getTerrainData(x2), C2 = _2.getProjectionData({ overscaledTileID: x2, aligned: f2, applyGlobeMatrix: !c2, applyTerrainMatrix: true });
	        m2.draw(d2, p2.TRIANGLES, s2, o2[x2.overscaledZ], n2, Ht.backCCW, Yi(a2, r3.dem, v2), P2, C2, a2.id, T2.vertexBuffer, T2.indexBuffer, T2.segments);
	      }
	    }
	    const Cr = [new t.P(0, 0), new t.P(t.a4, 0), new t.P(t.a4, t.a4), new t.P(0, t.a4)];
	    function Mr(e2, t2, i2, a2, r2, o2, s2, n2, l2 = false, c2 = false) {
	      const h2 = a2[a2.length - 1].overscaledZ, u2 = e2.context, d2 = u2.gl, _2 = e2.useProgram("raster"), p2 = e2.transform, m2 = e2.style.projection, f2 = e2.colorModeForRenderPass(), g2 = !e2.options.moving, v2 = i2.paint.get("raster-opacity"), x2 = i2.paint.get("raster-resampling"), b2 = i2.paint.get("raster-fade-duration"), y2 = !!e2.style.map.terrain;
	      for (const w2 of a2) {
	        const a3 = e2.getDepthModeForSublayer(w2.overscaledZ - h2, 1 === v2 ? Xt.ReadWrite : Xt.ReadOnly, d2.LESS), T2 = t2.getTile(w2), P2 = "nearest" === x2 ? d2.NEAREST : d2.LINEAR;
	        u2.activeTexture.set(d2.TEXTURE0), T2.texture.bind(P2, d2.CLAMP_TO_EDGE, d2.LINEAR_MIPMAP_NEAREST), u2.activeTexture.set(d2.TEXTURE1);
	        const { parentTile: C2, parentScaleBy: M2, parentTopLeft: I2, fadeValues: E2 } = Ir(T2, t2, b2, y2);
	        T2.fadeOpacity = E2.tileOpacity, C2 ? (C2.fadeOpacity = E2.parentTileOpacity, C2.texture.bind(P2, d2.CLAMP_TO_EDGE, d2.LINEAR_MIPMAP_NEAREST)) : T2.texture.bind(P2, d2.CLAMP_TO_EDGE, d2.LINEAR_MIPMAP_NEAREST), T2.texture.useMipmap && u2.extTextureFilterAnisotropic && e2.transform.pitch > 20 && d2.texParameterf(d2.TEXTURE_2D, u2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, u2.extTextureFilterAnisotropicMax);
	        const S2 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(w2), R2 = p2.getProjectionData({ overscaledTileID: w2, aligned: g2, applyGlobeMatrix: !c2, applyTerrainMatrix: true }), D2 = oa(I2, M2, E2.fadeMix, i2, n2), z2 = m2.getMeshFromTileID(u2, w2.canonical, o2, s2, "raster");
	        _2.draw(u2, d2.TRIANGLES, a3, r2 ? r2[w2.overscaledZ] : Yt.disabled, f2, l2 ? Ht.frontCCW : Ht.backCCW, D2, S2, R2, i2.id, z2.vertexBuffer, z2.indexBuffer, z2.segments);
	      }
	    }
	    function Ir(e2, i2, a2, r2) {
	      const o2 = { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: { tileOpacity: 1, parentTileOpacity: 1, fadeMix: { opacity: 1, mix: 0 } } };
	      if (0 === a2 || r2) return o2;
	      if (e2.fadingParentID) {
	        const r3 = i2.getLoadedTile(e2.fadingParentID);
	        if (!r3) return o2;
	        const s2 = Math.pow(2, r3.tileID.overscaledZ - e2.tileID.overscaledZ), n2 = [e2.tileID.canonical.x * s2 % 1, e2.tileID.canonical.y * s2 % 1], l2 = function(e3, i3, a3) {
	          const r4 = c(), o3 = (r4 - i3.timeAdded) / a3, s3 = e3.fadingDirection === ue.Incoming, n3 = t.an((r4 - e3.timeAdded) / a3, 0, 1), l3 = t.an(1 - o3, 0, 1), h2 = s3 ? n3 : l3;
	          return { tileOpacity: h2, parentTileOpacity: s3 ? l3 : n3, fadeMix: { opacity: 1, mix: 1 - h2 } };
	        }(e2, r3, a2);
	        return { parentTile: r3, parentScaleBy: s2, parentTopLeft: n2, fadeValues: l2 };
	      }
	      if (e2.selfFading) {
	        const i3 = function(e3, i4) {
	          const a3 = (c() - e3.timeAdded) / i4, r3 = t.an(a3, 0, 1);
	          return { tileOpacity: r3, fadeMix: { opacity: r3, mix: 0 } };
	        }(e2, a2);
	        return { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: i3 };
	      }
	      return o2;
	    }
	    const Er = new t.bo(1, 0, 0, 1), Sr = new t.bo(0, 1, 0, 1), Rr = new t.bo(0, 0, 1, 1), Dr = new t.bo(1, 0, 1, 1), zr = new t.bo(0, 1, 1, 1);
	    function Ar(e2, t2, i2, a2) {
	      kr(e2, 0, t2 + i2 / 2, e2.transform.width, i2, a2);
	    }
	    function Lr(e2, t2, i2, a2) {
	      kr(e2, t2 - i2 / 2, 0, i2, e2.transform.height, a2);
	    }
	    function kr(e2, t2, i2, a2, r2, o2) {
	      const s2 = e2.context, n2 = s2.gl;
	      n2.enable(n2.SCISSOR_TEST), n2.scissor(t2 * e2.pixelRatio, i2 * e2.pixelRatio, a2 * e2.pixelRatio, r2 * e2.pixelRatio), s2.clear({ color: o2 }), n2.disable(n2.SCISSOR_TEST);
	    }
	    function Fr(e2, i2, a2) {
	      const r2 = e2.context, o2 = r2.gl, s2 = e2.useProgram("debug"), n2 = Xt.disabled, l2 = Yt.disabled, c2 = e2.colorModeForRenderPass(), h2 = "$debug", u2 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(a2);
	      r2.activeTexture.set(o2.TEXTURE0);
	      const d2 = i2.getTileByID(a2.key).latestRawTileData, _2 = Math.floor((d2 && d2.byteLength || 0) / 1024), p2 = i2.getTile(a2).tileSize, m2 = 512 / Math.min(p2, 512) * (a2.overscaledZ / e2.transform.zoom) * 0.5;
	      let f2 = a2.canonical.toString();
	      a2.overscaledZ !== a2.canonical.z && (f2 += ` => ${a2.overscaledZ}`), function(e3, t2) {
	        e3.initDebugOverlayCanvas();
	        const i3 = e3.debugOverlayCanvas, a3 = e3.context.gl, r3 = e3.debugOverlayCanvas.getContext("2d");
	        r3.clearRect(0, 0, i3.width, i3.height), r3.shadowColor = "white", r3.shadowBlur = 2, r3.lineWidth = 1.5, r3.strokeStyle = "white", r3.textBaseline = "top", r3.font = "bold 36px Open Sans, sans-serif", r3.fillText(t2, 5, 5), r3.strokeText(t2, 5, 5), e3.debugOverlayTexture.update(i3), e3.debugOverlayTexture.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
	      }(e2, `${f2} ${_2}kB`);
	      const g2 = e2.transform.getProjectionData({ overscaledTileID: a2, applyGlobeMatrix: true, applyTerrainMatrix: true });
	      s2.draw(r2, o2.TRIANGLES, n2, l2, Wt.alphaBlended, Ht.disabled, qi(t.bo.transparent, m2), null, g2, h2, e2.debugBuffer, e2.quadTriangleIndexBuffer, e2.debugSegments), s2.draw(r2, o2.LINE_STRIP, n2, l2, c2, Ht.disabled, qi(t.bo.red), u2, g2, h2, e2.debugBuffer, e2.tileBorderIndexBuffer, e2.debugSegments);
	    }
	    function Br(e2, t2, i2, a2) {
	      const { isRenderingGlobe: r2 } = a2, o2 = e2.context, s2 = o2.gl, n2 = e2.transform, l2 = e2.colorModeForRenderPass(), c2 = e2.getDepthModeFor3D(), h2 = e2.useProgram("terrain");
	      o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, e2.width, e2.height]);
	      for (const a3 of i2) {
	        const i3 = t2.getTerrainMesh(a3.tileID), u2 = e2.renderToTexture.getTexture(a3), d2 = t2.getTerrainData(a3.tileID);
	        o2.activeTexture.set(s2.TEXTURE0), s2.bindTexture(s2.TEXTURE_2D, u2.texture);
	        const _2 = t2.getMeshFrameDelta(n2.zoom), p2 = n2.calculateFogMatrix(a3.tileID.toUnwrapped()), m2 = zi(_2, p2, e2.style.sky, n2.pitch, r2), f2 = n2.getProjectionData({ overscaledTileID: a3.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
	        h2.draw(o2, s2.TRIANGLES, c2, Yt.disabled, l2, Ht.backCCW, m2, d2, f2, "terrain", i3.vertexBuffer, i3.indexBuffer, i3.segments);
	      }
	    }
	    function Or(e2, i2) {
	      if (!i2.mesh) {
	        const a2 = new t.aV();
	        a2.emplaceBack(-1, -1), a2.emplaceBack(1, -1), a2.emplaceBack(1, 1), a2.emplaceBack(-1, 1);
	        const r2 = new t.aX();
	        r2.emplaceBack(0, 1, 2), r2.emplaceBack(0, 2, 3), i2.mesh = new St(e2.createVertexBuffer(a2, Rt.members), e2.createIndexBuffer(r2), t.aW.simpleSegment(0, 0, a2.length, r2.length));
	      }
	      return i2.mesh;
	    }
	    class jr {
	      constructor(e2, i2) {
	        this.context = new tr(e2), this.transform = i2, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: t.ar(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = Ie.maxOverzooming + Ie.maxUnderzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Ct();
	      }
	      resize(e2, t2, i2) {
	        if (this.width = Math.floor(e2 * i2), this.height = Math.floor(t2 * i2), this.pixelRatio = i2, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e3 of this.style._order) this.style._layers[e3].resize();
	      }
	      setup() {
	        const e2 = this.context, i2 = new t.aV();
	        i2.emplaceBack(0, 0), i2.emplaceBack(t.a4, 0), i2.emplaceBack(0, t.a4), i2.emplaceBack(t.a4, t.a4), this.tileExtentBuffer = e2.createVertexBuffer(i2, Rt.members), this.tileExtentSegments = t.aW.simpleSegment(0, 0, 4, 2);
	        const a2 = new t.aV();
	        a2.emplaceBack(0, 0), a2.emplaceBack(t.a4, 0), a2.emplaceBack(0, t.a4), a2.emplaceBack(t.a4, t.a4), this.debugBuffer = e2.createVertexBuffer(a2, Rt.members), this.debugSegments = t.aW.simpleSegment(0, 0, 4, 5);
	        const r2 = new t.cg();
	        r2.emplaceBack(0, 0, 0, 0), r2.emplaceBack(t.a4, 0, t.a4, 0), r2.emplaceBack(0, t.a4, 0, t.a4), r2.emplaceBack(t.a4, t.a4, t.a4, t.a4), this.rasterBoundsBuffer = e2.createVertexBuffer(r2, Ri.members), this.rasterBoundsSegments = t.aW.simpleSegment(0, 0, 4, 2);
	        const o2 = new t.aV();
	        o2.emplaceBack(0, 0), o2.emplaceBack(t.a4, 0), o2.emplaceBack(0, t.a4), o2.emplaceBack(t.a4, t.a4), this.rasterBoundsBufferPosOnly = e2.createVertexBuffer(o2, Rt.members), this.rasterBoundsSegmentsPosOnly = t.aW.simpleSegment(0, 0, 4, 5);
	        const s2 = new t.aV();
	        s2.emplaceBack(0, 0), s2.emplaceBack(1, 0), s2.emplaceBack(0, 1), s2.emplaceBack(1, 1), this.viewportBuffer = e2.createVertexBuffer(s2, Rt.members), this.viewportSegments = t.aW.simpleSegment(0, 0, 4, 2);
	        const n2 = new t.ch();
	        n2.emplaceBack(0), n2.emplaceBack(1), n2.emplaceBack(3), n2.emplaceBack(2), n2.emplaceBack(0), this.tileBorderIndexBuffer = e2.createIndexBuffer(n2);
	        const l2 = new t.aX();
	        l2.emplaceBack(1, 0, 2), l2.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e2.createIndexBuffer(l2);
	        const c2 = this.context.gl;
	        this.stencilClearMode = new Yt({ func: c2.ALWAYS, mask: 0 }, 0, 255, c2.ZERO, c2.ZERO, c2.ZERO), this.tileExtentMesh = new St(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
	      }
	      clearStencil() {
	        const e2 = this.context, i2 = e2.gl;
	        this.nextStencilID = 1, this.currentStencilSource = void 0;
	        const a2 = t.N();
	        t.c6(a2, 0, this.width, this.height, 0, 0, 1), t.Q(a2, a2, [i2.drawingBufferWidth, i2.drawingBufferHeight, 0]);
	        const r2 = { mainMatrix: a2, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: a2 };
	        this.useProgram("clippingMask", null, true).draw(e2, i2.TRIANGLES, Xt.disabled, this.stencilClearMode, Wt.disabled, Ht.disabled, null, null, r2, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
	      }
	      _renderTileClippingMasks(e2, t2, i2) {
	        if (this.currentStencilSource === e2.source || !e2.isTileClipped() || !t2 || !t2.length) return;
	        this.currentStencilSource = e2.source, this.nextStencilID + t2.length > 256 && this.clearStencil();
	        const a2 = this.context;
	        a2.setColorMode(Wt.disabled), a2.setDepthMode(Xt.disabled);
	        const r2 = {};
	        for (const e3 of t2) r2[e3.key] = this.nextStencilID++;
	        this._renderTileMasks(r2, t2, i2, true), this._renderTileMasks(r2, t2, i2, false), this._tileClippingMaskIDs = r2;
	      }
	      _renderTileMasks(e2, t2, i2, a2) {
	        const r2 = this.context, o2 = r2.gl, s2 = this.style.projection, n2 = this.transform, l2 = this.useProgram("clippingMask");
	        for (const c2 of t2) {
	          const t3 = e2[c2.key], h2 = this.style.map.terrain && this.style.map.terrain.getTerrainData(c2), u2 = s2.getMeshFromTileID(this.context, c2.canonical, a2, true, "stencil"), d2 = n2.getProjectionData({ overscaledTileID: c2, applyGlobeMatrix: !i2, applyTerrainMatrix: true });
	          l2.draw(r2, o2.TRIANGLES, Xt.disabled, new Yt({ func: o2.ALWAYS, mask: 0 }, t3, 255, o2.KEEP, o2.KEEP, o2.REPLACE), Wt.disabled, i2 ? Ht.disabled : Ht.backCCW, null, h2, d2, "$clipping", u2.vertexBuffer, u2.indexBuffer, u2.segments);
	        }
	      }
	      _renderTilesDepthBuffer() {
	        const e2 = this.context, t2 = e2.gl, i2 = this.style.projection, a2 = this.transform, r2 = this.useProgram("depth"), o2 = this.getDepthModeFor3D(), s2 = Ce(a2, { tileSize: a2.tileSize });
	        for (const n2 of s2) {
	          const s3 = this.style.map.terrain && this.style.map.terrain.getTerrainData(n2), l2 = i2.getMeshFromTileID(this.context, n2.canonical, true, true, "raster"), c2 = a2.getProjectionData({ overscaledTileID: n2, applyGlobeMatrix: true, applyTerrainMatrix: true });
	          r2.draw(e2, t2.TRIANGLES, o2, Yt.disabled, Wt.disabled, Ht.backCCW, null, s3, c2, "$clipping", l2.vertexBuffer, l2.indexBuffer, l2.segments);
	        }
	      }
	      stencilModeFor3D() {
	        this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
	        const e2 = this.nextStencilID++, t2 = this.context.gl;
	        return new Yt({ func: t2.NOTEQUAL, mask: 255 }, e2, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
	      }
	      stencilModeForClipping(e2) {
	        const t2 = this.context.gl;
	        return new Yt({ func: t2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e2.key], 0, t2.KEEP, t2.KEEP, t2.REPLACE);
	      }
	      getStencilConfigForOverlapAndUpdateStencilID(e2) {
	        const t2 = this.context.gl, i2 = e2.sort((e3, t3) => t3.overscaledZ - e3.overscaledZ), a2 = i2[i2.length - 1].overscaledZ, r2 = i2[0].overscaledZ - a2 + 1;
	        if (r2 > 1) {
	          this.currentStencilSource = void 0, this.nextStencilID + r2 > 256 && this.clearStencil();
	          const e3 = {};
	          for (let i3 = 0; i3 < r2; i3++) e3[i3 + a2] = new Yt({ func: t2.GEQUAL, mask: 255 }, i3 + this.nextStencilID, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
	          return this.nextStencilID += r2, [e3, i2];
	        }
	        return [{ [a2]: Yt.disabled }, i2];
	      }
	      stencilConfigForOverlapTwoPass(e2) {
	        const t2 = this.context.gl, i2 = e2.sort((e3, t3) => t3.overscaledZ - e3.overscaledZ), a2 = i2[i2.length - 1].overscaledZ, r2 = i2[0].overscaledZ - a2 + 1;
	        if (this.clearStencil(), r2 > 1) {
	          const e3 = {}, o2 = {};
	          for (let i3 = 0; i3 < r2; i3++) e3[i3 + a2] = new Yt({ func: t2.GREATER, mask: 255 }, r2 + 1 + i3, 255, t2.KEEP, t2.KEEP, t2.REPLACE), o2[i3 + a2] = new Yt({ func: t2.GREATER, mask: 255 }, 1 + i3, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
	          return this.nextStencilID = 2 * r2 + 1, [e3, o2, i2];
	        }
	        return this.nextStencilID = 3, [{ [a2]: new Yt({ func: t2.GREATER, mask: 255 }, 2, 255, t2.KEEP, t2.KEEP, t2.REPLACE) }, { [a2]: new Yt({ func: t2.GREATER, mask: 255 }, 1, 255, t2.KEEP, t2.KEEP, t2.REPLACE) }, i2];
	      }
	      colorModeForRenderPass() {
	        const e2 = this.context.gl;
	        if (this._showOverdrawInspector) {
	          const i2 = 1 / 8;
	          return new Wt([e2.CONSTANT_COLOR, e2.ONE], new t.bo(i2, i2, i2, 0), [true, true, true, true]);
	        }
	        return "opaque" === this.renderPass ? Wt.unblended : Wt.alphaBlended;
	      }
	      getDepthModeForSublayer(e2, t2, i2) {
	        if (!this.opaquePassEnabledForLayer()) return Xt.disabled;
	        const a2 = 1 - ((1 + this.currentLayer) * this.numSublayers + e2) * this.depthEpsilon;
	        return new Xt(i2 || this.context.gl.LEQUAL, t2, [a2, a2]);
	      }
	      getDepthModeFor3D() {
	        return new Xt(this.context.gl.LEQUAL, Xt.ReadWrite, this.depthRangeFor3D);
	      }
	      opaquePassEnabledForLayer() {
	        return this.currentLayer < this.opaquePassCutoff;
	      }
	      render(e2, i2) {
	        var a2, r2;
	        this.style = e2, this.options = i2, this.lineAtlas = e2.lineAtlas, this.imageManager = e2.imageManager, this.glyphManager = e2.glyphManager, this.symbolFadeChange = e2.placement.symbolFadeChange(c()), this.imageManager.beginFrame();
	        const o2 = this.style._order, s2 = this.style.tileManagers, n2 = {}, l2 = {}, h2 = {}, u2 = { isRenderingToTexture: false, isRenderingGlobe: (null === (a2 = e2.projection) || void 0 === a2 ? void 0 : a2.transitionState) > 0 };
	        for (const e3 in s2) {
	          const t2 = s2[e3];
	          t2.used && t2.prepare(this.context), n2[e3] = t2.getVisibleCoordinates(false), l2[e3] = n2[e3].slice().reverse(), h2[e3] = t2.getVisibleCoordinates(true).reverse();
	        }
	        this.opaquePassCutoff = 1 / 0;
	        for (let e3 = 0; e3 < o2.length; e3++) if (this.style._layers[o2[e3]].is3D()) {
	          this.opaquePassCutoff = e3;
	          break;
	        }
	        this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
	        for (const e3 of o2) {
	          const t2 = this.style._layers[e3];
	          if (!t2.hasOffscreenPass() || t2.isHidden(this.transform.zoom)) continue;
	          const i3 = l2[t2.source];
	          ("custom" === t2.type || i3.length) && this.renderLayer(this, s2[t2.source], t2, i3, u2);
	        }
	        if (null === (r2 = this.style.projection) || void 0 === r2 || r2.updateGPUdependent({ context: this.context, useProgram: (e3) => this.useProgram(e3) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: i2.showOverdrawInspector ? t.bo.black : t.bo.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function(e3, t2) {
	          const i3 = e3.context, a3 = i3.gl, r3 = ((e4, t3, i4) => {
	            const a4 = Math.cos(t3.rollInRadians), r4 = Math.sin(t3.rollInRadians), o4 = ge(t3), s4 = t3.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }).projectionTransition;
	            return { u_sky_color: e4.properties.get("sky-color"), u_horizon_color: e4.properties.get("horizon-color"), u_horizon: [(t3.width / 2 - o4 * r4) * i4, (t3.height / 2 + o4 * a4) * i4], u_horizon_normal: [-r4, a4], u_sky_horizon_blend: e4.properties.get("sky-horizon-blend") * t3.height / 2 * i4, u_sky_blend: s4 };
	          })(t2, e3.style.map.transform, e3.pixelRatio), o3 = new Xt(a3.LEQUAL, Xt.ReadWrite, [0, 1]), s3 = Yt.disabled, n3 = e3.colorModeForRenderPass(), l3 = e3.useProgram("sky"), c2 = Or(i3, t2);
	          l3.draw(i3, a3.TRIANGLES, o3, s3, n3, Ht.disabled, r3, null, void 0, "sky", c2.vertexBuffer, c2.indexBuffer, c2.segments);
	        }(this, this.style.sky), this._showOverdrawInspector = i2.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e2._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = o2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
	          const e3 = this.style._layers[o2[this.currentLayer]], t2 = s2[e3.source], i3 = n2[e3.source];
	          this._renderTileClippingMasks(e3, i3, false), this.renderLayer(this, t2, e3, i3, u2);
	        }
	        this.renderPass = "translucent";
	        let d2 = false;
	        for (this.currentLayer = 0; this.currentLayer < o2.length; this.currentLayer++) {
	          const e3 = this.style._layers[o2[this.currentLayer]], t2 = s2[e3.source];
	          if (this.renderToTexture && this.renderToTexture.renderLayer(e3, u2)) continue;
	          this.opaquePassEnabledForLayer() || d2 || (d2 = true, u2.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
	          const i3 = ("symbol" === e3.type ? h2 : l2)[e3.source];
	          this._renderTileClippingMasks(e3, n2[e3.source], !!this.renderToTexture), this.renderLayer(this, t2, e3, i3, u2);
	        }
	        if (u2.isRenderingGlobe && function(e3, i3, a3) {
	          const r3 = e3.context, o3 = r3.gl, s3 = e3.useProgram("atmosphere"), n3 = new Xt(o3.LEQUAL, Xt.ReadOnly, [0, 1]), l3 = e3.transform, c2 = function(e4, i4) {
	            const a4 = e4.properties.get("position"), r4 = [-a4.x, -a4.y, -a4.z], o4 = t.ar(new Float64Array(16));
	            return "map" === e4.properties.get("anchor") && (t.bf(o4, o4, i4.rollInRadians), t.bg(o4, o4, -i4.pitchInRadians), t.bf(o4, o4, i4.bearingInRadians), t.bg(o4, o4, i4.center.lat * Math.PI / 180), t.bI(o4, o4, -i4.center.lng * Math.PI / 180)), t.cf(r4, r4, o4), r4;
	          }(a3, e3.transform), h3 = l3.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }), u3 = i3.properties.get("atmosphere-blend") * h3.projectionTransition;
	          if (0 === u3) return;
	          const d3 = hi(l3.worldSize, l3.center.lat), _2 = l3.inverseProjectionMatrix, p2 = new Float64Array(4);
	          p2[3] = 1, t.aG(p2, p2, l3.modelViewProjectionMatrix), p2[0] /= p2[3], p2[1] /= p2[3], p2[2] /= p2[3], p2[3] = 1, t.aG(p2, p2, _2), p2[0] /= p2[3], p2[1] /= p2[3], p2[2] /= p2[3], p2[3] = 1;
	          const m2 = /* @__PURE__ */ ((e4, t2, i4, a4, r4) => ({ u_sun_pos: e4, u_atmosphere_blend: t2, u_globe_position: i4, u_globe_radius: a4, u_inv_proj_matrix: r4 }))(c2, u3, [p2[0], p2[1], p2[2]], d3, _2), f2 = Or(r3, i3);
	          s3.draw(r3, o3.TRIANGLES, n3, Yt.disabled, Wt.alphaBlended, Ht.disabled, m2, null, null, "atmosphere", f2.vertexBuffer, f2.indexBuffer, f2.segments);
	        }(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
	          const e3 = function(e4, t2) {
	            let i3 = null;
	            const a3 = Object.values(e4._layers).flatMap((i4) => i4.source && !i4.isHidden(t2) ? [e4.tileManagers[i4.source]] : []), r3 = a3.filter((e5) => "vector" === e5.getSource().type), o3 = a3.filter((e5) => "vector" !== e5.getSource().type), s3 = (e5) => {
	              (!i3 || i3.getSource().maxzoom < e5.getSource().maxzoom) && (i3 = e5);
	            };
	            return r3.forEach((e5) => s3(e5)), i3 || o3.forEach((e5) => s3(e5)), i3;
	          }(this.style, this.transform.zoom);
	          e3 && function(e4, t2, i3) {
	            for (let a3 = 0; a3 < i3.length; a3++) Fr(e4, t2, i3[a3]);
	          }(this, e3, e3.getVisibleCoordinates());
	        }
	        this.options.showPadding && function(e3) {
	          const t2 = e3.transform.padding;
	          Ar(e3, e3.transform.height - (t2.top || 0), 3, Er), Ar(e3, t2.bottom || 0, 3, Sr), Lr(e3, t2.left || 0, 3, Rr), Lr(e3, e3.transform.width - (t2.right || 0), 3, Dr);
	          const i3 = e3.transform.centerPoint;
	          !function(e4, t3, i4, a3) {
	            kr(e4, t3 - 1, i4 - 10, 2, 20, a3), kr(e4, t3 - 10, i4 - 1, 20, 2, a3);
	          }(e3, i3.x, e3.transform.height - i3.y, zr);
	        }(this), this.context.setDefault();
	      }
	      maybeDrawDepthAndCoords(e2) {
	        if (!this.style || !this.style.map || !this.style.map.terrain) return;
	        const i2 = this.terrainFacilitator.matrix, a2 = this.transform.modelViewProjectionMatrix;
	        let r2 = this.terrainFacilitator.dirty;
	        r2 || (r2 = e2 ? !t.ci(i2, a2) : !t.cj(i2, a2)), r2 || (r2 = this.style.map.terrain.tileManager.anyTilesAfterTime(this.terrainFacilitator.renderTime)), r2 && (t.ck(i2, a2), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, function(e3, i3) {
	          const a3 = e3.context, r3 = a3.gl, o2 = e3.transform, s2 = Wt.unblended, n2 = new Xt(r3.LEQUAL, Xt.ReadWrite, [0, 1]), l2 = i3.tileManager.getRenderableTiles(), c2 = e3.useProgram("terrainDepth");
	          a3.bindFramebuffer.set(i3.getFramebuffer("depth").framebuffer), a3.viewport.set([0, 0, e3.width / devicePixelRatio, e3.height / devicePixelRatio]), a3.clear({ color: t.bo.transparent, depth: 1 });
	          for (const e4 of l2) {
	            const t2 = i3.getTerrainMesh(e4.tileID), l3 = i3.getTerrainData(e4.tileID), h2 = o2.getProjectionData({ overscaledTileID: e4.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true }), u2 = { u_ele_delta: i3.getMeshFrameDelta(o2.zoom) };
	            c2.draw(a3, r3.TRIANGLES, n2, Yt.disabled, s2, Ht.backCCW, u2, l3, h2, "terrain", t2.vertexBuffer, t2.indexBuffer, t2.segments);
	          }
	          a3.bindFramebuffer.set(null), a3.viewport.set([0, 0, e3.width, e3.height]);
	        }(this, this.style.map.terrain), function(e3, i3) {
	          const a3 = e3.context, r3 = a3.gl, o2 = e3.transform, s2 = Wt.unblended, n2 = new Xt(r3.LEQUAL, Xt.ReadWrite, [0, 1]), l2 = i3.getCoordsTexture(), c2 = i3.tileManager.getRenderableTiles(), h2 = e3.useProgram("terrainCoords");
	          a3.bindFramebuffer.set(i3.getFramebuffer("coords").framebuffer), a3.viewport.set([0, 0, e3.width / devicePixelRatio, e3.height / devicePixelRatio]), a3.clear({ color: t.bo.transparent, depth: 1 }), i3.coordsIndex = [];
	          for (const e4 of c2) {
	            const t2 = i3.getTerrainMesh(e4.tileID), c3 = i3.getTerrainData(e4.tileID);
	            a3.activeTexture.set(r3.TEXTURE0), r3.bindTexture(r3.TEXTURE_2D, l2.texture);
	            const u2 = { u_terrain_coords_id: (255 - i3.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: i3.getMeshFrameDelta(o2.zoom) }, d2 = o2.getProjectionData({ overscaledTileID: e4.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
	            h2.draw(a3, r3.TRIANGLES, n2, Yt.disabled, s2, Ht.backCCW, u2, c3, d2, "terrain", t2.vertexBuffer, t2.indexBuffer, t2.segments), i3.coordsIndex.push(e4.tileID.key);
	          }
	          a3.bindFramebuffer.set(null), a3.viewport.set([0, 0, e3.width, e3.height]);
	        }(this, this.style.map.terrain));
	      }
	      renderLayer(e2, i2, a2, r2, o2) {
	        a2.isHidden(this.transform.zoom) || ("background" === a2.type || "custom" === a2.type || (r2 || []).length) && (this.id = a2.id, t.cl(a2) ? function(e3, i3, a3, r3, o3, s2) {
	          if ("translucent" !== e3.renderPass) return;
	          const { isRenderingToTexture: n2 } = s2, l2 = Yt.disabled, c2 = e3.colorModeForRenderPass();
	          (a3._unevaluatedLayout.hasValue("text-variable-anchor") || a3._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(e4, i4, a4, r4, o4, s3, n3, l3, c3) {
	            const h2 = i4.transform, u2 = i4.style.map.terrain, d2 = "map" === o4, _2 = "map" === s3;
	            for (const o5 of e4) {
	              const e5 = r4.getTile(o5), s4 = e5.getBucket(a4);
	              if (!s4 || !s4.text || !s4.text.segments.get().length) continue;
	              const p2 = t.ax(s4.textSizeData, h2.zoom), m2 = t.aM(e5, 1, i4.transform.zoom), f2 = Ae(d2, i4.transform, m2), g2 = "none" !== a4.layout.get("icon-text-fit") && s4.hasIconData();
	              if (p2) {
	                const i5 = Math.pow(2, h2.zoom - e5.tileID.overscaledZ), a5 = u2 ? (e6, t2) => u2.getElevation(o5, e6, t2) : null;
	                nr(s4, d2, _2, c3, h2, f2, i5, p2, g2, t.aN(h2, e5, n3, l3), o5.toUnwrapped(), a5);
	              }
	            }
	          }(r3, e3, a3, i3, a3.layout.get("text-rotation-alignment"), a3.layout.get("text-pitch-alignment"), a3.paint.get("text-translate"), a3.paint.get("text-translate-anchor"), o3), 0 !== a3.paint.get("icon-opacity").constantOr(1) && cr(e3, i3, a3, r3, false, a3.paint.get("icon-translate"), a3.paint.get("icon-translate-anchor"), a3.layout.get("icon-rotation-alignment"), a3.layout.get("icon-pitch-alignment"), a3.layout.get("icon-keep-upright"), l2, c2, n2), 0 !== a3.paint.get("text-opacity").constantOr(1) && cr(e3, i3, a3, r3, true, a3.paint.get("text-translate"), a3.paint.get("text-translate-anchor"), a3.layout.get("text-rotation-alignment"), a3.layout.get("text-pitch-alignment"), a3.layout.get("text-keep-upright"), l2, c2, n2), i3.map.showCollisionBoxes && (ar(e3, i3, a3, r3, true), ar(e3, i3, a3, r3, false));
	        }(e2, i2, a2, r2, this.style.placement.variableOffsets, o2) : t.cm(a2) ? function(e3, i3, a3, r3, o3) {
	          if ("translucent" !== e3.renderPass) return;
	          const { isRenderingToTexture: s2 } = o3, n2 = a3.paint.get("circle-opacity"), l2 = a3.paint.get("circle-stroke-width"), c2 = a3.paint.get("circle-stroke-opacity"), h2 = !a3.layout.get("circle-sort-key").isConstant();
	          if (0 === n2.constantOr(1) && (0 === l2.constantOr(1) || 0 === c2.constantOr(1))) return;
	          const u2 = e3.context, d2 = u2.gl, _2 = e3.transform, p2 = e3.getDepthModeForSublayer(0, Xt.ReadOnly), m2 = Yt.disabled, f2 = e3.colorModeForRenderPass(), g2 = [], v2 = _2.getCircleRadiusCorrection();
	          for (let o4 = 0; o4 < r3.length; o4++) {
	            const n3 = r3[o4], l3 = i3.getTile(n3), c3 = l3.getBucket(a3);
	            if (!c3) continue;
	            const u3 = a3.paint.get("circle-translate"), d3 = a3.paint.get("circle-translate-anchor"), p3 = t.aN(_2, l3, u3, d3), m3 = c3.programConfigurations.get(a3.id), f3 = e3.useProgram("circle", m3), x2 = c3.layoutVertexBuffer, b2 = c3.indexBuffer, y2 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(n3), w2 = { programConfiguration: m3, program: f3, layoutVertexBuffer: x2, indexBuffer: b2, uniformValues: Gi(e3, l3, a3, p3, v2), terrainData: y2, projectionData: _2.getProjectionData({ overscaledTileID: n3, applyGlobeMatrix: !s2, applyTerrainMatrix: true }) };
	            if (h2) {
	              const e4 = c3.segments.get();
	              for (const i4 of e4) g2.push({ segments: new t.aW([i4]), sortKey: i4.sortKey, state: w2 });
	            } else g2.push({ segments: c3.segments, sortKey: 0, state: w2 });
	          }
	          h2 && g2.sort((e4, t2) => e4.sortKey - t2.sortKey);
	          for (const t2 of g2) {
	            const { programConfiguration: i4, program: r4, layoutVertexBuffer: o4, indexBuffer: s3, uniformValues: n3, terrainData: l3, projectionData: c3 } = t2.state;
	            r4.draw(u2, d2.TRIANGLES, p2, m2, f2, Ht.backCCW, n3, l3, c3, a3.id, o4, s3, t2.segments, a3.paint, e3.transform.zoom, i4);
	          }
	        }(e2, i2, a2, r2, o2) : t.cn(a2) ? function(e3, i3, a3, r3, o3) {
	          if (0 === a3.paint.get("heatmap-opacity")) return;
	          const s2 = e3.context, { isRenderingToTexture: n2, isRenderingGlobe: l2 } = o3;
	          if (e3.style.map.terrain) {
	            for (const t2 of r3) {
	              const r4 = i3.getTile(t2);
	              i3.hasRenderableParent(t2) || ("offscreen" === e3.renderPass ? ur(e3, r4, a3, t2, l2) : "translucent" === e3.renderPass && dr(e3, a3, t2, n2, l2));
	            }
	            s2.viewport.set([0, 0, e3.width, e3.height]);
	          } else "offscreen" === e3.renderPass ? function(e4, i4, a4, r4) {
	            const o4 = e4.context, s3 = o4.gl, n3 = e4.transform, l3 = Yt.disabled, c2 = new Wt([s3.ONE, s3.ONE], t.bo.transparent, [true, true, true, true]);
	            ((function(e5, i5, a5) {
	              const r5 = e5.gl;
	              e5.activeTexture.set(r5.TEXTURE1), e5.viewport.set([0, 0, i5.width / 4, i5.height / 4]);
	              let o5 = a5.heatmapFbos.get(t.cc);
	              o5 ? (r5.bindTexture(r5.TEXTURE_2D, o5.colorAttachment.get()), e5.bindFramebuffer.set(o5.framebuffer)) : (o5 = _r(e5, i5.width / 4, i5.height / 4), a5.heatmapFbos.set(t.cc, o5));
	            }))(o4, e4, a4), o4.clear({ color: t.bo.transparent });
	            for (let t2 = 0; t2 < r4.length; t2++) {
	              const h2 = r4[t2];
	              if (i4.hasRenderableParent(h2)) continue;
	              const u2 = i4.getTile(h2), d2 = u2.getBucket(a4);
	              if (!d2) continue;
	              const _2 = d2.programConfigurations.get(a4.id), p2 = e4.useProgram("heatmap", _2), m2 = n3.getProjectionData({ overscaledTileID: h2, applyGlobeMatrix: true, applyTerrainMatrix: false }), f2 = n3.getCircleRadiusCorrection();
	              p2.draw(o4, s3.TRIANGLES, Xt.disabled, l3, c2, Ht.backCCW, Wi(u2, n3.zoom, a4.paint.get("heatmap-intensity"), f2), null, m2, a4.id, d2.layoutVertexBuffer, d2.indexBuffer, d2.segments, a4.paint, n3.zoom, _2);
	            }
	            o4.viewport.set([0, 0, e4.width, e4.height]);
	          }(e3, i3, a3, r3) : "translucent" === e3.renderPass && function(e4, i4) {
	            const a4 = e4.context, r4 = a4.gl;
	            a4.setColorMode(e4.colorModeForRenderPass());
	            const o4 = i4.heatmapFbos.get(t.cc);
	            o4 && (a4.activeTexture.set(r4.TEXTURE0), r4.bindTexture(r4.TEXTURE_2D, o4.colorAttachment.get()), a4.activeTexture.set(r4.TEXTURE1), pr(a4, i4).bind(r4.LINEAR, r4.CLAMP_TO_EDGE), e4.useProgram("heatmapTexture").draw(a4, r4.TRIANGLES, Xt.disabled, Yt.disabled, e4.colorModeForRenderPass(), Ht.disabled, $i(e4, i4, 0, 1), null, null, i4.id, e4.viewportBuffer, e4.quadTriangleIndexBuffer, e4.viewportSegments, i4.paint, e4.transform.zoom));
	          }(e3, a3);
	        }(e2, i2, a2, r2, o2) : t.co(a2) ? function(e3, t2, i3, a3, r3) {
	          if ("translucent" !== e3.renderPass) return;
	          const { isRenderingToTexture: o3 } = r3, s2 = i3.paint.get("line-opacity"), n2 = i3.paint.get("line-width");
	          if (0 === s2.constantOr(1) || 0 === n2.constantOr(1)) return;
	          const l2 = e3.getDepthModeForSublayer(0, Xt.ReadOnly), c2 = e3.colorModeForRenderPass(), h2 = i3.paint.get("line-dasharray"), u2 = h2.constantOr(1), d2 = i3.paint.get("line-pattern"), _2 = d2.constantOr(1), p2 = i3.paint.get("line-gradient"), m2 = i3.getCrossfadeParameters();
	          let f2;
	          f2 = _2 ? "linePattern" : u2 && p2 ? "lineGradientSDF" : u2 ? "lineSDF" : p2 ? "lineGradient" : "line";
	          const g2 = e3.context, v2 = g2.gl, x2 = e3.transform;
	          let b2 = true;
	          for (const r4 of a3) {
	            const a4 = t2.getTile(r4);
	            if (_2 && !a4.patternsLoaded()) continue;
	            const s3 = a4.getBucket(i3);
	            if (!s3) continue;
	            const n3 = s3.programConfigurations.get(i3.id), y2 = e3.context.program.get(), w2 = e3.useProgram(f2, n3), T2 = b2 || w2.program !== y2, P2 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(r4), C2 = d2.constantOr(null), M2 = h2 && h2.constantOr(null);
	            if (C2 && a4.imageAtlas) {
	              const e4 = a4.imageAtlas, t3 = e4.patternPositions[C2.to.toString()], i4 = e4.patternPositions[C2.from.toString()];
	              t3 && i4 && n3.setConstantPatternPositions(t3, i4);
	            } else if (M2) {
	              const t3 = "round" === i3.layout.get("line-cap"), a5 = e3.lineAtlas.getDash(M2.to, t3), r5 = e3.lineAtlas.getDash(M2.from, t3);
	              n3.setConstantDashPositions(a5, r5);
	            }
	            const I2 = x2.getProjectionData({ overscaledTileID: r4, applyGlobeMatrix: !o3, applyTerrainMatrix: true }), E2 = x2.getPixelScale();
	            let S2;
	            _2 ? (S2 = ea(e3, a4, i3, E2, m2), fr(g2, v2, a4, n3, m2)) : u2 && p2 ? (S2 = ia(e3, a4, i3, E2, m2, s3.lineClipsArray.length), xr(e3, t2, g2, v2, i3, s3, r4, n3, m2)) : u2 ? (S2 = ta(e3, a4, i3, E2, m2), gr(e3, g2, v2, n3, T2, m2)) : p2 ? (S2 = Ji(e3, a4, i3, E2, s3.lineClipsArray.length), vr(e3, t2, g2, v2, i3, s3, r4)) : S2 = Qi(e3, a4, i3, E2);
	            const R2 = e3.stencilModeForClipping(r4);
	            w2.draw(g2, v2.TRIANGLES, l2, R2, c2, Ht.disabled, S2, P2, I2, i3.id, s3.layoutVertexBuffer, s3.indexBuffer, s3.segments, i3.paint, e3.transform.zoom, n3, s3.layoutVertexBuffer2), b2 = false;
	          }
	        }(e2, i2, a2, r2, o2) : t.cp(a2) ? function(e3, i3, a3, r3, o3) {
	          const s2 = a3.paint.get("fill-color"), n2 = a3.paint.get("fill-opacity");
	          if (0 === n2.constantOr(1)) return;
	          const { isRenderingToTexture: l2 } = o3, c2 = e3.colorModeForRenderPass(), h2 = a3.paint.get("fill-pattern"), u2 = e3.opaquePassEnabledForLayer() && !h2.constantOr(1) && 1 === s2.constantOr(t.bo.transparent).a && 1 === n2.constantOr(0) ? "opaque" : "translucent";
	          if (e3.renderPass === u2) {
	            const t2 = e3.getDepthModeForSublayer(1, "opaque" === e3.renderPass ? Xt.ReadWrite : Xt.ReadOnly);
	            yr(e3, i3, a3, r3, t2, c2, false, l2);
	          }
	          if ("translucent" === e3.renderPass && a3.paint.get("fill-antialias")) {
	            const t2 = e3.getDepthModeForSublayer(a3.getPaintProperty("fill-outline-color") ? 2 : 0, Xt.ReadOnly);
	            yr(e3, i3, a3, r3, t2, c2, true, l2);
	          }
	        }(e2, i2, a2, r2, o2) : t.cq(a2) ? function(e3, t2, i3, a3, r3) {
	          const o3 = i3.paint.get("fill-extrusion-opacity");
	          if (0 === o3) return;
	          const { isRenderingToTexture: s2 } = r3;
	          if ("translucent" === e3.renderPass) {
	            const r4 = new Xt(e3.context.gl.LEQUAL, Xt.ReadWrite, e3.depthRangeFor3D);
	            if (1 !== o3 || i3.paint.get("fill-extrusion-pattern").constantOr(1)) wr(e3, t2, i3, a3, r4, Yt.disabled, Wt.disabled, s2), wr(e3, t2, i3, a3, r4, e3.stencilModeFor3D(), e3.colorModeForRenderPass(), s2);
	            else {
	              const o4 = e3.colorModeForRenderPass();
	              wr(e3, t2, i3, a3, r4, Yt.disabled, o4, s2);
	            }
	          }
	        }(e2, i2, a2, r2, o2) : t.cr(a2) ? function(e3, i3, a3, r3, o3) {
	          if ("offscreen" !== e3.renderPass && "translucent" !== e3.renderPass) return;
	          const { isRenderingToTexture: s2 } = o3, n2 = e3.context, l2 = e3.style.projection.useSubdivision, c2 = e3.getDepthModeForSublayer(0, Xt.ReadOnly), h2 = e3.colorModeForRenderPass();
	          if ("offscreen" === e3.renderPass) !function(e4, i4, a4, r4, o4, s3, n3) {
	            const l3 = e4.context, c3 = l3.gl;
	            for (const h3 of a4) {
	              const a5 = i4.getTile(h3), u2 = a5.dem;
	              if (!u2 || !u2.data) continue;
	              if (!a5.needsHillshadePrepare) continue;
	              const d2 = u2.dim, _2 = u2.stride, p2 = u2.getPixels();
	              if (l3.activeTexture.set(c3.TEXTURE1), l3.pixelStoreUnpackPremultiplyAlpha.set(false), a5.demTexture = a5.demTexture || e4.getTileTexture(_2), a5.demTexture) {
	                const e5 = a5.demTexture;
	                e5.update(p2, { premultiply: false }), e5.bind(c3.NEAREST, c3.CLAMP_TO_EDGE);
	              } else a5.demTexture = new t.T(l3, p2, c3.RGBA, { premultiply: false }), a5.demTexture.bind(c3.NEAREST, c3.CLAMP_TO_EDGE);
	              l3.activeTexture.set(c3.TEXTURE0);
	              let m2 = a5.fbo;
	              if (!m2) {
	                const e5 = new t.T(l3, { width: d2, height: d2, data: null }, c3.RGBA);
	                e5.bind(c3.LINEAR, c3.CLAMP_TO_EDGE), m2 = a5.fbo = l3.createFramebuffer(d2, d2, true, false), m2.colorAttachment.set(e5.texture);
	              }
	              l3.bindFramebuffer.set(m2.framebuffer), l3.viewport.set([0, 0, d2, d2]), e4.useProgram("hillshadePrepare").draw(l3, c3.TRIANGLES, o4, s3, n3, Ht.disabled, Xi(a5.tileID, u2), null, null, r4.id, e4.rasterBoundsBuffer, e4.quadTriangleIndexBuffer, e4.rasterBoundsSegments), a5.needsHillshadePrepare = false;
	            }
	          }(e3, i3, r3, a3, c2, Yt.disabled, h2), n2.viewport.set([0, 0, e3.width, e3.height]);
	          else if ("translucent" === e3.renderPass) if (l2) {
	            const [t2, o4, n3] = e3.stencilConfigForOverlapTwoPass(r3);
	            Tr(e3, i3, a3, n3, t2, c2, h2, false, s2), Tr(e3, i3, a3, n3, o4, c2, h2, true, s2);
	          } else {
	            const [t2, o4] = e3.getStencilConfigForOverlapAndUpdateStencilID(r3);
	            Tr(e3, i3, a3, o4, t2, c2, h2, false, s2);
	          }
	        }(e2, i2, a2, r2, o2) : t.cs(a2) ? function(e3, t2, i3, a3, r3) {
	          if ("translucent" !== e3.renderPass) return;
	          if (!a3.length) return;
	          const { isRenderingToTexture: o3 } = r3, s2 = e3.style.projection.useSubdivision, n2 = e3.getDepthModeForSublayer(0, Xt.ReadOnly), l2 = e3.colorModeForRenderPass();
	          if (s2) {
	            const [r4, s3, c2] = e3.stencilConfigForOverlapTwoPass(a3);
	            Pr(e3, t2, i3, c2, r4, n2, l2, false, o3), Pr(e3, t2, i3, c2, s3, n2, l2, true, o3);
	          } else {
	            const [r4, s3] = e3.getStencilConfigForOverlapAndUpdateStencilID(a3);
	            Pr(e3, t2, i3, s3, r4, n2, l2, false, o3);
	          }
	        }(e2, i2, a2, r2, o2) : t.bT(a2) ? function(e3, t2, i3, a3, r3) {
	          if ("translucent" !== e3.renderPass) return;
	          if (0 === i3.paint.get("raster-opacity")) return;
	          if (!a3.length) return;
	          const { isRenderingToTexture: o3 } = r3, s2 = t2.getSource(), n2 = e3.style.projection.useSubdivision;
	          if (s2 instanceof te) Mr(e3, t2, i3, a3, null, false, false, s2.tileCoords, s2.flippedWindingOrder, o3);
	          else if (n2) {
	            const [r4, s3, n3] = e3.stencilConfigForOverlapTwoPass(a3);
	            Mr(e3, t2, i3, n3, r4, false, true, Cr, false, o3), Mr(e3, t2, i3, n3, s3, true, true, Cr, false, o3);
	          } else {
	            const [r4, s3] = e3.getStencilConfigForOverlapAndUpdateStencilID(a3);
	            Mr(e3, t2, i3, s3, r4, false, true, Cr, false, o3);
	          }
	        }(e2, i2, a2, r2, o2) : t.ct(a2) ? function(e3, t2, i3, a3, r3) {
	          const o3 = i3.paint.get("background-color"), s2 = i3.paint.get("background-opacity");
	          if (0 === s2) return;
	          const { isRenderingToTexture: n2 } = r3, l2 = e3.context, c2 = l2.gl, h2 = e3.style.projection, u2 = e3.transform, d2 = u2.tileSize, _2 = i3.paint.get("background-pattern");
	          if (e3.isPatternMissing(_2)) return;
	          const p2 = !_2 && 1 === o3.a && 1 === s2 && e3.opaquePassEnabledForLayer() ? "opaque" : "translucent";
	          if (e3.renderPass !== p2) return;
	          const m2 = Yt.disabled, f2 = e3.getDepthModeForSublayer(0, "opaque" === p2 ? Xt.ReadWrite : Xt.ReadOnly), g2 = e3.colorModeForRenderPass(), v2 = e3.useProgram(_2 ? "backgroundPattern" : "background"), x2 = a3 || Ce(u2, { tileSize: d2, terrain: e3.style.map.terrain });
	          _2 && (l2.activeTexture.set(c2.TEXTURE0), e3.imageManager.bind(e3.context));
	          const b2 = i3.getCrossfadeParameters();
	          for (const t3 of x2) {
	            const a4 = u2.getProjectionData({ overscaledTileID: t3, applyGlobeMatrix: !n2, applyTerrainMatrix: true }), r4 = _2 ? ua(s2, e3, _2, { tileID: t3, tileSize: d2 }, b2) : ha(s2, o3), p3 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(t3), x3 = h2.getMeshFromTileID(l2, t3.canonical, false, true, "raster");
	            v2.draw(l2, c2.TRIANGLES, f2, m2, g2, Ht.backCCW, r4, p3, a4, i3.id, x3.vertexBuffer, x3.indexBuffer, x3.segments);
	          }
	        }(e2, 0, a2, r2, o2) : t.cu(a2) && function(e3, t2, i3, a3) {
	          const { isRenderingGlobe: r3 } = a3, o3 = e3.context, s2 = i3.implementation, n2 = e3.style.projection, l2 = e3.transform, c2 = l2.getProjectionDataForCustomLayer(r3), h2 = { farZ: l2.farZ, nearZ: l2.nearZ, fov: l2.fov * Math.PI / 180, modelViewProjectionMatrix: l2.modelViewProjectionMatrix, projectionMatrix: l2.projectionMatrix, shaderData: { variantName: n2.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${n2.shaderPreludeCode.vertexSource}`, define: n2.shaderDefine }, defaultProjectionData: c2 }, u2 = s2.renderingMode ? s2.renderingMode : "2d";
	          if ("offscreen" === e3.renderPass) {
	            const t3 = s2.prerender;
	            t3 && (e3.setCustomLayerDefaults(), o3.setColorMode(e3.colorModeForRenderPass()), t3.call(s2, o3.gl, h2), o3.setDirty(), e3.setBaseState());
	          } else if ("translucent" === e3.renderPass) {
	            e3.setCustomLayerDefaults(), o3.setColorMode(e3.colorModeForRenderPass()), o3.setStencilMode(Yt.disabled);
	            const t3 = "3d" === u2 ? e3.getDepthModeFor3D() : e3.getDepthModeForSublayer(0, Xt.ReadOnly);
	            o3.setDepthMode(t3), s2.render(o3.gl, h2), o3.setDirty(), e3.setBaseState(), o3.bindFramebuffer.set(null);
	          }
	        }(e2, 0, a2, o2));
	      }
	      saveTileTexture(e2) {
	        const t2 = this._tileTextures[e2.size[0]];
	        t2 ? t2.push(e2) : this._tileTextures[e2.size[0]] = [e2];
	      }
	      getTileTexture(e2) {
	        const t2 = this._tileTextures[e2];
	        return t2 && t2.length > 0 ? t2.pop() : null;
	      }
	      isPatternMissing(e2) {
	        if (!e2) return false;
	        if (!e2.from || !e2.to) return true;
	        const t2 = this.imageManager.getPattern(e2.from.toString()), i2 = this.imageManager.getPattern(e2.to.toString());
	        return !t2 || !i2;
	      }
	      useProgram(e2, t2, i2 = false, a2 = []) {
	        this.cache = this.cache || {};
	        const r2 = !!this.style.map.terrain, o2 = this.style.projection, s2 = i2 ? It.projectionMercator : o2.shaderPreludeCode, n2 = i2 ? Dt : o2.shaderDefine, l2 = e2 + (t2 ? t2.cacheKey : "") + `/${i2 ? zt : o2.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (r2 ? "/terrain" : "") + (a2 ? `/${a2.join("/")}` : "");
	        return this.cache[l2] || (this.cache[l2] = new ki(this.context, It[e2], t2, _a[e2], this._showOverdrawInspector, r2, s2, n2, a2)), this.cache[l2];
	      }
	      setCustomLayerDefaults() {
	        this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
	      }
	      setBaseState() {
	        const e2 = this.context.gl;
	        this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e2.FUNC_ADD);
	      }
	      initDebugOverlayCanvas() {
	        null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new t.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
	      }
	      destroy() {
	        var e2, t2;
	        if (this._tileTextures) {
	          for (const e3 in this._tileTextures) {
	            const t3 = this._tileTextures[e3];
	            if (t3) for (const e4 of t3) e4.destroy();
	          }
	          this._tileTextures = {};
	        }
	        if (this.tileExtentBuffer && this.tileExtentBuffer.destroy(), this.debugBuffer && this.debugBuffer.destroy(), this.rasterBoundsBuffer && this.rasterBoundsBuffer.destroy(), this.rasterBoundsBufferPosOnly && this.rasterBoundsBufferPosOnly.destroy(), this.viewportBuffer && this.viewportBuffer.destroy(), this.tileBorderIndexBuffer && this.tileBorderIndexBuffer.destroy(), this.quadTriangleIndexBuffer && this.quadTriangleIndexBuffer.destroy(), this.tileExtentMesh && (null === (e2 = this.tileExtentMesh.vertexBuffer) || void 0 === e2 || e2.destroy()), this.tileExtentMesh && (null === (t2 = this.tileExtentMesh.indexBuffer) || void 0 === t2 || t2.destroy()), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.cache) {
	          for (const e3 in this.cache) {
	            const t3 = this.cache[e3];
	            t3 && t3.program && this.context.gl.deleteProgram(t3.program);
	          }
	          this.cache = {};
	        }
	        this.context && this.context.setDefault();
	      }
	      overLimit() {
	        const { drawingBufferWidth: e2, drawingBufferHeight: t2 } = this.context.gl;
	        return this.width !== e2 || this.height !== t2;
	      }
	    }
	    function Nr(e2, t2) {
	      let i2, a2 = false, r2 = null, o2 = null;
	      const s2 = () => {
	        r2 = null, a2 && (e2.apply(o2, i2), r2 = setTimeout(s2, t2), a2 = false);
	      };
	      return (...e3) => (a2 = true, o2 = this, i2 = e3, r2 || s2(), r2);
	    }
	    class Zr {
	      constructor(e2) {
	        this._getCurrentHash = () => {
	          const e3 = window.location.hash.replace("#", "");
	          if (this._hashName) {
	            let t2;
	            return e3.split("&").map((e4) => e4.split("=")).forEach((e4) => {
	              e4[0] === this._hashName && (t2 = e4);
	            }), (t2 && t2[1] || "").split("/");
	          }
	          return e3.split("/");
	        }, this._onHashChange = () => {
	          const e3 = this._getCurrentHash();
	          if (!this._isValidHash(e3)) return false;
	          const t2 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e3[3] || 0) : this._map.getBearing();
	          return this._map.jumpTo({ center: [+e3[2], +e3[1]], zoom: +e3[0], bearing: t2, pitch: +(e3[4] || 0) }), true;
	        }, this._updateHashUnthrottled = () => {
	          const e3 = window.location.href.replace(/(#.*)?$/, this.getHashString());
	          window.history.replaceState(window.history.state, null, e3);
	        }, this._removeHash = () => {
	          const e3 = this._getCurrentHash();
	          if (0 === e3.length) return;
	          const t2 = e3.join("/");
	          let i2 = t2;
	          i2.split("&").length > 0 && (i2 = i2.split("&")[0]), this._hashName && (i2 = `${this._hashName}=${t2}`);
	          let a2 = window.location.hash.replace(i2, "");
	          a2.startsWith("#&") ? a2 = a2.slice(0, 1) + a2.slice(2) : "#" === a2 && (a2 = "");
	          let r2 = window.location.href.replace(/(#.+)?$/, a2);
	          r2 = r2.replace("&&", "&"), window.history.replaceState(window.history.state, null, r2);
	        }, this._updateHash = Nr(this._updateHashUnthrottled, 300), this._hashName = e2 && encodeURIComponent(e2);
	      }
	      addTo(e2) {
	        return this._map = e2, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
	      }
	      remove() {
	        return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
	      }
	      getHashString(e2) {
	        const t2 = this._map.getCenter(), i2 = Math.round(100 * this._map.getZoom()) / 100, a2 = Math.ceil((i2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), r2 = Math.pow(10, a2), o2 = Math.round(t2.lng * r2) / r2, s2 = Math.round(t2.lat * r2) / r2, n2 = this._map.getBearing(), l2 = this._map.getPitch();
	        let c2 = "";
	        if (c2 += e2 ? `/${o2}/${s2}/${i2}` : `${i2}/${s2}/${o2}`, (n2 || l2) && (c2 += "/" + Math.round(10 * n2) / 10), l2 && (c2 += `/${Math.round(l2)}`), this._hashName) {
	          const e3 = this._hashName;
	          let t3 = false;
	          const i3 = window.location.hash.slice(1).split("&").map((i4) => {
	            const a3 = i4.split("=")[0];
	            return a3 === e3 ? (t3 = true, `${a3}=${c2}`) : i4;
	          }).filter((e4) => e4);
	          return t3 || i3.push(`${e3}=${c2}`), `#${i3.join("&")}`;
	        }
	        return `#${c2}`;
	      }
	      _isValidHash(e2) {
	        if (e2.length < 3 || e2.some(isNaN)) return false;
	        try {
	          new t.V(+e2[2], +e2[1]);
	        } catch (e3) {
	          return false;
	        }
	        const i2 = +e2[0], a2 = +(e2[3] || 0), r2 = +(e2[4] || 0);
	        return i2 >= this._map.getMinZoom() && i2 <= this._map.getMaxZoom() && a2 >= -180 && a2 <= 180 && r2 >= this._map.getMinPitch() && r2 <= this._map.getMaxPitch();
	      }
	    }
	    const Gr = { linearity: 0.3, easing: t.cv(0, 0, 0.3, 1) }, Ur = t.e({ deceleration: 2500, maxSpeed: 1400 }, Gr), Vr = t.e({ deceleration: 20, maxSpeed: 1400 }, Gr), qr = t.e({ deceleration: 1e3, maxSpeed: 360 }, Gr), Wr = t.e({ deceleration: 1e3, maxSpeed: 90 }, Gr), $r = t.e({ deceleration: 1e3, maxSpeed: 360 }, Gr);
	    class Hr {
	      constructor(e2) {
	        this._map = e2, this.clear();
	      }
	      clear() {
	        this._inertiaBuffer = [];
	      }
	      record(e2) {
	        this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: c(), settings: e2 });
	      }
	      _drainInertiaBuffer() {
	        const e2 = this._inertiaBuffer, t2 = c();
	        for (; e2.length > 0 && t2 - e2[0].time > 160; ) e2.shift();
	      }
	      _onMoveEnd(e2) {
	        if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
	        const i2 = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new t.P(0, 0), pinchAround: void 0, around: void 0 };
	        for (const { settings: e3 } of this._inertiaBuffer) i2.zoom += e3.zoomDelta || 0, i2.bearing += e3.bearingDelta || 0, i2.pitch += e3.pitchDelta || 0, i2.roll += e3.rollDelta || 0, e3.panDelta && i2.pan._add(e3.panDelta), e3.around && (i2.around = e3.around), e3.pinchAround && (i2.pinchAround = e3.pinchAround);
	        const a2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r2 = {};
	        if (i2.pan.mag()) {
	          const o2 = Kr(i2.pan.mag(), a2, t.e({}, Ur, e2 || {})), s2 = i2.pan.mult(o2.amount / i2.pan.mag()), n2 = this._map.cameraHelper.handlePanInertia(s2, this._map.transform);
	          r2.center = n2.easingCenter, r2.offset = n2.easingOffset, Xr(r2, o2);
	        }
	        if (i2.zoom) {
	          const e3 = Kr(i2.zoom, a2, Vr);
	          r2.zoom = this._map.transform.zoom + e3.amount, Xr(r2, e3);
	        }
	        if (i2.bearing) {
	          const e3 = Kr(i2.bearing, a2, qr);
	          r2.bearing = this._map.transform.bearing + t.an(e3.amount, -179, 179), Xr(r2, e3);
	        }
	        if (i2.pitch) {
	          const e3 = Kr(i2.pitch, a2, Wr);
	          r2.pitch = this._map.transform.pitch + e3.amount, Xr(r2, e3);
	        }
	        if (i2.roll) {
	          const e3 = Kr(i2.roll, a2, $r);
	          r2.roll = this._map.transform.roll + t.an(e3.amount, -179, 179), Xr(r2, e3);
	        }
	        if (r2.zoom || r2.bearing) {
	          const e3 = void 0 === i2.pinchAround ? i2.around : i2.pinchAround;
	          r2.around = e3 ? this._map.unproject(e3) : this._map.getCenter();
	        }
	        return this.clear(), t.e(r2, { noMoveStart: true });
	      }
	    }
	    function Xr(e2, t2) {
	      (!e2.duration || e2.duration < t2.duration) && (e2.duration = t2.duration, e2.easing = t2.easing);
	    }
	    function Kr(e2, i2, a2) {
	      const { maxSpeed: r2, linearity: o2, deceleration: s2 } = a2, n2 = t.an(e2 * o2 / (i2 / 1e3), -r2, r2), l2 = Math.abs(n2) / (s2 * o2);
	      return { easing: a2.easing, duration: 1e3 * l2, amount: n2 * (l2 / 2) };
	    }
	    class Yr extends t.l {
	      preventDefault() {
	        this._defaultPrevented = true;
	      }
	      get defaultPrevented() {
	        return this._defaultPrevented;
	      }
	      constructor(e2, i2, a2, r2 = {}) {
	        a2 = a2 instanceof MouseEvent ? a2 : new MouseEvent(e2, a2);
	        const o2 = h.mousePos(i2.getCanvas(), a2), s2 = i2.unproject(o2);
	        super(e2, t.e({ point: o2, lngLat: s2, originalEvent: a2 }, r2)), this._defaultPrevented = false, this.target = i2;
	      }
	    }
	    class Qr extends t.l {
	      preventDefault() {
	        this._defaultPrevented = true;
	      }
	      get defaultPrevented() {
	        return this._defaultPrevented;
	      }
	      constructor(e2, i2, a2) {
	        const r2 = "touchend" === e2 ? a2.changedTouches : a2.touches, o2 = h.touchPos(i2.getCanvasContainer(), r2), s2 = o2.map((e3) => i2.unproject(e3)), n2 = o2.reduce((e3, t2, i3, a3) => e3.add(t2.div(a3.length)), new t.P(0, 0));
	        super(e2, { points: o2, point: n2, lngLats: s2, lngLat: i2.unproject(n2), originalEvent: a2 }), this._defaultPrevented = false;
	      }
	    }
	    class Jr extends t.l {
	      preventDefault() {
	        this._defaultPrevented = true;
	      }
	      get defaultPrevented() {
	        return this._defaultPrevented;
	      }
	      constructor(e2, t2, i2) {
	        super(e2, { originalEvent: i2 }), this._defaultPrevented = false;
	      }
	    }
	    class eo {
	      constructor(e2, t2) {
	        this._map = e2, this._clickTolerance = t2.clickTolerance;
	      }
	      reset() {
	        delete this._mousedownPos;
	      }
	      wheel(e2) {
	        return this._firePreventable(new Jr(e2.type, this._map, e2));
	      }
	      mousedown(e2, t2) {
	        return this._mousedownPos = t2, this._firePreventable(new Yr(e2.type, this._map, e2));
	      }
	      mouseup(e2) {
	        this._map.fire(new Yr(e2.type, this._map, e2));
	      }
	      click(e2, t2) {
	        this._mousedownPos && this._mousedownPos.dist(t2) >= this._clickTolerance || this._map.fire(new Yr(e2.type, this._map, e2));
	      }
	      dblclick(e2) {
	        return this._firePreventable(new Yr(e2.type, this._map, e2));
	      }
	      mouseover(e2) {
	        this._map.fire(new Yr(e2.type, this._map, e2));
	      }
	      mouseout(e2) {
	        this._map.fire(new Yr(e2.type, this._map, e2));
	      }
	      touchstart(e2) {
	        return this._firePreventable(new Qr(e2.type, this._map, e2));
	      }
	      touchmove(e2) {
	        this._map.fire(new Qr(e2.type, this._map, e2));
	      }
	      touchend(e2) {
	        this._map.fire(new Qr(e2.type, this._map, e2));
	      }
	      touchcancel(e2) {
	        this._map.fire(new Qr(e2.type, this._map, e2));
	      }
	      _firePreventable(e2) {
	        if (this._map.fire(e2), e2.defaultPrevented) return {};
	      }
	      isEnabled() {
	        return true;
	      }
	      isActive() {
	        return false;
	      }
	      enable() {
	      }
	      disable() {
	      }
	    }
	    class to {
	      constructor(e2) {
	        this._map = e2;
	      }
	      reset() {
	        this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
	      }
	      mousemove(e2) {
	        this._map.fire(new Yr(e2.type, this._map, e2));
	      }
	      mousedown() {
	        this._delayContextMenu = true, this._ignoreContextMenu = false;
	      }
	      mouseup() {
	        this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new Yr("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
	      }
	      contextmenu(e2) {
	        this._delayContextMenu ? this._contextMenuEvent = e2 : this._ignoreContextMenu || this._map.fire(new Yr(e2.type, this._map, e2)), this._map.listens("contextmenu") && e2.preventDefault();
	      }
	      isEnabled() {
	        return true;
	      }
	      isActive() {
	        return false;
	      }
	      enable() {
	      }
	      disable() {
	      }
	    }
	    class io {
	      constructor(e2) {
	        this._map = e2;
	      }
	      get transform() {
	        return this._map._requestedCameraState || this._map.transform;
	      }
	      get center() {
	        return { lng: this.transform.center.lng, lat: this.transform.center.lat };
	      }
	      get zoom() {
	        return this.transform.zoom;
	      }
	      get pitch() {
	        return this.transform.pitch;
	      }
	      get bearing() {
	        return this.transform.bearing;
	      }
	      unproject(e2) {
	        return this.transform.screenPointToLocation(t.P.convert(e2), this._map.terrain);
	      }
	    }
	    class ao {
	      constructor(e2, t2) {
	        this._map = e2, this._tr = new io(e2), this._el = e2.getCanvasContainer(), this._container = e2.getContainer(), this._clickTolerance = t2.clickTolerance || 1;
	      }
	      isEnabled() {
	        return !!this._enabled;
	      }
	      isActive() {
	        return !!this._active;
	      }
	      enable() {
	        this.isEnabled() || (this._enabled = true);
	      }
	      disable() {
	        this.isEnabled() && (this._enabled = false);
	      }
	      mousedown(e2, t2) {
	        this.isEnabled() && e2.shiftKey && 0 === e2.button && (h.disableDrag(), this._startPos = this._lastPos = t2, this._active = true);
	      }
	      mousemoveWindow(e2, t2) {
	        if (!this._active) return;
	        const i2 = t2;
	        if (this._lastPos.equals(i2) || !this._box && i2.dist(this._startPos) < this._clickTolerance) return;
	        const a2 = this._startPos;
	        this._lastPos = i2, this._box || (this._box = h.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e2));
	        const r2 = Math.min(a2.x, i2.x), o2 = Math.max(a2.x, i2.x), s2 = Math.min(a2.y, i2.y), n2 = Math.max(a2.y, i2.y);
	        h.setTransform(this._box, `translate(${r2}px,${s2}px)`), this._box.style.width = o2 - r2 + "px", this._box.style.height = n2 - s2 + "px";
	      }
	      mouseupWindow(e2, i2) {
	        if (!this._active) return;
	        if (0 !== e2.button) return;
	        const a2 = this._startPos, r2 = i2;
	        if (this.reset(), h.suppressClick(), a2.x !== r2.x || a2.y !== r2.y) return this._map.fire(new t.l("boxzoomend", { originalEvent: e2 })), { cameraAnimation: (e3) => e3.fitScreenCoordinates(a2, r2, this._tr.bearing, { linear: true }) };
	        this._fireEvent("boxzoomcancel", e2);
	      }
	      keydown(e2) {
	        this._active && 27 === e2.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e2));
	      }
	      reset() {
	        this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (h.remove(this._box), this._box = null), h.enableDrag(), delete this._startPos, delete this._lastPos;
	      }
	      _fireEvent(e2, i2) {
	        return this._map.fire(new t.l(e2, { originalEvent: i2 }));
	      }
	    }
	    function ro(e2, t2) {
	      if (e2.length !== t2.length) throw new Error(`The number of touches and points are not equal - touches ${e2.length}, points ${t2.length}`);
	      const i2 = {};
	      for (let a2 = 0; a2 < e2.length; a2++) i2[e2[a2].identifier] = t2[a2];
	      return i2;
	    }
	    class oo {
	      constructor(e2) {
	        this.reset(), this.numTouches = e2.numTouches;
	      }
	      reset() {
	        delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
	      }
	      touchstart(e2, i2, a2) {
	        (this.centroid || a2.length > this.numTouches) && (this.aborted = true), this.aborted || (void 0 === this.startTime && (this.startTime = e2.timeStamp), a2.length === this.numTouches && (this.centroid = function(e3) {
	          const i3 = new t.P(0, 0);
	          for (const t2 of e3) i3._add(t2);
	          return i3.div(e3.length);
	        }(i2), this.touches = ro(a2, i2)));
	      }
	      touchmove(e2, t2, i2) {
	        if (this.aborted || !this.centroid) return;
	        const a2 = ro(i2, t2);
	        for (const e3 in this.touches) {
	          const t3 = a2[e3];
	          (!t3 || t3.dist(this.touches[e3]) > 30) && (this.aborted = true);
	        }
	      }
	      touchend(e2, t2, i2) {
	        if ((!this.centroid || e2.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i2.length) {
	          const e3 = !this.aborted && this.centroid;
	          if (this.reset(), e3) return e3;
	        }
	      }
	    }
	    class so {
	      constructor(e2) {
	        this.singleTap = new oo(e2), this.numTaps = e2.numTaps, this.reset();
	      }
	      reset() {
	        this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
	      }
	      touchstart(e2, t2, i2) {
	        this.singleTap.touchstart(e2, t2, i2);
	      }
	      touchmove(e2, t2, i2) {
	        this.singleTap.touchmove(e2, t2, i2);
	      }
	      touchend(e2, t2, i2) {
	        const a2 = this.singleTap.touchend(e2, t2, i2);
	        if (a2) {
	          const t3 = e2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(a2) < 30;
	          if (t3 && i3 || this.reset(), this.count++, this.lastTime = e2.timeStamp, this.lastTap = a2, this.count === this.numTaps) return this.reset(), a2;
	        }
	      }
	    }
	    class no {
	      constructor(e2) {
	        this._tr = new io(e2), this._zoomIn = new so({ numTouches: 1, numTaps: 2 }), this._zoomOut = new so({ numTouches: 2, numTaps: 1 }), this.reset();
	      }
	      reset() {
	        this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
	      }
	      touchstart(e2, t2, i2) {
	        this._zoomIn.touchstart(e2, t2, i2), this._zoomOut.touchstart(e2, t2, i2);
	      }
	      touchmove(e2, t2, i2) {
	        this._zoomIn.touchmove(e2, t2, i2), this._zoomOut.touchmove(e2, t2, i2);
	      }
	      touchend(e2, t2, i2) {
	        const a2 = this._zoomIn.touchend(e2, t2, i2), r2 = this._zoomOut.touchend(e2, t2, i2), o2 = this._tr;
	        return a2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: o2.zoom + 1, around: o2.unproject(a2) }, { originalEvent: e2 }) }) : r2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: o2.zoom - 1, around: o2.unproject(r2) }, { originalEvent: e2 }) }) : void 0;
	      }
	      touchcancel() {
	        this.reset();
	      }
	      enable() {
	        this._enabled = true;
	      }
	      disable() {
	        this._enabled = false, this.reset();
	      }
	      isEnabled() {
	        return this._enabled;
	      }
	      isActive() {
	        return this._active;
	      }
	    }
	    class lo {
	      constructor(e2) {
	        this._enabled = !!e2.enable, this._moveStateManager = e2.moveStateManager, this._clickTolerance = e2.clickTolerance || 1, this._moveFunction = e2.move, this._activateOnStart = !!e2.activateOnStart, e2.assignEvents(this), this.reset();
	      }
	      reset(e2) {
	        this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(e2);
	      }
	      _move(...e2) {
	        const t2 = this._moveFunction(...e2);
	        if (t2.bearingDelta || t2.pitchDelta || t2.rollDelta || t2.around || t2.panDelta) return this._active = true, t2;
	      }
	      dragStart(e2, t2) {
	        this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e2) && (this._moveStateManager.startMove(e2), this._lastPoint = Array.isArray(t2) ? t2[0] : t2, this._activateOnStart && this._lastPoint && (this._active = true));
	      }
	      dragMove(e2, t2) {
	        if (!this.isEnabled()) return;
	        const i2 = this._lastPoint;
	        if (!i2) return;
	        if (e2.preventDefault(), !this._moveStateManager.isValidMoveEvent(e2)) return void this.reset(e2);
	        const a2 = Array.isArray(t2) ? t2[0] : t2;
	        return !this._moved && a2.dist(i2) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = a2, this._move(i2, a2));
	      }
	      dragEnd(e2) {
	        this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e2) && (this._moved && h.suppressClick(), this.reset(e2));
	      }
	      enable() {
	        this._enabled = true;
	      }
	      disable() {
	        this._enabled = false, this.reset();
	      }
	      isEnabled() {
	        return this._enabled;
	      }
	      isActive() {
	        return this._active;
	      }
	      getClickTolerance() {
	        return this._clickTolerance;
	      }
	    }
	    const co = 0, ho = 2, uo = { [co]: 1, [ho]: 2 };
	    class _o {
	      constructor(e2) {
	        this._correctEvent = e2.checkCorrectEvent;
	      }
	      startMove(e2) {
	        const t2 = h.mouseButton(e2);
	        this._eventButton = t2;
	      }
	      endMove(e2) {
	        delete this._eventButton;
	      }
	      isValidStartEvent(e2) {
	        return this._correctEvent(e2);
	      }
	      isValidMoveEvent(e2) {
	        return !function(e3, t2) {
	          const i2 = uo[t2];
	          return void 0 === e3.buttons || (e3.buttons & i2) !== i2;
	        }(e2, this._eventButton);
	      }
	      isValidEndEvent(e2) {
	        return h.mouseButton(e2) === this._eventButton;
	      }
	    }
	    class po {
	      constructor() {
	        this._firstTouch = void 0;
	      }
	      _isOneFingerTouch(e2) {
	        return 1 === e2.targetTouches.length;
	      }
	      _isSameTouchEvent(e2) {
	        return e2.targetTouches[0].identifier === this._firstTouch;
	      }
	      startMove(e2) {
	        this._firstTouch = e2.targetTouches[0].identifier;
	      }
	      endMove(e2) {
	        delete this._firstTouch;
	      }
	      isValidStartEvent(e2) {
	        return this._isOneFingerTouch(e2);
	      }
	      isValidMoveEvent(e2) {
	        return this._isOneFingerTouch(e2) && this._isSameTouchEvent(e2);
	      }
	      isValidEndEvent(e2) {
	        return this._isOneFingerTouch(e2) && this._isSameTouchEvent(e2);
	      }
	    }
	    class mo {
	      constructor(e2 = new _o({ checkCorrectEvent: () => true }), t2 = new po()) {
	        this.mouseMoveStateManager = e2, this.oneFingerTouchMoveStateManager = t2;
	      }
	      _executeRelevantHandler(e2, t2, i2) {
	        return e2 instanceof MouseEvent ? t2(e2) : "undefined" != typeof TouchEvent && e2 instanceof TouchEvent ? i2(e2) : void 0;
	      }
	      startMove(e2) {
	        this._executeRelevantHandler(e2, (e3) => this.mouseMoveStateManager.startMove(e3), (e3) => this.oneFingerTouchMoveStateManager.startMove(e3));
	      }
	      endMove(e2) {
	        this._executeRelevantHandler(e2, (e3) => this.mouseMoveStateManager.endMove(e3), (e3) => this.oneFingerTouchMoveStateManager.endMove(e3));
	      }
	      isValidStartEvent(e2) {
	        return this._executeRelevantHandler(e2, (e3) => this.mouseMoveStateManager.isValidStartEvent(e3), (e3) => this.oneFingerTouchMoveStateManager.isValidStartEvent(e3));
	      }
	      isValidMoveEvent(e2) {
	        return this._executeRelevantHandler(e2, (e3) => this.mouseMoveStateManager.isValidMoveEvent(e3), (e3) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(e3));
	      }
	      isValidEndEvent(e2) {
	        return this._executeRelevantHandler(e2, (e3) => this.mouseMoveStateManager.isValidEndEvent(e3), (e3) => this.oneFingerTouchMoveStateManager.isValidEndEvent(e3));
	      }
	    }
	    const fo = (e2) => {
	      e2.mousedown = e2.dragStart, e2.mousemoveWindow = e2.dragMove, e2.mouseup = e2.dragEnd, e2.contextmenu = (e3) => {
	        e3.preventDefault();
	      };
	    };
	    class go {
	      constructor(e2, t2) {
	        this._clickTolerance = e2.clickTolerance || 1, this._map = t2, this.reset();
	      }
	      reset() {
	        this._active = false, this._touches = {}, this._sum = new t.P(0, 0);
	      }
	      _shouldBePrevented(e2) {
	        return e2 < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
	      }
	      touchstart(e2, t2, i2) {
	        return this._calculateTransform(e2, t2, i2);
	      }
	      touchmove(e2, t2, i2) {
	        if (this._active) {
	          if (!this._shouldBePrevented(i2.length)) return e2.preventDefault(), this._calculateTransform(e2, t2, i2);
	          this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e2);
	        }
	      }
	      touchend(e2, t2, i2) {
	        this._calculateTransform(e2, t2, i2), this._active && this._shouldBePrevented(i2.length) && this.reset();
	      }
	      touchcancel() {
	        this.reset();
	      }
	      _calculateTransform(e2, i2, a2) {
	        a2.length > 0 && (this._active = true);
	        const r2 = ro(a2, i2), o2 = new t.P(0, 0), s2 = new t.P(0, 0);
	        let n2 = 0;
	        for (const e3 in r2) {
	          const t2 = r2[e3], i3 = this._touches[e3];
	          i3 && (o2._add(t2), s2._add(t2.sub(i3)), n2++, r2[e3] = t2);
	        }
	        if (this._touches = r2, this._shouldBePrevented(n2) || !s2.mag()) return;
	        const l2 = s2.div(n2);
	        return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: o2.div(n2), panDelta: l2 };
	      }
	      enable() {
	        this._enabled = true;
	      }
	      disable() {
	        this._enabled = false, this.reset();
	      }
	      isEnabled() {
	        return this._enabled;
	      }
	      isActive() {
	        return this._active;
	      }
	    }
	    class vo {
	      constructor() {
	        this.reset();
	      }
	      reset() {
	        this._active = false, delete this._firstTwoTouches;
	      }
	      touchstart(e2, t2, i2) {
	        this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([t2[0], t2[1]]));
	      }
	      touchmove(e2, t2, i2) {
	        if (!this._firstTwoTouches) return;
	        e2.preventDefault();
	        const [a2, r2] = this._firstTwoTouches, o2 = xo(i2, t2, a2), s2 = xo(i2, t2, r2);
	        if (!o2 || !s2) return;
	        const n2 = this._aroundCenter ? null : o2.add(s2).div(2);
	        return this._move([o2, s2], n2, e2);
	      }
	      touchend(e2, t2, i2) {
	        if (!this._firstTwoTouches) return;
	        const [a2, r2] = this._firstTwoTouches, o2 = xo(i2, t2, a2), s2 = xo(i2, t2, r2);
	        o2 && s2 || (this._active && h.suppressClick(), this.reset());
	      }
	      touchcancel() {
	        this.reset();
	      }
	      enable(e2) {
	        this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around;
	      }
	      disable() {
	        this._enabled = false, this.reset();
	      }
	      isEnabled() {
	        return !!this._enabled;
	      }
	      isActive() {
	        return !!this._active;
	      }
	    }
	    function xo(e2, t2, i2) {
	      for (let a2 = 0; a2 < e2.length; a2++) if (e2[a2].identifier === i2) return t2[a2];
	    }
	    function bo(e2, t2) {
	      return Math.log(e2 / t2) / Math.LN2;
	    }
	    class yo extends vo {
	      reset() {
	        super.reset(), delete this._distance, delete this._startDistance;
	      }
	      _start(e2) {
	        this._startDistance = this._distance = e2[0].dist(e2[1]);
	      }
	      _move(e2, t2) {
	        const i2 = this._distance;
	        if (this._distance = e2[0].dist(e2[1]), this._active || !(Math.abs(bo(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: bo(this._distance, i2), pinchAround: t2 };
	      }
	    }
	    function wo(e2, t2) {
	      return 180 * e2.angleWith(t2) / Math.PI;
	    }
	    class To extends vo {
	      reset() {
	        super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
	      }
	      _start(e2) {
	        this._startVector = this._vector = e2[0].sub(e2[1]), this._minDiameter = e2[0].dist(e2[1]);
	      }
	      _move(e2, t2, i2) {
	        const a2 = this._vector;
	        if (this._vector = e2[0].sub(e2[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = true, { bearingDelta: wo(this._vector, a2), pinchAround: t2 };
	      }
	      _isBelowThreshold(e2) {
	        this._minDiameter = Math.min(this._minDiameter, e2.mag());
	        const t2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = wo(e2, this._startVector);
	        return Math.abs(i2) < t2;
	      }
	    }
	    function Po(e2) {
	      return Math.abs(e2.y) > Math.abs(e2.x);
	    }
	    class Co extends vo {
	      constructor(e2) {
	        super(), this._currentTouchCount = 0, this._map = e2;
	      }
	      reset() {
	        super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
	      }
	      touchstart(e2, t2, i2) {
	        super.touchstart(e2, t2, i2), this._currentTouchCount = i2.length;
	      }
	      _start(e2) {
	        this._lastPoints = e2, Po(e2[0].sub(e2[1])) && (this._valid = false);
	      }
	      _move(e2, t2, i2) {
	        if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
	        const a2 = e2[0].sub(this._lastPoints[0]), r2 = e2[1].sub(this._lastPoints[1]);
	        return this._valid = this.gestureBeginsVertically(a2, r2, i2.timeStamp), this._valid ? (this._lastPoints = e2, this._active = true, { pitchDelta: (a2.y + r2.y) / 2 * -0.5 }) : void 0;
	      }
	      gestureBeginsVertically(e2, t2, i2) {
	        if (void 0 !== this._valid) return this._valid;
	        const a2 = e2.mag() >= 2, r2 = t2.mag() >= 2;
	        if (!a2 && !r2) return;
	        if (!a2 || !r2) return void 0 === this._firstMove && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
	        const o2 = e2.y > 0 == t2.y > 0;
	        return Po(e2) && Po(t2) && o2;
	      }
	    }
	    const Mo = { panStep: 100, bearingStep: 15, pitchStep: 10 };
	    class Io {
	      constructor(e2) {
	        this._tr = new io(e2);
	        const t2 = Mo;
	        this._panStep = t2.panStep, this._bearingStep = t2.bearingStep, this._pitchStep = t2.pitchStep, this._rotationDisabled = false;
	      }
	      reset() {
	        this._active = false;
	      }
	      keydown(e2) {
	        if (e2.altKey || e2.ctrlKey || e2.metaKey) return;
	        let t2 = 0, i2 = 0, a2 = 0, r2 = 0, o2 = 0;
	        switch (e2.keyCode) {
	          case 61:
	          case 107:
	          case 171:
	          case 187:
	            t2 = 1;
	            break;
	          case 189:
	          case 109:
	          case 173:
	            t2 = -1;
	            break;
	          case 37:
	            e2.shiftKey ? i2 = -1 : (e2.preventDefault(), r2 = -1);
	            break;
	          case 39:
	            e2.shiftKey ? i2 = 1 : (e2.preventDefault(), r2 = 1);
	            break;
	          case 38:
	            e2.shiftKey ? a2 = 1 : (e2.preventDefault(), o2 = -1);
	            break;
	          case 40:
	            e2.shiftKey ? a2 = -1 : (e2.preventDefault(), o2 = 1);
	            break;
	          default:
	            return;
	        }
	        return this._rotationDisabled && (i2 = 0, a2 = 0), { cameraAnimation: (s2) => {
	          const n2 = this._tr;
	          s2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Eo, zoom: t2 ? Math.round(n2.zoom) + t2 * (e2.shiftKey ? 2 : 1) : n2.zoom, bearing: n2.bearing + i2 * this._bearingStep, pitch: n2.pitch + a2 * this._pitchStep, offset: [-r2 * this._panStep, -o2 * this._panStep], center: n2.center }, { originalEvent: e2 });
	        } };
	      }
	      enable() {
	        this._enabled = true;
	      }
	      disable() {
	        this._enabled = false, this.reset();
	      }
	      isEnabled() {
	        return this._enabled;
	      }
	      isActive() {
	        return this._active;
	      }
	      disableRotation() {
	        this._rotationDisabled = true;
	      }
	      enableRotation() {
	        this._rotationDisabled = false;
	      }
	    }
	    function Eo(e2) {
	      return e2 * (2 - e2);
	    }
	    const So = 4.000244140625, Ro = 1 / 450;
	    class Do {
	      constructor(e2, t2) {
	        this._onTimeout = (e3) => {
	          this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e3);
	        }, this._map = e2, this._tr = new io(e2), this._triggerRenderFrame = t2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = Ro;
	      }
	      setZoomRate(e2) {
	        this._defaultZoomRate = e2;
	      }
	      setWheelZoomRate(e2) {
	        this._wheelZoomRate = e2;
	      }
	      isEnabled() {
	        return !!this._enabled;
	      }
	      isActive() {
	        return !!this._active || void 0 !== this._finishTimeout;
	      }
	      isZooming() {
	        return !!this._zooming;
	      }
	      enable(e2) {
	        this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around);
	      }
	      disable() {
	        this.isEnabled() && (this._enabled = false);
	      }
	      _shouldBePrevented(e2) {
	        return !!this._map.cooperativeGestures.isEnabled() && !(e2.ctrlKey || this._map.cooperativeGestures.isBypassed(e2));
	      }
	      wheel(e2) {
	        if (!this.isEnabled()) return;
	        if (this._shouldBePrevented(e2)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e2);
	        let t2 = e2.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e2.deltaY : e2.deltaY;
	        const i2 = c(), a2 = i2 - (this._lastWheelEventTime || 0);
	        this._lastWheelEventTime = i2, 0 !== t2 && t2 % So == 0 ? this._type = "wheel" : 0 !== t2 && Math.abs(t2) < 4 ? this._type = "trackpad" : a2 > 400 ? (this._type = null, this._lastValue = t2, this._timeout = setTimeout(this._onTimeout, 40, e2)) : this._type || (this._type = Math.abs(a2 * t2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, t2 += this._lastValue)), e2.shiftKey && t2 && (t2 /= 4), this._type && (this._lastWheelEvent = e2, this._delta -= t2, this._active || this._start(e2)), e2.preventDefault();
	      }
	      _start(e2) {
	        if (!this._delta) return;
	        this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
	        const i2 = h.mousePos(this._map.getCanvas(), e2), a2 = this._tr;
	        this._aroundPoint = this._aroundCenter ? a2.transform.locationToScreenPoint(t.V.convert(a2.center)) : i2, this._frameId || (this._frameId = true, this._triggerRenderFrame());
	      }
	      renderFrame() {
	        if (!this._frameId) return;
	        if (this._frameId = null, !this.isActive()) return;
	        const e2 = this._tr.transform;
	        if ("number" == typeof this._lastExpectedZoom) {
	          const t2 = e2.zoom - this._lastExpectedZoom;
	          "number" == typeof this._startZoom && (this._startZoom += t2), "number" == typeof this._targetZoom && (this._targetZoom += t2);
	        }
	        if (0 !== this._delta) {
	          const i3 = "wheel" === this._type && Math.abs(this._delta) > So ? this._wheelZoomRate : this._defaultZoomRate;
	          let a3 = 2 / (1 + Math.exp(-Math.abs(this._delta * i3)));
	          this._delta < 0 && 0 !== a3 && (a3 = 1 / a3);
	          const r3 = "number" != typeof this._targetZoom ? e2.scale : t.aq(this._targetZoom);
	          this._targetZoom = e2.applyConstrain(e2.getCameraLngLat(), t.at(r3 * a3)).zoom, "wheel" === this._type && (this._startZoom = e2.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
	        }
	        const i2 = "number" != typeof this._targetZoom ? e2.zoom : this._targetZoom, a2 = this._startZoom, r2 = this._easing;
	        let o2, s2 = false;
	        if ("wheel" === this._type && a2 && r2) {
	          const e3 = c() - this._lastWheelEventTime, n2 = Math.min((e3 + 5) / 200, 1), l2 = r2(n2);
	          o2 = t.G.number(a2, i2, l2), n2 < 1 ? this._frameId || (this._frameId = true) : s2 = true;
	        } else o2 = i2, s2 = true;
	        return this._active = true, s2 && (this._active = false, this._finishTimeout = setTimeout(() => {
	          this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
	        }, 200)), this._lastExpectedZoom = o2, { noInertia: true, needsRenderFrame: !s2, zoomDelta: o2 - e2.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
	      }
	      _smoothOutEasing(e2) {
	        let i2 = t.cx;
	        if (this._prevEase) {
	          const e3 = this._prevEase, a2 = (c() - e3.start) / e3.duration, r2 = e3.easing(a2 + 0.01) - e3.easing(a2), o2 = 0.27 / Math.sqrt(r2 * r2 + 1e-4) * 0.01, s2 = Math.sqrt(0.0729 - o2 * o2);
	          i2 = t.cv(o2, s2, 0.25, 1);
	        }
	        return this._prevEase = { start: c(), duration: e2, easing: i2 }, i2;
	      }
	      reset() {
	        this._active = false, this._zooming = false, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
	      }
	    }
	    class zo {
	      constructor(e2, t2) {
	        this._clickZoom = e2, this._tapZoom = t2;
	      }
	      enable() {
	        this._clickZoom.enable(), this._tapZoom.enable();
	      }
	      disable() {
	        this._clickZoom.disable(), this._tapZoom.disable();
	      }
	      isEnabled() {
	        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
	      }
	      isActive() {
	        return this._clickZoom.isActive() || this._tapZoom.isActive();
	      }
	    }
	    class Ao {
	      constructor(e2) {
	        this._tr = new io(e2), this.reset();
	      }
	      reset() {
	        this._active = false;
	      }
	      dblclick(e2, t2) {
	        return e2.preventDefault(), { cameraAnimation: (i2) => {
	          i2.easeTo({ duration: 300, zoom: this._tr.zoom + (e2.shiftKey ? -1 : 1), around: this._tr.unproject(t2) }, { originalEvent: e2 });
	        } };
	      }
	      enable() {
	        this._enabled = true;
	      }
	      disable() {
	        this._enabled = false, this.reset();
	      }
	      isEnabled() {
	        return this._enabled;
	      }
	      isActive() {
	        return this._active;
	      }
	    }
	    class Lo {
	      constructor() {
	        this._tap = new so({ numTouches: 1, numTaps: 1 }), this.reset();
	      }
	      reset() {
	        this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
	      }
	      touchstart(e2, t2, i2) {
	        if (!this._swipePoint) if (this._tapTime) {
	          const a2 = t2[0], r2 = e2.timeStamp - this._tapTime < 500, o2 = this._tapPoint.dist(a2) < 30;
	          r2 && o2 ? i2.length > 0 && (this._swipePoint = a2, this._swipeTouch = i2[0].identifier) : this.reset();
	        } else this._tap.touchstart(e2, t2, i2);
	      }
	      touchmove(e2, t2, i2) {
	        if (this._tapTime) {
	          if (this._swipePoint) {
	            if (i2[0].identifier !== this._swipeTouch) return;
	            const a2 = t2[0], r2 = a2.y - this._swipePoint.y;
	            return this._swipePoint = a2, e2.preventDefault(), this._active = true, { zoomDelta: r2 / 128 };
	          }
	        } else this._tap.touchmove(e2, t2, i2);
	      }
	      touchend(e2, t2, i2) {
	        if (this._tapTime) this._swipePoint && 0 === i2.length && this.reset();
	        else {
	          const a2 = this._tap.touchend(e2, t2, i2);
	          a2 && (this._tapTime = e2.timeStamp, this._tapPoint = a2);
	        }
	      }
	      touchcancel() {
	        this.reset();
	      }
	      enable() {
	        this._enabled = true;
	      }
	      disable() {
	        this._enabled = false, this.reset();
	      }
	      isEnabled() {
	        return this._enabled;
	      }
	      isActive() {
	        return this._active;
	      }
	    }
	    class ko {
	      constructor(e2, t2, i2) {
	        this._el = e2, this._mousePan = t2, this._touchPan = i2;
	      }
	      enable(e2) {
	        this._inertiaOptions = e2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
	      }
	      disable() {
	        this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
	      }
	      isEnabled() {
	        return this._mousePan.isEnabled() && this._touchPan.isEnabled();
	      }
	      isActive() {
	        return this._mousePan.isActive() || this._touchPan.isActive();
	      }
	    }
	    class Fo {
	      constructor(e2, t2, i2, a2) {
	        this._pitchWithRotate = e2.pitchWithRotate, this._rollEnabled = e2.rollEnabled, this._mouseRotate = t2, this._mousePitch = i2, this._mouseRoll = a2;
	      }
	      enable() {
	        this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
	      }
	      disable() {
	        this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
	      }
	      isEnabled() {
	        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
	      }
	      isActive() {
	        return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
	      }
	    }
	    class Bo {
	      constructor(e2, t2, i2, a2) {
	        this._el = e2, this._touchZoom = t2, this._touchRotate = i2, this._tapDragZoom = a2, this._rotationDisabled = false, this._enabled = true;
	      }
	      enable(e2) {
	        this._touchZoom.enable(e2), this._rotationDisabled || this._touchRotate.enable(e2), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
	      }
	      disable() {
	        this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
	      }
	      isEnabled() {
	        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
	      }
	      isActive() {
	        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
	      }
	      disableRotation() {
	        this._rotationDisabled = true, this._touchRotate.disable();
	      }
	      enableRotation() {
	        this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
	      }
	    }
	    class Oo {
	      constructor(e2, t2) {
	        this._bypassKey = -1 !== navigator.userAgent.indexOf("Mac") ? "metaKey" : "ctrlKey", this._map = e2, this._options = t2, this._enabled = false;
	      }
	      isActive() {
	        return false;
	      }
	      reset() {
	      }
	      _setupUI() {
	        if (this._container) return;
	        const e2 = this._map.getCanvasContainer();
	        e2.classList.add("maplibregl-cooperative-gestures"), this._container = h.create("div", "maplibregl-cooperative-gesture-screen", e2);
	        let t2 = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
	        "metaKey" === this._bypassKey && (t2 = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
	        const i2 = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), a2 = document.createElement("div");
	        a2.className = "maplibregl-desktop-message", a2.textContent = t2, this._container.appendChild(a2);
	        const r2 = document.createElement("div");
	        r2.className = "maplibregl-mobile-message", r2.textContent = i2, this._container.appendChild(r2), this._container.setAttribute("aria-hidden", "true");
	      }
	      _destroyUI() {
	        this._container && (h.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
	      }
	      enable() {
	        this._setupUI(), this._enabled = true;
	      }
	      disable() {
	        this._enabled = false, this._destroyUI();
	      }
	      isEnabled() {
	        return this._enabled;
	      }
	      isBypassed(e2) {
	        return e2[this._bypassKey];
	      }
	      notifyGestureBlocked(e2, i2) {
	        this._enabled && (this._map.fire(new t.l("cooperativegestureprevented", { gestureType: e2, originalEvent: i2 })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
	          this._container.classList.remove("maplibregl-show");
	        }, 100));
	      }
	    }
	    const jo = (e2) => e2.zoom || e2.drag || e2.roll || e2.pitch || e2.rotate;
	    class No extends t.l {
	    }
	    function Zo(e2) {
	      return e2.panDelta && e2.panDelta.mag() || e2.zoomDelta || e2.bearingDelta || e2.pitchDelta || e2.rollDelta;
	    }
	    class Go {
	      constructor(e2, i2) {
	        this.handleWindowEvent = (e3) => {
	          this.handleEvent(e3, `${e3.type}Window`);
	        }, this.handleEvent = (e3, i3) => {
	          if ("blur" === e3.type) return void this.stop(true);
	          this._updatingCamera = true;
	          const a3 = "renderFrame" === e3.type ? void 0 : e3, r2 = { needsRenderFrame: false }, o2 = {}, s2 = {};
	          for (const { handlerName: n3, handler: l3, allowed: c2 } of this._handlers) {
	            if (!l3.isEnabled()) continue;
	            let u2;
	            if (this._blockedByActive(s2, c2, n3)) l3.reset();
	            else if (l3[i3 || e3.type]) {
	              if (t.cy(e3, i3 || e3.type)) {
	                const t2 = h.mousePos(this._map.getCanvas(), e3);
	                u2 = l3[i3 || e3.type](e3, t2);
	              } else if (t.cz(e3, i3 || e3.type)) {
	                const t2 = this._getMapTouches(e3.touches), a4 = h.touchPos(this._map.getCanvas(), t2);
	                u2 = l3[i3 || e3.type](e3, a4, t2);
	              } else t.cA(i3 || e3.type) || (u2 = l3[i3 || e3.type](e3));
	              this.mergeHandlerResult(r2, o2, u2, n3, a3), u2 && u2.needsRenderFrame && this._triggerRenderFrame();
	            }
	            (u2 || l3.isActive()) && (s2[n3] = l3);
	          }
	          const n2 = {};
	          for (const e4 in this._previousActiveHandlers) s2[e4] || (n2[e4] = a3);
	          this._previousActiveHandlers = s2, (Object.keys(n2).length || Zo(r2)) && (this._changes.push([r2, o2, n2]), this._triggerRenderFrame()), (Object.keys(s2).length || Zo(r2)) && this._map._stop(true), this._updatingCamera = false;
	          const { cameraAnimation: l2 } = r2;
	          l2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], l2(this._map));
	        }, this._map = e2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Hr(e2), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i2);
	        const a2 = this._el;
	        this._listeners = [[a2, "touchstart", { passive: true }], [a2, "touchmove", { passive: false }], [a2, "touchend", void 0], [a2, "touchcancel", void 0], [a2, "mousedown", void 0], [a2, "mousemove", void 0], [a2, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [a2, "mouseover", void 0], [a2, "mouseout", void 0], [a2, "dblclick", void 0], [a2, "click", void 0], [a2, "keydown", { capture: false }], [a2, "keyup", void 0], [a2, "wheel", { passive: false }], [a2, "contextmenu", void 0], [window, "blur", void 0]];
	        for (const [e3, t2, i3] of this._listeners) h.addEventListener(e3, t2, e3 === document ? this.handleWindowEvent : this.handleEvent, i3);
	      }
	      destroy() {
	        for (const [e2, t2, i2] of this._listeners) h.removeEventListener(e2, t2, e2 === document ? this.handleWindowEvent : this.handleEvent, i2);
	      }
	      _addDefaultHandlers(e2) {
	        const i2 = this._map, a2 = i2.getCanvasContainer();
	        this._add("mapEvent", new eo(i2, e2));
	        const r2 = i2.boxZoom = new ao(i2, e2);
	        this._add("boxZoom", r2), e2.interactive && e2.boxZoom && r2.enable();
	        const o2 = i2.cooperativeGestures = new Oo(i2, e2.cooperativeGestures);
	        this._add("cooperativeGestures", o2), e2.cooperativeGestures && o2.enable();
	        const s2 = new no(i2), n2 = new Ao(i2);
	        i2.doubleClickZoom = new zo(n2, s2), this._add("tapZoom", s2), this._add("clickZoom", n2), e2.interactive && e2.doubleClickZoom && i2.doubleClickZoom.enable();
	        const l2 = new Lo();
	        this._add("tapDragZoom", l2);
	        const c2 = i2.touchPitch = new Co(i2);
	        this._add("touchPitch", c2), e2.interactive && e2.touchPitch && i2.touchPitch.enable(e2.touchPitch);
	        const u2 = () => i2.project(i2.getCenter()), d2 = function({ enable: e3, clickTolerance: i3, aroundCenter: a3 = true, minPixelCenterThreshold: r3 = 100, rotateDegreesPerPixelMoved: o3 = 0.8 }, s3) {
	          const n3 = new _o({ checkCorrectEvent: (e4) => 0 === h.mouseButton(e4) && e4.ctrlKey || 2 === h.mouseButton(e4) && !e4.ctrlKey });
	          return new lo({ clickTolerance: i3, move: (e4, i4) => {
	            const n4 = s3();
	            if (a3 && Math.abs(n4.y - e4.y) > r3) return { bearingDelta: t.cw(new t.P(e4.x, i4.y), i4, n4) };
	            let l3 = (i4.x - e4.x) * o3;
	            return a3 && i4.y < n4.y && (l3 = -l3), { bearingDelta: l3 };
	          }, moveStateManager: n3, enable: e3, assignEvents: fo });
	        }(e2, u2), _2 = function({ enable: e3, clickTolerance: t2, pitchDegreesPerPixelMoved: i3 = -0.5 }) {
	          const a3 = new _o({ checkCorrectEvent: (e4) => 0 === h.mouseButton(e4) && e4.ctrlKey || 2 === h.mouseButton(e4) });
	          return new lo({ clickTolerance: t2, move: (e4, t3) => ({ pitchDelta: (t3.y - e4.y) * i3 }), moveStateManager: a3, enable: e3, assignEvents: fo });
	        }(e2), p2 = function({ enable: e3, clickTolerance: t2, rollDegreesPerPixelMoved: i3 = 0.3 }, a3) {
	          const r3 = new _o({ checkCorrectEvent: (e4) => 2 === h.mouseButton(e4) && e4.ctrlKey });
	          return new lo({ clickTolerance: t2, move: (e4, t3) => {
	            const r4 = a3();
	            let o3 = (t3.x - e4.x) * i3;
	            return t3.y < r4.y && (o3 = -o3), { rollDelta: o3 };
	          }, moveStateManager: r3, enable: e3, assignEvents: fo });
	        }(e2, u2);
	        i2.dragRotate = new Fo(e2, d2, _2, p2), this._add("mouseRotate", d2, ["mousePitch"]), this._add("mousePitch", _2, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", p2, ["mousePitch"]), e2.interactive && e2.dragRotate && i2.dragRotate.enable();
	        const m2 = function({ enable: e3, clickTolerance: t2 }) {
	          const i3 = new _o({ checkCorrectEvent: (e4) => 0 === h.mouseButton(e4) && !e4.ctrlKey });
	          return new lo({ clickTolerance: t2, move: (e4, t3) => ({ around: t3, panDelta: t3.sub(e4) }), activateOnStart: true, moveStateManager: i3, enable: e3, assignEvents: fo });
	        }(e2), f2 = new go(e2, i2);
	        i2.dragPan = new ko(a2, m2, f2), this._add("mousePan", m2), this._add("touchPan", f2, ["touchZoom", "touchRotate"]), e2.interactive && e2.dragPan && i2.dragPan.enable(e2.dragPan);
	        const g2 = new To(), v2 = new yo();
	        i2.touchZoomRotate = new Bo(a2, v2, g2, l2), this._add("touchRotate", g2, ["touchPan", "touchZoom"]), this._add("touchZoom", v2, ["touchPan", "touchRotate"]), e2.interactive && e2.touchZoomRotate && i2.touchZoomRotate.enable(e2.touchZoomRotate), this._add("blockableMapEvent", new to(i2));
	        const x2 = i2.scrollZoom = new Do(i2, () => this._triggerRenderFrame());
	        this._add("scrollZoom", x2, ["mousePan"]), e2.interactive && e2.scrollZoom && i2.scrollZoom.enable(e2.scrollZoom);
	        const b2 = i2.keyboard = new Io(i2);
	        this._add("keyboard", b2), e2.interactive && e2.keyboard && i2.keyboard.enable();
	      }
	      _add(e2, t2, i2) {
	        this._handlers.push({ handlerName: e2, handler: t2, allowed: i2 }), this._handlersById[e2] = t2;
	      }
	      stop(e2) {
	        if (!this._updatingCamera) {
	          for (const { handler: e3 } of this._handlers) e3.reset();
	          this._inertia.clear(), this._fireEvents({}, {}, e2), this._changes = [];
	        }
	      }
	      isActive() {
	        for (const { handler: e2 } of this._handlers) if (e2.isActive()) return true;
	        return false;
	      }
	      isZooming() {
	        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
	      }
	      isRotating() {
	        return !!this._eventsInProgress.rotate;
	      }
	      isMoving() {
	        return Boolean(jo(this._eventsInProgress)) || this.isZooming();
	      }
	      _blockedByActive(e2, t2, i2) {
	        for (const a2 in e2) if (a2 !== i2 && (!t2 || t2.indexOf(a2) < 0)) return true;
	        return false;
	      }
	      _getMapTouches(e2) {
	        const t2 = [];
	        for (const i2 of e2) this._el.contains(i2.target) && t2.push(i2);
	        return t2;
	      }
	      mergeHandlerResult(e2, i2, a2, r2, o2) {
	        if (!a2) return;
	        t.e(e2, a2);
	        const s2 = { handlerName: r2, originalEvent: a2.originalEvent || o2 };
	        void 0 !== a2.zoomDelta && (i2.zoom = s2), void 0 !== a2.panDelta && (i2.drag = s2), void 0 !== a2.rollDelta && (i2.roll = s2), void 0 !== a2.pitchDelta && (i2.pitch = s2), void 0 !== a2.bearingDelta && (i2.rotate = s2);
	      }
	      _applyChanges() {
	        const e2 = {}, i2 = {}, a2 = {};
	        for (const [r2, o2, s2] of this._changes) r2.panDelta && (e2.panDelta = (e2.panDelta || new t.P(0, 0))._add(r2.panDelta)), r2.zoomDelta && (e2.zoomDelta = (e2.zoomDelta || 0) + r2.zoomDelta), r2.bearingDelta && (e2.bearingDelta = (e2.bearingDelta || 0) + r2.bearingDelta), r2.pitchDelta && (e2.pitchDelta = (e2.pitchDelta || 0) + r2.pitchDelta), r2.rollDelta && (e2.rollDelta = (e2.rollDelta || 0) + r2.rollDelta), void 0 !== r2.around && (e2.around = r2.around), void 0 !== r2.pinchAround && (e2.pinchAround = r2.pinchAround), r2.noInertia && (e2.noInertia = r2.noInertia), t.e(i2, o2), t.e(a2, s2);
	        this._updateMapTransform(e2, i2, a2), this._changes = [];
	      }
	      _updateMapTransform(e2, t2, i2) {
	        const a2 = this._map, r2 = a2._getTransformForUpdate(), o2 = a2.terrain;
	        if (!(Zo(e2) || o2 && this._terrainMovement)) return this._fireEvents(t2, i2, true);
	        a2._stop(true);
	        let { panDelta: s2, zoomDelta: n2, bearingDelta: l2, pitchDelta: c2, rollDelta: h2, around: u2, pinchAround: d2 } = e2;
	        void 0 !== d2 && (u2 = d2), u2 = u2 || a2.transform.centerPoint, o2 && !r2.isPointOnMapSurface(u2) && (u2 = r2.centerPoint);
	        const _2 = { panDelta: s2, zoomDelta: n2, rollDelta: h2, pitchDelta: c2, bearingDelta: l2, around: u2 };
	        this._map.cameraHelper.useGlobeControls && !r2.isPointOnMapSurface(u2) && (u2 = r2.centerPoint);
	        const p2 = u2.distSqr(r2.centerPoint) < 0.01 ? r2.center : r2.screenPointToLocation(s2 ? u2.sub(s2) : u2);
	        this._handleMapControls({ terrain: o2, tr: r2, deltasForHelper: _2, preZoomAroundLoc: p2, combinedEventsInProgress: t2, panDelta: s2 }), a2._applyUpdatedTransform(r2), this._map._update(), e2.noInertia || this._inertia.record(e2), this._fireEvents(t2, i2, true);
	      }
	      _handleMapControls({ terrain: e2, tr: t2, deltasForHelper: i2, preZoomAroundLoc: a2, combinedEventsInProgress: r2, panDelta: o2 }) {
	        const s2 = this._map.cameraHelper;
	        if (s2.handleMapControlsRollPitchBearingZoom(i2, t2), e2) return s2.useGlobeControls ? (this._terrainMovement || !r2.drag && !r2.zoom || (this._terrainMovement = true, this._map._elevationFreeze = true), void s2.handleMapControlsPan(i2, t2, a2)) : this._terrainMovement || !r2.drag && !r2.zoom ? void (r2.drag && this._terrainMovement && o2 ? t2.setCenter(t2.screenPointToLocation(t2.centerPoint.sub(o2))) : s2.handleMapControlsPan(i2, t2, a2)) : (this._terrainMovement = true, this._map._elevationFreeze = true, void s2.handleMapControlsPan(i2, t2, a2));
	        s2.handleMapControlsPan(i2, t2, a2);
	      }
	      _fireEvents(e2, i2, a2) {
	        const r2 = jo(this._eventsInProgress), o2 = jo(e2), s2 = {};
	        for (const t2 in e2) {
	          const { originalEvent: i3 } = e2[t2];
	          this._eventsInProgress[t2] || (s2[`${t2}start`] = i3), this._eventsInProgress[t2] = e2[t2];
	        }
	        !r2 && o2 && this._fireEvent("movestart", o2.originalEvent);
	        for (const e3 in s2) this._fireEvent(e3, s2[e3]);
	        o2 && this._fireEvent("move", o2.originalEvent);
	        for (const t2 in e2) {
	          const { originalEvent: i3 } = e2[t2];
	          this._fireEvent(t2, i3);
	        }
	        const l2 = {};
	        let c2;
	        for (const e3 in this._eventsInProgress) {
	          const { handlerName: t2, originalEvent: a3 } = this._eventsInProgress[e3];
	          this._handlersById[t2].isActive() || (delete this._eventsInProgress[e3], c2 = i2[t2] || a3, l2[`${e3}end`] = c2);
	        }
	        for (const e3 in l2) this._fireEvent(e3, l2[e3]);
	        const h2 = jo(this._eventsInProgress), u2 = (r2 || o2) && !h2;
	        if (u2 && this._terrainMovement) {
	          this._map._elevationFreeze = false, this._terrainMovement = false;
	          const e3 = this._map._getTransformForUpdate();
	          this._map.getCenterClampedToGround() && e3.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(e3);
	        }
	        if (a2 && u2) {
	          this._updatingCamera = true;
	          const e3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (e4) => 0 !== e4 && -this._bearingSnap < e4 && e4 < this._bearingSnap;
	          !e3 || !e3.essential && n.prefersReducedMotion ? (this._map.fire(new t.l("moveend", { originalEvent: c2 })), i3(this._map.getBearing()) && this._map.resetNorth()) : (i3(e3.bearing || this._map.getBearing()) && (e3.bearing = 0), e3.freezeElevation = true, this._map.easeTo(e3, { originalEvent: c2 })), this._updatingCamera = false;
	        }
	      }
	      _fireEvent(e2, i2) {
	        this._map.fire(new t.l(e2, i2 ? { originalEvent: i2 } : {}));
	      }
	      _requestFrame() {
	        return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e2) => {
	          delete this._frameId, this.handleEvent(new No("renderFrame", { timeStamp: e2 })), this._applyChanges();
	        });
	      }
	      _triggerRenderFrame() {
	        void 0 === this._frameId && (this._frameId = this._requestFrame());
	      }
	    }
	    class Uo extends t.E {
	      constructor(e2, t2, i2) {
	        super(), this._renderFrameCallback = () => {
	          const e3 = Math.min((c() - this._easeStart) / this._easeOptions.duration, 1);
	          this._onEaseFrame(this._easeOptions.easing(e3)), e3 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
	        }, this._moving = false, this._zooming = false, this.transform = e2, this._bearingSnap = i2.bearingSnap, this.cameraHelper = t2, this.on("moveend", () => {
	          delete this._requestedCameraState;
	        });
	      }
	      migrateProjection(e2, t2) {
	        e2.apply(this.transform), this.transform = e2, this.cameraHelper = t2;
	      }
	      getCenter() {
	        return new t.V(this.transform.center.lng, this.transform.center.lat);
	      }
	      setCenter(e2, t2) {
	        return this.jumpTo({ center: e2 }, t2);
	      }
	      getCenterElevation() {
	        return this.transform.elevation;
	      }
	      setCenterElevation(e2, t2) {
	        return this.jumpTo({ elevation: e2 }, t2), this;
	      }
	      getCenterClampedToGround() {
	        return this._centerClampedToGround;
	      }
	      setCenterClampedToGround(e2) {
	        this._centerClampedToGround = e2;
	      }
	      panBy(e2, i2, a2) {
	        return e2 = t.P.convert(e2).mult(-1), this.panTo(this.transform.center, t.e({ offset: e2 }, i2), a2);
	      }
	      panTo(e2, i2, a2) {
	        return this.easeTo(t.e({ center: e2 }, i2), a2);
	      }
	      getZoom() {
	        return this.transform.zoom;
	      }
	      setZoom(e2, t2) {
	        return this.jumpTo({ zoom: e2 }, t2), this;
	      }
	      zoomTo(e2, i2, a2) {
	        return this.easeTo(t.e({ zoom: e2 }, i2), a2);
	      }
	      zoomIn(e2, t2) {
	        return this.zoomTo(this.getZoom() + 1, e2, t2), this;
	      }
	      zoomOut(e2, t2) {
	        return this.zoomTo(this.getZoom() - 1, e2, t2), this;
	      }
	      getVerticalFieldOfView() {
	        return this.transform.fov;
	      }
	      setVerticalFieldOfView(e2, i2) {
	        return e2 != this.transform.fov && (this.transform.setFov(e2), this.fire(new t.l("movestart", i2)).fire(new t.l("move", i2)).fire(new t.l("moveend", i2))), this;
	      }
	      getBearing() {
	        return this.transform.bearing;
	      }
	      setBearing(e2, t2) {
	        return this.jumpTo({ bearing: e2 }, t2), this;
	      }
	      getPadding() {
	        return this.transform.padding;
	      }
	      setPadding(e2, t2) {
	        return this.jumpTo({ padding: e2 }, t2), this;
	      }
	      rotateTo(e2, i2, a2) {
	        return this.easeTo(t.e({ bearing: e2 }, i2), a2);
	      }
	      resetNorth(e2, i2) {
	        return this.rotateTo(0, t.e({ duration: 1e3 }, e2), i2), this;
	      }
	      resetNorthPitch(e2, i2) {
	        return this.easeTo(t.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e2), i2), this;
	      }
	      snapToNorth(e2, t2) {
	        return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e2, t2) : this;
	      }
	      getPitch() {
	        return this.transform.pitch;
	      }
	      setPitch(e2, t2) {
	        return this.jumpTo({ pitch: e2 }, t2), this;
	      }
	      getRoll() {
	        return this.transform.roll;
	      }
	      setRoll(e2, t2) {
	        return this.jumpTo({ roll: e2 }, t2), this;
	      }
	      cameraForBounds(e2, t2) {
	        e2 = $.convert(e2).adjustAntiMeridian();
	        const i2 = t2 && t2.bearing || 0;
	        return this._cameraForBoxAndBearing(e2.getNorthWest(), e2.getSouthEast(), i2, t2);
	      }
	      _cameraForBoxAndBearing(e2, i2, a2, r2) {
	        const o2 = { top: 0, bottom: 0, right: 0, left: 0 };
	        if ("number" == typeof (r2 = t.e({ padding: o2, offset: [0, 0], maxZoom: this.transform.maxZoom }, r2)).padding) {
	          const e3 = r2.padding;
	          r2.padding = { top: e3, bottom: e3, right: e3, left: e3 };
	        }
	        const s2 = t.e(o2, r2.padding);
	        r2.padding = s2;
	        const n2 = this.transform, l2 = new $(e2, i2);
	        return this.cameraHelper.cameraForBoxAndBearing(r2, s2, l2, a2, n2);
	      }
	      fitBounds(e2, t2, i2) {
	        return this._fitInternal(this.cameraForBounds(e2, t2), t2, i2);
	      }
	      fitScreenCoordinates(e2, i2, a2, r2, o2) {
	        return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(t.P.convert(e2)), this.transform.screenPointToLocation(t.P.convert(i2)), a2, r2), r2, o2);
	      }
	      _fitInternal(e2, i2, a2) {
	        return e2 ? (delete (i2 = t.e(e2, i2)).padding, i2.linear ? this.easeTo(i2, a2) : this.flyTo(i2, a2)) : this;
	      }
	      jumpTo(e2, i2) {
	        this.stop();
	        const a2 = this._getTransformForUpdate();
	        let r2 = false, o2 = false, s2 = false;
	        const n2 = a2.zoom;
	        this.cameraHelper.handleJumpToCenterZoom(a2, e2);
	        const l2 = a2.zoom !== n2;
	        return "elevation" in e2 && a2.elevation !== +e2.elevation && a2.setElevation(+e2.elevation), "bearing" in e2 && a2.bearing !== +e2.bearing && (r2 = true, a2.setBearing(+e2.bearing)), "pitch" in e2 && a2.pitch !== +e2.pitch && (o2 = true, a2.setPitch(+e2.pitch)), "roll" in e2 && a2.roll !== +e2.roll && (s2 = true, a2.setRoll(+e2.roll)), null == e2.padding || a2.isPaddingEqual(e2.padding) || a2.setPadding(e2.padding), this._applyUpdatedTransform(a2), this.fire(new t.l("movestart", i2)).fire(new t.l("move", i2)), l2 && this.fire(new t.l("zoomstart", i2)).fire(new t.l("zoom", i2)).fire(new t.l("zoomend", i2)), r2 && this.fire(new t.l("rotatestart", i2)).fire(new t.l("rotate", i2)).fire(new t.l("rotateend", i2)), o2 && this.fire(new t.l("pitchstart", i2)).fire(new t.l("pitch", i2)).fire(new t.l("pitchend", i2)), s2 && this.fire(new t.l("rollstart", i2)).fire(new t.l("roll", i2)).fire(new t.l("rollend", i2)), this.fire(new t.l("moveend", i2));
	      }
	      calculateCameraOptionsFromTo(e2, i2, a2, r2 = 0) {
	        const o2 = t.aa.fromLngLat(e2, i2), s2 = t.aa.fromLngLat(a2, r2), n2 = s2.x - o2.x, l2 = s2.y - o2.y, c2 = s2.z - o2.z, h2 = Math.hypot(n2, l2, c2);
	        if (0 === h2) throw new Error("Can't calculate camera options with same From and To");
	        const u2 = Math.hypot(n2, l2), d2 = t.at(this.transform.cameraToCenterDistance / h2 / this.transform.tileSize), _2 = 180 * Math.atan2(n2, -l2) / Math.PI;
	        let p2 = 180 * Math.acos(u2 / h2) / Math.PI;
	        return p2 = c2 < 0 ? 90 - p2 : 90 + p2, { center: s2.toLngLat(), elevation: r2, zoom: d2, pitch: p2, bearing: _2 };
	      }
	      calculateCameraOptionsFromCameraLngLatAltRotation(e2, t2, i2, a2, r2) {
	        const o2 = this.transform.calculateCenterFromCameraLngLatAlt(e2, t2, i2, a2);
	        return { center: o2.center, elevation: o2.elevation, zoom: o2.zoom, bearing: i2, pitch: a2, roll: r2 };
	      }
	      easeTo(e2, i2) {
	        this._stop(false, e2.easeId), (false === (e2 = t.e({ offset: [0, 0], duration: 500, easing: t.cx }, e2)).animate || !e2.essential && n.prefersReducedMotion) && (e2.duration = 0);
	        const a2 = this._getTransformForUpdate(), r2 = this.getBearing(), o2 = a2.pitch, s2 = a2.roll, l2 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, r2) : r2, c2 = "pitch" in e2 ? +e2.pitch : o2, h2 = "roll" in e2 ? this._normalizeBearing(e2.roll, s2) : s2, u2 = "padding" in e2 ? e2.padding : a2.padding, d2 = t.P.convert(e2.offset);
	        let _2, p2;
	        e2.around && (_2 = t.V.convert(e2.around), p2 = a2.locationToScreenPoint(_2));
	        const m2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, f2 = this.cameraHelper.handleEaseTo(a2, { bearing: l2, pitch: c2, roll: h2, padding: u2, around: _2, aroundPoint: p2, offsetAsPoint: d2, offset: e2.offset, zoom: e2.zoom, center: e2.center });
	        return this._rotating = this._rotating || r2 !== l2, this._pitching = this._pitching || c2 !== o2, this._rolling = this._rolling || h2 !== s2, this._padding = !a2.isPaddingEqual(u2), this._zooming = this._zooming || f2.isZooming, this._easeId = e2.easeId, this._prepareEase(i2, e2.noMoveStart, m2), this.terrain && this._prepareElevation(f2.elevationCenter), this._ease((t2) => {
	          f2.easeFunc(t2), this.terrain && !e2.freezeElevation && this._updateElevation(t2), this._applyUpdatedTransform(a2), this._fireMoveEvents(i2);
	        }, (t2) => {
	          this.terrain && e2.freezeElevation && this._finalizeElevation(), this._afterEase(i2, t2);
	        }, e2), this;
	      }
	      _prepareEase(e2, i2, a2 = {}) {
	        this._moving = true, i2 || a2.moving || this.fire(new t.l("movestart", e2)), this._zooming && !a2.zooming && this.fire(new t.l("zoomstart", e2)), this._rotating && !a2.rotating && this.fire(new t.l("rotatestart", e2)), this._pitching && !a2.pitching && this.fire(new t.l("pitchstart", e2)), this._rolling && !a2.rolling && this.fire(new t.l("rollstart", e2));
	      }
	      _prepareElevation(e2) {
	        this._elevationCenter = e2, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e2, this.transform.tileZoom), this._elevationFreeze = true;
	      }
	      _updateElevation(e2) {
	        void 0 !== this._elevationStart && void 0 !== this._elevationCenter || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
	        const i2 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
	        if (e2 < 1 && i2 !== this._elevationTarget) {
	          const t2 = this._elevationTarget - this._elevationStart;
	          this._elevationStart += e2 * (t2 - (i2 - (t2 * e2 + this._elevationStart)) / (1 - e2)), this._elevationTarget = i2;
	        }
	        this.transform.setElevation(t.G.number(this._elevationStart, this._elevationTarget, e2));
	      }
	      _finalizeElevation() {
	        this._elevationFreeze = false, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
	      }
	      _getTransformForUpdate() {
	        return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
	      }
	      _elevateCameraIfInsideTerrain(e2) {
	        if (!this.terrain && e2.elevation >= 0 && e2.pitch <= 90) return {};
	        const t2 = e2.getCameraLngLat(), i2 = e2.getCameraAltitude(), a2 = this.terrain ? this.terrain.getElevationForLngLatZoom(t2, e2.zoom) : 0;
	        if (i2 < a2) {
	          const i3 = this.calculateCameraOptionsFromTo(t2, a2, e2.center, e2.elevation);
	          return { pitch: i3.pitch, zoom: i3.zoom };
	        }
	        return {};
	      }
	      _applyUpdatedTransform(e2) {
	        const t2 = [];
	        if (t2.push((e3) => this._elevateCameraIfInsideTerrain(e3)), this.transformCameraUpdate && t2.push((e3) => this.transformCameraUpdate(e3)), !t2.length) return;
	        const i2 = e2.clone();
	        for (const e3 of t2) {
	          const t3 = i2.clone(), { center: a2, zoom: r2, roll: o2, pitch: s2, bearing: n2, elevation: l2 } = e3(t3);
	          a2 && t3.setCenter(a2), void 0 !== l2 && t3.setElevation(l2), void 0 !== r2 && t3.setZoom(r2), void 0 !== o2 && t3.setRoll(o2), void 0 !== s2 && t3.setPitch(s2), void 0 !== n2 && t3.setBearing(n2), i2.apply(t3);
	        }
	        this.transform.apply(i2);
	      }
	      _fireMoveEvents(e2) {
	        this.fire(new t.l("move", e2)), this._zooming && this.fire(new t.l("zoom", e2)), this._rotating && this.fire(new t.l("rotate", e2)), this._pitching && this.fire(new t.l("pitch", e2)), this._rolling && this.fire(new t.l("roll", e2));
	      }
	      _afterEase(e2, i2) {
	        if (this._easeId && i2 && this._easeId === i2) return;
	        delete this._easeId;
	        const a2 = this._zooming, r2 = this._rotating, o2 = this._pitching, s2 = this._rolling;
	        this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._rolling = false, this._padding = false, a2 && this.fire(new t.l("zoomend", e2)), r2 && this.fire(new t.l("rotateend", e2)), o2 && this.fire(new t.l("pitchend", e2)), s2 && this.fire(new t.l("rollend", e2)), this.fire(new t.l("moveend", e2));
	      }
	      flyTo(e2, i2) {
	        if (!e2.essential && n.prefersReducedMotion) {
	          const a3 = t.U(e2, ["center", "zoom", "bearing", "pitch", "roll", "elevation", "padding"]);
	          return this.jumpTo(a3, i2);
	        }
	        this.stop(), e2 = t.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t.cx }, e2);
	        const a2 = this._getTransformForUpdate(), r2 = a2.bearing, o2 = a2.pitch, s2 = a2.roll, l2 = a2.padding, c2 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, r2) : r2, h2 = "pitch" in e2 ? +e2.pitch : o2, u2 = "roll" in e2 ? this._normalizeBearing(e2.roll, s2) : s2, d2 = "padding" in e2 ? e2.padding : a2.padding, _2 = t.P.convert(e2.offset);
	        let p2 = a2.centerPoint.add(_2);
	        const m2 = a2.screenPointToLocation(p2), f2 = this.cameraHelper.handleFlyTo(a2, { bearing: c2, pitch: h2, roll: u2, padding: d2, locationAtOffset: m2, offsetAsPoint: _2, center: e2.center, minZoom: e2.minZoom, zoom: e2.zoom });
	        let g2 = e2.curve;
	        const v2 = Math.max(a2.width, a2.height), x2 = v2 / f2.scaleOfZoom, b2 = f2.pixelPathLength;
	        "number" == typeof f2.scaleOfMinZoom && (g2 = Math.sqrt(v2 / f2.scaleOfMinZoom / b2 * 2));
	        const y2 = g2 * g2;
	        function w2(e3) {
	          const t2 = (x2 * x2 - v2 * v2 + (e3 ? -1 : 1) * y2 * y2 * b2 * b2) / (2 * (e3 ? x2 : v2) * y2 * b2);
	          return Math.log(Math.sqrt(t2 * t2 + 1) - t2);
	        }
	        function T2(e3) {
	          return (Math.exp(e3) - Math.exp(-e3)) / 2;
	        }
	        function P2(e3) {
	          return (Math.exp(e3) + Math.exp(-e3)) / 2;
	        }
	        const C2 = w2(false);
	        let M2 = function(e3) {
	          return P2(C2) / P2(C2 + g2 * e3);
	        }, I2 = function(e3) {
	          return v2 * ((P2(C2) * (T2(t2 = C2 + g2 * e3) / P2(t2)) - T2(C2)) / y2) / b2;
	          var t2;
	        }, E2 = (w2(true) - C2) / g2;
	        if (Math.abs(b2) < 2e-6 || !isFinite(E2)) {
	          if (Math.abs(v2 - x2) < 1e-6) return this.easeTo(e2, i2);
	          const t2 = x2 < v2 ? -1 : 1;
	          E2 = Math.abs(Math.log(x2 / v2)) / g2, I2 = () => 0, M2 = (e3) => Math.exp(t2 * g2 * e3);
	        }
	        return e2.duration = "duration" in e2 ? +e2.duration : 1e3 * E2 / ("screenSpeed" in e2 ? +e2.screenSpeed / g2 : +e2.speed), e2.maxDuration && e2.duration > e2.maxDuration && (e2.duration = 0), this._zooming = true, this._rotating = r2 !== c2, this._pitching = h2 !== o2, this._rolling = u2 !== s2, this._padding = !a2.isPaddingEqual(d2), this._prepareEase(i2, false), this.terrain && this._prepareElevation(f2.targetCenter), this._ease((n2) => {
	          const m3 = n2 * E2, g3 = 1 / M2(m3), v3 = I2(m3);
	          this._rotating && a2.setBearing(t.G.number(r2, c2, n2)), this._pitching && a2.setPitch(t.G.number(o2, h2, n2)), this._rolling && a2.setRoll(t.G.number(s2, u2, n2)), this._padding && (a2.interpolatePadding(l2, d2, n2), p2 = a2.centerPoint.add(_2)), f2.easeFunc(n2, g3, v3, p2), this.terrain && !e2.freezeElevation && this._updateElevation(n2), this._applyUpdatedTransform(a2), this._fireMoveEvents(i2);
	        }, () => {
	          this.terrain && e2.freezeElevation && this._finalizeElevation(), this._afterEase(i2);
	        }, e2), this;
	      }
	      isEasing() {
	        return !!this._easeFrameId;
	      }
	      stop() {
	        return this._stop();
	      }
	      _stop(e2, t2) {
	        var i2;
	        if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
	          const e3 = this._onEaseEnd;
	          delete this._onEaseEnd, e3.call(this, t2);
	        }
	        return e2 || null === (i2 = this.handlers) || void 0 === i2 || i2.stop(false), this;
	      }
	      _ease(e2, t2, i2) {
	        false === i2.animate || 0 === i2.duration ? (e2(1), t2()) : (this._easeStart = c(), this._easeOptions = i2, this._onEaseFrame = e2, this._onEaseEnd = t2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
	      }
	      _normalizeBearing(e2, i2) {
	        e2 = t.W(e2, -180, 180);
	        const a2 = Math.abs(e2 - i2);
	        return Math.abs(e2 - 360 - i2) < a2 && (e2 -= 360), Math.abs(e2 + 360 - i2) < a2 && (e2 += 360), e2;
	      }
	      queryTerrainElevation(e2) {
	        return this.terrain ? this.terrain.getElevationForLngLatZoom(t.V.convert(e2), this.transform.tileZoom) : null;
	      }
	    }
	    const Vo = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
	    class qo {
	      constructor(e2 = Vo) {
	        this._toggleAttribution = () => {
	          this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
	        }, this._updateData = (e3) => {
	          !e3 || "metadata" !== e3.sourceDataType && "visibility" !== e3.sourceDataType && "style" !== e3.dataType && "terrain" !== e3.type || this._updateAttributions();
	        }, this._updateCompact = () => {
	          this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
	        }, this._updateCompactMinimize = () => {
	          this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
	        }, this.options = e2;
	      }
	      getDefaultPosition() {
	        return "bottom-right";
	      }
	      onAdd(e2) {
	        return this._map = e2, this._compact = this.options.compact, this._container = h.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = h.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = h.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
	      }
	      onRemove() {
	        h.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
	      }
	      _setElementTitle(e2, t2) {
	        const i2 = this._map._getUIString(`AttributionControl.${t2}`);
	        e2.title = i2, e2.setAttribute("aria-label", i2);
	      }
	      _updateAttributions() {
	        if (!this._map.style) return;
	        let e2 = [];
	        if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e2 = e2.concat(this.options.customAttribution.map((e3) => "string" != typeof e3 ? "" : e3)) : "string" == typeof this.options.customAttribution && e2.push(this.options.customAttribution)), this._map.style.stylesheet) {
	          const e3 = this._map.style.stylesheet;
	          this.styleOwner = e3.owner, this.styleId = e3.id;
	        }
	        const t2 = this._map.style.tileManagers;
	        for (const i3 in t2) {
	          const a2 = t2[i3];
	          if (a2.used || a2.usedForTerrain) {
	            const t3 = a2.getSource();
	            t3.attribution && e2.indexOf(t3.attribution) < 0 && e2.push(t3.attribution);
	          }
	        }
	        e2 = e2.filter((e3) => String(e3).trim()), e2.sort((e3, t3) => e3.length - t3.length), e2 = e2.filter((t3, i3) => {
	          for (let a2 = i3 + 1; a2 < e2.length; a2++) if (e2[a2].indexOf(t3) >= 0) return false;
	          return true;
	        });
	        const i2 = e2.join(" | ");
	        i2 !== this._attribHTML && (this._attribHTML = i2, e2.length ? (this._innerContainer.innerHTML = h.sanitize(i2), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
	      }
	    }
	    class Wo {
	      constructor(e2 = {}) {
	        this._updateCompact = () => {
	          const e3 = this._container.children;
	          if (e3.length) {
	            const t2 = e3[0];
	            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false !== this._compact && t2.classList.add("maplibregl-compact") : t2.classList.remove("maplibregl-compact");
	          }
	        }, this.options = e2;
	      }
	      getDefaultPosition() {
	        return "bottom-left";
	      }
	      onAdd(e2) {
	        this._map = e2, this._compact = this.options && this.options.compact, this._container = h.create("div", "maplibregl-ctrl");
	        const t2 = h.create("a", "maplibregl-ctrl-logo");
	        return t2.target = "_blank", t2.rel = "noopener nofollow", t2.href = "https://maplibre.org/", t2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t2), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
	      }
	      onRemove() {
	        h.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
	      }
	    }
	    class $o {
	      constructor() {
	        this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
	      }
	      add(e2) {
	        const t2 = ++this._id;
	        return this._queue.push({ callback: e2, id: t2, cancelled: false }), t2;
	      }
	      remove(e2) {
	        const t2 = this._currentlyRunning, i2 = t2 ? this._queue.concat(t2) : this._queue;
	        for (const t3 of i2) if (t3.id === e2) return void (t3.cancelled = true);
	      }
	      run(e2 = 0) {
	        if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
	        const t2 = this._currentlyRunning = this._queue;
	        this._queue = [];
	        for (const i2 of t2) if (!i2.cancelled && (i2.callback(e2), this._cleared)) break;
	        this._cleared = false, this._currentlyRunning = false;
	      }
	      clear() {
	        this._currentlyRunning && (this._cleared = true), this._queue = [];
	      }
	    }
	    var Ho = t.aT([{ name: "a_pos3d", type: "Int16", components: 3 }]);
	    class Xo extends t.E {
	      constructor(e2) {
	        super(), this._lastTilesetChange = c(), this.tileManager = e2, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e2._source.tileSize * 2 ** this.deltaZoom, e2.usedForTerrain = true, e2.tileSize = this.tileSize;
	      }
	      destruct() {
	        this.tileManager.usedForTerrain = false, this.tileManager.tileSize = null;
	      }
	      getSource() {
	        return this.tileManager._source;
	      }
	      update(e2, i2) {
	        this.tileManager.update(e2, i2), this._renderableTilesKeys = [];
	        const a2 = {};
	        for (const r2 of Ce(e2, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: i2, calculateTileZoom: this.tileManager._source.calculateTileZoom })) a2[r2.key] = true, this._renderableTilesKeys.push(r2.key), this._tiles[r2.key] || (r2.terrainRttPosMatrix32f = new Float64Array(16), t.c6(r2.terrainRttPosMatrix32f, 0, t.a4, t.a4, 0, 0, 1), this._tiles[r2.key] = new de(r2, this.tileSize), this._lastTilesetChange = c());
	        for (const e3 in this._tiles) a2[e3] || delete this._tiles[e3];
	      }
	      freeRtt(e2) {
	        for (const t2 in this._tiles) {
	          const i2 = this._tiles[t2];
	          (!e2 || i2.tileID.equals(e2) || i2.tileID.isChildOf(e2) || e2.isChildOf(i2.tileID)) && (i2.rtt = []);
	        }
	      }
	      getRenderableTiles() {
	        return this._renderableTilesKeys.map((e2) => this.getTileByID(e2));
	      }
	      getTileByID(e2) {
	        return this._tiles[e2];
	      }
	      getTerrainCoords(e2, t2) {
	        return t2 ? this._getTerrainCoordsForTileRanges(e2, t2) : this._getTerrainCoordsForRegularTile(e2);
	      }
	      _getTerrainCoordsForRegularTile(e2) {
	        const i2 = {};
	        for (const a2 of this._renderableTilesKeys) {
	          const r2 = this._tiles[a2].tileID, o2 = e2.clone(), s2 = t.bj();
	          if (r2.canonical.equals(e2.canonical)) t.c6(s2, 0, t.a4, t.a4, 0, 0, 1);
	          else if (r2.canonical.isChildOf(e2.canonical)) {
	            const i3 = r2.canonical.z - e2.canonical.z, a3 = r2.canonical.x - (r2.canonical.x >> i3 << i3), o3 = r2.canonical.y - (r2.canonical.y >> i3 << i3), n2 = t.a4 >> i3;
	            t.c6(s2, 0, n2, n2, 0, 0, 1), t.O(s2, s2, [-a3 * n2, -o3 * n2, 0]);
	          } else {
	            if (!e2.canonical.isChildOf(r2.canonical)) continue;
	            {
	              const i3 = e2.canonical.z - r2.canonical.z, a3 = e2.canonical.x - (e2.canonical.x >> i3 << i3), o3 = e2.canonical.y - (e2.canonical.y >> i3 << i3), n2 = t.a4 >> i3;
	              t.c6(s2, 0, t.a4, t.a4, 0, 0, 1), t.O(s2, s2, [a3 * n2, o3 * n2, 0]), t.Q(s2, s2, [1 / 2 ** i3, 1 / 2 ** i3, 0]);
	            }
	          }
	          o2.terrainRttPosMatrix32f = new Float32Array(s2), i2[a2] = o2;
	        }
	        return i2;
	      }
	      _getTerrainCoordsForTileRanges(e2, i2) {
	        const a2 = {};
	        for (const r2 of this._renderableTilesKeys) {
	          const o2 = this._tiles[r2].tileID;
	          if (!this._isWithinTileRanges(o2, i2)) continue;
	          const s2 = e2.clone(), n2 = t.bj();
	          if (o2.canonical.z === e2.canonical.z) {
	            const i3 = e2.canonical.x - o2.canonical.x, a3 = e2.canonical.y - o2.canonical.y;
	            t.c6(n2, 0, t.a4, t.a4, 0, 0, 1), t.O(n2, n2, [i3 * t.a4, a3 * t.a4, 0]);
	          } else if (o2.canonical.z > e2.canonical.z) {
	            const i3 = o2.canonical.z - e2.canonical.z, a3 = o2.canonical.x - (o2.canonical.x >> i3 << i3), r3 = o2.canonical.y - (o2.canonical.y >> i3 << i3), s3 = e2.canonical.x - (o2.canonical.x >> i3), l2 = e2.canonical.y - (o2.canonical.y >> i3), c2 = t.a4 >> i3;
	            t.c6(n2, 0, c2, c2, 0, 0, 1), t.O(n2, n2, [-a3 * c2 + s3 * t.a4, -r3 * c2 + l2 * t.a4, 0]);
	          } else {
	            const i3 = e2.canonical.z - o2.canonical.z, a3 = e2.canonical.x - (e2.canonical.x >> i3 << i3), r3 = e2.canonical.y - (e2.canonical.y >> i3 << i3), s3 = (e2.canonical.x >> i3) - o2.canonical.x, l2 = (e2.canonical.y >> i3) - o2.canonical.y, c2 = t.a4 << i3;
	            t.c6(n2, 0, c2, c2, 0, 0, 1), t.O(n2, n2, [a3 * t.a4 + s3 * c2, r3 * t.a4 + l2 * c2, 0]);
	          }
	          s2.terrainRttPosMatrix32f = new Float32Array(n2), a2[r2] = s2;
	        }
	        return a2;
	      }
	      getSourceTile(e2, t2) {
	        const i2 = this.tileManager._source;
	        let a2 = e2.overscaledZ - this.deltaZoom;
	        if (a2 > i2.maxzoom && (a2 = i2.maxzoom), a2 < i2.minzoom) return null;
	        this._sourceTileCache[e2.key] || (this._sourceTileCache[e2.key] = e2.scaledTo(a2).key);
	        let r2 = this.tileManager.getTileByID(this._sourceTileCache[e2.key]);
	        if ((!r2 || !r2.dem) && t2) for (; a2 >= i2.minzoom && (!r2 || !r2.dem); ) r2 = this.tileManager.getTileByID(e2.scaledTo(a2--).key);
	        return r2;
	      }
	      anyTilesAfterTime(e2 = Date.now()) {
	        return this._lastTilesetChange >= e2;
	      }
	      _isWithinTileRanges(e2, t2) {
	        return t2[e2.canonical.z] && e2.canonical.x >= t2[e2.canonical.z].minTileX && e2.canonical.x <= t2[e2.canonical.z].maxTileX && e2.canonical.y >= t2[e2.canonical.z].minTileY && e2.canonical.y <= t2[e2.canonical.z].maxTileY;
	      }
	    }
	    class Ko {
	      constructor(e2, t2, i2) {
	        this._meshCache = {}, this.painter = e2, this.tileManager = new Xo(t2), this.options = i2, this.exaggeration = "number" == typeof i2.exaggeration ? i2.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
	      }
	      getDEMElevation(e2, i2, a2, r2 = t.a4) {
	        var o2;
	        if (!(i2 >= 0 && i2 < r2 && a2 >= 0 && a2 < r2)) return 0;
	        const s2 = this.getTerrainData(e2), n2 = null === (o2 = s2.tile) || void 0 === o2 ? void 0 : o2.dem;
	        if (!n2) return 0;
	        const l2 = t.cB([], [i2 / r2 * t.a4, a2 / r2 * t.a4], s2.u_terrain_matrix), c2 = [l2[0] * n2.dim, l2[1] * n2.dim], h2 = Math.floor(c2[0]), u2 = Math.floor(c2[1]), d2 = c2[0] - h2, _2 = c2[1] - u2;
	        return n2.get(h2, u2) * (1 - d2) * (1 - _2) + n2.get(h2 + 1, u2) * d2 * (1 - _2) + n2.get(h2, u2 + 1) * (1 - d2) * _2 + n2.get(h2 + 1, u2 + 1) * d2 * _2;
	      }
	      getElevationForLngLatZoom(e2, i2) {
	        if (!t.cC(i2, e2.wrap())) return 0;
	        const { tileID: a2, mercatorX: r2, mercatorY: o2 } = this._getOverscaledTileIDFromLngLatZoom(e2, i2);
	        return this.getElevation(a2, r2 % t.a4, o2 % t.a4, t.a4);
	      }
	      getElevation(e2, i2, a2, r2 = t.a4) {
	        return this.getDEMElevation(e2, i2, a2, r2) * this.exaggeration;
	      }
	      getTerrainData(e2) {
	        if (!this._emptyDemTexture) {
	          const e3 = this.painter.context, i3 = new t.R({ width: 1, height: 1 }, new Uint8Array(4));
	          this._emptyDepthTexture = new t.T(e3, i3, e3.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new t.T(e3, new t.R({ width: 1, height: 1 }), e3.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(e3.gl.NEAREST, e3.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t.ar([]);
	        }
	        const i2 = this.tileManager.getSourceTile(e2, true);
	        if (i2 && i2.dem && (!i2.demTexture || i2.needsTerrainPrepare)) {
	          const e3 = this.painter.context;
	          i2.demTexture = this.painter.getTileTexture(i2.dem.stride), i2.demTexture ? i2.demTexture.update(i2.dem.getPixels(), { premultiply: false }) : i2.demTexture = new t.T(e3, i2.dem.getPixels(), e3.gl.RGBA, { premultiply: false }), i2.demTexture.bind(e3.gl.NEAREST, e3.gl.CLAMP_TO_EDGE), i2.needsTerrainPrepare = false;
	        }
	        const a2 = i2 && i2 + i2.tileID.key + e2.key;
	        if (a2 && !this._demMatrixCache[a2]) {
	          const a3 = this.tileManager.getSource().maxzoom;
	          let r2 = e2.canonical.z - i2.tileID.canonical.z;
	          e2.overscaledZ > e2.canonical.z && (e2.canonical.z >= a3 ? r2 = e2.canonical.z - a3 : t.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
	          const o2 = e2.canonical.x - (e2.canonical.x >> r2 << r2), s2 = e2.canonical.y - (e2.canonical.y >> r2 << r2), n2 = t.cD(new Float64Array(16), [1 / (t.a4 << r2), 1 / (t.a4 << r2), 0]);
	          t.O(n2, n2, [o2 * t.a4, s2 * t.a4, 0]), this._demMatrixCache[e2.key] = { matrix: n2, coord: e2 };
	        }
	        return { u_depth: 2, u_terrain: 3, u_terrain_dim: i2 && i2.dem && i2.dem.dim || 1, u_terrain_matrix: a2 ? this._demMatrixCache[e2.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i2 && i2.dem && i2.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (i2 && i2.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i2 };
	      }
	      getFramebuffer(e2) {
	        const i2 = this.painter, a2 = i2.width / devicePixelRatio, r2 = i2.height / devicePixelRatio;
	        return !this._fbo || this._fbo.width === a2 && this._fbo.height === r2 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new t.T(i2.context, { width: a2, height: r2, data: null }, i2.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(i2.context.gl.NEAREST, i2.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new t.T(i2.context, { width: a2, height: r2, data: null }, i2.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(i2.context.gl.NEAREST, i2.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = i2.context.createFramebuffer(a2, r2, true, false), this._fbo.depthAttachment.set(i2.context.createRenderbuffer(i2.context.gl.DEPTH_COMPONENT16, a2, r2))), this._fbo.colorAttachment.set("coords" === e2 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
	      }
	      getCoordsTexture() {
	        const e2 = this.painter.context;
	        if (this._coordsTexture) return this._coordsTexture;
	        const i2 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
	        for (let e3 = 0, t2 = 0; e3 < this._coordsTextureSize; e3++) for (let a3 = 0; a3 < this._coordsTextureSize; a3++, t2 += 4) i2[t2 + 0] = 255 & a3, i2[t2 + 1] = 255 & e3, i2[t2 + 2] = a3 >> 8 << 4 | e3 >> 8, i2[t2 + 3] = 0;
	        const a2 = new t.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i2.buffer)), r2 = new t.T(e2, a2, e2.gl.RGBA, { premultiply: false });
	        return r2.bind(e2.gl.NEAREST, e2.gl.CLAMP_TO_EDGE), this._coordsTexture = r2, r2;
	      }
	      pointCoordinate(e2) {
	        this.painter.maybeDrawDepthAndCoords(true);
	        const i2 = new Uint8Array(4), a2 = this.painter.context, r2 = a2.gl, o2 = Math.round(e2.x * this.painter.pixelRatio / devicePixelRatio), s2 = Math.round(e2.y * this.painter.pixelRatio / devicePixelRatio), n2 = Math.round(this.painter.height / devicePixelRatio);
	        a2.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), r2.readPixels(o2, n2 - s2 - 1, 1, 1, r2.RGBA, r2.UNSIGNED_BYTE, i2), a2.bindFramebuffer.set(null);
	        const l2 = i2[0] + (i2[2] >> 4 << 8), c2 = i2[1] + ((15 & i2[2]) << 8), h2 = this.coordsIndex[255 - i2[3]], u2 = h2 && this.tileManager.getTileByID(h2);
	        if (!u2) return null;
	        const d2 = this._coordsTextureSize, _2 = (1 << u2.tileID.canonical.z) * d2;
	        return new t.aa((u2.tileID.canonical.x * d2 + l2) / _2 + u2.tileID.wrap, (u2.tileID.canonical.y * d2 + c2) / _2, this.getElevation(u2.tileID, l2, c2, d2));
	      }
	      depthAtPoint(e2) {
	        const t2 = new Uint8Array(4), i2 = this.painter.context, a2 = i2.gl;
	        return i2.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), a2.readPixels(e2.x, this.painter.height / devicePixelRatio - e2.y - 1, 1, 1, a2.RGBA, a2.UNSIGNED_BYTE, t2), i2.bindFramebuffer.set(null), (t2[0] / 16777216 + t2[1] / 65536 + t2[2] / 256 + t2[3]) / 256;
	      }
	      getTerrainMesh(e2) {
	        var i2;
	        const a2 = (null === (i2 = this.painter.style.projection) || void 0 === i2 ? void 0 : i2.transitionState) > 0, r2 = a2 && 0 === e2.canonical.y, o2 = a2 && e2.canonical.y === (1 << e2.canonical.z) - 1, s2 = `m_${r2 ? "n" : ""}_${o2 ? "s" : ""}`;
	        if (this._meshCache[s2]) return this._meshCache[s2];
	        const n2 = this.painter.context, l2 = new t.cE(), c2 = new t.aX(), h2 = this.meshSize, u2 = t.a4 / h2, d2 = h2 * h2;
	        for (let e3 = 0; e3 <= h2; e3++) for (let t2 = 0; t2 <= h2; t2++) l2.emplaceBack(t2 * u2, e3 * u2, 0);
	        for (let e3 = 0; e3 < d2; e3 += h2 + 1) for (let t2 = 0; t2 < h2; t2++) c2.emplaceBack(t2 + e3, h2 + t2 + e3 + 1, h2 + t2 + e3 + 2), c2.emplaceBack(t2 + e3, h2 + t2 + e3 + 2, t2 + e3 + 1);
	        const _2 = l2.length, p2 = _2 + (h2 + 1), m2 = (h2 + 1) * h2, f2 = r2 ? t.bq : 0, g2 = r2 ? 0 : 1, v2 = o2 ? t.br : t.a4, x2 = o2 ? 0 : 1;
	        for (let e3 = 0; e3 <= h2; e3++) l2.emplaceBack(e3 * u2, f2, g2);
	        for (let e3 = 0; e3 <= h2; e3++) l2.emplaceBack(e3 * u2, v2, x2);
	        for (let e3 = 0; e3 < h2; e3++) c2.emplaceBack(m2 + e3, p2 + e3, p2 + e3 + 1), c2.emplaceBack(m2 + e3, p2 + e3 + 1, m2 + e3 + 1), c2.emplaceBack(0 + e3, _2 + e3 + 1, _2 + e3), c2.emplaceBack(0 + e3, 0 + e3 + 1, _2 + e3 + 1);
	        const b2 = l2.length, y2 = b2 + 2 * (h2 + 1);
	        for (const e3 of [0, 1]) for (let i3 = 0; i3 <= h2; i3++) for (const a3 of [0, 1]) l2.emplaceBack(e3 * t.a4, i3 * u2, a3);
	        for (let e3 = 0; e3 < 2 * h2; e3 += 2) c2.emplaceBack(b2 + e3, b2 + e3 + 1, b2 + e3 + 3), c2.emplaceBack(b2 + e3, b2 + e3 + 3, b2 + e3 + 2), c2.emplaceBack(y2 + e3, y2 + e3 + 3, y2 + e3 + 1), c2.emplaceBack(y2 + e3, y2 + e3 + 2, y2 + e3 + 3);
	        const w2 = new St(n2.createVertexBuffer(l2, Ho.members), n2.createIndexBuffer(c2), t.aW.simpleSegment(0, 0, l2.length, c2.length));
	        return this._meshCache[s2] = w2, w2;
	      }
	      getMeshFrameDelta(e2) {
	        return 2 * Math.PI * t.bD / Math.pow(2, Math.max(e2, 0)) / 5;
	      }
	      getMinTileElevationForLngLatZoom(e2, t2) {
	        var i2;
	        const { tileID: a2 } = this._getOverscaledTileIDFromLngLatZoom(e2, t2);
	        return null !== (i2 = this.getMinMaxElevation(a2).minElevation) && void 0 !== i2 ? i2 : 0;
	      }
	      getMinMaxElevation(e2) {
	        const t2 = this.getTerrainData(e2).tile, i2 = { minElevation: null, maxElevation: null };
	        return t2 && t2.dem && (i2.minElevation = t2.dem.min * this.exaggeration, i2.maxElevation = t2.dem.max * this.exaggeration), i2;
	      }
	      _getOverscaledTileIDFromLngLatZoom(e2, i2) {
	        const a2 = t.aa.fromLngLat(e2.wrap()), r2 = (1 << i2) * t.a4, o2 = a2.x * r2, s2 = a2.y * r2, n2 = Math.floor(o2 / t.a4), l2 = Math.floor(s2 / t.a4);
	        return { tileID: new t.a1(i2, 0, i2, n2, l2), mercatorX: o2, mercatorY: s2 };
	      }
	    }
	    class Yo {
	      constructor(e2, t2, i2) {
	        this._context = e2, this._size = t2, this._tileSize = i2, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
	      }
	      destruct() {
	        for (const e2 of this._objects) e2.texture.destroy(), e2.fbo.destroy();
	      }
	      _createObject(e2) {
	        const i2 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), a2 = new t.T(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
	        return a2.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), i2.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), i2.colorAttachment.set(a2.texture), { id: e2, fbo: i2, texture: a2, stamp: -1, inUse: false };
	      }
	      getObjectForId(e2) {
	        return this._objects[e2];
	      }
	      useObject(e2) {
	        e2.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((t2) => e2.id !== t2), this._recentlyUsed.push(e2.id);
	      }
	      stampObject(e2) {
	        e2.stamp = ++this._stamp;
	      }
	      getOrCreateFreeObject() {
	        for (const e3 of this._recentlyUsed) if (!this._objects[e3].inUse) return this._objects[e3];
	        if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
	        const e2 = this._createObject(this._objects.length);
	        return this._objects.push(e2), e2;
	      }
	      freeObject(e2) {
	        e2.inUse = false;
	      }
	      freeAllObjects() {
	        for (const e2 of this._objects) this.freeObject(e2);
	      }
	      isFull() {
	        return !(this._objects.length < this._size) && false === this._objects.some((e2) => !e2.inUse);
	      }
	    }
	    const Qo = { background: true, fill: true, line: true, raster: true, hillshade: true, "color-relief": true };
	    class Jo {
	      constructor(e2, t2) {
	        this.painter = e2, this.terrain = t2, this.pool = new Yo(e2.context, 30, t2.tileManager.tileSize * t2.qualityFactor);
	      }
	      destruct() {
	        this.pool.destruct();
	      }
	      getTexture(e2) {
	        return this.pool.getObjectForId(e2.rtt[this._stacks.length - 1].id).texture;
	      }
	      prepareForRender(e2, t2) {
	        this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.tileManager.getRenderableTiles(), this._renderableLayerIds = e2._order.filter((i2) => !e2._layers[i2].isHidden(t2)), this._coordsAscending = {};
	        for (const t3 in e2.tileManagers) {
	          this._coordsAscending[t3] = {};
	          const i2 = e2.tileManagers[t3].getVisibleCoordinates(), a2 = e2.tileManagers[t3].getSource(), r2 = a2 instanceof te ? a2.terrainTileRanges : null;
	          for (const e3 of i2) {
	            const i3 = this.terrain.tileManager.getTerrainCoords(e3, r2);
	            for (const e4 in i3) this._coordsAscending[t3][e4] || (this._coordsAscending[t3][e4] = []), this._coordsAscending[t3][e4].push(i3[e4]);
	          }
	        }
	        this._coordsAscendingStr = {};
	        for (const t3 of e2._order) {
	          const i2 = e2._layers[t3], a2 = i2.source;
	          if (Qo[i2.type] && !this._coordsAscendingStr[a2]) {
	            this._coordsAscendingStr[a2] = {};
	            for (const e3 in this._coordsAscending[a2]) this._coordsAscendingStr[a2][e3] = this._coordsAscending[a2][e3].map((e4) => e4.key).sort().join();
	          }
	        }
	        for (const e3 of this._renderableTiles) for (const t3 in this._coordsAscendingStr) {
	          const i2 = this._coordsAscendingStr[t3][e3.tileID.key];
	          i2 && i2 !== e3.rttCoords[t3] && (e3.rtt = []);
	        }
	      }
	      renderLayer(e2, i2) {
	        if (e2.isHidden(this.painter.transform.zoom)) return false;
	        const a2 = Object.assign(Object.assign({}, i2), { isRenderingToTexture: true }), r2 = e2.type, o2 = this.painter, s2 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e2.id;
	        if (Qo[r2] && (this._prevType && Qo[this._prevType] || this._stacks.push([]), this._prevType = r2, this._stacks[this._stacks.length - 1].push(e2.id), !s2)) return true;
	        if (Qo[this._prevType] || Qo[r2] && s2) {
	          this._prevType = r2;
	          const e3 = this._stacks.length - 1, i3 = this._stacks[e3] || [];
	          for (const r3 of this._renderableTiles) {
	            if (this.pool.isFull() && (Br(this.painter, this.terrain, this._rttTiles, a2), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(r3), r3.rtt[e3]) {
	              const t2 = this.pool.getObjectForId(r3.rtt[e3].id);
	              if (t2.stamp === r3.rtt[e3].stamp) {
	                this.pool.useObject(t2);
	                continue;
	              }
	            }
	            const s3 = this.pool.getOrCreateFreeObject();
	            this.pool.useObject(s3), this.pool.stampObject(s3), r3.rtt[e3] = { id: s3.id, stamp: s3.stamp }, o2.context.bindFramebuffer.set(s3.fbo.framebuffer), o2.context.clear({ color: t.bo.transparent, stencil: 0 }), o2.currentStencilSource = void 0;
	            for (let e4 = 0; e4 < i3.length; e4++) {
	              const t2 = o2.style._layers[i3[e4]], n2 = t2.source ? this._coordsAscending[t2.source][r3.tileID.key] : [r3.tileID];
	              o2.context.viewport.set([0, 0, s3.fbo.width, s3.fbo.height]), o2._renderTileClippingMasks(t2, n2, true), o2.renderLayer(o2, o2.style.tileManagers[t2.source], t2, n2, a2), t2.source && (r3.rttCoords[t2.source] = this._coordsAscendingStr[t2.source][r3.tileID.key]);
	            }
	          }
	          return Br(this.painter, this.terrain, this._rttTiles, a2), this._rttTiles = [], this.pool.freeAllObjects(), Qo[r2];
	        }
	        return false;
	      }
	    }
	    const es = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, ts = i, is = { hash: false, interactive: true, bearingSnap: 7, attributionControl: Vo, maplibreLogo: false, refreshExpiredTiles: true, canvasContextAttributes: { antialias: false, preserveDrawingBuffer: false, powerPreference: "high-performance", failIfMajorPerformanceCaveat: false, desynchronized: false, contextType: void 0 }, scrollZoom: true, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, trackResize: true, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: true, maxTileCacheSize: null, maxTileCacheZoomLevels: t.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, transformConstrain: null, fadeDuration: 300, crossSourceCollisions: true, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: true, rollEnabled: false, reduceMotion: void 0, validateStyle: true, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: true, centerClampedToGround: true, experimentalZoomLevelsToOverscale: void 0 }, as = { showCompass: true, showZoom: true, visualizePitch: false, visualizeRoll: true };
	    class rs {
	      constructor(e2, i2, a2 = false) {
	        this.mousedown = (e3) => {
	          this.startMove(e3, h.mousePos(this.element, e3)), h.addEventListener(window, "mousemove", this.mousemove), h.addEventListener(window, "mouseup", this.mouseup);
	        }, this.mousemove = (e3) => {
	          this.move(e3, h.mousePos(this.element, e3));
	        }, this.mouseup = (e3) => {
	          this._rotatePitchHandler.dragEnd(e3), this.offTemp();
	        }, this.touchstart = (e3) => {
	          1 !== e3.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = h.touchPos(this.element, e3.targetTouches)[0], this.startMove(e3, this._startPos), h.addEventListener(window, "touchmove", this.touchmove, { passive: false }), h.addEventListener(window, "touchend", this.touchend));
	        }, this.touchmove = (e3) => {
	          1 !== e3.targetTouches.length ? this.reset() : (this._lastPos = h.touchPos(this.element, e3.targetTouches)[0], this.move(e3, this._lastPos));
	        }, this.touchend = (e3) => {
	          0 === e3.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
	        }, this.reset = () => {
	          this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
	        }, this._clickTolerance = 10, this.element = i2;
	        const r2 = new mo();
	        this._rotatePitchHandler = new lo({ clickTolerance: 3, move: (e3, r3) => {
	          const o2 = i2.getBoundingClientRect(), s2 = new t.P((o2.bottom - o2.top) / 2, (o2.right - o2.left) / 2);
	          return { bearingDelta: t.cw(new t.P(e3.x, r3.y), r3, s2), pitchDelta: a2 ? -0.5 * (r3.y - e3.y) : void 0 };
	        }, moveStateManager: r2, enable: true, assignEvents: () => {
	        } }), this.map = e2, h.addEventListener(i2, "mousedown", this.mousedown), h.addEventListener(i2, "touchstart", this.touchstart, { passive: false }), h.addEventListener(i2, "touchcancel", this.reset);
	      }
	      startMove(e2, t2) {
	        this._rotatePitchHandler.dragStart(e2, t2), h.disableDrag();
	      }
	      move(e2, t2) {
	        const i2 = this.map, { bearingDelta: a2, pitchDelta: r2 } = this._rotatePitchHandler.dragMove(e2, t2) || {};
	        a2 && i2.setBearing(i2.getBearing() + a2), r2 && i2.setPitch(i2.getPitch() + r2);
	      }
	      off() {
	        const e2 = this.element;
	        h.removeEventListener(e2, "mousedown", this.mousedown), h.removeEventListener(e2, "touchstart", this.touchstart, { passive: false }), h.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), h.removeEventListener(window, "touchend", this.touchend), h.removeEventListener(e2, "touchcancel", this.reset), this.offTemp();
	      }
	      offTemp() {
	        h.enableDrag(), h.removeEventListener(window, "mousemove", this.mousemove), h.removeEventListener(window, "mouseup", this.mouseup), h.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), h.removeEventListener(window, "touchend", this.touchend);
	      }
	    }
	    let os;
	    function ss(e2, i2, a2, r2 = false) {
	      if (r2 || !a2.getCoveringTilesDetailsProvider().allowWorldCopies()) return null == e2 ? void 0 : e2.wrap();
	      const o2 = new t.V(e2.lng, e2.lat);
	      if (e2 = new t.V(e2.lng, e2.lat), i2) {
	        const r3 = new t.V(e2.lng - 360, e2.lat), o3 = new t.V(e2.lng + 360, e2.lat), s2 = a2.locationToScreenPoint(e2).distSqr(i2);
	        a2.locationToScreenPoint(r3).distSqr(i2) < s2 ? e2 = r3 : a2.locationToScreenPoint(o3).distSqr(i2) < s2 && (e2 = o3);
	      }
	      for (; Math.abs(e2.lng - a2.center.lng) > 180; ) {
	        const t2 = a2.locationToScreenPoint(e2);
	        if (t2.x >= 0 && t2.y >= 0 && t2.x <= a2.width && t2.y <= a2.height) break;
	        e2.lng > a2.center.lng ? e2.lng -= 360 : e2.lng += 360;
	      }
	      return e2.lng !== o2.lng && a2.isPointOnMapSurface(a2.locationToScreenPoint(e2)) ? e2 : o2;
	    }
	    const ns = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
	    function ls(e2, t2, i2) {
	      const a2 = e2.classList;
	      for (const e3 in ns) a2.remove(`maplibregl-${i2}-anchor-${e3}`);
	      a2.add(`maplibregl-${i2}-anchor-${t2}`);
	    }
	    class cs extends t.E {
	      constructor(e2) {
	        if (super(), this._onKeyPress = (e3) => {
	          const t2 = e3.code, i2 = e3.charCode || e3.keyCode;
	          "Space" !== t2 && "Enter" !== t2 && 32 !== i2 && 13 !== i2 || this.togglePopup();
	        }, this._onMapClick = (e3) => {
	          const t2 = e3.originalEvent.target, i2 = this._element;
	          this._popup && (t2 === i2 || i2.contains(t2)) && this.togglePopup();
	        }, this._update = (e3) => {
	          if (!this._map) return;
	          const t2 = this._map.loaded() && !this._map.isMoving();
	          ("terrain" === (null == e3 ? void 0 : e3.type) || "render" === (null == e3 ? void 0 : e3.type) && !t2) && this._map.once("render", this._update), this._lngLat = ss(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
	          let i2 = "";
	          "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? i2 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (i2 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
	          let a2 = "";
	          "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? a2 = "rotateX(0deg)" : "map" === this._pitchAlignment && (a2 = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || e3 && "moveend" !== e3.type || (this._pos = this._pos.round()), h.setTransform(this._element, `${ns[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${a2} ${i2}`), n.frameAsync(new AbortController()).then(() => {
	            this._updateOpacity(e3 && "moveend" === e3.type);
	          }).catch(() => {
	          });
	        }, this._onMove = (e3) => {
	          if (!this._isDragging) {
	            const t2 = this._clickTolerance || this._map._clickTolerance;
	            this._isDragging = e3.point.dist(this._pointerdownPos) >= t2;
	          }
	          this._isDragging && (this._pos = e3.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.l("dragstart"))), this.fire(new t.l("drag")));
	        }, this._onUp = () => {
	          this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.l("dragend")), this._state = "inactive";
	        }, this._addDragHandler = (e3) => {
	          this._element.contains(e3.originalEvent.target) && (e3.preventDefault(), this._positionDelta = e3.point.sub(this._pos).add(this._offset), this._pointerdownPos = e3.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
	        }, this._anchor = e2 && e2.anchor || "center", this._color = e2 && e2.color || "#3FB1CE", this._scale = e2 && e2.scale || 1, this._draggable = e2 && e2.draggable || false, this._clickTolerance = e2 && e2.clickTolerance || 0, this._subpixelPositioning = e2 && e2.subpixelPositioning || false, this._isDragging = false, this._state = "inactive", this._rotation = e2 && e2.rotation || 0, this._rotationAlignment = e2 && e2.rotationAlignment || "auto", this._pitchAlignment = e2 && e2.pitchAlignment && "auto" !== e2.pitchAlignment ? e2.pitchAlignment : this._rotationAlignment, this.setOpacity(null == e2 ? void 0 : e2.opacity, null == e2 ? void 0 : e2.opacityWhenCovered), e2 && e2.element) this._element = e2.element, this._offset = t.P.convert(e2 && e2.offset || [0, 0]);
	        else {
	          this._defaultMarker = true, this._element = h.create("div");
	          const i2 = h.createNS("http://www.w3.org/2000/svg", "svg"), a2 = 41, r2 = 27;
	          i2.setAttributeNS(null, "display", "block"), i2.setAttributeNS(null, "height", `${a2}px`), i2.setAttributeNS(null, "width", `${r2}px`), i2.setAttributeNS(null, "viewBox", `0 0 ${r2} ${a2}`);
	          const o2 = h.createNS("http://www.w3.org/2000/svg", "g");
	          o2.setAttributeNS(null, "stroke", "none"), o2.setAttributeNS(null, "stroke-width", "1"), o2.setAttributeNS(null, "fill", "none"), o2.setAttributeNS(null, "fill-rule", "evenodd");
	          const s2 = h.createNS("http://www.w3.org/2000/svg", "g");
	          s2.setAttributeNS(null, "fill-rule", "nonzero");
	          const n2 = h.createNS("http://www.w3.org/2000/svg", "g");
	          n2.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), n2.setAttributeNS(null, "fill", "#000000");
	          const l2 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
	          for (const e3 of l2) {
	            const t2 = h.createNS("http://www.w3.org/2000/svg", "ellipse");
	            t2.setAttributeNS(null, "opacity", "0.04"), t2.setAttributeNS(null, "cx", "10.5"), t2.setAttributeNS(null, "cy", "5.80029008"), t2.setAttributeNS(null, "rx", e3.rx), t2.setAttributeNS(null, "ry", e3.ry), n2.appendChild(t2);
	          }
	          const c2 = h.createNS("http://www.w3.org/2000/svg", "g");
	          c2.setAttributeNS(null, "fill", this._color);
	          const u2 = h.createNS("http://www.w3.org/2000/svg", "path");
	          u2.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), c2.appendChild(u2);
	          const d2 = h.createNS("http://www.w3.org/2000/svg", "g");
	          d2.setAttributeNS(null, "opacity", "0.25"), d2.setAttributeNS(null, "fill", "#000000");
	          const _2 = h.createNS("http://www.w3.org/2000/svg", "path");
	          _2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d2.appendChild(_2);
	          const p2 = h.createNS("http://www.w3.org/2000/svg", "g");
	          p2.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p2.setAttributeNS(null, "fill", "#FFFFFF");
	          const m2 = h.createNS("http://www.w3.org/2000/svg", "g");
	          m2.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
	          const f2 = h.createNS("http://www.w3.org/2000/svg", "circle");
	          f2.setAttributeNS(null, "fill", "#000000"), f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "cx", "5.5"), f2.setAttributeNS(null, "cy", "5.5"), f2.setAttributeNS(null, "r", "5.4999962");
	          const g2 = h.createNS("http://www.w3.org/2000/svg", "circle");
	          g2.setAttributeNS(null, "fill", "#FFFFFF"), g2.setAttributeNS(null, "cx", "5.5"), g2.setAttributeNS(null, "cy", "5.5"), g2.setAttributeNS(null, "r", "5.4999962"), m2.appendChild(f2), m2.appendChild(g2), s2.appendChild(n2), s2.appendChild(c2), s2.appendChild(d2), s2.appendChild(p2), s2.appendChild(m2), i2.appendChild(s2), i2.setAttributeNS(null, "height", a2 * this._scale + "px"), i2.setAttributeNS(null, "width", r2 * this._scale + "px"), this._element.appendChild(i2), this._offset = t.P.convert(e2 && e2.offset || [0, -14]);
	        }
	        if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (e3) => {
	          e3.preventDefault();
	        }), this._element.addEventListener("mousedown", (e3) => {
	          e3.preventDefault();
	        }), ls(this._element, this._anchor, "marker"), e2 && e2.className) for (const t2 of e2.className.split(" ")) this._element.classList.add(t2);
	        this._popup = null;
	      }
	      addTo(e2) {
	        return this.remove(), this._map = e2, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e2._getUIString("Marker.Title")), this._element.hasAttribute("role") || this._element.setAttribute("role", "button"), e2.getCanvasContainer().appendChild(this._element), e2.on("move", this._update), e2.on("moveend", this._update), e2.on("terrain", this._update), e2.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
	      }
	      remove() {
	        return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), h.remove(this._element), this._popup && this._popup.remove(), this;
	      }
	      getLngLat() {
	        return this._lngLat;
	      }
	      setLngLat(e2) {
	        return this._lngLat = t.V.convert(e2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
	      }
	      getElement() {
	        return this._element;
	      }
	      setPopup(e2) {
	        if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e2) {
	          if (!("offset" in e2.options)) {
	            const t2 = 38.1, i2 = 13.5, a2 = Math.abs(i2) / Math.SQRT2;
	            e2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t2], "bottom-left": [a2, -1 * (t2 - i2 + a2)], "bottom-right": [-a2, -1 * (t2 - i2 + a2)], left: [i2, -1 * (t2 - i2)], right: [-i2, -1 * (t2 - i2)] } : this._offset;
	          }
	          this._popup = e2, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
	        }
	        return this;
	      }
	      setSubpixelPositioning(e2) {
	        return this._subpixelPositioning = e2, this;
	      }
	      getPopup() {
	        return this._popup;
	      }
	      togglePopup() {
	        const e2 = this._popup;
	        return this._element.style.opacity === this._opacityWhenCovered ? this : e2 ? (e2.isOpen() ? e2.remove() : (e2.setLngLat(this._lngLat), e2.addTo(this._map)), this) : this;
	      }
	      _updateOpacity(e2 = false) {
	        var i2, a2;
	        const r2 = null === (i2 = this._map) || void 0 === i2 ? void 0 : i2.terrain, o2 = this._map.transform.isLocationOccluded(this._lngLat);
	        if (!r2 || o2) {
	          const e3 = o2 ? this._opacityWhenCovered : this._opacity;
	          return void (this._element.style.opacity !== e3 && (this._element.style.opacity = e3));
	        }
	        if (e2) this._opacityTimeout = null;
	        else {
	          if (this._opacityTimeout) return;
	          this._opacityTimeout = setTimeout(() => {
	            this._opacityTimeout = null;
	          }, 100);
	        }
	        const s2 = this._map, n2 = s2.terrain.depthAtPoint(this._pos), l2 = s2.terrain.getElevationForLngLatZoom(this._lngLat, s2.transform.tileZoom);
	        if (s2.transform.lngLatToCameraDepth(this._lngLat, l2) - n2 < 6e-3) return void (this._element.style.opacity = this._opacity);
	        const c2 = -this._offset.y / s2.transform.pixelsPerMeter, h2 = Math.sin(s2.getPitch() * Math.PI / 180) * c2, u2 = s2.terrain.depthAtPoint(new t.P(this._pos.x, this._pos.y - this._offset.y)), d2 = s2.transform.lngLatToCameraDepth(this._lngLat, l2 + h2) - u2 > 6e-3;
	        (null === (a2 = this._popup) || void 0 === a2 ? void 0 : a2.isOpen()) && d2 && this._popup.remove(), this._element.style.opacity = d2 ? this._opacityWhenCovered : this._opacity;
	      }
	      getOffset() {
	        return this._offset;
	      }
	      setOffset(e2) {
	        return this._offset = t.P.convert(e2), this._update(), this;
	      }
	      addClassName(e2) {
	        this._element.classList.add(e2);
	      }
	      removeClassName(e2) {
	        this._element.classList.remove(e2);
	      }
	      toggleClassName(e2) {
	        return this._element.classList.toggle(e2);
	      }
	      setDraggable(e2) {
	        return this._draggable = !!e2, this._map && (e2 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
	      }
	      isDraggable() {
	        return this._draggable;
	      }
	      setRotation(e2) {
	        return this._rotation = e2 || 0, this._update(), this;
	      }
	      getRotation() {
	        return this._rotation;
	      }
	      setRotationAlignment(e2) {
	        return this._rotationAlignment = e2 || "auto", this._update(), this;
	      }
	      getRotationAlignment() {
	        return this._rotationAlignment;
	      }
	      setPitchAlignment(e2) {
	        return this._pitchAlignment = e2 && "auto" !== e2 ? e2 : this._rotationAlignment, this._update(), this;
	      }
	      getPitchAlignment() {
	        return this._pitchAlignment;
	      }
	      setOpacity(e2, t2) {
	        return (void 0 === this._opacity || void 0 === e2 && void 0 === t2) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), void 0 !== e2 && (this._opacity = e2), void 0 !== t2 && (this._opacityWhenCovered = t2), this._map && this._updateOpacity(true), this;
	      }
	    }
	    const hs = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
	    let us = 0, ds = false;
	    const _s = { maxWidth: 100, unit: "metric" };
	    function ps(e2, t2, i2) {
	      const a2 = i2 && i2.maxWidth || 100, r2 = e2._container.clientHeight / 2, o2 = e2._container.clientWidth / 2, s2 = e2.unproject([o2 - a2 / 2, r2]), n2 = e2.unproject([o2 + a2 / 2, r2]), l2 = Math.round(e2.project(n2).x - e2.project(s2).x), c2 = Math.min(a2, l2, e2._container.clientWidth), h2 = s2.distanceTo(n2);
	      if (i2 && "imperial" === i2.unit) {
	        const i3 = 3.2808 * h2;
	        i3 > 5280 ? ms(t2, c2, i3 / 5280, e2._getUIString("ScaleControl.Miles")) : ms(t2, c2, i3, e2._getUIString("ScaleControl.Feet"));
	      } else i2 && "nautical" === i2.unit ? ms(t2, c2, h2 / 1852, e2._getUIString("ScaleControl.NauticalMiles")) : h2 >= 1e3 ? ms(t2, c2, h2 / 1e3, e2._getUIString("ScaleControl.Kilometers")) : ms(t2, c2, h2, e2._getUIString("ScaleControl.Meters"));
	    }
	    function ms(e2, t2, i2, a2) {
	      const r2 = function(e3) {
	        const t3 = Math.pow(10, `${Math.floor(e3)}`.length - 1);
	        let i3 = e3 / t3;
	        return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(e4) {
	          const t4 = Math.pow(10, Math.ceil(-Math.log(e4) / Math.LN10));
	          return Math.round(e4 * t4) / t4;
	        }(i3), t3 * i3;
	      }(i2);
	      e2.style.width = t2 * (r2 / i2) + "px", e2.innerHTML = `${r2}&nbsp;${a2}`;
	    }
	    const fs = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", subpixelPositioning: false, locationOccludedOpacity: void 0 }, gs = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
	    function vs(e2) {
	      if (e2) {
	        if ("number" == typeof e2) {
	          const i2 = Math.round(Math.abs(e2) / Math.SQRT2);
	          return { center: new t.P(0, 0), top: new t.P(0, e2), "top-left": new t.P(i2, i2), "top-right": new t.P(-i2, i2), bottom: new t.P(0, -e2), "bottom-left": new t.P(i2, -i2), "bottom-right": new t.P(-i2, -i2), left: new t.P(e2, 0), right: new t.P(-e2, 0) };
	        }
	        if (e2 instanceof t.P || Array.isArray(e2)) {
	          const i2 = t.P.convert(e2);
	          return { center: i2, top: i2, "top-left": i2, "top-right": i2, bottom: i2, "bottom-left": i2, "bottom-right": i2, left: i2, right: i2 };
	        }
	        return { center: t.P.convert(e2.center || [0, 0]), top: t.P.convert(e2.top || [0, 0]), "top-left": t.P.convert(e2["top-left"] || [0, 0]), "top-right": t.P.convert(e2["top-right"] || [0, 0]), bottom: t.P.convert(e2.bottom || [0, 0]), "bottom-left": t.P.convert(e2["bottom-left"] || [0, 0]), "bottom-right": t.P.convert(e2["bottom-right"] || [0, 0]), left: t.P.convert(e2.left || [0, 0]), right: t.P.convert(e2.right || [0, 0]) };
	      }
	      return vs(new t.P(0, 0));
	    }
	    const xs = i;
	    e.AJAXError = t.cI, e.Event = t.l, e.Evented = t.E, e.LngLat = t.V, e.MercatorCoordinate = t.aa, e.Point = t.P, e.addProtocol = t.cJ, e.config = t.a, e.removeProtocol = t.cK, e.AttributionControl = qo, e.BoxZoomHandler = ao, e.CanvasSource = ae, e.CooperativeGesturesHandler = Oo, e.DoubleClickZoomHandler = zo, e.DragPanHandler = ko, e.DragRotateHandler = Fo, e.EdgeInsets = Lt, e.FullscreenControl = class extends t.E {
	      constructor(e2 = {}) {
	        super(), this._onFullscreenChange = () => {
	          var e3;
	          let t2 = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
	          for (; null === (e3 = null == t2 ? void 0 : t2.shadowRoot) || void 0 === e3 ? void 0 : e3.fullscreenElement; ) t2 = t2.shadowRoot.fullscreenElement;
	          t2 === this._container !== this._fullscreen && this._handleFullscreenChange();
	        }, this._onClickFullscreen = () => {
	          this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
	        }, this._fullscreen = false, e2 && e2.container && (e2.container instanceof HTMLElement ? this._container = e2.container : t.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
	      }
	      onAdd(e2) {
	        return this._map = e2, this._container || (this._container = this._map.getContainer()), this._controlContainer = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
	      }
	      onRemove() {
	        h.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
	      }
	      _setupUI() {
	        const e2 = this._fullscreenButton = h.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
	        h.create("span", "maplibregl-ctrl-icon", e2).setAttribute("aria-hidden", "true"), e2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
	      }
	      _updateTitle() {
	        const e2 = this._getTitle();
	        this._fullscreenButton.setAttribute("aria-label", e2), this._fullscreenButton.title = e2;
	      }
	      _getTitle() {
	        return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
	      }
	      _isFullscreen() {
	        return this._fullscreen;
	      }
	      _handleFullscreenChange() {
	        this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new t.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new t.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
	      }
	      _exitFullscreen() {
	        window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
	      }
	      _requestFullscreen() {
	        this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
	      }
	      _togglePseudoFullScreen() {
	        this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
	      }
	    }, e.GeoJSONSource = ee, e.GeolocateControl = class extends t.E {
	      constructor(e2) {
	        super(), this._onSuccess = (e3) => {
	          if (this._map) {
	            if (this._isOutOfMapMaxBounds(e3)) return this._setErrorState(), this.fire(new t.l("outofmaxbounds", e3)), this._updateMarker(), void this._finish();
	            if (this.options.trackUserLocation) switch (this._lastKnownPosition = e3, this._watchState) {
	              case "WAITING_ACTIVE":
	              case "ACTIVE_LOCK":
	              case "ACTIVE_ERROR":
	                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
	                break;
	              case "BACKGROUND":
	              case "BACKGROUND_ERROR":
	                this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
	                break;
	              default:
	                throw new Error(`Unexpected watchState ${this._watchState}`);
	            }
	            this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e3), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e3), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new t.l("geolocate", e3)), this._finish();
	          }
	        }, this._updateCamera = (e3) => {
	          const i2 = new t.V(e3.coords.longitude, e3.coords.latitude), a2 = e3.coords.accuracy, r2 = this._map.getBearing(), o2 = t.e({ bearing: r2 }, this.options.fitBoundsOptions), s2 = $.fromLngLat(i2, a2);
	          this._map.fitBounds(s2, o2, { geolocateSource: true });
	        }, this._updateMarker = (e3) => {
	          if (e3) {
	            const i2 = new t.V(e3.coords.longitude, e3.coords.latitude);
	            this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = e3.coords.accuracy, this._updateCircleRadiusIfNeeded();
	          } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
	        }, this._onUpdate = () => {
	          this._updateCircleRadiusIfNeeded();
	        }, this._onError = (e3) => {
	          if (this._map) {
	            if (1 === e3.code) {
	              this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
	              const e4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
	              this._geolocateButton.title = e4, this._geolocateButton.setAttribute("aria-label", e4), void 0 !== this._geolocationWatchID && this._clearWatch();
	            } else {
	              if (3 === e3.code && ds) return;
	              this._setErrorState();
	            }
	            "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new t.l("error", e3)), this._finish();
	          }
	        }, this._finish = () => {
	          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
	        }, this._setupUI = () => {
	          this._map && (this._container.addEventListener("contextmenu", (e3) => e3.preventDefault()), this._geolocateButton = h.create("button", "maplibregl-ctrl-geolocate", this._container), h.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = true);
	        }, this._finishSetupUI = (e3) => {
	          if (this._map) {
	            if (false === e3) {
	              t.w("Geolocation support is not available so the GeolocateControl will be disabled.");
	              const e4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
	              this._geolocateButton.disabled = true, this._geolocateButton.title = e4, this._geolocateButton.setAttribute("aria-label", e4);
	            } else {
	              const e4 = this._map._getUIString("GeolocateControl.FindMyLocation");
	              this._geolocateButton.disabled = false, this._geolocateButton.title = e4, this._geolocateButton.setAttribute("aria-label", e4);
	            }
	            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = h.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new cs({ element: this._dotElement }), this._circleElement = h.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new cs({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (e4) => {
	              const i2 = (null == e4 ? void 0 : e4[0]) instanceof ResizeObserverEntry;
	              e4.geolocateSource || "ACTIVE_LOCK" !== this._watchState || i2 || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new t.l("trackuserlocationend")), this.fire(new t.l("userlocationlostfocus")));
	            });
	          }
	        }, this.options = t.e({}, hs, e2);
	      }
	      onAdd(e2) {
	        return this._map = e2, this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
	          return t._(this, arguments, void 0, function* (e3 = false) {
	            if (void 0 !== os && !e3) return os;
	            if (void 0 === window.navigator.permissions) return os = !!window.navigator.geolocation, os;
	            try {
	              const e4 = yield window.navigator.permissions.query({ name: "geolocation" });
	              os = "denied" !== e4.state;
	            } catch (e4) {
	              os = !!window.navigator.geolocation;
	            }
	            return os;
	          });
	        }().then((e3) => this._finishSetupUI(e3)), this._container;
	      }
	      onRemove() {
	        void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), h.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, us = 0, ds = false;
	      }
	      _isOutOfMapMaxBounds(e2) {
	        const t2 = this._map.getMaxBounds(), i2 = e2.coords;
	        return t2 && (i2.longitude < t2.getWest() || i2.longitude > t2.getEast() || i2.latitude < t2.getSouth() || i2.latitude > t2.getNorth());
	      }
	      _setErrorState() {
	        switch (this._watchState) {
	          case "WAITING_ACTIVE":
	            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
	            break;
	          case "ACTIVE_LOCK":
	            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
	            break;
	          case "BACKGROUND":
	            this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
	            break;
	          case "ACTIVE_ERROR":
	          case "BACKGROUND_ERROR":
	          case "OFF":
	          case void 0:
	            break;
	          default:
	            throw new Error(`Unexpected watchState ${this._watchState}`);
	        }
	      }
	      _updateCircleRadiusIfNeeded() {
	        const e2 = this._userLocationDotMarker.getLngLat();
	        if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && e2)) return;
	        const t2 = this._map.project(e2), i2 = this._map.unproject([t2.x + 100, t2.y]), a2 = e2.distanceTo(i2) / 100, r2 = 2 * this._accuracy / a2;
	        this._circleElement.style.width = `${r2.toFixed(2)}px`, this._circleElement.style.height = `${r2.toFixed(2)}px`;
	      }
	      trigger() {
	        if (!this._setup) return t.w("Geolocate control triggered before added to a map"), false;
	        if (this.options.trackUserLocation) {
	          switch (this._watchState) {
	            case "OFF":
	              this._watchState = "WAITING_ACTIVE", this.fire(new t.l("trackuserlocationstart"));
	              break;
	            case "WAITING_ACTIVE":
	            case "ACTIVE_LOCK":
	            case "ACTIVE_ERROR":
	            case "BACKGROUND_ERROR":
	              us--, ds = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new t.l("trackuserlocationend"));
	              break;
	            case "BACKGROUND":
	              this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.l("trackuserlocationstart")), this.fire(new t.l("userlocationfocus"));
	              break;
	            default:
	              throw new Error(`Unexpected watchState ${this._watchState}`);
	          }
	          switch (this._watchState) {
	            case "WAITING_ACTIVE":
	              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
	              break;
	            case "ACTIVE_LOCK":
	              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
	              break;
	            case "OFF":
	              break;
	            default:
	              throw new Error(`Unexpected watchState ${this._watchState}`);
	          }
	          if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
	          else if (void 0 === this._geolocationWatchID) {
	            let e2;
	            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), us++, us > 1 ? (e2 = { maximumAge: 6e5, timeout: 0 }, ds = true) : (e2 = this.options.positionOptions, ds = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e2);
	          }
	        } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
	        return true;
	      }
	      _clearWatch() {
	        window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
	      }
	    }, e.GlobeControl = class {
	      constructor() {
	        this._toggleProjection = () => {
	          var e2;
	          const t2 = null === (e2 = this._map.getProjection()) || void 0 === e2 ? void 0 : e2.type;
	          this._map.setProjection("mercator" !== t2 && t2 ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
	        }, this._updateGlobeIcon = () => {
	          var e2;
	          this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), "globe" === (null === (e2 = this._map.getProjection()) || void 0 === e2 ? void 0 : e2.type) ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
	        };
	      }
	      onAdd(e2) {
	        return this._map = e2, this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = h.create("button", "maplibregl-ctrl-globe", this._container), h.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
	      }
	      onRemove() {
	        h.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
	      }
	    }, e.Hash = Zr, e.ImageSource = te, e.KeyboardHandler = Io, e.LngLatBounds = $, e.LogoControl = Wo, e.Map = class extends Uo {
	      constructor(e2) {
	        var i2, a2;
	        t.cF.mark(t.cG.create);
	        const r2 = Object.assign(Object.assign(Object.assign({}, is), e2), { canvasContextAttributes: Object.assign(Object.assign({}, is.canvasContextAttributes), e2.canvasContextAttributes) });
	        if (null != r2.minZoom && null != r2.maxZoom && r2.minZoom > r2.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
	        if (null != r2.minPitch && null != r2.maxPitch && r2.minPitch > r2.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
	        if (null != r2.minPitch && r2.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
	        if (null != r2.maxPitch && r2.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
	        const o2 = new Zt(), s2 = new qt();
	        if (void 0 !== r2.minZoom && o2.setMinZoom(r2.minZoom), void 0 !== r2.maxZoom && o2.setMaxZoom(r2.maxZoom), void 0 !== r2.minPitch && o2.setMinPitch(r2.minPitch), void 0 !== r2.maxPitch && o2.setMaxPitch(r2.maxPitch), void 0 !== r2.renderWorldCopies && o2.setRenderWorldCopies(r2.renderWorldCopies), null !== r2.transformConstrain && o2.setConstrainOverride(r2.transformConstrain), super(o2, s2, { bearingSnap: r2.bearingSnap }), this._idleTriggered = false, this._crossFadingFactor = 1, this._renderTaskQueue = new $o(), this._controls = [], this._mapId = t.ag(), this._lostContextStyle = { style: null, images: null }, this._contextLost = (e3) => {
	          e3.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.painter.destroy();
	          for (const e4 of Object.values(this.style._layers)) if ("custom" === e4.type && console.warn(`Custom layer with id '${e4.id}' cannot be restored after WebGL context loss. You will need to re-add it manually after context restoration.`), e4._listeners) for (const [t2] of Object.entries(e4._listeners)) console.warn(`Custom layer with id '${e4.id}' had event listeners for event '${t2}' which cannot be restored after WebGL context loss. You will need to re-add them manually after context restoration.`);
	          this._lostContextStyle = this._getStyleAndImages(), this.style.destroy(), this.style = null, this.fire(new t.l("webglcontextlost", { originalEvent: e3 }));
	        }, this._contextRestored = (e3) => {
	          this._lostContextStyle.style && this.setStyle(this._lostContextStyle.style, { diff: false }), this._lostContextStyle.images && (this.style.imageManager.images = this._lostContextStyle.images), this._setupPainter(), this.resize(), this._update(), this.fire(new t.l("webglcontextrestored", { originalEvent: e3 }));
	        }, this._onMapScroll = (e3) => {
	          if (e3.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
	        }, this._onWindowOnline = () => {
	          this._update();
	        }, this._interactive = r2.interactive, this._maxTileCacheSize = r2.maxTileCacheSize, this._maxTileCacheZoomLevels = r2.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, r2.canvasContextAttributes), this._trackResize = true === r2.trackResize, this._bearingSnap = r2.bearingSnap, this._centerClampedToGround = r2.centerClampedToGround, this._refreshExpiredTiles = true === r2.refreshExpiredTiles, this._fadeDuration = r2.fadeDuration, this._crossSourceCollisions = true === r2.crossSourceCollisions, this._collectResourceTiming = true === r2.collectResourceTiming, this._locale = Object.assign(Object.assign({}, es), r2.locale), this._clickTolerance = r2.clickTolerance, this._overridePixelRatio = r2.pixelRatio, this._maxCanvasSize = r2.maxCanvasSize, this._zoomLevelsToOverscale = r2.experimentalZoomLevelsToOverscale, this.transformCameraUpdate = r2.transformCameraUpdate, this.transformConstrain = r2.transformConstrain, this.cancelPendingTileRequestsWhileZooming = true === r2.cancelPendingTileRequestsWhileZooming, void 0 !== r2.reduceMotion && (n.prefersReducedMotion = r2.reduceMotion), this._imageQueueHandle = g.addThrottleControl(() => this.isMoving()), this._requestManager = new v(r2.transformRequest), "string" == typeof r2.container) {
	          if (this._container = document.getElementById(r2.container), !this._container) throw new Error(`Container '${r2.container}' not found.`);
	        } else {
	          if (!(r2.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
	          this._container = r2.container;
	        }
	        if (r2.maxBounds && this.setMaxBounds(r2.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this.on("terrain", () => {
	          this.painter.terrainFacilitator.dirty = true, this._update(true);
	        }), this.once("idle", () => {
	          this._idleTriggered = true;
	        }), "undefined" != typeof window) {
	          addEventListener("online", this._onWindowOnline, false);
	          let e3 = false;
	          const t2 = Nr((e4) => {
	            this._trackResize && !this._removed && (this.resize(e4), this.redraw());
	          }, 50);
	          this._resizeObserver = new ResizeObserver((i3) => {
	            e3 ? t2(i3) : e3 = true;
	          }), this._resizeObserver.observe(this._container);
	        }
	        this.handlers = new Go(this, r2), this._hash = r2.hash && new Zr("string" == typeof r2.hash && r2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: r2.center, elevation: r2.elevation, zoom: r2.zoom, bearing: r2.bearing, pitch: r2.pitch, roll: r2.roll }), r2.bounds && (this.resize(), this.fitBounds(r2.bounds, t.e({}, r2.fitBoundsOptions, { duration: 0 }))));
	        const l2 = "string" == typeof r2.style || !("globe" === (null === (a2 = null === (i2 = r2.style) || void 0 === i2 ? void 0 : i2.projection) || void 0 === a2 ? void 0 : a2.type));
	        this.resize(null, l2), this._localIdeographFontFamily = r2.localIdeographFontFamily, this._validateStyle = r2.validateStyle, r2.style && this.setStyle(r2.style, { localIdeographFontFamily: r2.localIdeographFontFamily }), r2.attributionControl && this.addControl(new qo("boolean" == typeof r2.attributionControl ? void 0 : r2.attributionControl)), r2.maplibreLogo && this.addControl(new Wo(), r2.logoPosition), this.on("style.load", () => {
	          if (l2 || this._resizeTransform(), this.transform.unmodified) {
	            const e3 = t.U(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
	            this.jumpTo(e3);
	          }
	        }), this.on("data", (e3) => {
	          this._update("style" === e3.dataType), this.fire(new t.l(`${e3.dataType}data`, e3));
	        }), this.on("dataloading", (e3) => {
	          this.fire(new t.l(`${e3.dataType}dataloading`, e3));
	        }), this.on("dataabort", (e3) => {
	          this.fire(new t.l("sourcedataabort", e3));
	        });
	      }
	      _getMapId() {
	        return this._mapId;
	      }
	      setGlobalStateProperty(e2, t2) {
	        return this.style.setGlobalStateProperty(e2, t2), this._update(true);
	      }
	      getGlobalState() {
	        return this.style.getGlobalState();
	      }
	      addControl(e2, i2) {
	        if (void 0 === i2 && (i2 = e2.getDefaultPosition ? e2.getDefaultPosition() : "top-right"), !e2 || !e2.onAdd) return this.fire(new t.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
	        const a2 = e2.onAdd(this);
	        this._controls.push(e2);
	        const r2 = this._controlPositions[i2];
	        return -1 !== i2.indexOf("bottom") ? r2.insertBefore(a2, r2.firstChild) : r2.appendChild(a2), this;
	      }
	      removeControl(e2) {
	        if (!e2 || !e2.onRemove) return this.fire(new t.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
	        const i2 = this._controls.indexOf(e2);
	        return i2 > -1 && this._controls.splice(i2, 1), e2.onRemove(this), this;
	      }
	      hasControl(e2) {
	        return this._controls.indexOf(e2) > -1;
	      }
	      coveringTiles(e2) {
	        return Ce(this.transform, e2);
	      }
	      calculateCameraOptionsFromTo(e2, t2, i2, a2) {
	        return null == a2 && this.terrain && (a2 = this.terrain.getElevationForLngLatZoom(i2, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(e2, t2, i2, a2);
	      }
	      resize(e2, i2 = true) {
	        const [a2, r2] = this._containerDimensions(), o2 = this._getClampedPixelRatio(a2, r2);
	        if (this._resizeCanvas(a2, r2, o2), this.painter.resize(a2, r2, o2), this.painter.overLimit()) {
	          const e3 = this.painter.context.gl;
	          this._maxCanvasSize = [e3.drawingBufferWidth, e3.drawingBufferHeight];
	          const t2 = this._getClampedPixelRatio(a2, r2);
	          this._resizeCanvas(a2, r2, t2), this.painter.resize(a2, r2, t2);
	        }
	        this._resizeTransform(i2);
	        const s2 = !this._moving;
	        return s2 && (this.stop(), this.fire(new t.l("movestart", e2)).fire(new t.l("move", e2))), this.fire(new t.l("resize", e2)), s2 && this.fire(new t.l("moveend", e2)), this;
	      }
	      _resizeTransform(e2 = true) {
	        var t2;
	        const [i2, a2] = this._containerDimensions();
	        this.transform.resize(i2, a2, e2), null === (t2 = this._requestedCameraState) || void 0 === t2 || t2.resize(i2, a2, e2);
	      }
	      _getClampedPixelRatio(e2, t2) {
	        const { 0: i2, 1: a2 } = this._maxCanvasSize, r2 = this.getPixelRatio(), o2 = e2 * r2, s2 = t2 * r2;
	        return Math.min(o2 > i2 ? i2 / o2 : 1, s2 > a2 ? a2 / s2 : 1) * r2;
	      }
	      getPixelRatio() {
	        var e2;
	        return null !== (e2 = this._overridePixelRatio) && void 0 !== e2 ? e2 : devicePixelRatio;
	      }
	      setPixelRatio(e2) {
	        this._overridePixelRatio = e2, this.resize();
	      }
	      getBounds() {
	        return this.transform.getBounds();
	      }
	      getMaxBounds() {
	        return this.transform.getMaxBounds();
	      }
	      setMaxBounds(e2) {
	        return this.transform.setMaxBounds($.convert(e2)), this._update();
	      }
	      setMinZoom(e2) {
	        if ((e2 = null == e2 ? -2 : e2) >= -2 && e2 <= this.transform.maxZoom) return this.transform.setMinZoom(e2), this._update(), this.getZoom() < e2 && this.setZoom(e2), this;
	        throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
	      }
	      getMinZoom() {
	        return this.transform.minZoom;
	      }
	      setMaxZoom(e2) {
	        if ((e2 = null == e2 ? 22 : e2) >= this.transform.minZoom) return this.transform.setMaxZoom(e2), this._update(), this.getZoom() > e2 && this.setZoom(e2), this;
	        throw new Error("maxZoom must be greater than the current minZoom");
	      }
	      getMaxZoom() {
	        return this.transform.maxZoom;
	      }
	      setMinPitch(e2) {
	        if ((e2 = null == e2 ? 0 : e2) < 0) throw new Error("minPitch must be greater than or equal to 0");
	        if (e2 >= 0 && e2 <= this.transform.maxPitch) return this.transform.setMinPitch(e2), this._update(), this.getPitch() < e2 && this.setPitch(e2), this;
	        throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
	      }
	      getMinPitch() {
	        return this.transform.minPitch;
	      }
	      setMaxPitch(e2) {
	        if ((e2 = null == e2 ? 60 : e2) > 180) throw new Error("maxPitch must be less than or equal to 180");
	        if (e2 >= this.transform.minPitch) return this.transform.setMaxPitch(e2), this._update(), this.getPitch() > e2 && this.setPitch(e2), this;
	        throw new Error("maxPitch must be greater than the current minPitch");
	      }
	      getMaxPitch() {
	        return this.transform.maxPitch;
	      }
	      getRenderWorldCopies() {
	        return this.transform.renderWorldCopies;
	      }
	      setRenderWorldCopies(e2) {
	        return this.transform.setRenderWorldCopies(e2), this._update();
	      }
	      setTransformConstrain(e2) {
	        return this.transform.setConstrainOverride(e2), this._update();
	      }
	      project(e2) {
	        return this.transform.locationToScreenPoint(t.V.convert(e2), this.style && this.terrain);
	      }
	      unproject(e2) {
	        return this.transform.screenPointToLocation(t.P.convert(e2), this.terrain);
	      }
	      isMoving() {
	        var e2;
	        return this._moving || (null === (e2 = this.handlers) || void 0 === e2 ? void 0 : e2.isMoving());
	      }
	      isZooming() {
	        var e2;
	        return this._zooming || (null === (e2 = this.handlers) || void 0 === e2 ? void 0 : e2.isZooming());
	      }
	      isRotating() {
	        var e2;
	        return this._rotating || (null === (e2 = this.handlers) || void 0 === e2 ? void 0 : e2.isRotating());
	      }
	      _createDelegatedListener(e2, t2, i2) {
	        if ("mouseenter" === e2 || "mouseover" === e2) {
	          let a2 = false;
	          const r2 = (r3) => {
	            const o2 = t2.filter((e3) => this.getLayer(e3)), s2 = 0 !== o2.length ? this.queryRenderedFeatures(r3.point, { layers: o2 }) : [];
	            s2.length ? a2 || (a2 = true, i2.call(this, new Yr(e2, this, r3.originalEvent, { features: s2 }))) : a2 = false;
	          };
	          return { layers: t2, listener: i2, delegates: { mousemove: r2, mouseout: () => {
	            a2 = false;
	          } } };
	        }
	        if ("mouseleave" === e2 || "mouseout" === e2) {
	          let a2 = false;
	          const r2 = (r3) => {
	            const o3 = t2.filter((e3) => this.getLayer(e3));
	            (0 !== o3.length ? this.queryRenderedFeatures(r3.point, { layers: o3 }) : []).length ? a2 = true : a2 && (a2 = false, i2.call(this, new Yr(e2, this, r3.originalEvent)));
	          }, o2 = (t3) => {
	            a2 && (a2 = false, i2.call(this, new Yr(e2, this, t3.originalEvent)));
	          };
	          return { layers: t2, listener: i2, delegates: { mousemove: r2, mouseout: o2 } };
	        }
	        {
	          const a2 = (e3) => {
	            const a3 = t2.filter((e4) => this.getLayer(e4)), r2 = 0 !== a3.length ? this.queryRenderedFeatures(e3.point, { layers: a3 }) : [];
	            r2.length && (e3.features = r2, i2.call(this, e3), delete e3.features);
	          };
	          return { layers: t2, listener: i2, delegates: { [e2]: a2 } };
	        }
	      }
	      _saveDelegatedListener(e2, t2) {
	        this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e2] = this._delegatedListeners[e2] || [], this._delegatedListeners[e2].push(t2);
	      }
	      _removeDelegatedListener(e2, t2, i2) {
	        if (!this._delegatedListeners || !this._delegatedListeners[e2]) return;
	        const a2 = this._delegatedListeners[e2];
	        for (let e3 = 0; e3 < a2.length; e3++) {
	          const r2 = a2[e3];
	          if (r2.listener === i2 && r2.layers.length === t2.length && r2.layers.every((e4) => t2.includes(e4))) {
	            for (const e4 in r2.delegates) this.off(e4, r2.delegates[e4]);
	            return void a2.splice(e3, 1);
	          }
	        }
	      }
	      on(e2, t2, i2) {
	        if (void 0 === i2) return super.on(e2, t2);
	        const a2 = "string" == typeof t2 ? [t2] : t2, r2 = this._createDelegatedListener(e2, a2, i2);
	        this._saveDelegatedListener(e2, r2);
	        for (const e3 in r2.delegates) this.on(e3, r2.delegates[e3]);
	        return { unsubscribe: () => {
	          this._removeDelegatedListener(e2, a2, i2);
	        } };
	      }
	      once(e2, t2, i2) {
	        if (void 0 === i2) return super.once(e2, t2);
	        const a2 = "string" == typeof t2 ? [t2] : t2, r2 = this._createDelegatedListener(e2, a2, i2);
	        for (const t3 in r2.delegates) {
	          const o2 = r2.delegates[t3];
	          r2.delegates[t3] = (...t4) => {
	            this._removeDelegatedListener(e2, a2, i2), o2(...t4);
	          };
	        }
	        this._saveDelegatedListener(e2, r2);
	        for (const e3 in r2.delegates) this.once(e3, r2.delegates[e3]);
	        return this;
	      }
	      off(e2, t2, i2) {
	        return void 0 === i2 ? super.off(e2, t2) : (this._removeDelegatedListener(e2, "string" == typeof t2 ? [t2] : t2, i2), this);
	      }
	      queryRenderedFeatures(e2, i2) {
	        if (!this.style) return [];
	        let a2;
	        const r2 = e2 instanceof t.P || Array.isArray(e2), o2 = r2 ? e2 : [[0, 0], [this.transform.width, this.transform.height]];
	        if (i2 = i2 || (r2 ? {} : e2) || {}, o2 instanceof t.P || "number" == typeof o2[0]) a2 = [t.P.convert(o2)];
	        else {
	          const e3 = t.P.convert(o2[0]), i3 = t.P.convert(o2[1]);
	          a2 = [e3, new t.P(i3.x, e3.y), i3, new t.P(e3.x, i3.y), e3];
	        }
	        return this.style.queryRenderedFeatures(a2, i2, this.transform);
	      }
	      querySourceFeatures(e2, t2) {
	        return this.style.querySourceFeatures(e2, t2);
	      }
	      setStyle(e2, i2) {
	        return false !== (i2 = t.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, i2)).diff && i2.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e2 ? (this._diffStyle(e2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._updateStyle(e2, i2));
	      }
	      setTransformRequest(e2) {
	        return this._requestManager.setTransformRequest(e2), this;
	      }
	      _getUIString(e2) {
	        const t2 = this._locale[e2];
	        if (null == t2) throw new Error(`Missing UI string '${e2}'`);
	        return t2;
	      }
	      _updateStyle(e2, t2) {
	        var i2, a2;
	        if (t2.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(e2, t2));
	        const r2 = this.style && t2.transformStyle ? this.style.serialize() : void 0;
	        return this.style && (this.style.setEventedParent(null), this.style._remove(!e2)), e2 ? (this.style = new Si(this, t2 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e2 ? this.style.loadURL(e2, t2, r2) : this.style.loadJSON(e2, t2, r2), this) : (null === (a2 = null === (i2 = this.style) || void 0 === i2 ? void 0 : i2.projection) || void 0 === a2 || a2.destroy(), delete this.style, this);
	      }
	      _lazyInitEmptyStyle() {
	        this.style || (this.style = new Si(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
	      }
	      _diffStyle(e2, i2) {
	        if ("string" == typeof e2) {
	          const a2 = this._requestManager.transformRequest(e2, "Style");
	          t.j(a2, new AbortController()).then((e3) => {
	            this._updateDiff(e3.data, i2);
	          }).catch((e3) => {
	            e3 && this.fire(new t.k(e3));
	          });
	        } else "object" == typeof e2 && this._updateDiff(e2, i2);
	      }
	      _updateDiff(e2, i2) {
	        try {
	          this.style.setState(e2, i2) && this._update(true);
	        } catch (a2) {
	          t.w(`Unable to perform style diff: ${a2.message || a2.error || a2}.  Rebuilding the style from scratch.`), this._updateStyle(e2, i2);
	        }
	      }
	      getStyle() {
	        if (this.style) return this.style.serialize();
	      }
	      _getStyleAndImages() {
	        return this.style ? { style: this.style.serialize(), images: this.style.imageManager.cloneImages() } : { style: null, images: {} };
	      }
	      isStyleLoaded() {
	        return this.style ? this.style.loaded() : t.w("There is no style added to the map.");
	      }
	      addSource(e2, t2) {
	        return this._lazyInitEmptyStyle(), this.style.addSource(e2, t2), this._update(true);
	      }
	      isSourceLoaded(e2) {
	        const i2 = this.style && this.style.tileManagers[e2];
	        if (void 0 !== i2) return i2.loaded();
	        this.fire(new t.k(new Error(`There is no tile manager with ID '${e2}'`)));
	      }
	      setTerrain(e2) {
	        if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), e2) {
	          const i2 = this.style.tileManagers[e2.source];
	          if (!i2) throw new Error(`cannot load terrain, because there exists no source with ID: ${e2.source}`);
	          null === this.terrain && i2.reload();
	          for (const i3 in this.style._layers) {
	            const a2 = this.style._layers[i3];
	            "hillshade" === a2.type && a2.source === e2.source && t.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), "color-relief" === a2.type && a2.source === e2.source && t.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
	          }
	          this.terrain = new Ko(this.painter, i2, e2), this.painter.renderToTexture = new Jo(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (t2) => {
	            var i3;
	            "style" === t2.dataType ? this.terrain.tileManager.freeRtt() : "source" === t2.dataType && t2.tile && (t2.sourceId !== e2.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), "image" === (null === (i3 = t2.source) || void 0 === i3 ? void 0 : i3.type) ? this.terrain.tileManager.freeRtt() : this.terrain.tileManager.freeRtt(t2.tile.tileID));
	          }, this.style.on("data", this._terrainDataCallback);
	        } else this.terrain && this.terrain.tileManager.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
	        return this.fire(new t.l("terrain", { terrain: e2 })), this;
	      }
	      getTerrain() {
	        var e2, t2;
	        return null !== (t2 = null === (e2 = this.terrain) || void 0 === e2 ? void 0 : e2.options) && void 0 !== t2 ? t2 : null;
	      }
	      areTilesLoaded() {
	        const e2 = this.style && this.style.tileManagers;
	        for (const t2 in e2) {
	          const i2 = e2[t2]._tiles;
	          for (const e3 in i2) {
	            const t3 = i2[e3];
	            if ("loaded" !== t3.state && "errored" !== t3.state) return false;
	          }
	        }
	        return true;
	      }
	      removeSource(e2) {
	        return this.style.removeSource(e2), this._update(true);
	      }
	      getSource(e2) {
	        return this.style.getSource(e2);
	      }
	      setSourceTileLodParams(e2, t2, i2) {
	        if (i2) {
	          const a2 = this.getSource(i2);
	          if (!a2) throw new Error(`There is no source with ID "${i2}", cannot set LOD parameters`);
	          a2.calculateTileZoom = we(Math.max(1, e2), Math.max(1, t2));
	        } else for (const i3 in this.style.tileManagers) this.style.tileManagers[i3].getSource().calculateTileZoom = we(Math.max(1, e2), Math.max(1, t2));
	        return this._update(true), this;
	      }
	      refreshTiles(e2, i2) {
	        const a2 = this.style.tileManagers[e2];
	        if (!a2) throw new Error(`There is no tile manager with ID "${e2}", cannot refresh tile`);
	        void 0 === i2 ? a2.reload(true) : a2.refreshTiles(i2.map((e3) => new t.ad(e3.z, e3.x, e3.y)));
	      }
	      addImage(e2, i2, a2 = {}) {
	        const { pixelRatio: r2 = 1, sdf: o2 = false, stretchX: s2, stretchY: l2, content: c2, textFitWidth: h2, textFitHeight: u2 } = a2;
	        if (this._lazyInitEmptyStyle(), !(i2 instanceof HTMLImageElement || t.b(i2))) {
	          if (void 0 === i2.width || void 0 === i2.height) return this.fire(new t.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
	          {
	            const { width: a3, height: n2, data: d2 } = i2, _2 = i2;
	            return this.style.addImage(e2, { data: new t.R({ width: a3, height: n2 }, new Uint8Array(d2)), pixelRatio: r2, stretchX: s2, stretchY: l2, content: c2, textFitWidth: h2, textFitHeight: u2, sdf: o2, version: 0, userImage: _2 }), _2.onAdd && _2.onAdd(this, e2), this;
	          }
	        }
	        {
	          const { width: a3, height: d2, data: _2 } = n.getImageData(i2);
	          this.style.addImage(e2, { data: new t.R({ width: a3, height: d2 }, _2), pixelRatio: r2, stretchX: s2, stretchY: l2, content: c2, textFitWidth: h2, textFitHeight: u2, sdf: o2, version: 0 });
	        }
	      }
	      updateImage(e2, i2) {
	        const a2 = this.style.getImage(e2);
	        if (!a2) return this.fire(new t.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
	        const r2 = i2 instanceof HTMLImageElement || t.b(i2) ? n.getImageData(i2) : i2, { width: o2, height: s2, data: l2 } = r2;
	        if (void 0 === o2 || void 0 === s2) return this.fire(new t.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
	        if (o2 !== a2.data.width || s2 !== a2.data.height) return this.fire(new t.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
	        const c2 = !(i2 instanceof HTMLImageElement || t.b(i2));
	        return a2.data.replace(l2, c2), this.style.updateImage(e2, a2), this;
	      }
	      getImage(e2) {
	        return this.style.getImage(e2);
	      }
	      hasImage(e2) {
	        return e2 ? !!this.style.getImage(e2) : (this.fire(new t.k(new Error("Missing required image id"))), false);
	      }
	      removeImage(e2) {
	        this.style.removeImage(e2);
	      }
	      loadImage(e2) {
	        return g.getImage(this._requestManager.transformRequest(e2, "Image"), new AbortController());
	      }
	      listImages() {
	        return this.style.listImages();
	      }
	      addLayer(e2, t2) {
	        return this._lazyInitEmptyStyle(), this.style.addLayer(e2, t2), this._update(true);
	      }
	      moveLayer(e2, t2) {
	        return this.style.moveLayer(e2, t2), this._update(true);
	      }
	      removeLayer(e2) {
	        return this.style.removeLayer(e2), this._update(true);
	      }
	      getLayer(e2) {
	        return this.style.getLayer(e2);
	      }
	      getLayersOrder() {
	        return this.style.getLayersOrder();
	      }
	      setLayerZoomRange(e2, t2, i2) {
	        return this.style.setLayerZoomRange(e2, t2, i2), this._update(true);
	      }
	      setFilter(e2, t2, i2 = {}) {
	        return this.style.setFilter(e2, t2, i2), this._update(true);
	      }
	      getFilter(e2) {
	        return this.style.getFilter(e2);
	      }
	      setPaintProperty(e2, t2, i2, a2 = {}) {
	        return this.style.setPaintProperty(e2, t2, i2, a2), this._update(true);
	      }
	      getPaintProperty(e2, t2) {
	        return this.style.getPaintProperty(e2, t2);
	      }
	      setLayoutProperty(e2, t2, i2, a2 = {}) {
	        return this.style.setLayoutProperty(e2, t2, i2, a2), this._update(true);
	      }
	      getLayoutProperty(e2, t2) {
	        return this.style.getLayoutProperty(e2, t2);
	      }
	      setGlyphs(e2, t2 = {}) {
	        return this._lazyInitEmptyStyle(), this.style.setGlyphs(e2, t2), this._update(true);
	      }
	      getGlyphs() {
	        return this.style.getGlyphsUrl();
	      }
	      addSprite(e2, t2, i2 = {}) {
	        return this._lazyInitEmptyStyle(), this.style.addSprite(e2, t2, i2, (e3) => {
	          e3 || this._update(true);
	        }), this;
	      }
	      removeSprite(e2) {
	        return this._lazyInitEmptyStyle(), this.style.removeSprite(e2), this._update(true);
	      }
	      getSprite() {
	        return this.style.getSprite();
	      }
	      setSprite(e2, t2 = {}) {
	        return this._lazyInitEmptyStyle(), this.style.setSprite(e2, t2, (e3) => {
	          e3 || this._update(true);
	        }), this;
	      }
	      setLight(e2, t2 = {}) {
	        return this._lazyInitEmptyStyle(), this.style.setLight(e2, t2), this._update(true);
	      }
	      getLight() {
	        return this.style.getLight();
	      }
	      setSky(e2, t2 = {}) {
	        return this._lazyInitEmptyStyle(), this.style.setSky(e2, t2), this._update(true);
	      }
	      getSky() {
	        return this.style.getSky();
	      }
	      setFeatureState(e2, t2) {
	        return this.style.setFeatureState(e2, t2), this._update();
	      }
	      removeFeatureState(e2, t2) {
	        return this.style.removeFeatureState(e2, t2), this._update();
	      }
	      getFeatureState(e2) {
	        return this.style.getFeatureState(e2);
	      }
	      getContainer() {
	        return this._container;
	      }
	      getCanvasContainer() {
	        return this._canvasContainer;
	      }
	      getCanvas() {
	        return this._canvas;
	      }
	      _containerDimensions() {
	        let e2 = 0, t2 = 0;
	        return this._container && (e2 = this._container.clientWidth || 400, t2 = this._container.clientHeight || 300), [e2, t2];
	      }
	      _setupContainer() {
	        const e2 = this._container;
	        e2.classList.add("maplibregl-map");
	        const t2 = this._canvasContainer = h.create("div", "maplibregl-canvas-container", e2);
	        this._interactive && t2.classList.add("maplibregl-interactive"), this._canvas = h.create("canvas", "maplibregl-canvas", t2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
	        const i2 = this._containerDimensions(), a2 = this._getClampedPixelRatio(i2[0], i2[1]);
	        this._resizeCanvas(i2[0], i2[1], a2);
	        const r2 = this._controlContainer = h.create("div", "maplibregl-control-container", e2), o2 = this._controlPositions = {};
	        ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e3) => {
	          o2[e3] = h.create("div", `maplibregl-ctrl-${e3} `, r2);
	        }), this._container.addEventListener("scroll", this._onMapScroll, false);
	      }
	      _resizeCanvas(e2, t2, i2) {
	        this._canvas.width = Math.floor(i2 * e2), this._canvas.height = Math.floor(i2 * t2), this._canvas.style.width = `${e2}px`, this._canvas.style.height = `${t2}px`;
	      }
	      _setupPainter() {
	        const e2 = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: true, depth: true, stencil: true, premultipliedAlpha: true });
	        let t2 = null;
	        this._canvas.addEventListener("webglcontextcreationerror", (i3) => {
	          t2 = { requestedAttributes: e2 }, i3 && (t2.statusMessage = i3.statusMessage, t2.type = i3.type);
	        }, { once: true });
	        let i2 = null;
	        if (i2 = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, e2) : this._canvas.getContext("webgl2", e2) || this._canvas.getContext("webgl", e2), !i2) {
	          const e3 = "Failed to initialize WebGL";
	          throw t2 ? (t2.message = e3, new Error(JSON.stringify(t2))) : new Error(e3);
	        }
	        this.painter = new jr(i2, this.transform), u.testSupport(i2);
	      }
	      migrateProjection(e2, i2) {
	        super.migrateProjection(e2, i2), this.painter.transform = e2, this.fire(new t.l("projectiontransition", { newProjection: this.style.projection.name }));
	      }
	      loaded() {
	        return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
	      }
	      _update(e2) {
	        return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || e2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
	      }
	      _requestRenderFrame(e2) {
	        return this._update(), this._renderTaskQueue.add(e2);
	      }
	      _cancelRenderFrame(e2) {
	        this._renderTaskQueue.remove(e2);
	      }
	      _render(e2) {
	        var i2, a2, r2, o2, s2;
	        const n2 = this._idleTriggered ? this._fadeDuration : 0, l2 = (null === (i2 = this.style.projection) || void 0 === i2 ? void 0 : i2.transitionState) > 0;
	        if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e2), this._removed) return;
	        let h2 = false;
	        if (this.style && this._styleDirty) {
	          this._styleDirty = false;
	          const e3 = this.transform.zoom, i3 = c();
	          this.style.zoomHistory.update(e3, i3);
	          const a3 = new t.H(e3, { now: i3, fadeDuration: n2, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), r3 = a3.crossFadingFactor();
	          1 === r3 && r3 === this._crossFadingFactor || (h2 = true, this._crossFadingFactor = r3), this.style.update(a3);
	        }
	        const u2 = (null === (a2 = this.style.projection) || void 0 === a2 ? void 0 : a2.transitionState) > 0 !== l2;
	        null === (r2 = this.style.projection) || void 0 === r2 || r2.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState(null === (o2 = this.style.projection) || void 0 === o2 ? void 0 : o2.transitionState, null === (s2 = this.style.projection) || void 0 === s2 ? void 0 : s2.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || u2) && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.tileManager.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, n2, this._crossSourceCollisions, u2), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: n2, showPadding: this.showPadding }), this.fire(new t.l("render")), this.loaded() && !this._loaded && (this._loaded = true, t.cF.mark(t.cG.load), this.fire(new t.l("load"))), this.style && (this.style.hasTransitions() || h2) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
	        const d2 = this._sourcesDirty || this._styleDirty || this._placementDirty;
	        return d2 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.l("idle")), !this._loaded || this._fullyLoaded || d2 || (this._fullyLoaded = true, t.cF.mark(t.cG.fullLoad)), this;
	      }
	      redraw() {
	        return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
	      }
	      remove() {
	        var e2;
	        this._hash && this._hash.remove();
	        for (const e3 of this._controls) e3.onRemove(this);
	        this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && removeEventListener("online", this._onWindowOnline, false), g.removeThrottleControl(this._imageQueueHandle), null === (e2 = this._resizeObserver) || void 0 === e2 || e2.disconnect();
	        const i2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
	        (null == i2 ? void 0 : i2.loseContext) && i2.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), h.remove(this._canvasContainer), h.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, false), this._container.classList.remove("maplibregl-map"), t.cF.clearMetrics(), this._removed = true, this.fire(new t.l("remove"));
	      }
	      triggerRepaint() {
	        this.style && !this._frameRequest && (this._frameRequest = new AbortController(), n.frame(this._frameRequest, (e2) => {
	          t.cF.frame(e2), this._frameRequest = null;
	          try {
	            this._render(e2);
	          } catch (e3) {
	            if (!t.cH(e3) && !function(e4) {
	              return e4.message === Ja;
	            }(e3)) throw e3;
	          }
	        }, () => {
	        }));
	      }
	      get showTileBoundaries() {
	        return !!this._showTileBoundaries;
	      }
	      set showTileBoundaries(e2) {
	        this._showTileBoundaries !== e2 && (this._showTileBoundaries = e2, this._update());
	      }
	      get showPadding() {
	        return !!this._showPadding;
	      }
	      set showPadding(e2) {
	        this._showPadding !== e2 && (this._showPadding = e2, this._update());
	      }
	      get showCollisionBoxes() {
	        return !!this._showCollisionBoxes;
	      }
	      set showCollisionBoxes(e2) {
	        this._showCollisionBoxes !== e2 && (this._showCollisionBoxes = e2, e2 ? this.style._generateCollisionBoxes() : this._update());
	      }
	      get showOverdrawInspector() {
	        return !!this._showOverdrawInspector;
	      }
	      set showOverdrawInspector(e2) {
	        this._showOverdrawInspector !== e2 && (this._showOverdrawInspector = e2, this._update());
	      }
	      get repaint() {
	        return !!this._repaint;
	      }
	      set repaint(e2) {
	        this._repaint !== e2 && (this._repaint = e2, this.triggerRepaint());
	      }
	      get vertices() {
	        return !!this._vertices;
	      }
	      set vertices(e2) {
	        this._vertices = e2, this._update();
	      }
	      get version() {
	        return ts;
	      }
	      getCameraTargetElevation() {
	        return this.transform.elevation;
	      }
	      getProjection() {
	        return this.style.getProjection();
	      }
	      setProjection(e2) {
	        return this._lazyInitEmptyStyle(), this.style.setProjection(e2), this._update(true);
	      }
	    }, e.MapMouseEvent = Yr, e.MapTouchEvent = Qr, e.MapWheelEvent = Jr, e.Marker = cs, e.NavigationControl = class {
	      constructor(e2) {
	        this._updateZoomButtons = () => {
	          const e3 = this._map.getZoom(), t2 = e3 === this._map.getMaxZoom(), i2 = e3 === this._map.getMinZoom();
	          this._zoomInButton.disabled = t2, this._zoomOutButton.disabled = i2, this._zoomInButton.setAttribute("aria-disabled", t2.toString()), this._zoomOutButton.setAttribute("aria-disabled", i2.toString());
	        }, this._rotateCompassArrow = () => {
	          this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
	        }, this._setButtonTitle = (e3, t2) => {
	          const i2 = this._map._getUIString(`NavigationControl.${t2}`);
	          e3.title = i2, e3.setAttribute("aria-label", i2);
	        }, this.options = t.e({}, as, e2), this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e3) => e3.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e3) => this._map.zoomIn({}, { originalEvent: e3 })), h.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e3) => this._map.zoomOut({}, { originalEvent: e3 })), h.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e3) => {
	          this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e3 }) : this._map.resetNorth({}, { originalEvent: e3 });
	        }), this._compassIcon = h.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
	      }
	      onAdd(e2) {
	        return this._map = e2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new rs(this._map, this._compass, this.options.visualizePitch)), this._container;
	      }
	      onRemove() {
	        h.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
	      }
	      _createButton(e2, t2) {
	        const i2 = h.create("button", e2, this._container);
	        return i2.type = "button", i2.addEventListener("click", t2), i2;
	      }
	    }, e.Popup = class extends t.E {
	      constructor(e2) {
	        super(), this._updateOpacity = () => {
	          void 0 !== this.options.locationOccludedOpacity && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
	        }, this.remove = () => (this._content && h.remove(this._content), this._container && (h.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new t.l("close"))), this), this._onMouseUp = (e3) => {
	          this._update(e3.point);
	        }, this._onMouseMove = (e3) => {
	          this._update(e3.point);
	        }, this._onDrag = (e3) => {
	          this._update(e3.point);
	        }, this._update = (e3) => {
	          if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
	          if (!this._container) {
	            if (this._container = h.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = h.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const e4 of this.options.className.split(" ")) this._container.classList.add(e4);
	            this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
	          }
	          if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = ss(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e3) return;
	          const t2 = this._flatPos = this._pos = this._trackPointer && e3 ? e3 : this._map.project(this._lngLat);
	          this._map.terrain && (this._flatPos = this._trackPointer && e3 ? e3 : this._map.transform.locationToScreenPoint(this._lngLat));
	          let i2 = this.options.anchor;
	          const a2 = vs(this.options.offset);
	          if (!i2) {
	            const e4 = this._container.offsetWidth, r3 = this._container.offsetHeight;
	            let o2;
	            o2 = t2.y + a2.bottom.y < r3 ? ["top"] : t2.y > this._map.transform.height - r3 ? ["bottom"] : [], t2.x < e4 / 2 ? o2.push("left") : t2.x > this._map.transform.width - e4 / 2 && o2.push("right"), i2 = 0 === o2.length ? "bottom" : o2.join("-");
	          }
	          let r2 = t2.add(a2[i2]);
	          this.options.subpixelPositioning || (r2 = r2.round()), h.setTransform(this._container, `${ns[i2]} translate(${r2.x}px,${r2.y}px)`), ls(this._container, i2, "popup"), this._updateOpacity();
	        }, this._onClose = () => {
	          this.remove();
	        }, this.options = t.e(Object.create(fs), e2);
	      }
	      addTo(e2) {
	        return this._map && this.remove(), this._map = e2, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.l("open")), this;
	      }
	      isOpen() {
	        return !!this._map;
	      }
	      getLngLat() {
	        return this._lngLat;
	      }
	      setLngLat(e2) {
	        return this._lngLat = t.V.convert(e2), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
	      }
	      trackPointer() {
	        return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
	      }
	      getElement() {
	        return this._container;
	      }
	      setText(e2) {
	        return this.setDOMContent(document.createTextNode(e2));
	      }
	      setHTML(e2) {
	        const t2 = document.createDocumentFragment(), i2 = document.createElement("body");
	        let a2;
	        for (i2.innerHTML = e2; a2 = i2.firstChild, a2; ) t2.appendChild(a2);
	        return this.setDOMContent(t2);
	      }
	      getMaxWidth() {
	        var e2;
	        return null === (e2 = this._container) || void 0 === e2 ? void 0 : e2.style.maxWidth;
	      }
	      setMaxWidth(e2) {
	        return this.options.maxWidth = e2, this._update(), this;
	      }
	      setDOMContent(e2) {
	        if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
	        else this._content = h.create("div", "maplibregl-popup-content", this._container);
	        return this._content.appendChild(e2), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
	      }
	      addClassName(e2) {
	        return this._container && this._container.classList.add(e2), this;
	      }
	      removeClassName(e2) {
	        return this._container && this._container.classList.remove(e2), this;
	      }
	      setOffset(e2) {
	        return this.options.offset = e2, this._update(), this;
	      }
	      toggleClassName(e2) {
	        if (this._container) return this._container.classList.toggle(e2);
	      }
	      setSubpixelPositioning(e2) {
	        this.options.subpixelPositioning = e2;
	      }
	      _createCloseButton() {
	        this.options.closeButton && (this._closeButton = h.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
	      }
	      _focusFirstElement() {
	        if (!this.options.focusAfterOpen || !this._container) return;
	        const e2 = this._container.querySelector(gs);
	        e2 && e2.focus();
	      }
	    }, e.RasterDEMTileSource = Y, e.RasterTileSource = K, e.ScaleControl = class {
	      constructor(e2) {
	        this._onMove = () => {
	          ps(this._map, this._container, this.options);
	        }, this.setUnit = (e3) => {
	          this.options.unit = e3, ps(this._map, this._container, this.options);
	        }, this.options = Object.assign(Object.assign({}, _s), e2);
	      }
	      getDefaultPosition() {
	        return "bottom-left";
	      }
	      onAdd(e2) {
	        return this._map = e2, this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", e2.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
	      }
	      onRemove() {
	        h.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
	      }
	    }, e.ScrollZoomHandler = Do, e.Style = Si, e.TerrainControl = class {
	      constructor(e2) {
	        this._toggleTerrain = () => {
	          this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
	        }, this._updateTerrainIcon = () => {
	          this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
	        }, this.options = e2;
	      }
	      onAdd(e2) {
	        return this._map = e2, this._container = h.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = h.create("button", "maplibregl-ctrl-terrain", this._container), h.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
	      }
	      onRemove() {
	        h.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
	      }
	    }, e.TwoFingersTouchPitchHandler = Co, e.TwoFingersTouchRotateHandler = To, e.TwoFingersTouchZoomHandler = yo, e.TwoFingersTouchZoomRotateHandler = Bo, e.VectorTileSource = X, e.VideoSource = ie, e.addSourceType = (e2, i2) => t._(void 0, void 0, void 0, function* () {
	      if (oe(e2)) throw new Error(`A source type called "${e2}" already exists.`);
	      ((e3, t2) => {
	        re[e3] = t2;
	      })(e2, i2);
	    }), e.clearPrewarmedResources = function() {
	      const e2 = B;
	      e2 && (e2.isPreloaded() && 1 === e2.numActive() ? (e2.release(L), B = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
	    }, e.createTileMesh = ii, e.getMaxParallelImageRequests = function() {
	      return t.a.MAX_PARALLEL_IMAGE_REQUESTS;
	    }, e.getRTLTextPluginStatus = function() {
	      return ce().getRTLTextPluginStatus();
	    }, e.getVersion = function() {
	      return xs;
	    }, e.getWorkerCount = function() {
	      return k.workerCount;
	    }, e.getWorkerUrl = function() {
	      return t.a.WORKER_URL;
	    }, e.importScriptInWorkers = function(e2) {
	      return Z().broadcast("IS", e2);
	    }, e.isTimeFrozen = function() {
	      return l.isFrozen();
	    }, e.now = c, e.prewarm = function() {
	      j().acquire(L);
	    }, e.restoreNow = function() {
	      l.restoreNow();
	    }, e.setMaxParallelImageRequests = function(e2) {
	      t.a.MAX_PARALLEL_IMAGE_REQUESTS = e2;
	    }, e.setNow = function(e2) {
	      l.setNow(e2);
	    }, e.setRTLTextPlugin = function(e2, t2) {
	      return ce().setRTLTextPlugin(e2, t2);
	    }, e.setWorkerCount = function(e2) {
	      k.workerCount = e2;
	    }, e.setWorkerUrl = function(e2) {
	      t.a.WORKER_URL = e2;
	    };
	  });
	  var maplibregl$1 = maplibregl;
	  return maplibregl$1;
	}); 
} (maplibreGl));

var maplibreGlExports = maplibreGl.exports;

const version = 8;
const name = "M1SSION Neon 3D - FULL SPEC";
const sources = {
	openmaptiles: {
		type: "vector",
		url: "https://api.maptiler.com/tiles/v3/tiles.json?key=YOUR_MAPTILER_API_KEY_HERE"
	}
};
const glyphs = "https://api.maptiler.com/fonts/{fontstack}/{range}.pbf?key=YOUR_MAPTILER_API_KEY_HERE";
const layers = [
	{
		id: "background",
		type: "background",
		paint: {
			"background-color": "#03070D"
		}
	},
	{
		id: "land",
		type: "fill",
		source: "openmaptiles",
		"source-layer": "landcover",
		paint: {
			"fill-color": "#050B13",
			"fill-opacity": 1
		}
	},
	{
		id: "water",
		type: "fill",
		source: "openmaptiles",
		"source-layer": "water",
		paint: {
			"fill-color": "#0A1526",
			"fill-opacity": 1
		}
	},
	{
		id: "water-outline",
		type: "line",
		source: "openmaptiles",
		"source-layer": "water",
		paint: {
			"line-color": "#27E1FF",
			"line-width": 0.6,
			"line-blur": 2.5,
			"line-opacity": 0.7
		}
	},
	{
		id: "roads-minor",
		type: "line",
		source: "openmaptiles",
		"source-layer": "transportation",
		filter: [
			"in",
			"class",
			"minor",
			"service",
			"track"
		],
		paint: {
			"line-color": "#27E1FF",
			"line-width": {
				stops: [
					[
						12,
						0.5
					],
					[
						16,
						1.5
					],
					[
						20,
						3
					]
				]
			},
			"line-blur": {
				stops: [
					[
						12,
						1
					],
					[
						16,
						2
					],
					[
						20,
						4
					]
				]
			},
			"line-opacity": 0.4
		}
	},
	{
		id: "roads-major",
		type: "line",
		source: "openmaptiles",
		"source-layer": "transportation",
		filter: [
			"in",
			"class",
			"primary",
			"secondary",
			"tertiary",
			"trunk",
			"motorway"
		],
		paint: {
			"line-color": "#27E1FF",
			"line-width": {
				stops: [
					[
						10,
						1
					],
					[
						14,
						2.5
					],
					[
						18,
						5
					]
				]
			},
			"line-blur": {
				stops: [
					[
						10,
						2
					],
					[
						14,
						4
					],
					[
						18,
						6
					]
				]
			},
			"line-opacity": 0.8
		}
	},
	{
		id: "buildings-extrusion",
		type: "fill-extrusion",
		source: "openmaptiles",
		"source-layer": "building",
		minzoom: 12,
		paint: {
			"fill-extrusion-color": [
				"interpolate",
				[
					"linear"
				],
				[
					"zoom"
				],
				12,
				"#3C46FF",
				15,
				"#5566FF",
				18,
				"#8CA8FF"
			],
			"fill-extrusion-opacity": [
				"interpolate",
				[
					"linear"
				],
				[
					"zoom"
				],
				12,
				0.75,
				14,
				0.9,
				16,
				0.98,
				20,
				1
			],
			"fill-extrusion-height": [
				"coalesce",
				[
					"get",
					"render_height"
				],
				[
					"get",
					"height"
				],
				15
			],
			"fill-extrusion-base": [
				"coalesce",
				[
					"get",
					"render_min_height"
				],
				[
					"get",
					"min_height"
				],
				0
			]
		},
		layout: {
			visibility: "visible"
		}
	},
	{
		id: "buildings-rim",
		type: "line",
		source: "openmaptiles",
		"source-layer": "building",
		minzoom: 14,
		paint: {
			"line-color": "#7DEBFF",
			"line-width": {
				stops: [
					[
						14,
						0.3
					],
					[
						18,
						0.8
					]
				]
			},
			"line-opacity": 0.6
		}
	},
	{
		id: "poi-labels",
		type: "symbol",
		source: "openmaptiles",
		"source-layer": "poi",
		layout: {
			"text-field": "",
			visibility: "none"
		}
	},
	{
		id: "place-labels",
		type: "symbol",
		source: "openmaptiles",
		"source-layer": "place",
		layout: {
			"text-field": [
				"get",
				"name"
			],
			"text-font": [
				"Noto Sans Regular"
			],
			"text-size": 11,
			visibility: "visible"
		},
		paint: {
			"text-color": "#7DEBFF",
			"text-halo-color": "#03070D",
			"text-halo-width": 1.5,
			"text-opacity": 0.15
		}
	}
];
const fog = {
	color: "#050B13",
	range: [
		0.5,
		6
	],
	"horizon-blend": 0.08,
	"high-color": "#0A1526",
	"space-color": "#03070D",
	"star-intensity": 0.15
};
const light = {
	anchor: "viewport",
	color: "#7DEBFF",
	intensity: 0.35,
	position: [
		1.5,
		210,
		50
	]
};
const pitch = 45;
const bearing = 0;
const neonStyleTemplate = {
	version: version,
	name: name,
	sources: sources,
	glyphs: glyphs,
	layers: layers,
	fog: fog,
	light: light,
	pitch: pitch,
	bearing: bearing
};

const BuzzMapButtonSecure = ({
  onBuzzPress,
  mapCenter,
  onAreaGenerated
}) => {
  const { isAuthenticated, user } = useAuthContext();
  const { callBuzzApi } = useBuzzApi();
  const { accrueFromBuzzMap } = useCashbackWallet();
  const [serverPricing, setServerPricing] = reactExports.useState(null);
  const [pricingLoading, setPricingLoading] = reactExports.useState(true);
  const { unitsData } = useM1UnitsRealtime(user?.id);
  const [isProcessing, setIsProcessing] = reactExports.useState(false);
  const [currentLocation, setCurrentLocation] = reactExports.useState(null);
  reactExports.useEffect(() => {
    const loadServerPricing = async () => {
      if (!user?.id) {
        setPricingLoading(false);
        return;
      }
      try {
        setPricingLoading(true);
        const { data, error } = await supabase.rpc("m1_get_next_buzz_level", {
          p_user_id: user.id
        });
        if (error) {
          setPricingLoading(false);
          return;
        }
        const pricing = Array.isArray(data) ? data[0] : data;
        setServerPricing(pricing);
      } catch (err) {
      } finally {
        setPricingLoading(false);
      }
    };
    loadServerPricing();
    const handleBuzzCreated = () => {
      loadServerPricing();
    };
    window.addEventListener("buzzAreaCreated", handleBuzzCreated);
    return () => window.removeEventListener("buzzAreaCreated", handleBuzzCreated);
  }, [user?.id]);
  reactExports.useEffect(() => {
    if (!navigator.geolocation) {
      if (mapCenter) {
        setCurrentLocation(mapCenter);
      } else {
        setCurrentLocation([41.9028, 12.4964]);
      }
      return;
    }
    const watchId = navigator.geolocation.watchPosition(
      (position) => {
        setCurrentLocation([position.coords.latitude, position.coords.longitude]);
      },
      (error) => {
        if (mapCenter) {
          setCurrentLocation(mapCenter);
        } else {
          setCurrentLocation([41.9028, 12.4964]);
        }
      },
      { enableHighAccuracy: true, timeout: 1e4, maximumAge: 6e4 }
    );
    return () => navigator.geolocation.clearWatch(watchId);
  }, [mapCenter]);
  const getCoordinates = () => {
    if (currentLocation) return currentLocation;
    if (mapCenter && mapCenter[0] && mapCenter[1]) return mapCenter;
    const lastPos = localStorage.getItem("lastKnownPosition");
    if (lastPos) {
      try {
        const parsed = JSON.parse(lastPos);
        if (parsed.lat && parsed.lng) return [parsed.lat, parsed.lng];
      } catch (e) {
      }
    }
    return [41.9028, 12.4964];
  };
  const handleBuzzMapPress = async () => {
    if (!isAuthenticated || !user) {
      ue.error("Devi accedere per usare BUZZ MAP.");
      return;
    }
    const coordinates = getCoordinates();
    if (!coordinates || !coordinates[0] || !coordinates[1]) {
      ue.error("Posizione necessaria per BUZZ MAP");
      return;
    }
    localStorage.setItem("lastKnownPosition", JSON.stringify({
      lat: coordinates[0],
      lng: coordinates[1],
      timestamp: Date.now()
    }));
    if (!serverPricing) {
      ue.error("Errore nel caricamento dei prezzi. Riprova.");
      return;
    }
    const costM1U = serverPricing.m1u;
    const currentBalance = unitsData?.balance || 0;
    if (currentBalance < costM1U) {
      showInsufficientM1UToast(costM1U, currentBalance);
      return;
    }
    setIsProcessing(true);
    try {
      const edgeResult = await callBuzzApi({
        userId: user.id,
        mode: "map",
        //  FIX: Explicit mode to force MAP branch
        generateMap: true,
        coordinates: { lat: coordinates[0], lng: coordinates[1] },
        sessionId: Date.now().toString()
      });
      if (!edgeResult?.area_id) {
      }
      if (!edgeResult) {
        ue.error("Errore di connessione. Verifica la tua connessione e riprova.");
        return;
      }
      if (!edgeResult.success) {
        ue.error(edgeResult.errorMessage || "Errore durante la creazione dell'area. Riprova.");
        return;
      }
      const actualLevel = edgeResult.level || serverPricing.level;
      const actualRadius = edgeResult.radius_km || serverPricing.radius_km;
      ue.success(
        `BUZZ MAP creato  Livello ${actualLevel}  ${Math.round(actualRadius)}km  ${costM1U} M1U`,
        {
          duration: 4e3,
          style: {
            background: "linear-gradient(135deg, #9333EA 0%, #EF4444 100%)",
            color: "white",
            fontWeight: "bold"
          }
        }
      );
      try {
        const costEur = costM1U / 10;
        await accrueFromBuzzMap({ costEur });
      } catch (cashbackErr) {
      }
      try {
        const { error: locationError } = await supabase.rpc("set_my_agent_location", {
          p_lat: coordinates[0],
          p_lng: coordinates[1],
          p_accuracy: null,
          p_status: "online"
        });
        if (locationError) {
        } else {
        }
      } catch (e) {
      }
      onAreaGenerated?.(coordinates[0], coordinates[1], actualRadius);
      onBuzzPress();
      await new Promise((resolve) => setTimeout(resolve, 800));
      await new Promise((resolve) => {
        const timeout = setTimeout(() => {
          resolve();
        }, 3e3);
        const handler = () => {
          clearTimeout(timeout);
          window.removeEventListener("areasReloaded", handler);
          resolve();
        };
        window.addEventListener("areasReloaded", handler);
      });
      window.dispatchEvent(new CustomEvent("buzzAreaCreated", {
        detail: {
          level: actualLevel,
          radiusKm: actualRadius,
          costM1U,
          lat: coordinates[0],
          lng: coordinates[1],
          areaId: edgeResult.area_id
        }
      }));
      notifyShadowContext("map");
    } catch (error) {
      if (error.message?.includes("429")) {
        ue.error("Hai raggiunto il limite giornaliero. Riprova dopo mezzanotte.");
      } else {
        ue.error("Errore durante la creazione della BUZZ MAP");
      }
    } finally {
      setIsProcessing(false);
    }
  };
  const priceDisplay = serverPricing ? `${serverPricing.radius_km}km  ${serverPricing.m1u} M1U` : "Loading...";
  const isDisabled = !isAuthenticated || isProcessing || pricingLoading;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      className: "fixed left-1/2 transform -translate-x-1/2 z-50",
      style: {
        bottom: "clamp(16px, 3vh, 28px)",
        transform: "translateX(-50%)"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.button,
        {
          "data-onboarding": "buzz-map-button",
          whileTap: { scale: isAuthenticated ? 0.97 : 1 },
          disabled: isDisabled,
          onClick: handleBuzzMapPress,
          className: "relative border-0 bg-transparent p-0 z-20",
          style: { cursor: isDisabled ? "not-allowed" : "pointer" },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `tron-disc tron-disc-red ${isDisabled ? "opacity-50" : ""}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tron-disc-rotating", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `tron-led-ring ${isProcessing ? "loading" : ""}` }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tron-disc-dots" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tron-disc-dots-sides" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tron-disc-content", children: isProcessing || pricingLoading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center space-y-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tron-loading-spinner", style: { inset: "30%" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold text-white/80", style: {
                fontFamily: "Orbitron, sans-serif",
                fontSize: "clamp(8px, 2vw, 10px)",
                letterSpacing: "0.05em"
              }, children: "PROCESSING" })
            ] }) : !isAuthenticated ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center space-y-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Lock, { className: "w-6 h-6 text-white/60" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold text-white/60", style: {
                fontFamily: "Orbitron, sans-serif",
                fontSize: "clamp(8px, 2vw, 10px)",
                letterSpacing: "0.05em"
              }, children: "LOGIN" })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-white", style: {
                fontFamily: "Orbitron, sans-serif",
                fontSize: "clamp(12px, 3vw, 16px)",
                letterSpacing: "0.05em",
                textShadow: "0 0 10px rgba(255, 51, 51, 0.8), 0 0 20px rgba(255, 51, 51, 0.4)"
              }, children: "BUZZ MAP" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-white/90 mt-0.5", style: {
                fontFamily: "Orbitron, sans-serif",
                fontSize: "clamp(8px, 2vw, 11px)",
                letterSpacing: "0.03em"
              }, children: priceDisplay })
            ] }) })
          ] })
        }
      )
    }
  ) });
};

const PortalContainer = ({ portalCount = 12, onPortalAction }) => {
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const portals = [
    { id: "all", label: "All Portals", icon: Target, color: "from-cyan-500 to-purple-600" }
  ];
  const [activeFilters, setActiveFilters] = reactExports.useState(/* @__PURE__ */ new Set(["ALL"]));
  const handlePortalClick = (portalId) => {
    onPortalAction?.(portalId);
    const newFilters = new Set(activeFilters);
    const filterKey = "ALL";
    if (newFilters.has(filterKey)) {
      newFilters.delete(filterKey);
    } else {
      newFilters.clear();
      newFilters.add(filterKey);
    }
    setActiveFilters(newFilters);
    const enabled = newFilters.has(filterKey);
    const event = new CustomEvent("M1_PORTAL_FILTER", {
      detail: { type: "ALL", enabled }
    });
    window.dispatchEvent(event);
  };
  const toggleDrawer = () => {
    setIsOpen(!isOpen);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    !isOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: toggleDrawer,
        className: "portal-pill-centered",
        "aria-label": "Open PORTALS menu",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "portal-pill-label", children: "PORTALS" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "portal-pill-badge", children: portalCount })
        ]
      }
    ),
    isOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-drawer-centered", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-drawer-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "portal-drawer-title", children: "PORTALS" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "portal-drawer-badge", children: portalCount })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "ghost",
            size: "sm",
            onClick: toggleDrawer,
            className: "portal-drawer-close",
            "aria-label": "Close PORTALS menu",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { className: "w-4 h-4" })
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "portal-drawer-grid", children: portals.map((portal) => {
        const Icon = portal.icon;
        const isActive = activeFilters.has("ALL");
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => handlePortalClick(portal.id),
            className: `portal-button ${isActive ? "portal-button-active" : ""}`,
            "data-portal-type": portal.id,
            "aria-label": `Toggle all portals`,
            "aria-pressed": isActive,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `portal-button-gradient bg-gradient-to-br ${portal.color} ${isActive ? "opacity-100" : "opacity-50"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "w-5 h-5" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "portal-button-label", children: portal.label })
            ]
          },
          portal.id
        );
      }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "portal-drawer-footer", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-cyan-400/60", children: "Click per mostrare/nascondere tutti i portali" }) })
    ] })
  ] });
};

const useBuzzMapLogic = () => {
  const { user } = useAuthContext();
  const [currentWeekAreas, setCurrentWeekAreas] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState(null);
  const fetchCurrentWeekAreas = async () => {
    if (!user?.id) {
      setCurrentWeekAreas([]);
      return;
    }
    setLoading(true);
    try {
      const { data: gameTargets, error: targetError } = await supabase.from("buzz_game_targets").select("*").eq("is_active", true);
      if (targetError) {
        setError(targetError);
        setCurrentWeekAreas([]);
        setLoading(false);
        return;
      }
      const validTargets = gameTargets?.filter(
        (target) => target.lat && target.lon && target.lat !== 0 && target.lon !== 0 && Math.abs(target.lat) <= 90 && Math.abs(target.lon) <= 180
      ) || [];
      if (validTargets.length === 0) {
        setCurrentWeekAreas([]);
        setLoading(false);
        return;
      }
      const currentWeek = getCurrentWeekOfYear();
      const { data: userAreas, error: userAreasError } = await supabase.from("user_map_areas").select("*").eq("user_id", user.id).eq("source", "buzz_map").eq("week", currentWeek).order("created_at", { ascending: false }).limit(1);
      if (userAreasError) {
        setError(userAreasError);
        setCurrentWeekAreas([]);
        setLoading(false);
        return;
      }
      if (!userAreas || userAreas.length === 0) {
        setCurrentWeekAreas([]);
        setLoading(false);
        return;
      }
      const transformedAreas = userAreas.map((area, index) => {
        const lat = area.center_lat ?? area.lat;
        const lng = area.center_lng ?? area.lng;
        if ((area.lat === null || area.lat === void 0) && area.center_lat !== null && area.center_lat !== void 0) {
        }
        if ((area.lng === null || area.lng === void 0) && area.center_lng !== null && area.center_lng !== void 0) {
        }
        return {
          id: area.id,
          lat,
          lng,
          radius_km: area.radius_km,
          level: area.level,
          //  M1-3D VERIFY: Track level from DB
          coordinates: { lat, lng },
          radius: area.radius_km * 1e3,
          // Convert to meters for map display
          color: "#00FFFF",
          colorName: "cyan",
          week: area.week || currentWeek,
          generation: index + 1,
          isActive: true,
          user_id: area.user_id,
          created_at: area.created_at || (/* @__PURE__ */ new Date()).toISOString()
        };
      });
      setCurrentWeekAreas(transformedAreas);
      setError(null);
    } catch (err) {
      setError(err);
      setCurrentWeekAreas([]);
    } finally {
      setLoading(false);
    }
  };
  const reloadAreas = async () => {
    await fetchCurrentWeekAreas();
  };
  reactExports.useEffect(() => {
    const handleMissionReset = () => {
      setCurrentWeekAreas([]);
      try {
        localStorage.removeItem("map-search-areas");
        localStorage.removeItem("map-markers");
        localStorage.removeItem("dev-map-points");
        localStorage.removeItem("buzz_map_5km_warning_shown");
      } catch (e) {
      }
      setTimeout(() => fetchCurrentWeekAreas(), 500);
    };
    window.addEventListener("missionLaunched", handleMissionReset);
    window.addEventListener("missionReset", handleMissionReset);
    window.addEventListener("mission:reset", handleMissionReset);
    return () => {
      window.removeEventListener("missionLaunched", handleMissionReset);
      window.removeEventListener("missionReset", handleMissionReset);
      window.removeEventListener("mission:reset", handleMissionReset);
    };
  }, []);
  reactExports.useEffect(() => {
    fetchCurrentWeekAreas();
    if (user?.id) {
      const channel = supabase.channel("user_map_areas_changes").on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "user_map_areas",
          filter: `user_id=eq.${user.id}`
        },
        (payload) => {
          fetchCurrentWeekAreas();
          if (payload.new) {
            const lat = payload.new.center_lat ?? payload.new.lat;
            const lng = payload.new.center_lng ?? payload.new.lng;
            window.dispatchEvent(new CustomEvent("buzzAreaCreated", {
              detail: {
                lat,
                lng,
                radius_km: payload.new.radius_km
              }
            }));
          }
        }
      ).subscribe((status) => {
        if (status === "SUBSCRIBED") {
          emitSubscribed("user_map_areas_changes");
        } else if (status === "CHANNEL_ERROR" || status === "TIMED_OUT") {
          emitError(String(status), "user_map_areas_changes");
        }
      });
      return () => {
        channel.unsubscribe();
      };
    }
  }, [user?.id]);
  return {
    areas: currentWeekAreas,
    loading,
    error: error || new Error("No error"),
    currentWeekAreas,
    reloadAreas
  };
};

const UPDATE_INTERVAL_MS = 3e4;
const MIN_DISTANCE_METERS = 10;
function calculateDistance(pos1, pos2) {
  const R = 6371e3;
  const 1 = pos1.lat * Math.PI / 180;
  const 2 = pos2.lat * Math.PI / 180;
  const  = (pos2.lat - pos1.lat) * Math.PI / 180;
  const  = (pos2.lng - pos1.lng) * Math.PI / 180;
  const a = Math.sin( / 2) * Math.sin( / 2) + Math.cos(1) * Math.cos(2) * Math.sin( / 2) * Math.sin( / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}
async function upsertAgentLocation(userId, position) {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session?.user?.id) {
      return;
    }
    const { error } = await supabase.rpc("set_my_agent_location", {
      p_lat: position.lat,
      p_lng: position.lng,
      p_accuracy: position.acc,
      p_status: "online"
    });
    if (error) {
      if (error.code === "406" || error.message?.includes("406") || error.message?.includes("Not Acceptable")) {
        return;
      }
      if (error.code === "PGRST202" || error.message?.includes("Could not find the function")) {
        return;
      }
      if (error.code === "PGRST116" || error.code === "42P01" || error.code === "PGRST301") {
        return;
      }
    } else {
    }
  } catch (e) {
  }
}
function useAgentLocationUpdater(position, enabled) {
  const { user } = useUnifiedAuth();
  const lastPositionRef = reactExports.useRef(null);
  const lastUpdateRef = reactExports.useRef(0);
  reactExports.useEffect(() => {
    if (!user?.id || !enabled || !position) {
      return;
    }
    const now = Date.now();
    const timeSinceLastUpdate = now - lastUpdateRef.current;
    let shouldUpdate = timeSinceLastUpdate >= UPDATE_INTERVAL_MS;
    if (lastPositionRef.current && timeSinceLastUpdate < UPDATE_INTERVAL_MS) {
      const distance = calculateDistance(lastPositionRef.current, position);
      if (distance >= MIN_DISTANCE_METERS) {
        shouldUpdate = true;
      }
    } else if (!lastPositionRef.current) {
      shouldUpdate = true;
    }
    if (shouldUpdate) {
      upsertAgentLocation(user.id, position);
      lastPositionRef.current = position;
      lastUpdateRef.current = now;
    }
  }, [user?.id, position, enabled]);
  reactExports.useEffect(() => {
    if (!user?.id) return;
    return () => {
      (async () => {
        try {
          await supabase.rpc("set_my_agent_location", {
            p_lat: lastPositionRef.current?.lat || 0,
            p_lng: lastPositionRef.current?.lng || 0,
            p_accuracy: null,
            p_status: "offline"
          });
        } catch (e) {
        }
      })();
    };
  }, [user?.id]);
}

async function getLivePortals() {
  return [];
}
async function getLiveEvents() {
  return [];
}
async function getLiveAgents() {
  try {
    const { supabase } = await __vitePreload(async () => { const { supabase } = await import('./index.BEQCqgv7.js').then(n => n.bU);return { supabase }},true?__vite__mapDeps([0,1,2,3,4,5,6,7,8,9]):void 0);
    const { data: { session } } = await supabase.auth.getSession();
    const { data: locations, error: locError } = await supabase.from("user_locations").select("user_id, lat, lng, accuracy, status, updated_at").not("lat", "is", null).not("lng", "is", null).order("updated_at", { ascending: false }).limit(100);
    if (locError) {
      return [];
    }
    if (!locations || locations.length === 0) {
      return [];
    }
    const userIds = locations.map((l) => l.user_id);
    const { data: profiles } = await supabase.from("profiles").select("id, full_name, agent_code, rank_id").in("id", userIds);
    const profileMap = new Map(
      profiles?.map((p) => [
        p.id,
        {
          full_name: p.full_name,
          agent_code: p.agent_code,
          rank_id: p.rank_id
        }
      ]) || []
    );
    const fifteenMinutesAgo = new Date(Date.now() - 15 * 60 * 1e3).toISOString();
    const agents = locations.map((row) => {
      const profile = profileMap.get(row.user_id);
      const isRecent = row.updated_at && row.updated_at > fifteenMinutesAgo;
      return {
        id: row.user_id,
        lat: row.lat,
        lng: row.lng,
        username: profile?.full_name || profile?.agent_code || "Agent",
        status: isRecent ? "online" : "offline",
        lastSeen: row.updated_at,
        agent_code: profile?.agent_code,
        rank_id: profile?.rank_id
      };
    });
    return agents;
  } catch (e) {
    return [];
  }
}
async function getControlZones() {
  return [];
}
function onPortalsChanged(callback) {
  return () => {
  };
}
function onEventsChanged(callback) {
  return () => {
  };
}
function onAgentsChanged(callback) {
  let channelCleanup = null;
  (async () => {
    try {
      const { supabase } = await __vitePreload(async () => { const { supabase } = await import('./index.BEQCqgv7.js').then(n => n.bU);return { supabase }},true?__vite__mapDeps([0,1,2,3,4,5,6,7,8,9]):void 0);
      const channel = supabase.channel("user-locations-live").on("postgres_changes", {
        event: "*",
        schema: "public",
        table: "user_locations"
      }, async () => {
        const agents = await getLiveAgents();
        callback(agents);
      }).subscribe();
      channelCleanup = () => {
        supabase.removeChannel(channel);
      };
    } catch (e) {
    }
  })();
  return () => {
    if (channelCleanup) {
      channelCleanup();
    }
  };
}

function useLiveLayers(enabled = true) {
  const [state, setState] = reactExports.useState({
    portals: [],
    events: [],
    agents: [],
    zones: [],
    loading: true
  });
  const throttleRef = reactExports.useRef({});
  const throttledUpdate = reactExports.useCallback((key, updateFn) => {
    const now = Date.now();
    const lastUpdate = throttleRef.current[key] || 0;
    if (now - lastUpdate > 250) {
      throttleRef.current[key] = now;
      updateFn();
    }
  }, []);
  reactExports.useEffect(() => {
    if (!enabled) return;
    let mounted = true;
    Promise.all([
      getLivePortals(),
      getLiveEvents(),
      getLiveAgents(),
      getControlZones()
    ]).then(([portals, events, agents, zones]) => {
      if (mounted) {
        setState({
          portals,
          events,
          agents,
          zones,
          loading: false
        });
      }
    });
    const unsubPortals = onPortalsChanged();
    const unsubEvents = onEventsChanged();
    const unsubAgents = onAgentsChanged((agents) => {
      if (mounted) {
        throttledUpdate("agents", () => {
          setState((prev) => ({ ...prev, agents }));
        });
      }
    });
    return () => {
      mounted = false;
      unsubPortals();
      unsubEvents();
      unsubAgents();
    };
  }, [enabled, throttledUpdate]);
  return state;
}

const byteToHex = [];
for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] +
        byteToHex[arr[offset + 1]] +
        byteToHex[arr[offset + 2]] +
        byteToHex[arr[offset + 3]] +
        '-' +
        byteToHex[arr[offset + 4]] +
        byteToHex[arr[offset + 5]] +
        '-' +
        byteToHex[arr[offset + 6]] +
        byteToHex[arr[offset + 7]] +
        '-' +
        byteToHex[arr[offset + 8]] +
        byteToHex[arr[offset + 9]] +
        '-' +
        byteToHex[arr[offset + 10]] +
        byteToHex[arr[offset + 11]] +
        byteToHex[arr[offset + 12]] +
        byteToHex[arr[offset + 13]] +
        byteToHex[arr[offset + 14]] +
        byteToHex[arr[offset + 15]]).toLowerCase();
}

let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    if (!getRandomValues) {
        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {
            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
        getRandomValues = crypto.getRandomValues.bind(crypto);
    }
    return getRandomValues(rnds8);
}

const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = { randomUUID };

function v4(options, buf, offset) {
    if (native.randomUUID && true && !options) {
        return native.randomUUID();
    }
    options = options || {};
    const rnds = options.random ?? options.rng?.() ?? rng();
    if (rnds.length < 16) {
        throw new Error('Random bytes length must be >= 16');
    }
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;
    return unsafeStringify(rnds);
}

function safeLatLng(e) {
  try {
    const ll = e?.latlng;
    if (ll && Number.isFinite(ll.lat) && Number.isFinite(ll.lng)) {
      return { lat: ll.lat, lng: ll.lng };
    }
  } catch {
  }
  return null;
}

function useSearchAreasLogic(defaultLocation) {
  const DEV_MOCKS = false;
  const [storageAreas, setStorageAreas] = useLocalStorage("map-search-areas", []);
  const [searchAreas, setSearchAreas] = reactExports.useState([]);
  const [activeSearchArea, setActiveSearchArea] = reactExports.useState(null);
  const [isAddingSearchArea, setIsAddingSearchArea] = reactExports.useState(false);
  const pendingRadiusRef = reactExports.useRef(500);
  const [searchAreasThisWeek, setSearchAreasThisWeek] = reactExports.useState(0);
  const [isLoading, setIsLoading] = reactExports.useState(true);
  const forceReloadAreas = async () => {
    try {
      const { data: sessionData } = await supabase.auth.getSession();
      if (!sessionData?.session?.user?.id) {
        setSearchAreas(storageAreas || []);
        setIsLoading(false);
        return;
      }
      const { data: areasData, error } = await supabase.from("search_areas").select("*").eq("user_id", sessionData.session.user.id).order("created_at", { ascending: false });
      if (error) {
        setSearchAreas(storageAreas || []);
        setIsLoading(false);
        return;
      }
      if (areasData && areasData.length > 0) {
        const areas = areasData.map((area) => ({
          id: area.id,
          lat: area.lat,
          lng: area.lng,
          radius: area.radius,
          label: area.label || `Area di ricerca`,
          position: { lat: area.lat, lng: area.lng },
          color: "#00f0ff"
        }));
        setSearchAreas(areas);
        setSearchAreasThisWeek(areasData.length);
      } else {
        setSearchAreas([]);
      }
    } catch (error) {
      setSearchAreas(storageAreas || []);
    } finally {
      setIsLoading(false);
    }
  };
  reactExports.useEffect(() => {
    forceReloadAreas();
  }, []);
  reactExports.useEffect(() => {
    const handleMissionReset = () => {
      setSearchAreas([]);
      setStorageAreas([]);
      setActiveSearchArea(null);
      setSearchAreasThisWeek(0);
      try {
        localStorage.removeItem("map-search-areas");
      } catch (e) {
      }
    };
    window.addEventListener("missionLaunched", handleMissionReset);
    window.addEventListener("missionReset", handleMissionReset);
    window.addEventListener("mission:reset", handleMissionReset);
    return () => {
      window.removeEventListener("missionLaunched", handleMissionReset);
      window.removeEventListener("missionReset", handleMissionReset);
      window.removeEventListener("mission:reset", handleMissionReset);
    };
  }, [setStorageAreas]);
  reactExports.useEffect(() => {
    if (!isLoading && searchAreas.length >= 0) {
      setStorageAreas(searchAreas);
    }
  }, [searchAreas, setStorageAreas, isLoading]);
  const calculateRadius = () => {
    const baseRadius = 1e5;
    const decreaseFactor = Math.pow(0.95, searchAreasThisWeek);
    const calculatedRadius = Math.max(5e3, baseRadius * decreaseFactor);
    return calculatedRadius;
  };
  const handleAddArea = (radius) => {
    const calculatedRadius = radius || calculateRadius();
    pendingRadiusRef.current = calculatedRadius;
    setIsAddingSearchArea(true);
    ue.info("Clicca sulla mappa per aggiungere una nuova area di ricerca", {
      description: `L'area sar creata con il raggio di ${(pendingRadiusRef.current / 1e3).toFixed(1)} km`
    });
  };
  const handleMapClickArea = async (e) => {
    if (!isAddingSearchArea) {
      return;
    }
    const ll = safeLatLng(e);
    if (!ll) {
      return;
    }
    try {
      const lat = ll.lat;
      const lng = ll.lng;
      const radius = pendingRadiusRef.current;
      if (false) ;
      const { data: sessionData } = await supabase.auth.getSession();
      if (!sessionData?.session?.user) {
        if (DEV_MOCKS) ;
        ue.error("Utente non autenticato");
        setIsAddingSearchArea(false);
        return;
      }
      const userId = sessionData.session.user.id;
      const newArea = {
        id: v4(),
        lat,
        lng,
        radius,
        label: `Area di ricerca ${searchAreasThisWeek + 1}`,
        color: "#00f0ff",
        position: { lat, lng }
      };
      const { data, error } = await supabase.from("search_areas").insert({
        user_id: userId,
        lat,
        lng,
        radius,
        label: newArea.label
      }).select().single();
      if (error) {
        if (DEV_MOCKS) ;
        ue.error("Si  verificato un errore nel salvare l'area di ricerca");
        setIsAddingSearchArea(false);
        return;
      }
      if (data) newArea.id = data.id;
      setSearchAreasThisWeek((prev) => prev + 1);
      setSearchAreas((prevAreas) => [...prevAreas, newArea]);
      setActiveSearchArea(newArea.id);
      setIsAddingSearchArea(false);
      ue.success("Area di ricerca aggiunta alla mappa", { description: `Raggio: ${(radius / 1e3).toFixed(1)} km` });
      setTimeout(() => {
        forceReloadAreas();
      }, 500);
    } catch (error) {
      setIsAddingSearchArea(false);
      ue.error("Si  verificato un errore nell'aggiunta dell'area");
    }
  };
  const saveSearchArea = (id, label, radius) => {
    setSearchAreas(searchAreas.map(
      (area) => area.id === id ? { ...area, label, radius } : area
    ));
    ue.success("Area di ricerca aggiornata");
  };
  const deleteSearchArea = async (id) => {
    try {
      const { error } = await supabase.from("search_areas").delete().eq("id", id);
      if (error) {
        if (DEV_MOCKS) ;
        ue.error("Errore nell'eliminare l'area di ricerca");
        return false;
      }
      setSearchAreas((prevAreas) => {
        const filteredAreas = prevAreas.filter((area) => area.id !== id);
        return filteredAreas;
      });
      if (activeSearchArea === id) {
        setActiveSearchArea(null);
      }
      ue.success("Area di ricerca rimossa");
      setTimeout(() => {
        forceReloadAreas();
      }, 300);
      return true;
    } catch (error) {
      ue.error("Errore nell'eliminare l'area di ricerca");
      return false;
    }
  };
  const clearAllSearchAreas = () => {
    setSearchAreas([]);
    setActiveSearchArea(null);
    ue.success("Tutte le aree di ricerca sono state rimosse");
  };
  const toggleAddingSearchArea = () => {
    setIsAddingSearchArea((prev) => !prev);
    if (!isAddingSearchArea) {
      const radius = calculateRadius();
      pendingRadiusRef.current = radius;
      ue.info(`Clicca sulla mappa per creare un'area di ricerca (raggio: ${(radius / 1e3).toFixed(1)}km)`);
    }
  };
  return {
    searchAreas,
    setSearchAreas,
    activeSearchArea,
    setActiveSearchArea,
    isAddingSearchArea,
    setIsAddingSearchArea,
    handleAddArea,
    handleMapClickArea,
    saveSearchArea,
    deleteSearchArea,
    clearAllSearchAreas,
    toggleAddingSearchArea,
    isLoading,
    forceReloadAreas,
    // Export for manual refresh
    setPendingRadius: (radius) => {
      pendingRadiusRef.current = radius;
    }
  };
}

function useMapMarkersLogic() {
  const [storageMarkers, setStorageMarkers] = useLocalStorage("map-markers", []);
  const [markers, setMarkers] = reactExports.useState(storageMarkers || []);
  const [activeMarker, setActiveMarker] = reactExports.useState(null);
  const [isAddingMarker, setIsAddingMarker] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setStorageMarkers(markers);
  }, [markers, setStorageMarkers]);
  const handleAddMarker = () => {
    setIsAddingMarker(true);
    ue.info("Clicca sulla mappa per aggiungere un nuovo punto", {
      description: "Potrai aggiungere una nota al punto dopo averlo creato"
    });
  };
  const handleMapClickMarker = (e) => {
    if (isAddingMarker && e.latLng) {
      try {
        const lat = e.latLng.lat();
        const lng = e.latLng.lng();
        const newMarker = {
          id: v4(),
          lat,
          lng,
          title: "",
          // Add the title property
          note: "",
          position: { lat, lng },
          createdAt: /* @__PURE__ */ new Date()
        };
        setMarkers((prev) => [...prev, newMarker]);
        setActiveMarker(newMarker.id);
        setIsAddingMarker(false);
        ue.success("Punto aggiunto alla mappa", {
          description: "Clicca sul punto per aggiungere una nota"
        });
      } catch (error) {
        setIsAddingMarker(false);
        ue.error("Si  verificato un errore durante l'aggiunta del punto");
      }
    }
  };
  const saveMarkerNote = (id, note) => {
    setMarkers(markers.map(
      (marker) => marker.id === id ? { ...marker, note, editing: false } : marker
    ));
    ue.success("Nota salvata");
  };
  const deleteMarker = (id) => {
    setMarkers(markers.filter((marker) => marker.id !== id));
    if (activeMarker === id) setActiveMarker(null);
    ue.success("Punto rimosso dalla mappa");
  };
  const editMarker = (id) => {
    setMarkers(markers.map(
      (marker) => marker.id === id ? { ...marker, editing: true } : marker
    ));
    setActiveMarker(id);
  };
  const clearAllMarkers = () => {
    if (confirm("Sei sicuro di voler eliminare tutti i punti?")) {
      setMarkers([]);
      setActiveMarker(null);
      ue.success("Tutti i punti sono stati rimossi");
    }
  };
  return {
    markers,
    setMarkers,
    activeMarker,
    setActiveMarker,
    isAddingMarker,
    setIsAddingMarker,
    handleAddMarker,
    handleMapClickMarker,
    saveMarkerNote,
    deleteMarker,
    editMarker,
    clearAllMarkers
  };
}

const AgentsLayer3D = ({ map, enabled, agents: agentsProp, mePosition, currentUserId, onAgentClick }) => {
  const [agents, setAgents] = reactExports.useState([]);
  const [positions, setPositions] = reactExports.useState(/* @__PURE__ */ new Map());
  const augmentedAgents = reactExports.useMemo(() => {
    const result = [...agents];
    if (mePosition) {
      const myAgentIndex = currentUserId ? result.findIndex((a) => a.id === currentUserId) : -1;
      if (myAgentIndex >= 0) {
        result[myAgentIndex] = {
          ...result[myAgentIndex],
          lat: mePosition.lat,
          lng: mePosition.lng,
          status: "online",
          lastSeen: (/* @__PURE__ */ new Date()).toISOString()
        };
      } else {
        const existingMeIndex = result.findIndex((a) => a.id === "me-local");
        if (existingMeIndex >= 0) {
          result[existingMeIndex] = {
            ...result[existingMeIndex],
            lat: mePosition.lat,
            lng: mePosition.lng,
            status: "online",
            lastSeen: (/* @__PURE__ */ new Date()).toISOString()
          };
        } else {
          result.push({
            id: "me-local",
            lat: mePosition.lat,
            lng: mePosition.lng,
            username: "Tu",
            status: "online",
            lastSeen: (/* @__PURE__ */ new Date()).toISOString()
          });
        }
      }
    }
    return result;
  }, [agents, mePosition?.lat, mePosition?.lng, currentUserId]);
  reactExports.useEffect(() => {
    if (!enabled) return;
    if (agentsProp) {
      setAgents(agentsProp);
    } else {
      getLiveAgents().then(setAgents);
      const unsubscribe = onAgentsChanged(setAgents);
      return () => unsubscribe();
    }
  }, [enabled, agentsProp]);
  const rafRef = React.useRef(null);
  reactExports.useEffect(() => {
    if (!map || !enabled) return;
    const updatePositions = () => {
      const newPositions = /* @__PURE__ */ new Map();
      augmentedAgents.forEach((agent) => {
        try {
          const point = map.project([agent.lng, agent.lat]);
          newPositions.set(agent.id, { x: point.x, y: point.y });
        } catch (e) {
        }
      });
      setPositions(newPositions);
    };
    const updateOnRender = () => {
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
      rafRef.current = requestAnimationFrame(updatePositions);
    };
    updatePositions();
    map.on("move", updatePositions);
    map.on("zoom", updatePositions);
    map.on("resize", updatePositions);
    map.on("render", updateOnRender);
    return () => {
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
      map.off("move", updatePositions);
      map.off("zoom", updatePositions);
      map.off("resize", updatePositions);
      map.off("render", updateOnRender);
    };
  }, [map, augmentedAgents, enabled]);
  if (!enabled || augmentedAgents.length === 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 pointer-events-none", style: { zIndex: 650 }, children: augmentedAgents.map((agent) => {
    const pos = positions.get(agent.id);
    if (!pos) return null;
    const isMe = agent.id === "me-local" || currentUserId && agent.id === currentUserId;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "absolute pointer-events-auto cursor-pointer",
        style: {
          left: `${pos.x}px`,
          top: `${pos.y}px`,
          transform: "translate(-50%, -50%)",
          //  NO transition - marker agganciato alla mappa senza lag
          willChange: "left, top"
          // GPU acceleration hint
        },
        onClick: () => onAgentClick?.(agent),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: isMe ? "m1-agent-dot m1-agent-dot--me" : "m1-agent-dot",
              title: isMe ? "Tu (la tua posizione)" : agent.username
            }
          ),
          isMe && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "absolute -bottom-5 left-1/2 -translate-x-1/2 text-[10px] font-bold text-cyan-400 whitespace-nowrap",
              style: { textShadow: "0 0 4px rgba(0,0,0,0.8)" },
              children: "TU"
            }
          )
        ]
      },
      agent.id
    );
  }) });
};

const PORTALS_SEED = [
  { id: "p_tokyo", name: "Portal  Tokyo", lat: 35.6762, lng: 139.6503 },
  { id: "p_osaka", name: "Portal  Osaka", lat: 34.6937, lng: 135.5023 },
  { id: "p_hk", name: "Portal  Hong Kong", lat: 22.3193, lng: 114.1694 },
  { id: "p_bali", name: "Portal  Bali", lat: -8.3405, lng: 115.092 },
  { id: "p_png", name: "Portal  PNG", lat: -6.314993, lng: 143.95555 },
  { id: "p_madrid", name: "Portal  Madrid", lat: 40.4168, lng: -3.7038 },
  { id: "p_paris", name: "Portal  Paris", lat: 48.8566, lng: 2.3522 },
  { id: "p_nice", name: "Portal  Nice", lat: 43.7102, lng: 7.262 },
  { id: "p_tripoli", name: "Portal  Tripoli", lat: 32.8872, lng: 13.1913 },
  { id: "p_dubai", name: "Portal  Dubai", lat: 25.2048, lng: 55.2708 },
  { id: "p_la", name: "Portal  LA", lat: 34.0522, lng: -118.2437 },
  { id: "p_reyk", name: "Portal  Reykjavik", lat: 64.1466, lng: -21.9426 }
];

const ECHO_LORE_FRAGMENTS = [
  '"The map remembers what you forgot."',
  '"Signal 7.26 was never decoded."',
  '"They built the grid before the city."',
  '"One prize was hidden twice."',
  '"The coordinates shift at midnight."'
];
const LOST_FREQUENCY_PUZZLES = [
  '"Decode this frequency."  Signal: 7.26.M1',
  '"What has keys but opens no locks?"  An old signal from ECHO.',
  '"I speak without a mouth. I hear without ears."  Interference pattern detected.',
  '"The more you take, the more you leave behind."  Shadow trace incomplete.'
];
const PORTAL_BEHAVIORS = [
  //  1. NICE  MCP PROTECTED ACCESS 
  {
    id: "p_nice",
    cityLabel: "Portal  Nice",
    type: "MCP_PROTECTED",
    requirement: {
      type: "buzz_count",
      minBuzz: 5,
      minBuzzMap: 1,
      label: "ACCESS LEVEL 04 REQUIRED"
    },
    dialogueUnlocked: [
      { entity: "MCP", lines: ["ACCESS LEVEL 04 CONFIRMED.", "Classified reward unlocked."] }
    ],
    dialogueLocked: [
      { entity: "MCP", lines: ["ACCESS LEVEL 04 REQUIRED.", "Only agents with sufficient activity may enter."] }
    ],
    reward: {
      type: "random",
      // +100 M1U OR 1 free clue
      amount: 100,
      label: "+100 M1U or 1 FREE CLUE",
      visualOnly: true
    },
    effects: { glitch: "light" }
  },
  //  2. PARIS  SHADOW RED ZONE 
  {
    id: "p_paris",
    cityLabel: "Portal  Paris",
    type: "SHADOW_RED_ZONE",
    dialogueUnlocked: [
      { entity: "SHADOW", lines: ["You should not be here, Agent."] }
    ],
    reward: {
      type: "hint",
      label: "+1 clue fragment detected...",
      visualOnly: true
    },
    effects: { glitch: "heavy" }
  },
  //  3. TRIPOLI  GEOGRAPHIC VORTEX 
  {
    id: "p_tripoli",
    cityLabel: "Portal  Tripoli",
    type: "GEO_VORTEX",
    dialogueUnlocked: [
      { entity: "MCP", lines: ["Geospatial anomaly detected.", "Re-aligning coordinates..."] }
    ],
    effects: { cameraSwirl: true, glitch: "light" }
  },
  //  4. MADRID  PULSE BREAKER (PLACEHOLDER) 
  {
    id: "p_madrid",
    cityLabel: "Portal  Madrid",
    type: "PULSE_BREAKER",
    dialogueUnlocked: [
      { entity: "MCP", lines: ["Pulse Breaker prototype.", "Full module coming soon."] }
    ],
    effects: { glitch: "light" }
  },
  //  5. REYKJAVIK  ECHO ARCHIVE 
  {
    id: "p_reyk",
    cityLabel: "Portal  Reykjavik",
    type: "ECHO_ARCHIVE",
    dialogueUnlocked: [
      { entity: "ECHO", lines: ["Accessing discontinued data fragments"] }
    ],
    loreFragments: ECHO_LORE_FRAGMENTS,
    effects: { glitch: "light", audio: "static" }
  },
  //  6. DUBAI  SHADOW INTERFERENCE FIELD 
  {
    id: "p_dubai",
    cityLabel: "Portal  Dubai",
    type: "SHADOW_INTERFERENCE",
    dialogueUnlocked: [
      { entity: "SHADOW", lines: ["Signal compromised.", "Compensation granted."] }
    ],
    reward: {
      type: "m1u",
      amount: 20,
      label: "+20 M1U",
      visualOnly: true
    },
    effects: { glitch: "heavy" }
  },
  //  7. HONG KONG  GLOBAL GLITCH LOCKDOWN 
  {
    id: "p_hk",
    cityLabel: "Portal  Hong Kong",
    type: "GLOBAL_GLITCH_LOCKDOWN",
    dialogueUnlocked: [
      { entity: "SHADOW", lines: ["System lockdown initiated."] }
    ],
    effects: { glitch: "global", lockdown: 60 }
  },
  //  8. BALI  AGENT MIRROR 
  {
    id: "p_bali",
    cityLabel: "Portal  Bali",
    type: "AGENT_MIRROR",
    dialogueUnlocked: [
      { entity: "MCP", lines: ["Your path is unfolding.", "Observe carefully."] }
    ],
    effects: {}
  },
  //  9. OSAKA  THE LOST FREQUENCY 
  {
    id: "p_osaka",
    cityLabel: "Portal  Osaka",
    type: "LOST_FREQUENCY",
    dialogueUnlocked: [
      { entity: "SHADOW", lines: ["You shouldn't have tuned this frequency."] }
    ],
    puzzles: LOST_FREQUENCY_PUZZLES,
    effects: { glitch: "heavy", audio: "radio" }
  },
  //  10. PNG  GATEWAY TO MISSION ZERO 
  {
    id: "p_png",
    cityLabel: "Portal  Papua New Guinea",
    type: "GATEWAY_ZERO",
    dialogueUnlocked: [
      { entity: "MCP", lines: ["Gateway sealed. Protocol Zero pending."] },
      { entity: "SHADOW", lines: ["You're not ready."] }
    ],
    effects: { glitch: "heavy" }
  },
  //  11. LA  HOLLYWOOD GATE 
  {
    id: "p_la",
    cityLabel: "Portal  Los Angeles",
    type: "HOLLYWOOD_GATE",
    requirement: {
      type: "buzz_map_count",
      minBuzzMap: 19,
      label: "ACCESS LEVEL 19 REQUIRED"
    },
    dialogueUnlocked: [
      { entity: "MCP", lines: ["Hollywood Gate  Coming Soon."] }
    ],
    dialogueLocked: [
      { entity: "MCP", lines: ["ACCESS DENIED  Level 19 required.", "Create more BUZZ MAP areas to unlock."] }
    ],
    effects: { glitch: "light" }
  },
  //  12. TOKYO  SHADOW NEXUS 
  {
    id: "p_tokyo",
    cityLabel: "Portal  Tokyo",
    type: "SHADOW_NEXUS",
    dialogueUnlocked: [
      { entity: "SHADOW", lines: ["Convergence point detected."] },
      { entity: "ECHO", lines: ["...signals converge here...", "...be careful what you seek..."] }
    ],
    effects: { glitch: "heavy", audio: "static" }
  }
];
function getPortalBehavior(portalId) {
  return PORTAL_BEHAVIORS.find((p) => p.id === portalId);
}
function getRandomLoreFragment(portalId) {
  const config = getPortalBehavior(portalId);
  if (!config?.loreFragments?.length) return "";
  return config.loreFragments[Math.floor(Math.random() * config.loreFragments.length)];
}
function getRandomPuzzle(portalId) {
  const config = getPortalBehavior(portalId);
  if (!config?.puzzles?.length) return "";
  return config.puzzles[Math.floor(Math.random() * config.puzzles.length)];
}
function getRandomNiceReward() {
  const random = Math.random();
  if (random > 0.5) {
    return { type: "m1u", label: "+100 M1U" };
  }
  return { type: "clue", label: "1 FREE CLUE" };
}

const STORAGE_KEY_BUZZ_COUNT = "m1ssion_portal_buzz_count";
const STORAGE_KEY_BUZZ_MAP_COUNT = "m1ssion_portal_buzz_map_count";
function useActivityTracker() {
  const [buzzCount, setBuzzCount] = reactExports.useState(0);
  const [buzzMapCount, setBuzzMapCount] = reactExports.useState(0);
  reactExports.useEffect(() => {
    const storedBuzz = localStorage.getItem(STORAGE_KEY_BUZZ_COUNT);
    const storedBuzzMap = localStorage.getItem(STORAGE_KEY_BUZZ_MAP_COUNT);
    if (storedBuzz) setBuzzCount(parseInt(storedBuzz, 10) || 0);
    if (storedBuzzMap) setBuzzMapCount(parseInt(storedBuzzMap, 10) || 0);
    const handleBuzz = () => {
      setBuzzCount((prev) => {
        const newVal = prev + 1;
        localStorage.setItem(STORAGE_KEY_BUZZ_COUNT, String(newVal));
        return newVal;
      });
    };
    const handleBuzzMap = () => {
      setBuzzMapCount((prev) => {
        const newVal = prev + 1;
        localStorage.setItem(STORAGE_KEY_BUZZ_MAP_COUNT, String(newVal));
        return newVal;
      });
    };
    window.addEventListener("buzzCompleted", handleBuzz);
    window.addEventListener("buzzAreaCreated", handleBuzzMap);
    return () => {
      window.removeEventListener("buzzCompleted", handleBuzz);
      window.removeEventListener("buzzAreaCreated", handleBuzzMap);
    };
  }, []);
  return { buzzCount, buzzMapCount };
}
const EntitySymbol = ({ entity }) => {
  const colors = {
    MCP: "#00E5FF",
    SHADOW: "#FF3366",
    ECHO: "#9966FF"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "portal-entity-symbol",
      style: {
        color: colors[entity],
        textShadow: `0 0 20px ${colors[entity]}`
      },
      children: [
        entity === "MCP" && /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, { size: 24 }),
        entity === "SHADOW" && /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { size: 24 }),
        entity === "ECHO" && /* @__PURE__ */ jsxRuntimeExports.jsx(Radio, { size: 24 }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "ml-2 font-mono text-sm", children: [
          entity,
          "://PORTAL"
        ] })
      ]
    }
  );
};
const DialogueDisplay = ({ dialogues, onComplete }) => {
  const [currentIndex, setCurrentIndex] = reactExports.useState(0);
  const [displayedText, setDisplayedText] = reactExports.useState("");
  const [isTyping, setIsTyping] = reactExports.useState(true);
  const currentDialogue = dialogues[currentIndex];
  const fullText = currentDialogue?.lines.join("\n") || "";
  reactExports.useEffect(() => {
    let index = 0;
    setDisplayedText("");
    setIsTyping(true);
    const timer = setInterval(() => {
      if (index < fullText.length) {
        setDisplayedText(fullText.slice(0, index + 1));
        index++;
      } else {
        clearInterval(timer);
        setIsTyping(false);
        if (currentIndex < dialogues.length - 1) {
          setTimeout(() => setCurrentIndex((prev) => prev + 1), 1200);
        } else if (onComplete) {
          setTimeout(onComplete, 400);
        }
      }
    }, 25);
    return () => clearInterval(timer);
  }, [currentIndex, fullText, dialogues.length, onComplete]);
  if (!currentDialogue) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-dialogue", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(EntitySymbol, { entity: currentDialogue.entity }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("pre", { className: "portal-dialogue-text", children: [
      displayedText,
      isTyping && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "portal-cursor", children: "" })
    ] })
  ] });
};
const LockdownTimer = ({ seconds, onComplete }) => {
  const [remaining, setRemaining] = reactExports.useState(seconds);
  reactExports.useEffect(() => {
    if (remaining <= 0) {
      onComplete();
      return;
    }
    const timer = setTimeout(() => setRemaining((prev) => prev - 1), 1e3);
    return () => clearTimeout(timer);
  }, [remaining, onComplete]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-lockdown-timer", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "portal-lockdown-number", children: remaining }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "portal-lockdown-label", children: "SYSTEM LOCKDOWN" })
  ] });
};
const AgentMirrorPanel = ({ buzzCount, buzzMapCount }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-mirror-panel", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-mirror-title", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Eye, { size: 20, className: "mr-2" }),
      "AGENT MIRROR"
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-mirror-stats", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-mirror-stat", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "portal-mirror-label", children: "BUZZ Actions" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "portal-mirror-value", children: buzzCount })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-mirror-stat", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "portal-mirror-label", children: "BUZZ MAP Areas" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "portal-mirror-value", children: buzzMapCount })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-mirror-stat", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "portal-mirror-label", children: "Estimated Rank" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "portal-mirror-value", children: [
          "Top ",
          Math.max(5, 100 - (buzzCount * 3 + buzzMapCount * 10)),
          "%"
        ] })
      ] })
    ] })
  ] });
};
const RewardDisplay = ({ reward, isRandom }) => {
  const [randomReward] = reactExports.useState(() => isRandom ? getRandomNiceReward() : null);
  const displayLabel = isRandom && randomReward ? randomReward.label : reward.label;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    motion.div,
    {
      className: "portal-reward",
      initial: { scale: 0.8, opacity: 0 },
      animate: { scale: 1, opacity: 1 },
      transition: { delay: 0.3 },
      children: [
        isRandom ? /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { size: 24, className: "portal-reward-icon" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Gift, { size: 24, className: "portal-reward-icon" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "portal-reward-label", children: displayLabel }),
        reward.visualOnly && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "portal-reward-note", children: "(Visual preview)" })
      ]
    }
  );
};
const PulseBreakerPlaceholder = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-placeholder", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "portal-placeholder-icon", children: "" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "portal-placeholder-title", children: "PULSE BREAKER" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "portal-placeholder-text", children: "Prototype module detected." }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "portal-placeholder-sub", children: "Full feature coming soon." })
  ] });
};
const HollywoodGatePlaceholder = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-placeholder hollywood", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "portal-placeholder-icon", children: "" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "portal-placeholder-title", children: "HOLLYWOOD GATE" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "portal-placeholder-text", children: "Coming Soon." })
  ] });
};
const PortalBehaviorOverlay = ({
  portal,
  isVisible,
  onClose,
  mapRef
}) => {
  const { buzzCount, buzzMapCount } = useActivityTracker();
  const [phase, setPhase] = reactExports.useState("dialogue");
  const [isLocked, setIsLocked] = reactExports.useState(false);
  const [showReward, setShowReward] = reactExports.useState(false);
  const [loreFragment, setLoreFragment] = reactExports.useState("");
  const [puzzle, setPuzzle] = reactExports.useState("");
  const behavior = reactExports.useMemo(() => {
    if (!portal) return void 0;
    return getPortalBehavior(portal.id);
  }, [portal]);
  reactExports.useEffect(() => {
    if (isVisible && portal) {
      setPhase("dialogue");
      setShowReward(false);
    }
  }, [isVisible, portal]);
  reactExports.useEffect(() => {
    if (!behavior?.requirement) {
      setIsLocked(false);
      return;
    }
    const req = behavior.requirement;
    if (req.type === "buzz_count") {
      const needsBuzz = req.minBuzz || 5;
      const needsBuzzMap = req.minBuzzMap || 1;
      setIsLocked(buzzCount < needsBuzz || buzzMapCount < needsBuzzMap);
    } else if (req.type === "buzz_map_count") {
      const needsBuzzMap = req.minBuzzMap || 19;
      setIsLocked(buzzMapCount < needsBuzzMap);
    } else {
      setIsLocked(false);
    }
  }, [behavior, buzzCount, buzzMapCount]);
  reactExports.useEffect(() => {
    if (!portal || !isVisible) return;
    if (behavior?.type === "ECHO_ARCHIVE") {
      setLoreFragment(getRandomLoreFragment(portal.id));
    }
    if (behavior?.type === "LOST_FREQUENCY") {
      setPuzzle(getRandomPuzzle(portal.id));
    }
  }, [portal, behavior, isVisible]);
  reactExports.useEffect(() => {
    if (!isVisible || !behavior) return;
    if (behavior.effects.glitch === "heavy" || behavior.effects.glitch === "global") {
      document.body.classList.add("shadow-glitch-active");
      setTimeout(() => document.body.classList.remove("shadow-glitch-active"), 1500);
    }
    if (behavior.effects.cameraSwirl && mapRef?.current) {
      const map = mapRef.current;
      try {
        map.easeTo({
          bearing: 360,
          duration: 2e3,
          easing: (t) => t * (2 - t)
        });
        setTimeout(() => {
          map.easeTo({
            bearing: 0,
            duration: 1e3
          });
        }, 2e3);
      } catch (e) {
      }
    }
    if (behavior.effects.lockdown && behavior.type === "GLOBAL_GLITCH_LOCKDOWN") {
      setPhase("lockdown");
      document.body.classList.add("portal-lockdown-active");
    }
    return () => {
      document.body.classList.remove("shadow-glitch-active");
      document.body.classList.remove("portal-lockdown-active");
    };
  }, [isVisible, behavior, mapRef]);
  const handleDialogueComplete = reactExports.useCallback(() => {
    setPhase("content");
    if (behavior?.reward && !isLocked) {
      setTimeout(() => setShowReward(true), 400);
    }
  }, [behavior, isLocked]);
  const handleLockdownComplete = reactExports.useCallback(() => {
    document.body.classList.remove("portal-lockdown-active");
    setPhase("content");
    onClose();
  }, [onClose]);
  if (!isVisible || !portal || !behavior) return null;
  const dialogues = isLocked ? behavior.dialogueLocked : behavior.dialogueUnlocked;
  const portalColor = behavior.type.includes("SHADOW") || behavior.type === "GATEWAY_ZERO" ? "#FF3366" : behavior.type === "ECHO_ARCHIVE" ? "#9966FF" : "#00E5FF";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    motion.div,
    {
      className: "portal-behavior-overlay",
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      exit: { opacity: 0 },
      transition: { duration: 0.3 },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "portal-behavior-backdrop",
            onClick: phase !== "lockdown" ? onClose : void 0
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          motion.div,
          {
            className: "portal-behavior-modal",
            initial: { scale: 0.9, opacity: 0, y: 20 },
            animate: { scale: 1, opacity: 1, y: 0 },
            exit: { scale: 0.9, opacity: 0, y: 20 },
            transition: { duration: 0.3 },
            style: { borderColor: `${portalColor}40` },
            children: [
              phase !== "lockdown" && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "portal-behavior-close", onClick: onClose, "aria-label": "Close", children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { size: 18 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-behavior-header", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "portal-behavior-icon", style: { borderColor: `${portalColor}50`, color: portalColor }, children: isLocked ? /* @__PURE__ */ jsxRuntimeExports.jsx(Lock, { size: 24 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(LockOpen, { size: 24 }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "portal-behavior-title", style: { color: portalColor }, children: behavior.cityLabel }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "portal-behavior-type", children: behavior.type.replace(/_/g, " ") })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-behavior-content", children: [
                phase === "lockdown" && behavior.effects.lockdown && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  LockdownTimer,
                  {
                    seconds: behavior.effects.lockdown,
                    onComplete: handleLockdownComplete
                  }
                ),
                phase === "dialogue" && dialogues && dialogues.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DialogueDisplay,
                  {
                    dialogues,
                    onComplete: handleDialogueComplete
                  }
                ),
                phase === "content" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  behavior.type === "AGENT_MIRROR" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    AgentMirrorPanel,
                    {
                      buzzCount,
                      buzzMapCount
                    }
                  ),
                  behavior.type === "ECHO_ARCHIVE" && loreFragment && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-lore", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Radio, { size: 20, className: "portal-lore-icon" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "portal-lore-text", children: loreFragment })
                  ] }),
                  behavior.type === "LOST_FREQUENCY" && puzzle && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-puzzle", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Zap, { size: 20, className: "portal-puzzle-icon" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "portal-puzzle-text", children: puzzle })
                  ] }),
                  behavior.type === "PULSE_BREAKER" && /* @__PURE__ */ jsxRuntimeExports.jsx(PulseBreakerPlaceholder, {}),
                  behavior.type === "HOLLYWOOD_GATE" && !isLocked && /* @__PURE__ */ jsxRuntimeExports.jsx(HollywoodGatePlaceholder, {}),
                  behavior.type === "GATEWAY_ZERO" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-sealed", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Lock, { size: 28, className: "portal-sealed-icon" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Gateway remains sealed until Protocol Zero." })
                  ] }),
                  showReward && behavior.reward && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    RewardDisplay,
                    {
                      reward: behavior.reward,
                      isRandom: behavior.reward.type === "random"
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "portal-behavior-footer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "portal-coords", children: [
                portal.lat.toFixed(4),
                ", ",
                portal.lng.toFixed(4)
              ] }) })
            ]
          }
        )
      ]
    }
  ) });
};

const PortalsLayer3D = ({ map, enabled }) => {
  const [portals, setPortals] = reactExports.useState([]);
  const [positions, setPositions] = reactExports.useState(/* @__PURE__ */ new Map());
  const [selectedPortal, setSelectedPortal] = reactExports.useState(null);
  const rafRef = reactExports.useRef(null);
  const mapRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    mapRef.current = map;
  }, [map]);
  reactExports.useEffect(() => {
    if (!enabled) return;
    getLivePortals().then((livePortals) => {
      const seedPortals = PORTALS_SEED.map((p) => ({
        id: p.id,
        lat: p.lat,
        lng: p.lng,
        name: p.name,
        status: "active",
        intensity: 75,
        lastUpdate: (/* @__PURE__ */ new Date()).toISOString()
      }));
      setPortals([...livePortals, ...seedPortals]);
    });
    const unsubscribe = onPortalsChanged();
    return () => unsubscribe();
  }, [enabled]);
  reactExports.useEffect(() => {
    if (!map || !enabled) return;
    const updatePositions = () => {
      const newPositions = /* @__PURE__ */ new Map();
      portals.forEach((portal) => {
        const point = map.project([portal.lng, portal.lat]);
        newPositions.set(portal.id, { x: point.x, y: point.y });
      });
      setPositions(newPositions);
    };
    const updateOnRender = () => {
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
      rafRef.current = requestAnimationFrame(updatePositions);
    };
    updatePositions();
    map.on("move", updatePositions);
    map.on("zoom", updatePositions);
    map.on("resize", updatePositions);
    map.on("render", updateOnRender);
    return () => {
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
      map.off("move", updatePositions);
      map.off("zoom", updatePositions);
      map.off("resize", updatePositions);
      map.off("render", updateOnRender);
    };
  }, [map, portals, enabled]);
  reactExports.useEffect(() => {
    const handlePortalEvent = (e) => {
      const { type, enabled: filterEnabled } = e.detail;
    };
    window.addEventListener("M1_PORTAL_FILTER", handlePortalEvent);
    return () => window.removeEventListener("M1_PORTAL_FILTER", handlePortalEvent);
  }, []);
  if (!enabled || portals.length === 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 pointer-events-none", style: { zIndex: 11 }, children: portals.map((portal) => {
      const pos = positions.get(portal.id);
      if (!pos) return null;
      const behavior = getPortalBehavior(portal.id);
      const portalColor = behavior?.type === "SHADOW_RED_ZONE" || behavior?.type === "SHADOW_INTERFERENCE" || behavior?.type === "GATEWAY_ZERO" || behavior?.type === "LOST_FREQUENCY" ? "#FF3366" : behavior?.type === "ECHO_ARCHIVE" ? "#9966FF" : "#00f0ff";
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "absolute pointer-events-auto cursor-pointer",
          style: {
            left: `${pos.x}px`,
            top: `${pos.y}px`,
            transform: "translate(-50%, -50%)"
          },
          onClick: () => setSelectedPortal(portal),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "m1-portal-dot",
              style: {
                width: 14,
                height: 14,
                borderRadius: "50%",
                background: portalColor,
                boxShadow: `0 0 14px ${portalColor}`,
                border: `2px solid ${portalColor}40`,
                transition: "all 0.2s ease"
              },
              title: portal.name
            }
          )
        },
        portal.id
      );
    }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      PortalBehaviorOverlay,
      {
        portal: selectedPortal,
        isVisible: !!selectedPortal,
        onClose: () => setSelectedPortal(null),
        mapRef
      }
    )
  ] });
};

const useMarkerRewards = (markerId) => {
  const [rewards, setRewards] = reactExports.useState([]);
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState(null);
  reactExports.useEffect(() => {
    if (!markerId) {
      setRewards([]);
      return;
    }
    const fetchRewards = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const { data, error: error2 } = await supabase.from("marker_rewards").select("reward_type, payload, description").eq("marker_id", markerId);
        if (error2) {
          throw error2;
        }
        setRewards(Array.isArray(data) ? data : []);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Unknown error");
        setRewards([]);
      } finally {
        setIsLoading(false);
      }
    };
    fetchRewards();
  }, [markerId]);
  return { rewards: Array.isArray(rewards) ? rewards : [], isLoading, error };
};

var module$1 = {};
(function main(global, module2, isWorker, workerSize) {
  var canUseWorker = !!(global.Worker && global.Blob && global.Promise && global.OffscreenCanvas && global.OffscreenCanvasRenderingContext2D && global.HTMLCanvasElement && global.HTMLCanvasElement.prototype.transferControlToOffscreen && global.URL && global.URL.createObjectURL);
  var canUsePaths = typeof Path2D === "function" && typeof DOMMatrix === "function";
  var canDrawBitmap = function() {
    if (!global.OffscreenCanvas) {
      return false;
    }
    try {
      var canvas = new OffscreenCanvas(1, 1);
      var ctx = canvas.getContext("2d");
      ctx.fillRect(0, 0, 1, 1);
      var bitmap = canvas.transferToImageBitmap();
      ctx.createPattern(bitmap, "no-repeat");
    } catch (e) {
      return false;
    }
    return true;
  }();
  function noop() {
  }
  function promise(func) {
    var ModulePromise = module2.exports.Promise;
    var Prom = ModulePromise !== void 0 ? ModulePromise : global.Promise;
    if (typeof Prom === "function") {
      return new Prom(func);
    }
    func(noop, noop);
    return null;
  }
  var bitmapMapper = /* @__PURE__ */ function(skipTransform, map) {
    return {
      transform: function(bitmap) {
        if (skipTransform) {
          return bitmap;
        }
        if (map.has(bitmap)) {
          return map.get(bitmap);
        }
        var canvas = new OffscreenCanvas(bitmap.width, bitmap.height);
        var ctx = canvas.getContext("2d");
        ctx.drawImage(bitmap, 0, 0);
        map.set(bitmap, canvas);
        return canvas;
      },
      clear: function() {
        map.clear();
      }
    };
  }(canDrawBitmap, /* @__PURE__ */ new Map());
  var raf = function() {
    var TIME = Math.floor(1e3 / 60);
    var frame, cancel;
    var frames = {};
    var lastFrameTime = 0;
    if (typeof requestAnimationFrame === "function" && typeof cancelAnimationFrame === "function") {
      frame = function(cb) {
        var id = Math.random();
        frames[id] = requestAnimationFrame(function onFrame(time) {
          if (lastFrameTime === time || lastFrameTime + TIME - 1 < time) {
            lastFrameTime = time;
            delete frames[id];
            cb();
          } else {
            frames[id] = requestAnimationFrame(onFrame);
          }
        });
        return id;
      };
      cancel = function(id) {
        if (frames[id]) {
          cancelAnimationFrame(frames[id]);
        }
      };
    } else {
      frame = function(cb) {
        return setTimeout(cb, TIME);
      };
      cancel = function(timer) {
        return clearTimeout(timer);
      };
    }
    return { frame, cancel };
  }();
  var getWorker = /* @__PURE__ */ function() {
    var worker;
    var prom;
    var resolves = {};
    function decorate(worker2) {
      function execute(options, callback) {
        worker2.postMessage({ options: options || {}, callback });
      }
      worker2.init = function initWorker(canvas) {
        var offscreen = canvas.transferControlToOffscreen();
        worker2.postMessage({ canvas: offscreen }, [offscreen]);
      };
      worker2.fire = function fireWorker(options, size, done) {
        if (prom) {
          execute(options, null);
          return prom;
        }
        var id = Math.random().toString(36).slice(2);
        prom = promise(function(resolve) {
          function workerDone(msg) {
            if (msg.data.callback !== id) {
              return;
            }
            delete resolves[id];
            worker2.removeEventListener("message", workerDone);
            prom = null;
            bitmapMapper.clear();
            done();
            resolve();
          }
          worker2.addEventListener("message", workerDone);
          execute(options, id);
          resolves[id] = workerDone.bind(null, { data: { callback: id } });
        });
        return prom;
      };
      worker2.reset = function resetWorker() {
        worker2.postMessage({ reset: true });
        for (var id in resolves) {
          resolves[id]();
          delete resolves[id];
        }
      };
    }
    return function() {
      if (worker) {
        return worker;
      }
      if (!isWorker && canUseWorker) {
        var code = [
          "var CONFETTI, SIZE = {}, module = {};",
          "(" + main.toString() + ")(this, module, true, SIZE);",
          "onmessage = function(msg) {",
          "  if (msg.data.options) {",
          "    CONFETTI(msg.data.options).then(function () {",
          "      if (msg.data.callback) {",
          "        postMessage({ callback: msg.data.callback });",
          "      }",
          "    });",
          "  } else if (msg.data.reset) {",
          "    CONFETTI && CONFETTI.reset();",
          "  } else if (msg.data.resize) {",
          "    SIZE.width = msg.data.resize.width;",
          "    SIZE.height = msg.data.resize.height;",
          "  } else if (msg.data.canvas) {",
          "    SIZE.width = msg.data.canvas.width;",
          "    SIZE.height = msg.data.canvas.height;",
          "    CONFETTI = module.exports.create(msg.data.canvas);",
          "  }",
          "}"
        ].join("\n");
        try {
          worker = new Worker(URL.createObjectURL(new Blob([code])));
        } catch (e) {
          typeof console !== "undefined" && typeof console.warn === "function" ? console.warn(" Could not load worker", e) : null;
          return null;
        }
        decorate(worker);
      }
      return worker;
    };
  }();
  var defaults = {
    particleCount: 50,
    angle: 90,
    spread: 45,
    startVelocity: 45,
    decay: 0.9,
    gravity: 1,
    drift: 0,
    ticks: 200,
    x: 0.5,
    y: 0.5,
    shapes: ["square", "circle"],
    zIndex: 100,
    colors: [
      "#26ccff",
      "#a25afd",
      "#ff5e7e",
      "#88ff5a",
      "#fcff42",
      "#ffa62d",
      "#ff36ff"
    ],
    // probably should be true, but back-compat
    disableForReducedMotion: false,
    scalar: 1
  };
  function convert(val, transform) {
    return transform ? transform(val) : val;
  }
  function isOk(val) {
    return !(val === null || val === void 0);
  }
  function prop(options, name, transform) {
    return convert(
      options && isOk(options[name]) ? options[name] : defaults[name],
      transform
    );
  }
  function onlyPositiveInt(number) {
    return number < 0 ? 0 : Math.floor(number);
  }
  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
  }
  function toDecimal(str) {
    return parseInt(str, 16);
  }
  function colorsToRgb(colors) {
    return colors.map(hexToRgb);
  }
  function hexToRgb(str) {
    var val = String(str).replace(/[^0-9a-f]/gi, "");
    if (val.length < 6) {
      val = val[0] + val[0] + val[1] + val[1] + val[2] + val[2];
    }
    return {
      r: toDecimal(val.substring(0, 2)),
      g: toDecimal(val.substring(2, 4)),
      b: toDecimal(val.substring(4, 6))
    };
  }
  function getOrigin(options) {
    var origin = prop(options, "origin", Object);
    origin.x = prop(origin, "x", Number);
    origin.y = prop(origin, "y", Number);
    return origin;
  }
  function setCanvasWindowSize(canvas) {
    canvas.width = document.documentElement.clientWidth;
    canvas.height = document.documentElement.clientHeight;
  }
  function setCanvasRectSize(canvas) {
    var rect = canvas.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
  }
  function getCanvas(zIndex) {
    var canvas = document.createElement("canvas");
    canvas.style.position = "fixed";
    canvas.style.top = "0px";
    canvas.style.left = "0px";
    canvas.style.pointerEvents = "none";
    canvas.style.zIndex = zIndex;
    return canvas;
  }
  function ellipse(context, x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {
    context.save();
    context.translate(x, y);
    context.rotate(rotation);
    context.scale(radiusX, radiusY);
    context.arc(0, 0, 1, startAngle, endAngle, antiClockwise);
    context.restore();
  }
  function randomPhysics(opts) {
    var radAngle = opts.angle * (Math.PI / 180);
    var radSpread = opts.spread * (Math.PI / 180);
    return {
      x: opts.x,
      y: opts.y,
      wobble: Math.random() * 10,
      wobbleSpeed: Math.min(0.11, Math.random() * 0.1 + 0.05),
      velocity: opts.startVelocity * 0.5 + Math.random() * opts.startVelocity,
      angle2D: -radAngle + (0.5 * radSpread - Math.random() * radSpread),
      tiltAngle: (Math.random() * (0.75 - 0.25) + 0.25) * Math.PI,
      color: opts.color,
      shape: opts.shape,
      tick: 0,
      totalTicks: opts.ticks,
      decay: opts.decay,
      drift: opts.drift,
      random: Math.random() + 2,
      tiltSin: 0,
      tiltCos: 0,
      wobbleX: 0,
      wobbleY: 0,
      gravity: opts.gravity * 3,
      ovalScalar: 0.6,
      scalar: opts.scalar,
      flat: opts.flat
    };
  }
  function updateFetti(context, fetti) {
    fetti.x += Math.cos(fetti.angle2D) * fetti.velocity + fetti.drift;
    fetti.y += Math.sin(fetti.angle2D) * fetti.velocity + fetti.gravity;
    fetti.velocity *= fetti.decay;
    if (fetti.flat) {
      fetti.wobble = 0;
      fetti.wobbleX = fetti.x + 10 * fetti.scalar;
      fetti.wobbleY = fetti.y + 10 * fetti.scalar;
      fetti.tiltSin = 0;
      fetti.tiltCos = 0;
      fetti.random = 1;
    } else {
      fetti.wobble += fetti.wobbleSpeed;
      fetti.wobbleX = fetti.x + 10 * fetti.scalar * Math.cos(fetti.wobble);
      fetti.wobbleY = fetti.y + 10 * fetti.scalar * Math.sin(fetti.wobble);
      fetti.tiltAngle += 0.1;
      fetti.tiltSin = Math.sin(fetti.tiltAngle);
      fetti.tiltCos = Math.cos(fetti.tiltAngle);
      fetti.random = Math.random() + 2;
    }
    var progress = fetti.tick++ / fetti.totalTicks;
    var x1 = fetti.x + fetti.random * fetti.tiltCos;
    var y1 = fetti.y + fetti.random * fetti.tiltSin;
    var x2 = fetti.wobbleX + fetti.random * fetti.tiltCos;
    var y2 = fetti.wobbleY + fetti.random * fetti.tiltSin;
    context.fillStyle = "rgba(" + fetti.color.r + ", " + fetti.color.g + ", " + fetti.color.b + ", " + (1 - progress) + ")";
    context.beginPath();
    if (canUsePaths && fetti.shape.type === "path" && typeof fetti.shape.path === "string" && Array.isArray(fetti.shape.matrix)) {
      context.fill(transformPath2D(
        fetti.shape.path,
        fetti.shape.matrix,
        fetti.x,
        fetti.y,
        Math.abs(x2 - x1) * 0.1,
        Math.abs(y2 - y1) * 0.1,
        Math.PI / 10 * fetti.wobble
      ));
    } else if (fetti.shape.type === "bitmap") {
      var rotation = Math.PI / 10 * fetti.wobble;
      var scaleX = Math.abs(x2 - x1) * 0.1;
      var scaleY = Math.abs(y2 - y1) * 0.1;
      var width = fetti.shape.bitmap.width * fetti.scalar;
      var height = fetti.shape.bitmap.height * fetti.scalar;
      var matrix = new DOMMatrix([
        Math.cos(rotation) * scaleX,
        Math.sin(rotation) * scaleX,
        -Math.sin(rotation) * scaleY,
        Math.cos(rotation) * scaleY,
        fetti.x,
        fetti.y
      ]);
      matrix.multiplySelf(new DOMMatrix(fetti.shape.matrix));
      var pattern = context.createPattern(bitmapMapper.transform(fetti.shape.bitmap), "no-repeat");
      pattern.setTransform(matrix);
      context.globalAlpha = 1 - progress;
      context.fillStyle = pattern;
      context.fillRect(
        fetti.x - width / 2,
        fetti.y - height / 2,
        width,
        height
      );
      context.globalAlpha = 1;
    } else if (fetti.shape === "circle") {
      context.ellipse ? context.ellipse(fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI) : ellipse(context, fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI);
    } else if (fetti.shape === "star") {
      var rot = Math.PI / 2 * 3;
      var innerRadius = 4 * fetti.scalar;
      var outerRadius = 8 * fetti.scalar;
      var x = fetti.x;
      var y = fetti.y;
      var spikes = 5;
      var step = Math.PI / spikes;
      while (spikes--) {
        x = fetti.x + Math.cos(rot) * outerRadius;
        y = fetti.y + Math.sin(rot) * outerRadius;
        context.lineTo(x, y);
        rot += step;
        x = fetti.x + Math.cos(rot) * innerRadius;
        y = fetti.y + Math.sin(rot) * innerRadius;
        context.lineTo(x, y);
        rot += step;
      }
    } else {
      context.moveTo(Math.floor(fetti.x), Math.floor(fetti.y));
      context.lineTo(Math.floor(fetti.wobbleX), Math.floor(y1));
      context.lineTo(Math.floor(x2), Math.floor(y2));
      context.lineTo(Math.floor(x1), Math.floor(fetti.wobbleY));
    }
    context.closePath();
    context.fill();
    return fetti.tick < fetti.totalTicks;
  }
  function animate(canvas, fettis, resizer, size, done) {
    var animatingFettis = fettis.slice();
    var context = canvas.getContext("2d");
    var animationFrame;
    var destroy;
    var prom = promise(function(resolve) {
      function onDone() {
        animationFrame = destroy = null;
        context.clearRect(0, 0, size.width, size.height);
        bitmapMapper.clear();
        done();
        resolve();
      }
      function update() {
        if (isWorker && !(size.width === workerSize.width && size.height === workerSize.height)) {
          size.width = canvas.width = workerSize.width;
          size.height = canvas.height = workerSize.height;
        }
        if (!size.width && !size.height) {
          resizer(canvas);
          size.width = canvas.width;
          size.height = canvas.height;
        }
        context.clearRect(0, 0, size.width, size.height);
        animatingFettis = animatingFettis.filter(function(fetti) {
          return updateFetti(context, fetti);
        });
        if (animatingFettis.length) {
          animationFrame = raf.frame(update);
        } else {
          onDone();
        }
      }
      animationFrame = raf.frame(update);
      destroy = onDone;
    });
    return {
      addFettis: function(fettis2) {
        animatingFettis = animatingFettis.concat(fettis2);
        return prom;
      },
      canvas,
      promise: prom,
      reset: function() {
        if (animationFrame) {
          raf.cancel(animationFrame);
        }
        if (destroy) {
          destroy();
        }
      }
    };
  }
  function confettiCannon(canvas, globalOpts) {
    var isLibCanvas = !canvas;
    var allowResize = !!prop(globalOpts || {}, "resize");
    var hasResizeEventRegistered = false;
    var globalDisableForReducedMotion = prop(globalOpts, "disableForReducedMotion", Boolean);
    var shouldUseWorker = canUseWorker && !!prop(globalOpts || {}, "useWorker");
    var worker = shouldUseWorker ? getWorker() : null;
    var resizer = isLibCanvas ? setCanvasWindowSize : setCanvasRectSize;
    var initialized = canvas && worker ? !!canvas.__confetti_initialized : false;
    var preferLessMotion = typeof matchMedia === "function" && matchMedia("(prefers-reduced-motion)").matches;
    var animationObj;
    function fireLocal(options, size, done) {
      var particleCount = prop(options, "particleCount", onlyPositiveInt);
      var angle = prop(options, "angle", Number);
      var spread = prop(options, "spread", Number);
      var startVelocity = prop(options, "startVelocity", Number);
      var decay = prop(options, "decay", Number);
      var gravity = prop(options, "gravity", Number);
      var drift = prop(options, "drift", Number);
      var colors = prop(options, "colors", colorsToRgb);
      var ticks = prop(options, "ticks", Number);
      var shapes = prop(options, "shapes");
      var scalar = prop(options, "scalar");
      var flat = !!prop(options, "flat");
      var origin = getOrigin(options);
      var temp = particleCount;
      var fettis = [];
      var startX = canvas.width * origin.x;
      var startY = canvas.height * origin.y;
      while (temp--) {
        fettis.push(
          randomPhysics({
            x: startX,
            y: startY,
            angle,
            spread,
            startVelocity,
            color: colors[temp % colors.length],
            shape: shapes[randomInt(0, shapes.length)],
            ticks,
            decay,
            gravity,
            drift,
            scalar,
            flat
          })
        );
      }
      if (animationObj) {
        return animationObj.addFettis(fettis);
      }
      animationObj = animate(canvas, fettis, resizer, size, done);
      return animationObj.promise;
    }
    function fire(options) {
      var disableForReducedMotion = globalDisableForReducedMotion || prop(options, "disableForReducedMotion", Boolean);
      var zIndex = prop(options, "zIndex", Number);
      if (disableForReducedMotion && preferLessMotion) {
        return promise(function(resolve) {
          resolve();
        });
      }
      if (isLibCanvas && animationObj) {
        canvas = animationObj.canvas;
      } else if (isLibCanvas && !canvas) {
        canvas = getCanvas(zIndex);
        document.body.appendChild(canvas);
      }
      if (allowResize && !initialized) {
        resizer(canvas);
      }
      var size = {
        width: canvas.width,
        height: canvas.height
      };
      if (worker && !initialized) {
        worker.init(canvas);
      }
      initialized = true;
      if (worker) {
        canvas.__confetti_initialized = true;
      }
      function onResize() {
        if (worker) {
          var obj = {
            getBoundingClientRect: function() {
              if (!isLibCanvas) {
                return canvas.getBoundingClientRect();
              }
            }
          };
          resizer(obj);
          worker.postMessage({
            resize: {
              width: obj.width,
              height: obj.height
            }
          });
          return;
        }
        size.width = size.height = null;
      }
      function done() {
        animationObj = null;
        if (allowResize) {
          hasResizeEventRegistered = false;
          global.removeEventListener("resize", onResize);
        }
        if (isLibCanvas && canvas) {
          if (document.body.contains(canvas)) {
            document.body.removeChild(canvas);
          }
          canvas = null;
          initialized = false;
        }
      }
      if (allowResize && !hasResizeEventRegistered) {
        hasResizeEventRegistered = true;
        global.addEventListener("resize", onResize, false);
      }
      if (worker) {
        return worker.fire(options, size, done);
      }
      return fireLocal(options, size, done);
    }
    fire.reset = function() {
      if (worker) {
        worker.reset();
      }
      if (animationObj) {
        animationObj.reset();
      }
    };
    return fire;
  }
  var defaultFire;
  function getDefaultFire() {
    if (!defaultFire) {
      defaultFire = confettiCannon(null, { useWorker: true, resize: true });
    }
    return defaultFire;
  }
  function transformPath2D(pathString, pathMatrix, x, y, scaleX, scaleY, rotation) {
    var path2d = new Path2D(pathString);
    var t1 = new Path2D();
    t1.addPath(path2d, new DOMMatrix(pathMatrix));
    var t2 = new Path2D();
    t2.addPath(t1, new DOMMatrix([
      Math.cos(rotation) * scaleX,
      Math.sin(rotation) * scaleX,
      -Math.sin(rotation) * scaleY,
      Math.cos(rotation) * scaleY,
      x,
      y
    ]));
    return t2;
  }
  function shapeFromPath(pathData) {
    if (!canUsePaths) {
      throw new Error("path confetti are not supported in this browser");
    }
    var path, matrix;
    if (typeof pathData === "string") {
      path = pathData;
    } else {
      path = pathData.path;
      matrix = pathData.matrix;
    }
    var path2d = new Path2D(path);
    var tempCanvas = document.createElement("canvas");
    var tempCtx = tempCanvas.getContext("2d");
    if (!matrix) {
      var maxSize = 1e3;
      var minX = maxSize;
      var minY = maxSize;
      var maxX = 0;
      var maxY = 0;
      var width, height;
      for (var x = 0; x < maxSize; x += 2) {
        for (var y = 0; y < maxSize; y += 2) {
          if (tempCtx.isPointInPath(path2d, x, y, "nonzero")) {
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
          }
        }
      }
      width = maxX - minX;
      height = maxY - minY;
      var maxDesiredSize = 10;
      var scale = Math.min(maxDesiredSize / width, maxDesiredSize / height);
      matrix = [
        scale,
        0,
        0,
        scale,
        -Math.round(width / 2 + minX) * scale,
        -Math.round(height / 2 + minY) * scale
      ];
    }
    return {
      type: "path",
      path,
      matrix
    };
  }
  function shapeFromText(textData) {
    var text, scalar = 1, color = "#000000", fontFamily = '"Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", "EmojiOne Color", "Android Emoji", "Twemoji Mozilla", "system emoji", sans-serif';
    if (typeof textData === "string") {
      text = textData;
    } else {
      text = textData.text;
      scalar = "scalar" in textData ? textData.scalar : scalar;
      fontFamily = "fontFamily" in textData ? textData.fontFamily : fontFamily;
      color = "color" in textData ? textData.color : color;
    }
    var fontSize = 10 * scalar;
    var font = "" + fontSize + "px " + fontFamily;
    var canvas = new OffscreenCanvas(fontSize, fontSize);
    var ctx = canvas.getContext("2d");
    ctx.font = font;
    var size = ctx.measureText(text);
    var width = Math.ceil(size.actualBoundingBoxRight + size.actualBoundingBoxLeft);
    var height = Math.ceil(size.actualBoundingBoxAscent + size.actualBoundingBoxDescent);
    var padding = 2;
    var x = size.actualBoundingBoxLeft + padding;
    var y = size.actualBoundingBoxAscent + padding;
    width += padding + padding;
    height += padding + padding;
    canvas = new OffscreenCanvas(width, height);
    ctx = canvas.getContext("2d");
    ctx.font = font;
    ctx.fillStyle = color;
    ctx.fillText(text, x, y);
    var scale = 1 / scalar;
    return {
      type: "bitmap",
      // TODO these probably need to be transfered for workers
      bitmap: canvas.transferToImageBitmap(),
      matrix: [scale, 0, 0, scale, -width * scale / 2, -height * scale / 2]
    };
  }
  module2.exports = function() {
    return getDefaultFire().apply(this, arguments);
  };
  module2.exports.reset = function() {
    getDefaultFire().reset();
  };
  module2.exports.create = confettiCannon;
  module2.exports.shapeFromPath = shapeFromPath;
  module2.exports.shapeFromText = shapeFromText;
})(function() {
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  return this || {};
}(), module$1, false);
const confetti = module$1.exports;
module$1.exports.create;

const ClaimRewardModal = ({
  isOpen,
  onClose,
  markerId,
  rewards: rawRewards,
  onSuccess
}) => {
  const rewards = Array.isArray(rawRewards) ? rawRewards : [];
  const [isClaiming, setIsClaiming] = reactExports.useState(false);
  const [showSuccessAnimation, setShowSuccessAnimation] = reactExports.useState(false);
  const [claimedRewardType, setClaimedRewardType] = reactExports.useState("");
  const [claimedAmount, setClaimedAmount] = reactExports.useState(0);
  const triggerCelebration = (rewardType) => {
    const colors = rewardType === "m1u" ? ["#FFD700", "#FFA500"] : rewardType === "physical_prize" ? ["#FF1493", "#00D1FF"] : ["#00D1FF", "#FF1493"];
    confetti({
      particleCount: 50,
      // Ridotto da 100
      spread: 60,
      origin: { y: 0.6 },
      colors,
      disableForReducedMotion: true,
      // Rispetta preferenze utente
      gravity: 1.2,
      // Caduta pi veloce
      decay: 0.95
      // Dissolvenza pi rapida
    });
  };
  const getRewardIcon = (rewardType) => {
    switch (rewardType) {
      case "buzz_free":
        return "";
      case "xp_points":
        return "";
      case "message":
        return "";
      case "event_ticket":
        return "";
      case "badge":
        return "";
      case "m1u":
        return "";
      case "clue":
        return "";
      case "physical_prize":
        return "";
      default:
        return "";
    }
  };
  const handleClaim = async () => {
    if (!markerId) {
      ue.error("Errore: marker non identificato");
      return;
    }
    setIsClaiming(true);
    try {
      const { data, error } = await supabase.functions.invoke("claim-marker-reward", { body: { markerId } });
      if (error?.status === 401) {
        setIsClaiming(false);
        ue.error("Sessione scaduta, effettua nuovamente il login");
        setTimeout(() => window.location.href = "/login", 1e3);
        return;
      }
      if (data?.ok === true) {
        const m1uEntry = data?.summary?.find((s) => s.type === "m1u");
        const serverM1U = m1uEntry?.info?.amount;
        const rewardType = data?.summary?.[0]?.type || rewards[0]?.reward_type?.toLowerCase() || "unknown";
        if (m1uEntry?.info?.error) {
          ue.error(`Errore M1U: ${m1uEntry.info.error}`);
        }
        setClaimedRewardType(rewardType);
        setClaimedAmount(serverM1U || rewards[0]?.payload?.amount || 50);
        setShowSuccessAnimation(true);
        triggerCelebration(rewardType);
        __vitePreload(async () => { const {trackMarkerRewardClaimed} = await import('./index.BEQCqgv7.js').then(n => n.bX);return { trackMarkerRewardClaimed }},true?__vite__mapDeps([0,1,2,3,4,5,6,7,8,9]):void 0).then(({ trackMarkerRewardClaimed }) => {
          trackMarkerRewardClaimed(markerId, rewardType);
        }).catch(() => {
        });
        setTimeout(() => {
          setShowSuccessAnimation(false);
          setIsClaiming(false);
          onClose?.();
          setTimeout(() => {
            window.dispatchEvent(new CustomEvent("m1u-balance-updated"));
          }, 100);
          if (rewardType === "buzz_free") {
            setTimeout(() => {
              window.location.href = "/buzz";
            }, 300);
          }
          notifyShadowContext("reward");
          onSuccess?.();
        }, 2500);
        return;
      }
      setIsClaiming(false);
      if (data?.code === "ALREADY_CLAIMED") {
        ue.info("Premio gi riscattato in precedenza");
        onClose?.();
        return;
      }
      if (data?.code === "NO_REWARD") {
        ue.error("Nessuna ricompensa trovata per questo marker");
        return;
      }
      ue.error("Errore nel riscatto del premio");
    } catch (apiError) {
      setIsClaiming(false);
      ue.error("Errore di connessione, riprova");
    }
  };
  const SuccessAnimation = () => {
    const icon = claimedRewardType === "m1u" ? "" : claimedRewardType === "physical_prize" ? "" : claimedRewardType === "buzz_free" ? "" : claimedRewardType === "clue" ? "" : claimedRewardType === "xp_points" ? "" : "";
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "fixed inset-0 z-[10000] flex items-center justify-center bg-black",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center px-8", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-8xl mb-6", children: icon }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-4xl font-bold text-white mb-4", children: "PREMIO SBLOCCATO!" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
            claimedRewardType === "m1u" && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-3xl font-bold text-[#FFD700]", children: [
              "+",
              claimedAmount,
              " M1U"
            ] }),
            claimedRewardType === "buzz_free" && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl font-bold text-[#00D1FF]", children: "BUZZ Gratuito Sbloccato!" }),
            claimedRewardType === "physical_prize" && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl font-bold text-[#FF1493]", children: "HAI VINTO UN PREMIO!" }),
            claimedRewardType === "clue" && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-2xl font-bold text-[#00D1FF]", children: "Nuovo Indizio Trovato!" }),
            claimedRewardType === "xp_points" && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-2xl font-bold text-[#F59E0B]", children: [
              "+",
              claimedAmount || 10,
              " XP Guadagnati!"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-white/60 mt-6 text-sm", children: "Controlla le notifiche per i dettagli" })
          ] })
        ] })
      }
    );
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    showSuccessAnimation && /* @__PURE__ */ jsxRuntimeExports.jsx(SuccessAnimation, {}),
    isOpen && !showSuccessAnimation && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "fixed inset-0 z-[9998] bg-black/80 backdrop-blur-sm",
          style: {
            pointerEvents: "auto",
            position: "fixed",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            width: "100vw",
            height: "100vh"
          },
          onClick: onClose
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "fixed inset-4 z-[9999] flex items-center justify-center",
          style: {
            pointerEvents: "auto",
            maxHeight: "90vh",
            overflowY: "auto",
            padding: "env(safe-area-inset-top, 16px) env(safe-area-inset-right, 16px) env(safe-area-inset-bottom, 16px) env(safe-area-inset-left, 16px)"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gradient-to-br from-[#0a0a0a] via-[#1a1a2e] to-[#0a0a0a] border border-[#00D1FF]/30 rounded-2xl shadow-[0_0_50px_rgba(0,209,255,0.4)] backdrop-blur-xl relative overflow-hidden w-full max-w-md max-h-full overflow-y-auto", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-gradient-to-r from-[#00D1FF]/5 via-transparent to-[#FF1493]/5 rounded-2xl" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative z-10 text-center py-6 px-6 border-b border-[#00D1FF]/20", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-3xl mb-2", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-white", children: "Premio Trovato!" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-[#00D1FF] text-sm font-medium mt-1", children: "Hai scoperto un marker con premi speciali" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative z-10 space-y-6 p-6 max-h-[60vh] overflow-y-auto", children: [
              rewards.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-8", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-5xl mb-4", children: "" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-white/70 text-lg", children: "Caricamento premi in corso..." }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-white/50 text-sm mt-2", children: "Se il problema persiste, prova a ricaricare la pagina" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: rewards.length > 0 && rewards.filter((reward) => {
                if (!reward.reward_type) {
                  return false;
                }
                if (reward.reward_type === "message") {
                  const message = reward.payload?.text || reward.description || "";
                  const cleanMessage = message.trim();
                  const isCorrupted = cleanMessage.length === 0 || cleanMessage.length === 1 || /^[^\w\s]*$/.test(cleanMessage) || ["", ",", "", "P", "dsdf", "ciao", "M1", "m1"].includes(cleanMessage.toLowerCase());
                  if (isCorrupted) {
                    return false;
                  }
                }
                return true;
              }).slice(0, 3).map((reward, index) => {
                let displayDescription = reward.description;
                if (reward.reward_type === "message") {
                  const message = reward.payload?.text || reward.description || "";
                  const cleanMessage = message.trim();
                  if (!cleanMessage || cleanMessage.length < 2 || /^[^\w\s]*$/.test(cleanMessage)) {
                    displayDescription = "Premio messaggio speciale!";
                  } else {
                    displayDescription = cleanMessage;
                  }
                }
                return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative overflow-hidden rounded-xl bg-gradient-to-r from-[#00D1FF]/10 via-[#FF1493]/10 to-[#00D1FF]/10 border border-[#00D1FF]/30 p-4 backdrop-blur-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-14 h-14 rounded-full bg-gradient-to-br from-[#00D1FF]/30 to-[#FF1493]/30 flex items-center justify-center shadow-[0_0_20px_rgba(0,209,255,0.3)]", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-2xl filter drop-shadow-[0_0_8px_rgba(0,209,255,0.8)]", children: getRewardIcon(reward.reward_type) }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-white font-bold text-lg", children: reward.reward_type === "buzz_free" ? "BUZZ GRATUITO" : reward.reward_type === "xp_points" ? "PUNTI ESPERIENZA" : reward.reward_type === "message" ? "PREMIO MESSAGGIO" : reward.reward_type === "event_ticket" ? "BIGLIETTO EVENTO" : reward.reward_type === "badge" ? "DISTINTIVO" : reward.reward_type === "m1u" ? "CREDITI M1U" : reward.reward_type === "clue" ? "INDIZIO SEGRETO" : reward.reward_type === "physical_prize" ? "PREMIO FISICO" : displayDescription || `Premio ${reward.reward_type}` }),
                    reward.reward_type === "buzz_free" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-[#00D1FF] text-sm font-semibold", children: [
                      "+",
                      reward.payload?.buzzCount || 1,
                      " BUZZ gratuiti"
                    ] }),
                    reward.reward_type === "xp_points" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-[#00D1FF] text-sm font-semibold", children: [
                      "+",
                      reward.payload?.xp || 10,
                      " XP"
                    ] }),
                    reward.reward_type === "message" && displayDescription && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-300 text-sm", children: displayDescription }),
                    reward.reward_type === "event_ticket" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-[#00D1FF] text-sm font-semibold", children: [
                      "Tipo: ",
                      reward.payload?.ticket_type || "Standard"
                    ] }),
                    reward.reward_type === "badge" && displayDescription && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-300 text-sm", children: displayDescription }),
                    reward.reward_type === "m1u" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-[#FFD700] text-sm font-semibold", children: [
                      "+",
                      reward.payload?.amount || 50,
                      " M1U sul tuo conto"
                    ] }),
                    reward.reward_type === "clue" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-[#00D1FF] text-sm font-semibold", children: "Indizio per la missione attiva" }),
                    reward.reward_type === "physical_prize" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-[#FF1493] text-sm font-semibold", children: [
                      " ",
                      reward.payload?.prize_name || "Premio speciale"
                    ] })
                  ] })
                ] }) }, index);
              }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4 pt-6 border-t border-[#00D1FF]/20", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "outline",
                    onClick: onClose,
                    disabled: isClaiming,
                    className: "flex-1 border-gray-600 text-gray-300 hover:bg-gray-800/50 transition-all duration-300",
                    children: "Annulla"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    onClick: handleClaim,
                    disabled: isClaiming || rewards.length === 0,
                    className: "flex-1 bg-gradient-to-r from-[#00D1FF] to-[#FF1493] text-white font-bold hover:shadow-[0_0_30px_rgba(0,209,255,0.6)] transition-all duration-300 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed",
                    "data-testid": "claim-reward-cta",
                    children: isClaiming ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin" }),
                      "Riscattando..."
                    ] }) : rewards.length === 0 ? "Caricamento..." : "Riscatta subito"
                  }
                )
              ] })
            ] })
          ] })
        }
      )
    ] })
  ] });
};

const MIN_ZOOM_FOR_REWARDS = 17;
const RewardsLayer3D = ({ map, enabled, markers = [], userPosition, isAdmin = false }) => {
  const [positions, setPositions] = reactExports.useState(/* @__PURE__ */ new Map());
  const [selectedMarker, setSelectedMarker] = reactExports.useState(null);
  const [currentZoom, setCurrentZoom] = reactExports.useState(0);
  const { rewards } = useMarkerRewards(selectedMarker);
  const rafRef = React.useRef(null);
  reactExports.useEffect(() => {
    if (!map || !enabled) return;
    const updatePositions = () => {
      const newPositions = /* @__PURE__ */ new Map();
      markers.forEach((marker) => {
        const point = map.project([marker.lng, marker.lat]);
        newPositions.set(marker.id, { x: point.x, y: point.y });
      });
      setPositions(newPositions);
      setCurrentZoom(map.getZoom());
    };
    const updateOnRender = () => {
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
      rafRef.current = requestAnimationFrame(updatePositions);
    };
    updatePositions();
    map.on("move", updatePositions);
    map.on("zoom", updatePositions);
    map.on("resize", updatePositions);
    map.on("render", updateOnRender);
    return () => {
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
      map.off("move", updatePositions);
      map.off("zoom", updatePositions);
      map.off("resize", updatePositions);
      map.off("render", updateOnRender);
    };
  }, [map, markers, enabled]);
  if (!enabled || markers.length === 0) return null;
  const visibleMarkers = markers.filter(
    (m) => m.claimed || currentZoom >= MIN_ZOOM_FOR_REWARDS
  );
  if (visibleMarkers.length === 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 pointer-events-none", style: { zIndex: 660 }, children: visibleMarkers.map((marker) => {
      const pos = positions.get(marker.id);
      if (!pos) return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "absolute pointer-events-auto cursor-pointer",
          style: {
            left: `${pos.x}px`,
            top: `${pos.y}px`,
            transform: "translate(-50%, -50%)",
            //  AREA CLICCABILE GRANDE per mobile (44x44 minimo per touch)
            width: "48px",
            height: "48px",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            touchAction: "manipulation"
          },
          onClick: (e) => {
            e.stopPropagation();
            setSelectedMarker(marker.id);
          },
          onTouchEnd: (e) => {
            e.stopPropagation();
            setSelectedMarker(marker.id);
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "m1-reward-marker",
              style: {
                //  Marker PI GRANDE e visibile
                width: marker.claimed ? 20 : 24,
                height: marker.claimed ? 20 : 24,
                borderRadius: "50%",
                //  VERDE = non riscattato, VIOLA = riscattato
                background: marker.claimed ? "#8B5CF6" : "#10b981",
                border: "3px solid rgba(255, 255, 255, 0.9)",
                boxShadow: marker.claimed ? "0 0 12px 4px rgba(139, 92, 246, 0.9), 0 0 24px 8px rgba(139, 92, 246, 0.5)" : "0 0 12px 4px rgba(16, 185, 129, 0.9), 0 0 24px 8px rgba(16, 185, 129, 0.5)",
                animation: marker.claimed ? "none" : "rewardPulse 1.5s ease-in-out infinite"
              },
              title: marker.claimed ? `${marker.title || "Reward"} (Riscattato)` : marker.title || "Reward"
            }
          )
        },
        marker.id
      );
    }) }),
    selectedMarker && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ClaimRewardModal,
      {
        isOpen: true,
        onClose: () => setSelectedMarker(null),
        markerId: selectedMarker,
        rewards: rewards || []
      }
    )
  ] });
};

const EARTH_RADIUS_KM = 6371;
function makeCircle(centerLng, centerLat, radiusKm, steps = 128) {
  const coords = [];
  const distRatio = radiusKm / EARTH_RADIUS_KM;
  const centerLatRad = centerLat * Math.PI / 180;
  const centerLngRad = centerLng * Math.PI / 180;
  for (let i = 0; i <= steps; i++) {
    const bearing = i / steps * 2 * Math.PI;
    const lat2 = Math.asin(
      Math.sin(centerLatRad) * Math.cos(distRatio) + Math.cos(centerLatRad) * Math.sin(distRatio) * Math.cos(bearing)
    );
    const lng2 = centerLngRad + Math.atan2(
      Math.sin(bearing) * Math.sin(distRatio) * Math.cos(centerLatRad),
      Math.cos(distRatio) - Math.sin(centerLatRad) * Math.sin(lat2)
    );
    coords.push([
      lng2 * 180 / Math.PI,
      lat2 * 180 / Math.PI
    ]);
  }
  return {
    type: "Feature",
    geometry: {
      type: "Polygon",
      coordinates: [coords]
    },
    properties: {
      center: [centerLng, centerLat],
      radiusKm
    }
  };
}

const AreasLayer3D = ({
  map,
  enabled,
  userAreas = [],
  searchAreas = [],
  onDeleteSearchArea,
  currentAreaVersion = "none"
}) => {
  const [tooltip, setTooltip] = reactExports.useState(null);
  const rafRef = reactExports.useRef(null);
  const initializedRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    setTooltip(null);
  }, [userAreas]);
  reactExports.useEffect(() => {
    const handleBuzzCreated = () => {
      setTooltip(null);
    };
    window.addEventListener("buzzAreaCreated", handleBuzzCreated);
    return () => window.removeEventListener("buzzAreaCreated", handleBuzzCreated);
  }, []);
  reactExports.useEffect(() => {
    if (!map || !tooltip) return;
    const updateTooltipPosition = () => {
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
      rafRef.current = requestAnimationFrame(() => {
        const point = map.project([tooltip.lng, tooltip.lat]);
        setTooltip((prev) => prev ? { ...prev, screenX: point.x, screenY: point.y } : null);
      });
    };
    updateTooltipPosition();
    map.on("move", updateTooltipPosition);
    map.on("zoom", updateTooltipPosition);
    map.on("rotate", updateTooltipPosition);
    map.on("pitch", updateTooltipPosition);
    map.on("render", updateTooltipPosition);
    return () => {
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
      map.off("move", updateTooltipPosition);
      map.off("zoom", updateTooltipPosition);
      map.off("rotate", updateTooltipPosition);
      map.off("pitch", updateTooltipPosition);
      map.off("render", updateTooltipPosition);
    };
  }, [map, tooltip?.lat, tooltip?.lng]);
  reactExports.useEffect(() => {
    if (!map || !enabled || initializedRef.current) return;
    const initLayers = () => {
      if (!map.getSource("user-areas")) {
        map.addSource("user-areas", {
          type: "geojson",
          data: { type: "FeatureCollection", features: [] }
        });
      }
      if (!map.getLayer("user-areas-fill")) {
        map.addLayer({
          id: "user-areas-fill",
          type: "fill",
          source: "user-areas",
          paint: {
            "fill-color": "rgba(0,209,255,0.15)",
            "fill-opacity": 0.8
          }
        });
      }
      if (!map.getLayer("user-areas-border")) {
        map.addLayer({
          id: "user-areas-border",
          type: "line",
          source: "user-areas",
          paint: {
            "line-color": "#00D1FF",
            "line-width": 3,
            "line-opacity": 0.8
          }
        });
      }
      if (!map.getSource("search-areas")) {
        map.addSource("search-areas", {
          type: "geojson",
          data: { type: "FeatureCollection", features: [] }
        });
      }
      if (!map.getLayer("search-areas-fill")) {
        map.addLayer({
          id: "search-areas-fill",
          type: "fill",
          source: "search-areas",
          paint: {
            "fill-color": "rgba(255,0,255,0.1)",
            "fill-opacity": 0.6
          }
        });
      }
      if (!map.getLayer("search-areas-border")) {
        map.addLayer({
          id: "search-areas-border",
          type: "line",
          source: "search-areas",
          paint: {
            "line-color": "#ff00ff",
            "line-width": 2,
            "line-opacity": 0.6
          }
        });
      }
      const urlParams = new URLSearchParams(window.location.search);
      const isDebug = urlParams.has("debug");
      const uaOnly = urlParams.has("uaOnly");
      if (isDebug || uaOnly) {
        if (map.getLayer("search-areas-fill")) {
          map.setLayoutProperty("search-areas-fill", "visibility", "none");
        }
        if (map.getLayer("search-areas-border")) {
          map.setLayoutProperty("search-areas-border", "visibility", "none");
        }
      }
      if (map.getLayer("user-areas-fill") && map.getLayer("search-areas-fill")) {
        map.moveLayer("user-areas-fill");
        map.moveLayer("user-areas-border");
      }
      const handleUserAreaClick = (e) => {
        if (!e.features || e.features.length === 0) return;
        const feature = e.features[0];
        const props = feature.properties;
        const coords = feature.geometry.coordinates[0][0];
        const point = map.project(coords);
        setTooltip({
          id: props.id,
          type: "user",
          label: props.label || "Buzz Area",
          radius: props.radiusKm * 1e3,
          level: props.level,
          radius_km: props.radius_km,
          screenX: point.x,
          screenY: point.y,
          lat: coords[1],
          lng: coords[0]
        });
      };
      const handleSearchAreaClick = (e) => {
        if (!e.features || e.features.length === 0) return;
        const feature = e.features[0];
        const props = feature.properties;
        const coords = feature.geometry.coordinates[0][0];
        const point = map.project(coords);
        setTooltip({
          id: props.id,
          type: "search",
          label: props.label || "Search Area",
          radius: props.radiusKm * 1e3,
          screenX: point.x,
          screenY: point.y,
          lat: coords[1],
          lng: coords[0]
        });
      };
      map.on("click", "user-areas-fill", handleUserAreaClick);
      map.on("click", "search-areas-fill", handleSearchAreaClick);
      map.on("mouseenter", "user-areas-fill", () => {
        map.getCanvas().style.cursor = "pointer";
      });
      map.on("mouseleave", "user-areas-fill", () => {
        map.getCanvas().style.cursor = "";
      });
      map.on("mouseenter", "search-areas-fill", () => {
        map.getCanvas().style.cursor = "pointer";
      });
      map.on("mouseleave", "search-areas-fill", () => {
        map.getCanvas().style.cursor = "";
      });
      initializedRef.current = true;
    };
    if (map.loaded()) {
      initLayers();
    } else {
      map.once("load", initLayers);
    }
    return () => {
      initializedRef.current = false;
    };
  }, [map, enabled]);
  reactExports.useEffect(() => {
    if (!map || !initializedRef.current) {
      return;
    }
    const source = map.getSource("user-areas");
    if (!source) {
      return;
    }
    const features = userAreas.filter((area) => {
      const isValidLat = typeof area.lat === "number" && isFinite(area.lat) && Math.abs(area.lat) <= 90;
      const isValidLng = typeof area.lng === "number" && isFinite(area.lng) && Math.abs(area.lng) <= 180;
      if (!isValidLat || !isValidLng) {
        return false;
      }
      return true;
    }).map((area) => {
      const radiusMeters = Number.isFinite(area.radius) ? area.radius : Number.isFinite(area.radius_km) ? area.radius_km * 1e3 : NaN;
      if (!Number.isFinite(radiusMeters)) {
        return null;
      }
      const radiusKm = Number.isFinite(area.radius_km) ? area.radius_km : radiusMeters / 1e3;
      const circle = makeCircle(area.lng, area.lat, radiusKm);
      return {
        ...circle,
        properties: {
          ...circle.properties,
          id: area.id,
          label: area.label || "Buzz Area",
          radiusKm,
          //  Exact DB value
          radius_km: radiusKm,
          //  Exact DB value
          radiusMeters,
          //  Derived value
          level: area.level
        }
      };
    }).filter((feature) => feature !== null);
    if (features.length > 0) ;
    source.setData({ type: "FeatureCollection", features });
    if (features.length > 0) ;
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("debug")) {
      const searchSource = map.getSource("search-areas");
      if (searchSource) {
        const searchData = searchSource._data || searchSource.serialize && searchSource.serialize().data;
        const searchFeats = searchData?.features || [];
        if (searchFeats.length > 0) ;
      }
    }
    if (features.length > 0) {
      try {
        if (map.getLayer("user-areas-fill")) {
          map.moveLayer("user-areas-fill");
        }
        if (map.getLayer("user-areas-border")) {
          map.moveLayer("user-areas-border");
        }
      } catch (e) {
      }
    }
  }, [map, currentAreaVersion]);
  reactExports.useEffect(() => {
    if (!map || !initializedRef.current) return;
    const source = map.getSource("search-areas");
    if (!source) return;
    const features = searchAreas.map((area) => {
      const radiusKm = area.radius / 1e3;
      const circle = makeCircle(area.lng, area.lat, radiusKm);
      return {
        ...circle,
        properties: {
          ...circle.properties,
          id: area.id,
          label: area.label || "Search Area",
          radiusKm,
          color: area.color || "#ff00ff"
        }
      };
    });
    source.setData({ type: "FeatureCollection", features });
  }, [map, searchAreas]);
  if (!enabled) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: tooltip && /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        position: "absolute",
        left: tooltip.screenX,
        top: tooltip.screenY,
        transform: "translate(-50%, -120%)",
        background: "rgba(0, 0, 0, 0.85)",
        color: "#fff",
        padding: "8px 12px",
        borderRadius: "6px",
        fontSize: "12px",
        whiteSpace: "nowrap",
        pointerEvents: "none",
        zIndex: 100,
        boxShadow: "0 2px 8px rgba(0, 0, 0, 0.3)",
        border: "1px solid rgba(255, 255, 255, 0.2)"
      },
      children: [
        tooltip.type === "user" && tooltip.level !== void 0 && tooltip.radius_km !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontWeight: "bold" }, children: [
          "Livello ",
          tooltip.level,
          "  ",
          Math.round(tooltip.radius_km),
          " km"
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: "bold", marginBottom: "4px" }, children: tooltip.label }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "11px", opacity: 0.9 }, children: [
            "Radius: ",
            Math.round(tooltip.radius / 1e3),
            "km"
          ] })
        ] }),
        tooltip.type === "search" && onDeleteSearchArea && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: (e) => {
              e.stopPropagation();
              onDeleteSearchArea(tooltip.id);
              setTooltip(null);
            },
            style: {
              marginTop: "6px",
              padding: "4px 8px",
              background: "rgba(255, 0, 0, 0.8)",
              border: "none",
              borderRadius: "4px",
              color: "#fff",
              fontSize: "10px",
              cursor: "pointer",
              pointerEvents: "auto"
            },
            children: "Delete"
          }
        )
      ]
    }
  ) });
};

const BuzzDiagnosticPanel = () => {
  const { user } = useAuthContext();
  const isDebugEnabled = useDebugFlag();
  const [areas, setAreas] = reactExports.useState([]);
  const [isCollapsed, setIsCollapsed] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (!user?.id || !isDebugEnabled) return;
    const loadAreas = async () => {
      const { data, error } = await supabase.from("user_map_areas").select("id, week, radius_km, level, created_at, source, center_lat, center_lng").eq("user_id", user.id).eq("source", "buzz_map").order("created_at", { ascending: false }).limit(10);
      if (error) {
        return;
      }
      setAreas(data || []);
    };
    loadAreas();
    const channel = supabase.channel("buzz_diagnostic").on(
      "postgres_changes",
      {
        event: "INSERT",
        schema: "public",
        table: "user_map_areas",
        filter: `user_id=eq.${user.id}`
      },
      (payload) => {
        loadAreas();
      }
    ).subscribe();
    return () => {
      supabase.removeChannel(channel);
    };
  }, [user?.id, isDebugEnabled]);
  if (!isDebugEnabled) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fixed bottom-20 left-2 z-[9999] bg-black/90 border border-cyan-500/30 rounded-lg shadow-xl max-w-sm", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "px-3 py-2 flex items-center justify-between cursor-pointer hover:bg-white/5",
        onClick: () => setIsCollapsed(!isCollapsed),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "text-xs font-bold text-cyan-400", children: [
            " BUZZ DIAGNOSTIC (",
            areas.length,
            ")"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-cyan-400 text-xs", children: isCollapsed ? "" : "" })
        ]
      }
    ),
    !isCollapsed && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-3 pb-3 max-h-96 overflow-y-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2 text-xs", children: [
      areas.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-500 py-2", children: "No BUZZ areas yet" }),
      areas.map((area, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "border-t border-cyan-500/20 pt-2 space-y-1",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-start", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-cyan-300 font-semibold", children: [
                "#",
                idx + 1
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-400 text-[10px]", children: new Date(area.created_at).toLocaleString("it-IT", {
                day: "2-digit",
                month: "2-digit",
                hour: "2-digit",
                minute: "2-digit"
              }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-x-2 gap-y-0.5 text-[10px]", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-500", children: "Week:" }),
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-white font-mono", children: area.week })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-500", children: "Level:" }),
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-cyan-400 font-bold", children: area.level })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-500", children: "Radius:" }),
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-yellow-400 font-mono", children: [
                  area.radius_km,
                  " km"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-500", children: "Cost:" }),
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-green-400 font-mono", children: [
                  area.cost_m1u || 0,
                  " M1U"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-500", children: "Center:" }),
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-300 font-mono", children: [
                  area.center_lat?.toFixed(5) || "N/A",
                  ", ",
                  area.center_lng?.toFixed(5) || "N/A"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-500", children: "Source:" }),
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-purple-400", children: area.source })
              ] })
            ] })
          ]
        },
        area.id
      ))
    ] }) })
  ] });
};

const BuzzDebugBadge = ({ latestArea }) => {
  const { user } = useAuthContext();
  const isDebugEnabled = useDebugFlag();
  const { nextLevel, nextRadiusKm } = useBuzzMapPricingNew(user?.id);
  const [dbCurrentRadiusKm, setDbCurrentRadiusKm] = reactExports.useState(null);
  const [dbCurrentLevel, setDbCurrentLevel] = reactExports.useState(null);
  const [geoJsonRadiusKm, setGeoJsonRadiusKm] = reactExports.useState(null);
  const [geoJsonLevel, setGeoJsonLevel] = reactExports.useState(null);
  reactExports.useEffect(() => {
    if (!user?.id || !isDebugEnabled) return;
    const loadLatestFromDB = async () => {
      const currentWeek = getCurrentWeekOfYear();
      const { data, error } = await supabase.from("user_map_areas").select("id, radius_km, level, created_at").eq("user_id", user.id).eq("source", "buzz_map").eq("week", currentWeek).order("created_at", { ascending: false }).limit(1).single();
      if (error && error.code !== "PGRST116") {
        return;
      }
      if (data) {
        setDbCurrentRadiusKm(data.radius_km);
        setDbCurrentLevel(data.level);
      } else {
        setDbCurrentRadiusKm(null);
        setDbCurrentLevel(null);
      }
    };
    loadLatestFromDB();
    const handleBuzzCreated = () => {
      setTimeout(() => loadLatestFromDB(), 500);
    };
    window.addEventListener("buzzAreaCreated", handleBuzzCreated);
    return () => {
      window.removeEventListener("buzzAreaCreated", handleBuzzCreated);
    };
  }, [user?.id, isDebugEnabled]);
  reactExports.useEffect(() => {
    if (!isDebugEnabled) return;
    const readGeoJson = () => {
      try {
        const map2 = window.M1_MAP;
        if (!map2) return;
        const source = map2.getSource?.("user-areas");
        const data = source && (source._data || source.serialize?.().data);
        const props = data?.features?.[0]?.properties;
        if (props) {
          setGeoJsonRadiusKm(props.radiusKm || null);
          setGeoJsonLevel(props.level || null);
        } else {
          setGeoJsonRadiusKm(null);
          setGeoJsonLevel(null);
        }
      } catch (e) {
      }
    };
    readGeoJson();
    const map = window.M1_MAP;
    if (!map) return;
    const handleSourceData = (e) => {
      if (e.sourceId === "user-areas" && e.isSourceLoaded) {
        setTimeout(readGeoJson, 100);
      }
    };
    const handleBuzzUpdate = () => {
      setTimeout(readGeoJson, 500);
    };
    map.on("sourcedata", handleSourceData);
    window.addEventListener("buzzAreaCreated", handleBuzzUpdate);
    return () => {
      map.off("sourcedata", handleSourceData);
      window.removeEventListener("buzzAreaCreated", handleBuzzUpdate);
    };
  }, [isDebugEnabled]);
  if (!isDebugEnabled) return null;
  const uiRadiusKm = geoJsonRadiusKm;
  const uiLevel = geoJsonLevel;
  const radiusMismatch = dbCurrentRadiusKm !== null && uiRadiusKm !== null && Math.abs(dbCurrentRadiusKm - uiRadiusKm) > 0.01;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "fixed top-20 right-2 z-[9999] bg-black/90 border rounded-lg shadow-xl text-xs p-3 space-y-1 min-w-[280px]",
      style: {
        borderColor: radiusMismatch ? "#ef4444" : "#06b6d4"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-bold text-cyan-400 border-b border-cyan-500/30 pb-1 mb-2", children: " BUZZ VERIFY MODE" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-x-4 gap-y-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-400", children: "Source:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-cyan-300 font-mono", children: "user-areas GeoJSON" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-400", children: "DB current:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `font-mono ${radiusMismatch ? "text-red-400 font-bold" : "text-cyan-300"}`, children: dbCurrentRadiusKm !== null ? `L${dbCurrentLevel || "?"}  ${dbCurrentRadiusKm.toFixed(1)} km` : "N/A" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-400", children: "GeoJSON live:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `font-mono ${radiusMismatch ? "text-red-400 font-bold" : "text-green-400"}`, children: uiRadiusKm !== null ? `L${uiLevel || "?"}  ${uiRadiusKm.toFixed(1)} km` : "N/A" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-400", children: "Next:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-purple-400 font-mono", children: [
            "L",
            nextLevel,
            "  ",
            nextRadiusKm.toFixed(1),
            " km"
          ] })
        ] }),
        latestArea && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-[10px] text-gray-500 pt-1 border-t border-gray-700/50", children: [
          "Center: ",
          latestArea.lat.toFixed(4),
          ", ",
          latestArea.lng.toFixed(4)
        ] }),
        radiusMismatch && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-400 text-[10px] pt-1 border-t border-red-500/30 font-bold", children: " MISMATCH DETECTED" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-[9px] text-gray-600 pt-1 space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " buzzAreaCreated" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " realtime" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " render" })
        ] })
      ]
    }
  );
};

const MapVerificationPanel = () => {
  const [results, setResults] = reactExports.useState([]);
  const [isRunning, setIsRunning] = reactExports.useState(false);
  const runVerification = async () => {
    setIsRunning(true);
    const newResults = [];
    const step1 = {
      step: "1. Debug Helpers",
      status: "pending",
      details: ""
    };
    const helpers = ["M1_MAP", "__inventoryLayers", "__whoDrawsHere", "__onlyUserAreas", "__killOverlay"];
    const missing = helpers.filter((h) => !window[h]);
    step1.status = missing.length === 0 ? "pass" : "fail";
    step1.details = missing.length === 0 ? " All helpers available" : ` Missing: ${missing.join(", ")}`;
    newResults.push(step1);
    setResults([...newResults]);
    if (step1.status === "fail") {
      setIsRunning(false);
      return;
    }
    await new Promise((r) => setTimeout(r, 500));
    const step2 = {
      step: "2. Layer Inventory",
      status: "pending",
      details: ""
    };
    try {
      const inventory = window.__inventoryLayers?.();
      const circleLayers = inventory?.filter(
        (l) => l.id.includes("user-areas") || l.id.includes("search-areas")
      ) || [];
      step2.status = "pass";
      step2.details = `Found ${circleLayers.length} circle layers`;
      step2.data = circleLayers;
    } catch (e) {
      step2.status = "fail";
      step2.details = ` Error: ${e}`;
    }
    newResults.push(step2);
    setResults([...newResults]);
    await new Promise((r) => setTimeout(r, 500));
    const step3 = {
      step: "3. Who Draws Here",
      status: "pending",
      details: ""
    };
    try {
      const map = window.M1_MAP;
      const center = map.getCenter();
      const drawers = window.__whoDrawsHere?.(center.lng, center.lat);
      const circleDrawers = drawers?.filter(
        (d) => typeof d.layer === "string" && (d.layer.includes("fill") || d.layer.includes("border"))
      ) || [];
      step3.status = "pass";
      step3.details = circleDrawers.length > 0 ? `Drawing: ${circleDrawers.map((d) => d.layer).join(", ")}` : " No circles at center";
      step3.data = circleDrawers;
    } catch (e) {
      step3.status = "fail";
      step3.details = ` Error: ${e}`;
    }
    newResults.push(step3);
    setResults([...newResults]);
    await new Promise((r) => setTimeout(r, 500));
    const step4 = {
      step: "4. User-Areas Props (GeoJSON)",
      status: "pending",
      details: ""
    };
    try {
      const map = window.M1_MAP;
      const source = map.getSource("user-areas");
      const data = source?._data || source?.serialize?.().data;
      const props = data?.features?.[0]?.properties;
      if (!props) {
        step4.status = "fail";
        step4.details = " No user-areas data";
      } else {
        step4.status = "pass";
        step4.details = `L${props.level}  ${props.radius_km || props.radiusKm}km`;
        step4.data = props;
      }
    } catch (e) {
      step4.status = "fail";
      step4.details = ` Error: ${e}`;
    }
    newResults.push(step4);
    setResults([...newResults]);
    await new Promise((r) => setTimeout(r, 500));
    const step5 = {
      step: "5. DB User Map Areas",
      status: "pending",
      details: ""
    };
    try {
      const supabase = window.supabase;
      if (!supabase) {
        step5.status = "fail";
        step5.details = " Supabase not available";
      } else {
        const getIsoWeekUTC = () => {
          const now = /* @__PURE__ */ new Date();
          const dt = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
          const day = dt.getUTCDay() || 7;
          dt.setUTCDate(dt.getUTCDate() + 4 - day);
          const yearStart = new Date(Date.UTC(dt.getUTCFullYear(), 0, 1));
          return Math.ceil(((dt.getTime() - yearStart.getTime()) / 864e5 + 1) / 7);
        };
        const currentWeek = getIsoWeekUTC();
        const { data: dbData, error } = await supabase.from("user_map_areas").select("*").eq("source", "buzz_map").eq("week", currentWeek).order("created_at", { ascending: false }).limit(1).single();
        if (error || !dbData) {
          step5.status = "fail";
          step5.details = ` No DB data: ${error?.message || "empty"}`;
        } else {
          step5.status = "pass";
          step5.details = `Level ${dbData.level}  ${dbData.radius_km}km (DB)`;
          step5.data = dbData;
          const uaProps = newResults[3]?.data;
          if (uaProps && (uaProps.level !== dbData.level || uaProps.radiusKm !== dbData.radius_km)) {
            step5.details += "  MISMATCH with GeoJSON!";
          }
        }
      }
    } catch (e) {
      step5.status = "fail";
      step5.details = ` Error: ${e}`;
    }
    newResults.push(step5);
    setResults([...newResults]);
    setIsRunning(false);
  };
  const clearUserAreas = () => {
    try {
      const map = window.M1_MAP;
      const source = map.getSource("user-areas");
      source.setData({ type: "FeatureCollection", features: [] });
    } catch (e) {
    }
  };
  const killOverlay = () => {
    try {
      window.__killOverlay?.();
    } catch (e) {
    }
  };
  const onlyUserAreas = () => {
    try {
      window.__onlyUserAreas?.();
    } catch (e) {
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fixed top-20 right-4 z-[9999] bg-black/90 backdrop-blur-sm border border-cyan-500/30 rounded-lg p-4 max-w-md max-h-[70vh] overflow-y-auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-cyan-400 font-bold text-sm", children: "MAP VERIFICATION" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          size: "sm",
          onClick: runVerification,
          disabled: isRunning,
          className: "bg-cyan-500/20 hover:bg-cyan-500/30 text-cyan-400 text-xs",
          children: isRunning ? " Running..." : " Run Test"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2 mb-4", children: results.map((result, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-black/50 rounded p-2 text-xs", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mb-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: result.status === "pass" ? "text-green-400" : result.status === "fail" ? "text-red-400" : "text-yellow-400", children: result.status === "pass" ? "" : result.status === "fail" ? "" : "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-white font-medium", children: result.step })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-400 ml-6", children: result.details })
    ] }, i)) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          size: "sm",
          onClick: onlyUserAreas,
          className: "bg-purple-500/20 hover:bg-purple-500/30 text-purple-400 text-xs flex-1",
          children: " Only UA"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          size: "sm",
          onClick: clearUserAreas,
          className: "bg-orange-500/20 hover:bg-orange-500/30 text-orange-400 text-xs flex-1",
          children: " Clear UA"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          size: "sm",
          onClick: killOverlay,
          className: "bg-red-500/20 hover:bg-red-500/30 text-red-400 text-xs flex-1",
          children: " Kill Overlay"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4 pt-4 border-t border-cyan-500/20 text-[10px] text-gray-500", children: "Auto-verification panel  Press BUZZ MAP then re-run test to verify shrink" })
  ] });
};

const NOTES_KEY$1 = "map3d-notes";
const NotesLayer3D = ({ map, enabled }) => {
  const [notes, setNotes] = reactExports.useState(() => {
    try {
      const saved = localStorage.getItem(NOTES_KEY$1);
      if (saved) {
        return JSON.parse(saved);
      }
      return [];
    } catch (e) {
      return [];
    }
  });
  const [positions, setPositions] = reactExports.useState(/* @__PURE__ */ new Map());
  const [selectedNote, setSelectedNote] = reactExports.useState(null);
  const [editingNote, setEditingNote] = reactExports.useState(null);
  reactExports.useEffect(() => {
    try {
      localStorage.setItem(NOTES_KEY$1, JSON.stringify(notes));
    } catch (e) {
    }
  }, [notes]);
  reactExports.useEffect(() => {
    if (!map || !enabled) return;
    const updatePositions = () => {
      const newPositions = /* @__PURE__ */ new Map();
      notes.forEach((note) => {
        const point = map.project([note.lng, note.lat]);
        newPositions.set(note.id, { x: point.x, y: point.y });
      });
      setPositions(newPositions);
    };
    updatePositions();
    map.on("move", updatePositions);
    map.on("zoom", updatePositions);
    map.on("resize", updatePositions);
    return () => {
      map.off("move", updatePositions);
      map.off("zoom", updatePositions);
      map.off("resize", updatePositions);
    };
  }, [map, notes, enabled]);
  const handleSave = () => {
    if (!editingNote || !selectedNote) return;
    setNotes((prev) => prev.map(
      (n) => n.id === selectedNote ? { ...n, title: editingNote.title, note: editingNote.note } : n
    ));
    setSelectedNote(null);
    setEditingNote(null);
    ue.success("Nota salvata");
  };
  const handleDelete = (id) => {
    setNotes((prev) => prev.filter((n) => n.id !== id));
    if (selectedNote === id) {
      setSelectedNote(null);
      setEditingNote(null);
    }
    ue.success("Nota rimossa");
  };
  if (!enabled) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 pointer-events-none", style: { zIndex: 670 }, children: notes.map((note) => {
      const pos = positions.get(note.id);
      if (!pos) return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "absolute pointer-events-auto cursor-pointer",
          style: {
            left: `${pos.x}px`,
            top: `${pos.y}px`,
            transform: "translate(-50%, -50%)"
          },
          onClick: () => {
            setSelectedNote(note.id);
            setEditingNote({ title: note.title, note: note.note });
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            MapPin,
            {
              className: "text-purple-500",
              size: 24,
              fill: note.note ? "#a855f7" : "transparent",
              style: { filter: "drop-shadow(0 0 4px rgba(168, 85, 247, 0.8))" }
            }
          )
        },
        note.id
      );
    }) }),
    selectedNote && editingNote && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-[9999] w-full max-w-md p-4",
        style: { pointerEvents: "auto" },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-black/90 border border-purple-500/30 rounded-2xl p-6 backdrop-blur-xl", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-white font-bold text-lg", children: "Modifica Nota" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "ghost",
                size: "sm",
                onClick: () => {
                  setSelectedNote(null);
                  setEditingNote(null);
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { className: "w-4 h-4" })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                value: editingNote.title,
                onChange: (e) => setEditingNote({ ...editingNote, title: e.target.value }),
                placeholder: "Titolo",
                className: "bg-black/50 border-purple-500/30"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Textarea,
              {
                value: editingNote.note,
                onChange: (e) => setEditingNote({ ...editingNote, note: e.target.value }),
                placeholder: "Descrizione...",
                rows: 3,
                className: "bg-black/50 border-purple-500/30"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "destructive",
                  size: "sm",
                  onClick: () => handleDelete(selectedNote),
                  className: "flex-1",
                  children: "Elimina"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  size: "sm",
                  onClick: handleSave,
                  className: "flex-1 bg-purple-600 hover:bg-purple-700",
                  children: "Salva"
                }
              )
            ] })
          ] })
        ] })
      }
    )
  ] });
};

const LayerTogglePanel = ({ layers, onToggle }) => {
  const [isExpanded, setIsExpanded] = reactExports.useState(false);
  const layerConfigs = [
    { key: "agents", label: "Agents", icon: Users, color: "#FF3366" },
    { key: "portals", label: "Portals", icon: Hexagon, color: "#00f0ff" },
    { key: "rewards", label: "Rewards", icon: Gift, color: "#FFD700" },
    { key: "areas", label: "Aree", icon: Circle, color: "#00D1FF" },
    { key: "notes", label: "Note", icon: FileText, color: "#a855f7" }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "fixed right-4 z-[100]",
      style: {
        top: "calc(env(safe-area-inset-top, 0px) + 96px)",
        pointerEvents: "auto"
      },
      children: [
        !isExpanded && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => setIsExpanded(true),
            className: "flex items-center gap-2 px-4 py-2 bg-black/80 backdrop-blur-xl rounded-full border border-cyan-500/20 hover:border-cyan-500/40 transition-all",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Layers, { className: "w-4 h-4 text-cyan-400" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-white font-bold font-orbitron", children: "LAYERS" })
            ]
          }
        ),
        isExpanded && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2 bg-black/80 backdrop-blur-xl rounded-2xl p-3 border border-cyan-500/20 min-w-[160px]", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "flex items-center justify-between mb-2 pb-2 border-b border-white/10 cursor-pointer",
              onClick: () => setIsExpanded(false),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Layers, { className: "w-4 h-4 text-cyan-400" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-white font-bold font-orbitron", children: "LAYERS" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUp, { className: "w-4 h-4 text-cyan-400" })
              ]
            }
          ),
          layerConfigs.map(({ key, label, icon: Icon, color }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              variant: "ghost",
              size: "sm",
              onClick: () => onToggle(key),
              className: `justify-start gap-2 transition-all ${layers[key] ? "bg-white/10 text-white" : "text-gray-400 hover:text-white"}`,
              style: {
                borderLeft: layers[key] ? `3px solid ${color}` : "3px solid transparent"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "w-4 h-4", style: { color: layers[key] ? color : void 0 } }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs", children: label }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `ml-auto w-2 h-2 rounded-full ${layers[key] ? "bg-green-500" : "bg-gray-600"}` })
              ]
            },
            key
          ))
        ] })
      ]
    }
  );
};
function Hexagon(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z" })
    }
  );
}

const GeolocationPermissionGuide = ({
  isIOS = false,
  isPWA = false,
  onRetry
}) => {
  const openSettings = () => {
    if (isIOS) {
      try {
        window.open("App-Prefs:Privacy&path=LOCATION", "_system");
      } catch {
        alert("Apri Impostazioni > Privacy e Sicurezza > Localizzazione");
      }
    } else {
      alert("Apri le impostazioni del browser e abilita la geolocalizzazione per questo sito");
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { className: "glass-card bg-gradient-to-br from-amber-500/10 via-orange-500/10 to-red-500/10 border-amber-500/30 p-6 m-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center space-y-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-16 h-16 rounded-full bg-gradient-to-br from-amber-500/30 to-red-500/30 flex items-center justify-center shadow-[0_0_30px_rgba(245,158,11,0.4)]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { className: "w-8 h-8 text-amber-400" }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-white", children: "Geolocalizzazione Bloccata" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-300 text-sm leading-relaxed", children: isIOS && isPWA ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "La geolocalizzazione  stata bloccata per questa app. Per utilizzare le funzioni di mappa e localizzazione, devi abilitarla manualmente nelle impostazioni." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "La geolocalizzazione  bloccata per questo sito. Abilita l'accesso alla posizione nelle impostazioni del browser." }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gradient-to-r from-[#00D1FF]/10 to-[#FF1493]/10 rounded-lg p-4 border border-[#00D1FF]/20", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start gap-3 text-left", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Settings, { className: "w-5 h-5 text-[#00D1FF] mt-0.5 flex-shrink-0" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-300 space-y-2", children: isIOS ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-medium text-white", children: "Istruzioni per iOS:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "list-decimal list-inside space-y-1 text-xs", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
            "Apri l'app ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Impostazioni" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
            "Vai su ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Privacy e Sicurezza" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
            "Seleziona ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Localizzazione" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
            'Assicurati che "Servizi di localizzazione" sia ',
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "attivo" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
            "Scorri fino a ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Safari" }),
            " e selezionalo"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
            "Scegli ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: `"Durante l'uso dell'app"` })
          ] }),
          isPWA && /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Riavvia l'app M1SSION dal tuo schermo home" })
        ] })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-medium text-white", children: "Istruzioni per il browser:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "list-decimal list-inside space-y-1 text-xs", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
            "Clicca sull'icona del ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "lucchetto" }),
            " nella barra degli indirizzi"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
            "Seleziona ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: '"Autorizzazioni del sito"' })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
            'Cambia "Posizione" da ',
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: '"Blocca"' }),
            " a ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: '"Consenti"' })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Ricarica la pagina" })
        ] })
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button,
        {
          variant: "outline",
          onClick: openSettings,
          className: "flex-1 border-amber-500/50 text-amber-400 hover:bg-amber-500/10",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Settings, { className: "w-4 h-4 mr-2" }),
            "Apri Impostazioni"
          ]
        }
      ),
      onRetry && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button,
        {
          onClick: onRetry,
          className: "flex-1 bg-gradient-to-r from-[#00D1FF] to-[#FF1493] text-white font-medium hover:shadow-[0_0_20px_rgba(0,209,255,0.4)]",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { className: "w-4 h-4 mr-2" }),
            "Riprova"
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-gray-500 space-y-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Suggerimento:" }),
        " Dopo aver modificato le impostazioni,",
        isPWA ? " riavvia l'app" : " ricarica la pagina",
        " per applicare le modifiche."
      ] }),
      isIOS && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: " Su iOS, potresti dover chiudere completamente Safari e riaprirlo." })
    ] })
  ] }) });
};

function use3DDevMocks() {
  {
    return {
      agents: [],
      rewards: [],
      notesSeed: [],
      userAreas: [],
      searchAreas: []
    };
  }
}

const NOTES_KEY = "map3d-notes";
const DevNotesPanel = ({ map }) => {
  const [open, setOpen] = reactExports.useState(false);
  const [notes, setNotes] = reactExports.useState([]);
  reactExports.useEffect(() => {
    if (!open) return;
    try {
      const saved = localStorage.getItem(NOTES_KEY);
      setNotes(saved ? JSON.parse(saved) : []);
    } catch (e) {
      setNotes([]);
    }
  }, [open]);
  const count = notes.length;
  const flyTo = (n) => {
    if (!map) return;
    map.flyTo({ center: [n.lng, n.lat], zoom: Math.max(map.getZoom(), 15), duration: 800 });
  };
  const remove = (id) => {
    const next = notes.filter((n) => n.id !== id);
    setNotes(next);
    localStorage.setItem(NOTES_KEY, JSON.stringify(next));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        position: "fixed",
        bottom: "calc(env(safe-area-inset-bottom, 34px) + 80px)",
        left: 12,
        zIndex: 1002,
        pointerEvents: "auto"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "m1x-pill m1x-pill--note",
            onClick: () => setOpen((o) => !o),
            title: "Note (DEV)",
            style: { transform: "scale(0.75)" },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m1x-pill__icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, { className: "h-5 w-5 text-cyan-400" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "m1x-pill__label", children: [
                "Note (",
                count,
                ")"
              ] })
            ]
          }
        ),
        open && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2 w-[195px] rounded-xl border border-cyan-500/30 bg-black/70 backdrop-blur-md p-1.5 text-xs text-white/90", children: notes.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-[10px] text-white/70 px-1.5 py-2", children: "Nessuna nota. Tocca un marker per modificare." }) : /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "max-h-[195px] overflow-auto space-y-1.5 pr-1", children: notes.map((n) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "rounded-lg border border-white/10 p-1.5", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-medium text-[11px] truncate", children: n.title || "Senza titolo" }),
          n.note && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-[10px] text-white/70 line-clamp-2", children: n.note }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-1.5 flex items-center gap-1.5", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { size: "sm", className: "h-6 px-1.5 text-[10px] bg-black/60 hover:bg-black/80 border border-cyan-500/30", onClick: () => flyTo(n), children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Crosshair, { className: "h-2.5 w-2.5 mr-0.5" }),
              " Centra"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { size: "sm", variant: "destructive", className: "h-6 px-1.5 text-[10px]", onClick: () => remove(n.id), children: "Elimina" })
          ] })
        ] }, n.id)) }) })
      ]
    }
  );
};

const DevAreasPanel = ({ map, searchAreas, onDelete, onFocus, onAddArea }) => {
  const [open, setOpen] = reactExports.useState(false);
  const [showRadiusPicker, setShowRadiusPicker] = reactExports.useState(false);
  const [selectedRadius, setSelectedRadius] = reactExports.useState(500);
  const radiusOptions = [
    { value: 250, label: "250m" },
    { value: 500, label: "500m" },
    { value: 1e3, label: "1km" },
    { value: 2e3, label: "2km" }
  ];
  const handleAddAreaClick = () => {
    setSelectedRadius(500);
    setShowRadiusPicker(true);
  };
  const handleConfirmRadius = () => {
    setShowRadiusPicker(false);
    onAddArea(selectedRadius);
  };
  const flyTo = (a) => {
    if (!map) return;
    map.flyTo({ center: [a.lng, a.lat], zoom: Math.max(map.getZoom(), 15), duration: 800 });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          position: "fixed",
          bottom: "calc(env(safe-area-inset-bottom, 34px) + 80px)",
          right: 12,
          zIndex: 1002,
          pointerEvents: "auto"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "m1x-pill m1x-pill--areas",
              onClick: () => setOpen((o) => !o),
              title: "Punti/Aree (DEV)",
              style: { transform: "scale(0.75)" },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m1x-pill__icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MapPin, { className: "h-5 w-5 text-purple-400" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "m1x-pill__label", children: [
                  "Punti/Aree (",
                  searchAreas?.length || 0,
                  ")"
                ] })
              ]
            }
          ),
          open && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 w-[195px] rounded-xl border border-purple-500/30 bg-black/70 backdrop-blur-md p-1.5 text-xs text-white/90", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-1.5", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-[10px] text-white/80", children: "Gestisci aree di ricerca" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { size: "sm", className: "h-6 px-1.5 text-[10px] bg-black/60 hover:bg-black/80 border border-purple-500/30", onClick: handleAddAreaClick, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "h-2.5 w-2.5 mr-0.5" }),
                " Nuova"
              ] })
            ] }),
            !searchAreas || searchAreas.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-[10px] text-white/70 px-1.5 py-2", children: 'Nessuna area. Usa "Nuova" e poi clicca sulla mappa.' }) : /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "max-h-[195px] overflow-auto space-y-1.5 pr-1", children: searchAreas.map((a) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "rounded-lg border border-white/10 p-1.5", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-medium text-[11px] truncate", children: a.label || "Area di ricerca" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-[10px] text-white/70", children: [
                "Raggio: ",
                (a.radius / 1e3).toFixed(1),
                " km"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-1.5 flex items-center gap-1.5", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { size: "sm", className: "h-6 px-1.5 text-[10px] bg-black/60 hover:bg-black/80 border border-cyan-500/30", onClick: () => {
                  onFocus(a.id);
                  flyTo(a);
                }, children: "Focus" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { size: "sm", variant: "destructive", className: "h-6 px-1.5 text-[10px]", onClick: () => onDelete(a.id), children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "h-2.5 w-2.5 mr-0.5" }),
                  " Elimina"
                ] })
              ] })
            ] }, a.id)) })
          ] })
        ]
      }
    ),
    showRadiusPicker && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m1x-radius-picker-backdrop", onClick: () => setShowRadiusPicker(false) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "m1x-radius-picker", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m1x-radius-picker__title", children: "Seleziona il raggio dell'area" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m1x-radius-picker__options", children: radiusOptions.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: `m1x-radius-picker__option ${selectedRadius === option.value ? "m1x-radius-picker__option--selected" : ""}`,
            onClick: () => setSelectedRadius(option.value),
            children: option.label
          },
          option.value
        )) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "m1x-radius-picker__actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "m1x-radius-picker__btn m1x-radius-picker__btn--cancel",
              onClick: () => setShowRadiusPicker(false),
              children: "Annulla"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "m1x-radius-picker__btn m1x-radius-picker__btn--confirm",
              onClick: handleConfirmRadius,
              children: "Conferma"
            }
          )
        ] })
      ] })
    ] })
  ] });
};

function useBattleRealtimeSubscription(battleId) {
  const [state, setState] = reactExports.useState({
    status: "await_defense"
  });
  const [channel, setChannel] = reactExports.useState(null);
  reactExports.useEffect(() => {
    if (!battleId) {
      setChannel(null);
      return;
    }
    const battleChannel = supabase.channel(`battle:${battleId}`).on(
      "postgres_changes",
      {
        event: "*",
        schema: "public",
        table: "battles",
        // TRON Battle canonical table
        filter: `id=eq.${battleId}`
      },
      (payload) => {
        const newData = payload.new;
        let mappedStatus = "await_defense";
        if (newData.status === "resolved" || newData.status === "expired") {
          mappedStatus = "resolved";
        } else if (newData.status === "cancelled") {
          mappedStatus = "cancelled";
        } else if (newData.status === "pending" || newData.status === "accepted") {
          mappedStatus = "await_defense";
        }
        setState((prev) => ({
          ...prev,
          status: mappedStatus,
          winnerId: newData.winner_id,
          until: newData.expires_at ? new Date(newData.expires_at).getTime() : void 0
        }));
      }
    ).on(
      "postgres_changes",
      {
        event: "INSERT",
        schema: "public",
        table: "battle_audit",
        // TRON audit events
        filter: `battle_id=eq.${battleId}`
      },
      (payload) => {
        const audit = payload.new;
        setState((prev) => ({
          ...prev,
          lastEvent: {
            type: audit.event_type,
            payload: audit.payload
          }
        }));
      }
    ).subscribe((status) => {
    });
    setChannel(battleChannel);
    return () => {
      battleChannel.unsubscribe();
    };
  }, [battleId]);
  return { state, channel };
}

function MissileTrail2D({ fromLatLng, toLatLng, onEnd }) {
  const [phase, setPhase] = reactExports.useState("flying");
  const [missilePos, setMissilePos] = reactExports.useState({ x: 20, y: 80 });
  const [particles, setParticles] = reactExports.useState([]);
  const [impactParticles, setImpactParticles] = reactExports.useState([]);
  reactExports.useRef(null);
  const rafRef = reactExports.useRef(0);
  const targetX = 80;
  const targetY = 20;
  const startX = 20;
  const startY = 80;
  reactExports.useEffect(() => {
    const duration = 1200;
    const startTime = Date.now();
    let particleId = 0;
    const animate = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const eased = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
      const currentX = startX + (targetX - startX) * eased;
      const currentY = startY + (targetY - startY) * eased;
      setMissilePos({ x: currentX, y: currentY });
      if (progress < 1) {
        const newParticles = [];
        for (let i = 0; i < 3; i++) {
          newParticles.push({
            id: particleId++,
            x: currentX + (Math.random() - 0.5) * 2,
            y: currentY + (Math.random() - 0.5) * 2,
            vx: (Math.random() - 0.5) * 0.5,
            vy: Math.random() * 0.3 + 0.1,
            life: 1,
            size: Math.random() * 4 + 2,
            color: Math.random() > 0.5 ? "#ff4444" : "#ffaa00"
          });
        }
        setParticles((prev) => [...prev.slice(-50), ...newParticles]);
      }
      setParticles(
        (prev) => prev.map((p) => ({
          ...p,
          x: p.x + p.vx,
          y: p.y + p.vy,
          life: p.life - 0.03,
          size: p.size * 0.95
        })).filter((p) => p.life > 0)
      );
      if (progress < 1) {
        rafRef.current = requestAnimationFrame(animate);
      } else {
        setPhase("impact");
        triggerExplosion();
      }
    };
    animate();
    return () => {
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
    };
  }, []);
  const triggerExplosion = () => {
    const explosionParticles = [];
    let id = 0;
    for (let i = 0; i < 30; i++) {
      const angle = i / 30 * Math.PI * 2;
      const speed = Math.random() * 3 + 1;
      explosionParticles.push({
        id: id++,
        x: targetX,
        y: targetY,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 1,
        size: Math.random() * 8 + 4,
        color: ["#ff0000", "#ff4400", "#ff8800", "#ffcc00"][Math.floor(Math.random() * 4)]
      });
    }
    setImpactParticles(explosionParticles);
    let frame = 0;
    const animateExplosion = () => {
      frame++;
      setImpactParticles(
        (prev) => prev.map((p) => ({
          ...p,
          x: p.x + p.vx,
          y: p.y + p.vy,
          vx: p.vx * 0.95,
          vy: p.vy * 0.95,
          life: p.life - 0.04,
          size: p.size * 0.97
        })).filter((p) => p.life > 0)
      );
      if (frame < 40) {
        requestAnimationFrame(animateExplosion);
      } else {
        setPhase("done");
        onEnd?.();
      }
    };
    setTimeout(() => requestAnimationFrame(animateExplosion), 50);
  };
  if (phase === "done") return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "fixed inset-0 pointer-events-none overflow-hidden",
      style: { zIndex: 2e3 },
      children: [
        particles.map((p) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "absolute rounded-full",
            style: {
              left: `${p.x}%`,
              top: `${p.y}%`,
              width: p.size,
              height: p.size,
              backgroundColor: p.color,
              opacity: p.life,
              boxShadow: `0 0 ${p.size * 2}px ${p.color}`,
              transform: "translate(-50%, -50%)"
            }
          },
          p.id
        )),
        phase === "flying" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            className: "absolute",
            style: {
              left: `${missilePos.x}%`,
              top: `${missilePos.y}%`,
              transform: "translate(-50%, -50%) rotate(-45deg)"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: "relative",
                style: {
                  width: 24,
                  height: 8,
                  background: "linear-gradient(90deg, #333 0%, #666 50%, #ff4444 100%)",
                  borderRadius: "0 4px 4px 0",
                  boxShadow: "0 0 20px #ff4444, 0 0 40px #ff0000"
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        position: "absolute",
                        right: -6,
                        top: "50%",
                        transform: "translateY(-50%)",
                        width: 0,
                        height: 0,
                        borderLeft: "8px solid #ff4444",
                        borderTop: "5px solid transparent",
                        borderBottom: "5px solid transparent"
                      }
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    motion.div,
                    {
                      animate: { scale: [1, 1.3, 1], opacity: [0.8, 1, 0.8] },
                      transition: { duration: 0.1, repeat: Infinity },
                      style: {
                        position: "absolute",
                        left: -12,
                        top: "50%",
                        transform: "translateY(-50%)",
                        width: 16,
                        height: 6,
                        background: "linear-gradient(90deg, transparent, #ffaa00, #ff4400)",
                        borderRadius: "4px 0 0 4px",
                        filter: "blur(2px)"
                      }
                    }
                  )
                ]
              }
            )
          }
        ),
        phase === "impact" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              className: "absolute",
              initial: { scale: 0, opacity: 1 },
              animate: { scale: 3, opacity: 0 },
              transition: { duration: 0.4 },
              style: {
                left: `${targetX}%`,
                top: `${targetY}%`,
                width: 40,
                height: 40,
                borderRadius: "50%",
                background: "radial-gradient(circle, #fff 0%, #ff4400 50%, transparent 100%)",
                transform: "translate(-50%, -50%)",
                boxShadow: "0 0 60px #ff4400, 0 0 100px #ff0000"
              }
            }
          ),
          impactParticles.map((p) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "absolute rounded-full",
              style: {
                left: `${p.x}%`,
                top: `${p.y}%`,
                width: p.size,
                height: p.size,
                backgroundColor: p.color,
                opacity: p.life,
                boxShadow: `0 0 ${p.size}px ${p.color}`,
                transform: "translate(-50%, -50%)"
              }
            },
            p.id
          )),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              className: "absolute",
              initial: { scale: 0, opacity: 0.8 },
              animate: { scale: 4, opacity: 0 },
              transition: { duration: 0.6 },
              style: {
                left: `${targetX}%`,
                top: `${targetY}%`,
                width: 30,
                height: 30,
                borderRadius: "50%",
                border: "3px solid #ff4400",
                transform: "translate(-50%, -50%)"
              }
            }
          )
        ] })
      ]
    }
  );
}

function EMPWave2D({ centerLatLng, onEnd }) {
  const [lightnings, setLightnings] = reactExports.useState([]);
  reactExports.useEffect(() => {
    const bolts = [];
    for (let i = 0; i < 12; i++) {
      bolts.push({
        id: i,
        angle: i / 12 * 360 + Math.random() * 15,
        length: 80 + Math.random() * 60,
        delay: Math.random() * 0.5
      });
    }
    setLightnings(bolts);
    const timer = setTimeout(() => {
      onEnd?.();
    }, 2500);
    return () => clearTimeout(timer);
  }, [onEnd]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "fixed inset-0 pointer-events-none overflow-hidden",
      style: { zIndex: 2e3 },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            className: "absolute left-1/2 top-1/2",
            style: { transform: "translate(-50%, -50%)" },
            initial: { scale: 0, opacity: 1 },
            animate: { scale: [0, 1.5, 0.8], opacity: [1, 0.9, 0] },
            transition: { duration: 0.8 },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "rounded-full",
                style: {
                  width: 100,
                  height: 100,
                  background: "radial-gradient(circle, #00d4ff 0%, #8b5cf6 50%, transparent 100%)",
                  boxShadow: "0 0 80px #00d4ff, 0 0 120px #8b5cf6"
                }
              }
            )
          }
        ),
        [0, 0.15, 0.3].map((delay, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            className: "absolute left-1/2 top-1/2 rounded-full",
            style: { transform: "translate(-50%, -50%)" },
            initial: { width: 20, height: 20, opacity: 0.9 },
            animate: {
              width: [20, 300 + i * 100],
              height: [20, 300 + i * 100],
              opacity: [0.9, 0]
            },
            transition: { duration: 1.5, delay, ease: "easeOut" },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "w-full h-full rounded-full",
                style: {
                  border: `${3 - i}px solid`,
                  borderColor: i === 0 ? "#00d4ff" : i === 1 ? "#8b5cf6" : "#00ff88",
                  boxShadow: `0 0 20px ${i === 0 ? "#00d4ff" : i === 1 ? "#8b5cf6" : "#00ff88"}`
                }
              }
            )
          },
          i
        )),
        lightnings.map((bolt) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            className: "absolute left-1/2 top-1/2",
            style: {
              transform: `translate(-50%, -50%) rotate(${bolt.angle}deg)`,
              transformOrigin: "center center"
            },
            initial: { opacity: 0, scaleY: 0 },
            animate: {
              opacity: [0, 1, 1, 0],
              scaleY: [0, 1, 1, 0.5]
            },
            transition: {
              duration: 0.6,
              delay: bolt.delay,
              times: [0, 0.2, 0.7, 1]
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  width: 3,
                  height: bolt.length,
                  background: `linear-gradient(to top, transparent, ${bolt.id % 3 === 0 ? "#00d4ff" : bolt.id % 3 === 1 ? "#8b5cf6" : "#00ff88"})`,
                  boxShadow: `0 0 10px ${bolt.id % 3 === 0 ? "#00d4ff" : bolt.id % 3 === 1 ? "#8b5cf6" : "#00ff88"}`,
                  marginTop: 30
                }
              }
            )
          },
          bolt.id
        )),
        Array.from({ length: 20 }).map((_, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            className: "absolute left-1/2 top-1/2 rounded-full",
            initial: {
              x: 0,
              y: 0,
              opacity: 1,
              scale: 1
            },
            animate: {
              x: (Math.random() - 0.5) * 400,
              y: (Math.random() - 0.5) * 400,
              opacity: 0,
              scale: 0
            },
            transition: {
              duration: 1.5,
              delay: Math.random() * 0.3,
              ease: "easeOut"
            },
            style: {
              width: 6 + Math.random() * 6,
              height: 6 + Math.random() * 6,
              backgroundColor: ["#00d4ff", "#8b5cf6", "#00ff88"][Math.floor(Math.random() * 3)],
              boxShadow: "0 0 10px currentColor",
              transform: "translate(-50%, -50%)"
            }
          },
          `particle-${i}`
        )),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            className: "absolute left-1/2 top-1/2 text-center",
            style: { transform: "translate(-50%, -50%)" },
            initial: { opacity: 0, scale: 0.5 },
            animate: { opacity: [0, 1, 1, 0], scale: [0.5, 1.2, 1, 0.8] },
            transition: { duration: 2, delay: 0.3 },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "text-4xl font-bold font-orbitron",
                style: {
                  color: "#00d4ff",
                  textShadow: "0 0 20px #00d4ff, 0 0 40px #8b5cf6"
                },
                children: " VICTORY "
              }
            )
          }
        )
      ]
    }
  );
}

function ShieldBubble2D({ targetLatLng, onEnd }) {
  const [hexagons, setHexagons] = reactExports.useState([]);
  reactExports.useEffect(() => {
    setHexagons(Array.from({ length: 6 }, (_, i) => i));
    const timer = setTimeout(() => {
      onEnd?.();
    }, 3e3);
    return () => clearTimeout(timer);
  }, [onEnd]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "fixed inset-0 pointer-events-none overflow-hidden",
      style: { zIndex: 2e3 },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          motion.div,
          {
            className: "absolute left-1/2 top-1/2",
            style: { transform: "translate(-50%, -50%)" },
            initial: { scale: 0, opacity: 0 },
            animate: {
              scale: [0, 1.3, 1],
              opacity: [0, 0.9, 0.7]
            },
            transition: { duration: 0.5, ease: "easeOut" },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.div,
                {
                  className: "absolute rounded-full",
                  style: {
                    width: 180,
                    height: 180,
                    left: "50%",
                    top: "50%",
                    transform: "translate(-50%, -50%)",
                    border: "3px solid #00d4ff",
                    boxShadow: "0 0 30px #00d4ff, 0 0 60px #00d4ff40, inset 0 0 30px #00d4ff40"
                  },
                  animate: {
                    boxShadow: [
                      "0 0 30px #00d4ff, 0 0 60px #00d4ff40, inset 0 0 30px #00d4ff40",
                      "0 0 50px #00d4ff, 0 0 80px #00d4ff60, inset 0 0 50px #00d4ff60",
                      "0 0 30px #00d4ff, 0 0 60px #00d4ff40, inset 0 0 30px #00d4ff40"
                    ]
                  },
                  transition: { duration: 1, repeat: 2 }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.div,
                {
                  className: "rounded-full",
                  style: {
                    width: 160,
                    height: 160,
                    background: "radial-gradient(circle, rgba(0,212,255,0.3) 0%, rgba(0,212,255,0.1) 50%, transparent 100%)",
                    backdropFilter: "blur(4px)"
                  },
                  animate: {
                    scale: [1, 1.05, 1]
                  },
                  transition: { duration: 0.8, repeat: 3 }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "absolute left-1/2 top-1/2",
                  style: { transform: "translate(-50%, -50%)" },
                  children: hexagons.map((_, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    motion.div,
                    {
                      className: "absolute",
                      style: {
                        width: 40,
                        height: 46,
                        left: "50%",
                        top: "50%",
                        transform: `translate(-50%, -50%) rotate(${i * 60}deg) translateY(-50px)`
                      },
                      initial: { opacity: 0, scale: 0 },
                      animate: {
                        opacity: [0, 0.8, 0.6, 0.8, 0],
                        scale: [0, 1, 1, 1, 0]
                      },
                      transition: {
                        duration: 2.5,
                        delay: i * 0.1,
                        times: [0, 0.2, 0.5, 0.8, 1]
                      },
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 40 46", className: "w-full h-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "polygon",
                        {
                          points: "20,0 40,11.5 40,34.5 20,46 0,34.5 0,11.5",
                          fill: "none",
                          stroke: "#00d4ff",
                          strokeWidth: "2",
                          style: { filter: "drop-shadow(0 0 5px #00d4ff)" }
                        }
                      ) })
                    },
                    i
                  ))
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.div,
                {
                  className: "absolute left-1/2 top-1/2",
                  style: { transform: "translate(-50%, -50%)" },
                  initial: { opacity: 0, scale: 0.5 },
                  animate: {
                    opacity: [0, 1, 1, 0],
                    scale: [0.5, 1, 1, 0.8]
                  },
                  transition: { duration: 2.5 },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      className: "text-5xl",
                      style: {
                        filter: "drop-shadow(0 0 10px #00d4ff)"
                      },
                      children: ""
                    }
                  )
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            className: "absolute left-1/2 top-[60%]",
            style: { transform: "translateX(-50%)" },
            initial: { opacity: 0, y: 20 },
            animate: {
              opacity: [0, 1, 1, 0],
              y: [20, 0, 0, -10]
            },
            transition: { duration: 2.5, times: [0, 0.2, 0.8, 1] },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "text-xl font-bold font-orbitron tracking-wider",
                style: {
                  color: "#00d4ff",
                  textShadow: "0 0 10px #00d4ff, 0 0 20px #00d4ff60"
                },
                children: "DEFENDING"
              }
            )
          }
        ),
        [0, 0.3, 0.6].map((delay, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            className: "absolute left-1/2 top-1/2 rounded-full",
            style: {
              transform: "translate(-50%, -50%)",
              border: "2px solid #00d4ff40"
            },
            initial: { width: 160, height: 160, opacity: 0.6 },
            animate: {
              width: [160, 300],
              height: [160, 300],
              opacity: [0.6, 0]
            },
            transition: {
              duration: 1.5,
              delay: delay + 0.5,
              ease: "easeOut"
            }
          },
          i
        ))
      ]
    }
  );
}

const __vite_import_meta_env__ = {};
function shouldUse3D(requestedMode = "3d-auto") {
  if (requestedMode === "2d") return false;
  const envMode = __vite_import_meta_env__?.VITE_BATTLE_FX_MODE;
  if (envMode === "2d") {
    return false;
  }
  if (requestedMode === "3d-auto") {
    try {
      const canvas = document.createElement("canvas");
      const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
      const available = !!gl;
      return available;
    } catch (e) {
      return false;
    }
  }
  return true;
}
function renderBattleFX(config) {
  const use3D = shouldUse3D(config.mode);
  if (use3D) {
    try {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: render2DFallback(config), children: render3DFX(config) });
    } catch (error) {
      return render2DFallback(config);
    }
  }
  return render2DFallback(config);
}
function render2DFallback(config) {
  switch (config.type) {
    case "missile":
      if (!config.from || !config.to) {
        return null;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MissileTrail2D, { fromLatLng: config.from, toLatLng: config.to, onEnd: config.onEnd });
    case "emp":
      if (!config.center) {
        return null;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(EMPWave2D, { centerLatLng: config.center, onEnd: config.onEnd });
    case "shield":
      if (!config.center) {
        return null;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ShieldBubble2D, { targetLatLng: config.center, onEnd: config.onEnd });
    default:
      return null;
  }
}
function render3DFX(config) {
  const { MissileTrail3D, EMPWave3D, ShieldBubble3D } = require("../battle3d");
  switch (config.type) {
    case "missile":
      if (!config.from || !config.to) return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MissileTrail3D, { fromLatLng: config.from, toLatLng: config.to, onEnd: config.onEnd });
    case "emp":
      if (!config.center) return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(EMPWave3D, { centerLatLng: config.center, onEnd: config.onEnd });
    case "shield":
      if (!config.center) return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ShieldBubble3D, { targetLatLng: config.center, onEnd: config.onEnd });
    default:
      return null;
  }
}

function BattleFxLayer({ map, battleFxMode }) {
  const { user, isAuthenticated } = useUnifiedAuth();
  const [activeFx, setActiveFx] = reactExports.useState([]);
  const [currentBattleSessionId, setCurrentBattleSessionId] = reactExports.useState(null);
  const [agentPositions, setAgentPositions] = reactExports.useState(/* @__PURE__ */ new Map());
  const { state: battleState } = useBattleRealtimeSubscription(currentBattleSessionId);
  reactExports.useEffect(() => {
    if (!isAuthenticated || !user?.id) return;
    const fetchActiveBattle = async () => {
      try {
        const { data, error } = await supabase.from("battles").select("id, creator_id, opponent_id, status").or(`creator_id.eq.${user.id},opponent_id.eq.${user.id}`).in("status", ["pending", "accepted", "countdown", "active"]).order("created_at", { ascending: false }).limit(1).maybeSingle();
        if (error) {
          return;
        }
        if (data) {
          const activeBattle = data;
          setCurrentBattleSessionId(activeBattle.id);
        } else {
          setCurrentBattleSessionId(null);
        }
      } catch (e) {
      }
    };
    fetchActiveBattle();
    const interval = setInterval(fetchActiveBattle, 1e4);
    return () => clearInterval(interval);
  }, [isAuthenticated, user?.id]);
  reactExports.useEffect(() => {
    if (!isAuthenticated) return;
    const fetchAgentPositions = async () => {
      try {
        const { data, error } = await supabase.from("agent_locations").select("agent_id, lat, lng, updated_at").order("updated_at", { ascending: false, nullsFirst: false }).limit(100);
        if (error) {
          return;
        }
        if (data) {
          const posMap = /* @__PURE__ */ new Map();
          data.forEach((loc) => {
            if (!posMap.has(loc.agent_id)) {
              posMap.set(loc.agent_id, { lat: loc.lat, lng: loc.lng });
            }
          });
          setAgentPositions(posMap);
        }
      } catch (e) {
      }
    };
    fetchAgentPositions();
    const channel = supabase.channel("agent-locations-fx").on("postgres_changes", {
      event: "*",
      schema: "public",
      table: "agent_locations"
    }, () => {
      fetchAgentPositions();
    }).subscribe();
    return () => {
      supabase.removeChannel(channel);
    };
  }, [isAuthenticated]);
  reactExports.useEffect(() => {
    if (!battleState || !map) return;
    const handleBattleEvent = async () => {
      const event = battleState.lastEvent;
      if (!event) return;
      try {
        if (!currentBattleSessionId) return;
        const { data: session, error } = await supabase.from("battles").select("creator_id, opponent_id, stake_type, stake_amount").eq("id", currentBattleSessionId).maybeSingle();
        if (error || !session) {
          return;
        }
        const sessionData = session;
        const attackerPos = agentPositions.get(sessionData.creator_id);
        const defenderPos = agentPositions.get(sessionData.opponent_id);
        if (!attackerPos || !defenderPos) {
          return;
        }
        const fxMode = battleFxMode === "high" ? "3d-auto" : "2d";
        switch (event.type) {
          case "attack_started": {
            const fxId = `attack-${Date.now()}`;
            const fxNode = renderBattleFX({
              type: "missile",
              from: [attackerPos.lat, attackerPos.lng],
              to: [defenderPos.lat, defenderPos.lng],
              mode: fxMode,
              onEnd: () => removeFx(fxId)
            });
            setActiveFx((prev) => [...prev, {
              id: fxId,
              node: fxNode,
              createdAt: Date.now()
            }]);
            break;
          }
          case "defense_needed": {
            const fxId = `defense-${Date.now()}`;
            const fxNode = renderBattleFX({
              type: "shield",
              center: [defenderPos.lat, defenderPos.lng],
              mode: fxMode,
              onEnd: () => removeFx(fxId)
            });
            setActiveFx((prev) => [...prev, {
              id: fxId,
              node: fxNode,
              createdAt: Date.now()
            }]);
            break;
          }
          case "battle_resolved": {
            const winnerId = battleState.winnerId;
            if (!winnerId) return;
            const winnerPos = agentPositions.get(winnerId);
            if (!winnerPos) return;
            const fxId = `resolved-${Date.now()}`;
            const fxNode = renderBattleFX({
              type: "emp",
              center: [winnerPos.lat, winnerPos.lng],
              mode: fxMode,
              onEnd: () => {
                removeFx(fxId);
                setCurrentBattleSessionId(null);
              }
            });
            setActiveFx((prev) => [...prev, {
              id: fxId,
              node: fxNode,
              createdAt: Date.now()
            }]);
            break;
          }
        }
      } catch (e) {
      }
    };
    handleBattleEvent();
  }, [battleState, map, battleFxMode, currentBattleSessionId, agentPositions]);
  const removeFx = reactExports.useCallback((id) => {
    setActiveFx((prev) => prev.filter((fx) => fx.id !== id));
  }, []);
  reactExports.useEffect(() => {
    const MAX_FX_DURATION = 5e3;
    const interval = setInterval(() => {
      const now = Date.now();
      setActiveFx((prev) => prev.filter((fx) => now - fx.createdAt < MAX_FX_DURATION));
    }, 1e3);
    return () => clearInterval(interval);
  }, []);
  reactExports.useEffect(() => {
    const MAX_SIMULTANEOUS_FX = battleFxMode === "high" ? 10 : 5;
    if (activeFx.length > MAX_SIMULTANEOUS_FX) {
      setActiveFx((prev) => prev.slice(-MAX_SIMULTANEOUS_FX));
    }
  }, [activeFx.length, battleFxMode]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute inset-0 pointer-events-none",
      style: { zIndex: 999 },
      children: activeFx.map((fx) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: fx.node }, fx.id))
    }
  );
}

function MapBattleOverlay({ map, battle, timeLeft, result }) {
  const [attackerScreen, setAttackerScreen] = reactExports.useState(null);
  const [defenderScreen, setDefenderScreen] = reactExports.useState(null);
  const [missilePos, setMissilePos] = reactExports.useState(null);
  const [showExplosion, setShowExplosion] = reactExports.useState(false);
  const [trailParticles, setTrailParticles] = reactExports.useState([]);
  const animationRef = reactExports.useRef(null);
  const particleIdRef = reactExports.useRef(0);
  const updateScreenPositions = () => {
    if (!map || !battle) return;
    try {
      const attackerPoint = map.project([battle.attackerLng, battle.attackerLat]);
      const defenderPoint = map.project([battle.defenderLng, battle.defenderLat]);
      setAttackerScreen({ x: attackerPoint.x, y: attackerPoint.y });
      setDefenderScreen({ x: defenderPoint.x, y: defenderPoint.y });
    } catch (e) {
    }
  };
  reactExports.useEffect(() => {
    if (!map || !battle) return;
    updateScreenPositions();
    map.on("move", updateScreenPositions);
    map.on("zoom", updateScreenPositions);
    return () => {
      map.off("move", updateScreenPositions);
      map.off("zoom", updateScreenPositions);
    };
  }, [map, battle]);
  reactExports.useEffect(() => {
    if (!battle || !attackerScreen || !defenderScreen) return;
    const totalDuration = battle.duration * 1e3;
    const startTime = Date.now();
    const animate = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / totalDuration, 1);
      const easeProgress = 1 - Math.pow(1 - progress, 3);
      const x = attackerScreen.x + (defenderScreen.x - attackerScreen.x) * easeProgress;
      const y = attackerScreen.y + (defenderScreen.y - attackerScreen.y) * easeProgress;
      const arcHeight = Math.min(200, Math.abs(defenderScreen.x - attackerScreen.x) * 0.4);
      const arcY = y - Math.sin(progress * Math.PI) * arcHeight;
      setMissilePos({ x, y: arcY });
      if (progress < 1 && elapsed % 50 < 20) {
        particleIdRef.current++;
        setTrailParticles((prev) => [...prev.slice(-30), {
          id: particleIdRef.current,
          x: x + (Math.random() - 0.5) * 10,
          y: arcY + (Math.random() - 0.5) * 10
        }]);
      }
      if (progress < 1) {
        animationRef.current = requestAnimationFrame(animate);
      } else {
        setShowExplosion(true);
        setTrailParticles([]);
        setTimeout(() => setShowExplosion(false), 2500);
      }
    };
    animate();
    return () => {
      if (animationRef.current) cancelAnimationFrame(animationRef.current);
    };
  }, [battle, attackerScreen, defenderScreen]);
  if (!battle || !attackerScreen || !defenderScreen) return null;
  const angle = missilePos ? Math.atan2(defenderScreen.y - attackerScreen.y, defenderScreen.x - attackerScreen.x) * (180 / Math.PI) : 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fixed inset-0 pointer-events-none z-[2000]", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-24 left-1/2 -translate-x-1/2 z-[2001]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.div,
      {
        className: "px-8 py-4 rounded-2xl bg-gradient-to-r from-black/90 via-red-950/80 to-black/90 backdrop-blur-md border border-red-500/50",
        initial: { y: -50, opacity: 0, scale: 0.8 },
        animate: { y: 0, opacity: 1, scale: 1 },
        style: {
          boxShadow: "0 0 40px rgba(255,50,50,0.4), inset 0 0 30px rgba(255,0,0,0.1)"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-red-400 uppercase tracking-[0.3em] mb-2 flex items-center justify-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.span,
              {
                animate: { opacity: [1, 0.3, 1] },
                transition: { duration: 0.5, repeat: Infinity },
                children: ""
              }
            ),
            "BATTLE IN PROGRESS",
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.span,
              {
                animate: { opacity: [1, 0.3, 1] },
                transition: { duration: 0.5, repeat: Infinity },
                children: ""
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "text-4xl font-bold text-white font-mono",
              style: { textShadow: "0 0 20px rgba(255,100,100,0.8)" },
              children: [
                Math.floor(timeLeft / 60),
                ":",
                String(timeLeft % 60).padStart(2, "0")
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm text-gray-400 mt-2", children: [
            "Target: ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-cyan-400 font-semibold", children: battle.defenderName })
          ] })
        ] })
      }
    ) }),
    missilePos && /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "absolute inset-0 w-full h-full", style: { filter: "url(#glow)" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "beamGradient", x1: "0%", y1: "0%", x2: "100%", y2: "0%", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#00ffff", stopOpacity: "0" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "30%", stopColor: "#00ffff", stopOpacity: "0.3" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "70%", stopColor: "#ff00ff", stopOpacity: "0.5" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#ff4444", stopOpacity: "0.8" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("filter", { id: "glow", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("feGaussianBlur", { stdDeviation: "4", result: "coloredBlur" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("feMerge", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("feMergeNode", { in: "coloredBlur" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("feMergeNode", { in: "SourceGraphic" })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.line,
        {
          x1: attackerScreen.x,
          y1: attackerScreen.y,
          x2: missilePos.x,
          y2: missilePos.y,
          stroke: "url(#beamGradient)",
          strokeWidth: "6",
          initial: { pathLength: 0 },
          animate: { pathLength: 1 }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.line,
        {
          x1: attackerScreen.x,
          y1: attackerScreen.y,
          x2: missilePos.x,
          y2: missilePos.y,
          stroke: "#00ffff",
          strokeWidth: "2",
          strokeDasharray: "15 10",
          opacity: "0.6"
        }
      )
    ] }),
    trailParticles.map((p) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.div,
      {
        className: "absolute w-2 h-2 rounded-full",
        style: {
          left: p.x,
          top: p.y,
          background: "radial-gradient(circle, #00ffff 0%, #ff00ff 50%, transparent 100%)",
          boxShadow: "0 0 10px #00ffff"
        },
        initial: { scale: 1, opacity: 0.8 },
        animate: { scale: 0, opacity: 0 },
        transition: { duration: 0.8 }
      },
      p.id
    )),
    missilePos && !showExplosion && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      motion.div,
      {
        className: "absolute",
        style: {
          left: missilePos.x,
          top: missilePos.y,
          transform: `translate(-50%, -50%) rotate(${angle}deg)`
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              className: "absolute -inset-6 rounded-full",
              style: {
                background: "radial-gradient(circle, rgba(0,255,255,0.3) 0%, rgba(255,0,255,0.2) 50%, transparent 70%)"
              },
              animate: { scale: [1, 1.3, 1], opacity: [0.5, 0.8, 0.5] },
              transition: { duration: 0.3, repeat: Infinity }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", style: { width: "50px", height: "20px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                style: {
                  width: "50px",
                  height: "20px",
                  background: "linear-gradient(180deg, #4a5568 0%, #1a202c 50%, #2d3748 100%)",
                  borderRadius: "10px 4px 4px 10px",
                  border: "1px solid rgba(0,255,255,0.5)",
                  boxShadow: "0 0 20px rgba(0,255,255,0.6), 0 0 40px rgba(255,0,255,0.4), inset 0 2px 4px rgba(255,255,255,0.2)"
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-1/2 left-2 right-4 h-px bg-gradient-to-r from-cyan-400 to-purple-400 opacity-60", style: { transform: "translateY(-50%)" } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    motion.div,
                    {
                      className: "absolute top-1 left-3 w-2 h-2 rounded-full bg-cyan-400",
                      animate: { opacity: [1, 0.3, 1] },
                      transition: { duration: 0.2, repeat: Infinity },
                      style: { boxShadow: "0 0 8px #00ffff" }
                    }
                  )
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "absolute -right-3 top-1/2",
                style: {
                  transform: "translateY(-50%)",
                  width: 0,
                  height: 0,
                  borderLeft: "16px solid #00ffff",
                  borderTop: "10px solid transparent",
                  borderBottom: "10px solid transparent",
                  filter: "drop-shadow(0 0 8px #00ffff)"
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                className: "absolute -left-8 top-1/2",
                style: { transform: "translateY(-50%)" },
                animate: { scaleX: [1, 1.5, 1], opacity: [0.8, 1, 0.8] },
                transition: { duration: 0.08, repeat: Infinity },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                  width: "35px",
                  height: "18px",
                  background: "radial-gradient(ellipse at right, #ff00ff 0%, #ff4444 30%, #ff8800 60%, transparent 100%)",
                  borderRadius: "50%",
                  filter: "blur(3px)"
                } })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                className: "absolute -left-4 top-1/2",
                style: { transform: "translateY(-50%)" },
                animate: { scaleX: [1, 1.3, 1] },
                transition: { duration: 0.05, repeat: Infinity },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                  width: "20px",
                  height: "10px",
                  background: "radial-gradient(ellipse at right, #fff 0%, #00ffff 50%, transparent 100%)",
                  borderRadius: "50%",
                  filter: "blur(2px)"
                } })
              }
            ),
            Array.from({ length: 8 }).map((_, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                className: "absolute rounded-full",
                style: {
                  left: -12 - i * 3,
                  top: 6 + (Math.random() - 0.5) * 12,
                  width: 3 - i * 0.3,
                  height: 3 - i * 0.3,
                  backgroundColor: ["#00ffff", "#ff00ff", "#fff", "#ff4444"][i % 4]
                },
                animate: {
                  x: [-5, -25],
                  opacity: [1, 0],
                  scale: [1, 0.3]
                },
                transition: {
                  duration: 0.2,
                  repeat: Infinity,
                  delay: i * 0.02
                }
              },
              i
            ))
          ] })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: showExplosion && defenderScreen && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      [0, 1, 2].map((ring) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: "absolute rounded-full border-2",
          style: {
            left: defenderScreen.x,
            top: defenderScreen.y,
            transform: "translate(-50%, -50%)",
            borderColor: ["#00ffff", "#ff00ff", "#ff4444"][ring]
          },
          initial: { width: 0, height: 0, opacity: 1 },
          animate: { width: 300 + ring * 50, height: 300 + ring * 50, opacity: 0 },
          transition: { duration: 1.5, delay: ring * 0.1 }
        },
        `ring-${ring}`
      )),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: "absolute",
          style: { left: defenderScreen.x, top: defenderScreen.y, transform: "translate(-50%, -50%)" },
          initial: { scale: 0, opacity: 1 },
          animate: { scale: 4, opacity: 0 },
          transition: { duration: 0.8 },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "w-40 h-40 rounded-full",
              style: {
                background: "radial-gradient(circle, #fff 0%, #00ffff 20%, #ff00ff 40%, #ff4444 60%, transparent 80%)",
                boxShadow: "0 0 80px #00ffff, 0 0 120px #ff00ff"
              }
            }
          )
        }
      ),
      Array.from({ length: 30 }).map((_, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: "absolute rounded-full",
          style: {
            left: defenderScreen.x,
            top: defenderScreen.y,
            width: 4 + Math.random() * 8,
            height: 4 + Math.random() * 8,
            backgroundColor: ["#00ffff", "#ff00ff", "#fff", "#ff4444", "#ffff00"][i % 5],
            boxShadow: `0 0 10px ${["#00ffff", "#ff00ff", "#fff"][i % 3]}`
          },
          initial: { x: 0, y: 0, scale: 1, opacity: 1 },
          animate: {
            x: (Math.random() - 0.5) * 300,
            y: (Math.random() - 0.5) * 300,
            scale: 0,
            opacity: 0
          },
          transition: { duration: 1.5, delay: i * 0.02, ease: "easeOut" }
        },
        i
      )),
      [1, 2, 3].map((n) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: "absolute rounded-full",
          style: {
            left: defenderScreen.x + (Math.random() - 0.5) * 80,
            top: defenderScreen.y + (Math.random() - 0.5) * 80,
            transform: "translate(-50%, -50%)"
          },
          initial: { scale: 0, opacity: 1 },
          animate: { scale: 2, opacity: 0 },
          transition: { duration: 0.6, delay: 0.2 + n * 0.15 },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "w-16 h-16 rounded-full",
              style: {
                background: "radial-gradient(circle, #fff 0%, #ff8800 50%, transparent 100%)"
              }
            }
          )
        },
        `sec-${n}`
      ))
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: result && /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.div,
      {
        className: "absolute inset-0 flex items-center justify-center bg-black/70 backdrop-blur-md",
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          motion.div,
          {
            className: "text-center",
            initial: { scale: 0.3, y: 50, rotateX: 90 },
            animate: { scale: 1, y: 0, rotateX: 0 },
            transition: { type: "spring", damping: 12 },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.div,
                {
                  className: "text-9xl mb-6",
                  animate: {
                    scale: [1, 1.1, 1],
                    rotate: result.won ? [0, 5, -5, 0] : [0, -3, 3, 0]
                  },
                  transition: { duration: 1, repeat: Infinity },
                  children: result.won ? "" : ""
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.div,
                {
                  className: `text-6xl font-bold ${result.won ? "text-green-400" : "text-red-400"}`,
                  style: {
                    textShadow: `0 0 40px ${result.won ? "rgba(74,222,128,0.8)" : "rgba(248,113,113,0.8)"}`,
                    fontFamily: "Orbitron, sans-serif"
                  },
                  initial: { opacity: 0, y: 20 },
                  animate: { opacity: 1, y: 0 },
                  transition: { delay: 0.3 },
                  children: result.won ? "VICTORY!" : "DEFEATED!"
                }
              )
            ]
          }
        )
      }
    ) }),
    defenderScreen && !showExplosion && !result && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      motion.div,
      {
        className: "absolute",
        style: { left: defenderScreen.x, top: defenderScreen.y, transform: "translate(-50%, -50%)" },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            motion.svg,
            {
              width: "80",
              height: "80",
              viewBox: "0 0 80 80",
              animate: { rotate: 360 },
              transition: { duration: 4, repeat: Infinity, ease: "linear" },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "40", cy: "40", r: "35", fill: "none", stroke: "#ff4444", strokeWidth: "2", strokeDasharray: "8 4", opacity: "0.8" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "40", cy: "40", r: "25", fill: "none", stroke: "#00ffff", strokeWidth: "1", opacity: "0.6" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "40", cy: "40", r: "15", fill: "none", stroke: "#ff00ff", strokeWidth: "1", opacity: "0.4" })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              className: "absolute inset-0 flex items-center justify-center",
              animate: { scale: [1, 1.2, 1] },
              transition: { duration: 1, repeat: Infinity },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 rounded-full bg-red-500", style: { boxShadow: "0 0 10px #ff0000" } })
            }
          )
        ]
      }
    )
  ] });
}

function useMyActiveBattles(userId) {
  const [activeBattles, setActiveBattles] = reactExports.useState([]);
  const [pendingChallenges, setPendingChallenges] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState(null);
  const fetchBattles = async () => {
    if (!userId) {
      setActiveBattles([]);
      setPendingChallenges([]);
      return;
    }
    setLoading(true);
    setError(null);
    try {
      const { data: active, error: activeError } = await supabase.from("battles").select("*").or(`creator_id.eq.${userId},opponent_id.eq.${userId}`).in("status", ["accepted", "ready", "countdown", "active"]).order("created_at", { ascending: false });
      if (activeError) throw activeError;
      const { data: pending, error: pendingError } = await supabase.from("battles").select("*").eq("opponent_id", userId).eq("status", "pending").order("created_at", { ascending: false });
      if (pendingError) throw pendingError;
      setActiveBattles(active || []);
      setPendingChallenges(pending || []);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };
  reactExports.useEffect(() => {
    fetchBattles();
    const channel = supabase.channel(`my-battles-${userId}`).on(
      "postgres_changes",
      {
        event: "*",
        schema: "public",
        table: "battles",
        filter: `creator_id=eq.${userId}`
      },
      () => fetchBattles()
    ).on(
      "postgres_changes",
      {
        event: "*",
        schema: "public",
        table: "battles",
        filter: `opponent_id=eq.${userId}`
      },
      () => fetchBattles()
    ).subscribe();
    return () => {
      supabase.removeChannel(channel);
    };
  }, [userId]);
  return {
    activeBattles,
    pendingChallenges,
    loading,
    error,
    refetch: fetchBattles
  };
}

function useBattleSystem() {
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [currentSession, setCurrentSession] = reactExports.useState(null);
  const startAttack = reactExports.useCallback(async (defenderId, weaponKey) => {
    setIsLoading(true);
    try {
      const { data, error } = await supabase.rpc("start_battle_v2", {
        p_defender_id: defenderId,
        p_weapon_key: weaponKey,
        p_client_nonce: crypto.randomUUID()
      });
      if (error) {
        ue.error("Attack failed", {
          description: error.message
        });
        return null;
      }
      if (!data.success) {
        ue.error("Attack failed", {
          description: data.error || "Unknown error"
        });
        return null;
      }
      setCurrentSession(data.session_id || null);
      ue.success("Attack initiated!", {
        description: `Waiting for defense... (60s)`
      });
      return {
        session_id: data.session_id,
        expires_at: data.expires_at
      };
    } catch (err) {
      ue.error("System error", {
        description: "Failed to start battle"
      });
      return null;
    } finally {
      setIsLoading(false);
    }
  }, []);
  const submitDefense = reactExports.useCallback(async (sessionId, defenseKey) => {
    setIsLoading(true);
    try {
      const { data, error } = await supabase.rpc("submit_defense_v2", {
        p_session_id: sessionId,
        p_defense_key: defenseKey
      });
      if (error) {
        ue.error("Defense failed", {
          description: error.message
        });
        return null;
      }
      if (!data.success) {
        ue.error("Defense failed", {
          description: data.error || "Unknown error"
        });
        return null;
      }
      setCurrentSession(null);
      const outcome = data.outcome === "attacker_win" ? "Attacker wins!" : "Defender wins!";
      ue.success("Battle resolved!", {
        description: outcome
      });
      return {
        status: "resolved",
        winner_id: data.winner_id
      };
    } catch (err) {
      ue.error("System error", {
        description: "Failed to submit defense"
      });
      return null;
    } finally {
      setIsLoading(false);
    }
  }, []);
  const getMyBattles = reactExports.useCallback(async (status, limit = 20) => {
    try {
      const { data, error } = await supabase.rpc("get_my_battles", {
        p_status: status || null,
        p_limit: limit
      });
      if (error) {
        return [];
      }
      return data || [];
    } catch (err) {
      return [];
    }
  }, []);
  const getMyCooldowns = reactExports.useCallback(async () => {
    try {
      const { data, error } = await supabase.rpc("get_my_cooldowns");
      if (error) {
        return [];
      }
      return data || [];
    } catch (err) {
      return [];
    }
  }, []);
  const getWeaponsCatalog = reactExports.useCallback(async () => {
    try {
      const { data, error } = await supabase.rpc("get_weapons_catalog");
      if (error) {
        return [];
      }
      return data || [];
    } catch (err) {
      return [];
    }
  }, []);
  const getDefenseCatalog = reactExports.useCallback(async () => {
    try {
      const { data, error } = await supabase.from("defense_catalog").select("key, name, description, power, m1u_cost, cooldown_sec, effect_key, min_rank").eq("enabled", true).order("power", { ascending: true });
      if (error) {
        return [];
      }
      return data || [];
    } catch (err) {
      return [];
    }
  }, []);
  const isUserAttackable = reactExports.useCallback(async (userId) => {
    try {
      const { data: agentData, error: agentError } = await supabase.from("agent_locations").select("status, last_seen").eq("user_id", userId).eq("status", "online").gte("last_seen", new Date(Date.now() - 5 * 60 * 1e3).toISOString()).maybeSingle();
      if (agentError || !agentData) {
        return false;
      }
      const { data: battleData, error: battleError } = await supabase.from("battle_sessions").select("id").eq("defender_id", userId).eq("status", "await_defense").maybeSingle();
      if (battleError) {
        return false;
      }
      return !battleData;
    } catch (err) {
      return false;
    }
  }, []);
  const finalizeExpired = reactExports.useCallback(async () => {
    try {
      const { data, error } = await supabase.rpc("finalize_expired_battles");
      if (error) {
        return 0;
      }
      const count = data || 0;
      return count;
    } catch (err) {
      return 0;
    }
  }, []);
  return {
    // State
    isLoading,
    currentSession,
    // Actions (FASE 2 completa)
    startAttack,
    submitDefense,
    finalizeExpired,
    // Queries
    getMyBattles,
    getMyCooldowns,
    getWeaponsCatalog,
    getDefenseCatalog,
    isUserAttackable
  };
}

function BattleHUD({ sessionId, onClose }) {
  const [isExpanded, setIsExpanded] = reactExports.useState(true);
  const [selectedDefense, setSelectedDefense] = reactExports.useState("");
  const [timeLeft, setTimeLeft] = reactExports.useState(0);
  const [isSubmitting, setIsSubmitting] = reactExports.useState(false);
  const [actionHistory, setActionHistory] = reactExports.useState([]);
  const { submitDefense, getDefenseCatalog } = useBattleSystem();
  const [defenseCatalog, setDefenseCatalog] = reactExports.useState([]);
  const [catalogLoading, setCatalogLoading] = reactExports.useState(false);
  const { state } = useBattleRealtimeSubscription(sessionId);
  reactExports.useEffect(() => {
    if (!sessionId) return;
    const loadDefenses = async () => {
      setCatalogLoading(true);
      const defenses = await getDefenseCatalog();
      setDefenseCatalog(defenses);
      setCatalogLoading(false);
    };
    loadDefenses();
  }, [sessionId, getDefenseCatalog]);
  reactExports.useEffect(() => {
    if (!state.lastEvent) return;
    const newAction = {
      id: `${state.lastEvent.type}-${Date.now()}`,
      type: state.lastEvent.type,
      timestamp: Date.now(),
      description: formatEventDescription(state.lastEvent.type, state.lastEvent.payload)
    };
    setActionHistory((prev) => [newAction, ...prev].slice(0, 3));
  }, [state.lastEvent]);
  reactExports.useEffect(() => {
    if (!state.until || state.status !== "await_defense") {
      setTimeLeft(0);
      return;
    }
    const updateTimer = () => {
      const remaining = Math.max(0, state.until - Date.now());
      setTimeLeft(Math.floor(remaining / 1e3));
    };
    updateTimer();
    const interval = setInterval(updateTimer, 1e3);
    return () => clearInterval(interval);
  }, [state.until, state.status]);
  const handleDefend = async () => {
    if (!sessionId || !selectedDefense || isSubmitting) return;
    setIsSubmitting(true);
    try {
      const result = await submitDefense(sessionId, selectedDefense);
    } catch (error) {
    } finally {
      setIsSubmitting(false);
    }
  };
  if (!sessionId) return null;
  const isResolved = state.status === "resolved";
  const isCancelled = state.status === "cancelled";
  const canDefend = state.status === "await_defense" && timeLeft > 0 && !isSubmitting;
  const getStatusColor = () => {
    if (isResolved) return "text-muted-foreground";
    if (isCancelled) return "text-muted-foreground";
    if (timeLeft < 10) return "text-destructive";
    return "text-foreground";
  };
  const getStatusText = () => {
    if (isResolved) return state.winnerId ? `Winner: ${state.winnerId.slice(0, 8)}...` : "Battle concluded";
    if (isCancelled) return "Battle cancelled";
    return "You are under attack!";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "fixed bottom-20 right-4 w-80 z-40 shadow-lg border-primary/20", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { className: "pb-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Swords, { className: "h-5 w-5 text-destructive" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { className: "text-base", children: "Battle Active" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          state.status === "await_defense" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1 text-sm text-muted-foreground", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Clock, { className: "h-4 w-4" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-mono", children: [
              timeLeft,
              "s"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "ghost",
              size: "sm",
              onClick: () => setIsExpanded(!isExpanded),
              className: "h-8 w-8 p-0",
              children: isExpanded ? /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "h-4 w-4" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUp, { className: "h-4 w-4" })
            }
          )
        ] })
      ] }),
      isExpanded && /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { className: `text-xs ${getStatusColor()}`, children: getStatusText() })
    ] }),
    isExpanded && /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { className: "space-y-3", children: [
      actionHistory.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "text-xs font-medium flex items-center gap-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Activity, { className: "h-3 w-3" }),
          "Recent Actions"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-16 rounded-md border border-border/50 bg-muted/30", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-2 space-y-1", children: actionHistory.map((action) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-muted-foreground", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-mono text-[10px]", children: new Date(action.timestamp).toLocaleTimeString() }),
          "  ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: action.description })
        ] }, action.id)) }) })
      ] }),
      !isResolved && !isCancelled ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "text-xs font-medium flex items-center gap-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, { className: "h-3 w-3" }),
            "Select Defense"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Select,
            {
              value: selectedDefense,
              onValueChange: setSelectedDefense,
              disabled: !canDefend || catalogLoading,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { className: "h-9 text-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Choose defense..." }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: catalogLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "loading", disabled: true, children: "Loading..." }) : defenseCatalog.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "none", disabled: true, children: "No defenses available" }) : defenseCatalog.map((defense) => /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectItem, { value: defense.key, children: [
                  defense.name,
                  " (Power: ",
                  defense.power,
                  ")"
                ] }, defense.key)) })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            onClick: handleDefend,
            disabled: !canDefend || !selectedDefense,
            className: "w-full h-9 text-sm",
            variant: timeLeft < 10 ? "destructive" : "default",
            children: isSubmitting ? "Activating..." : timeLeft < 10 ? "DEFEND NOW!" : "Activate Defense"
          }
        ),
        timeLeft === 0 && state.status === "await_defense" && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-destructive text-center", children: "Time expired - awaiting resolution" })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-4 space-y-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium", children: isCancelled ? "Battle Cancelled" : "Battle Concluded" }),
        state.winnerId && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-muted-foreground", children: [
          "Winner: ",
          state.winnerId.slice(0, 12),
          "..."
        ] }),
        onClose && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onClose, variant: "outline", size: "sm", className: "mt-2", children: "Close" })
      ] })
    ] })
  ] });
}
function formatEventDescription(type, payload) {
  switch (type) {
    case "attack_started":
      return `Attack initiated with ${payload?.weapon || "weapon"}`;
    case "defense_needed":
      return "Defense window open";
    case "battle_resolved":
      return `Battle resolved - ${payload?.outcome || "complete"}`;
    default:
      return `Event: ${type}`;
  }
}

function BattleMount({ sessionId, onClose }) {
  if (!sessionId) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BattleHUD, { sessionId, onClose });
}

var PAGE_KEYS = ["PageUp", "PageDown"];
var ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var BACK_KEYS = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
};
var SLIDER_NAME = "Slider";
var [Collection, useCollection, createCollectionScope] = createCollection(SLIDER_NAME);
var [createSliderContext] = createContextScope(SLIDER_NAME, [
  createCollectionScope
]);
var [SliderProvider, useSliderContext] = createSliderContext(SLIDER_NAME);
var Slider$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      name,
      min = 0,
      max = 100,
      step = 1,
      orientation = "horizontal",
      disabled = false,
      minStepsBetweenThumbs = 0,
      defaultValue = [min],
      value,
      onValueChange = () => {
      },
      onValueCommit = () => {
      },
      inverted = false,
      form,
      ...sliderProps
    } = props;
    const thumbRefs = reactExports.useRef(/* @__PURE__ */ new Set());
    const valueIndexToChangeRef = reactExports.useRef(0);
    const isHorizontal = orientation === "horizontal";
    const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;
    const [values = [], setValues] = useControllableState({
      prop: value,
      defaultProp: defaultValue,
      onChange: (value2) => {
        const thumbs = [...thumbRefs.current];
        thumbs[valueIndexToChangeRef.current]?.focus();
        onValueChange(value2);
      }
    });
    const valuesBeforeSlideStartRef = reactExports.useRef(values);
    function handleSlideStart(value2) {
      const closestIndex = getClosestValueIndex(values, value2);
      updateValues(value2, closestIndex);
    }
    function handleSlideMove(value2) {
      updateValues(value2, valueIndexToChangeRef.current);
    }
    function handleSlideEnd() {
      const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];
      const nextValue = values[valueIndexToChangeRef.current];
      const hasChanged = nextValue !== prevValue;
      if (hasChanged) onValueCommit(values);
    }
    function updateValues(value2, atIndex, { commit } = { commit: false }) {
      const decimalCount = getDecimalCount(step);
      const snapToStep = roundValue(Math.round((value2 - min) / step) * step + min, decimalCount);
      const nextValue = clamp(snapToStep, [min, max]);
      setValues((prevValues = []) => {
        const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);
        if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {
          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);
          const hasChanged = String(nextValues) !== String(prevValues);
          if (hasChanged && commit) onValueCommit(nextValues);
          return hasChanged ? nextValues : prevValues;
        } else {
          return prevValues;
        }
      });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SliderProvider,
      {
        scope: props.__scopeSlider,
        name,
        disabled,
        min,
        max,
        valueIndexToChangeRef,
        thumbs: thumbRefs.current,
        values,
        orientation,
        form,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SliderOrientation,
          {
            "aria-disabled": disabled,
            "data-disabled": disabled ? "" : void 0,
            ...sliderProps,
            ref: forwardedRef,
            onPointerDown: composeEventHandlers(sliderProps.onPointerDown, () => {
              if (!disabled) valuesBeforeSlideStartRef.current = values;
            }),
            min,
            max,
            inverted,
            onSlideStart: disabled ? void 0 : handleSlideStart,
            onSlideMove: disabled ? void 0 : handleSlideMove,
            onSlideEnd: disabled ? void 0 : handleSlideEnd,
            onHomeKeyDown: () => !disabled && updateValues(min, 0, { commit: true }),
            onEndKeyDown: () => !disabled && updateValues(max, values.length - 1, { commit: true }),
            onStepKeyDown: ({ event, direction: stepDirection }) => {
              if (!disabled) {
                const isPageKey = PAGE_KEYS.includes(event.key);
                const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.includes(event.key);
                const multiplier = isSkipKey ? 10 : 1;
                const atIndex = valueIndexToChangeRef.current;
                const value2 = values[atIndex];
                const stepInDirection = step * multiplier * stepDirection;
                updateValues(value2 + stepInDirection, atIndex, { commit: true });
              }
            }
          }
        ) }) })
      }
    );
  }
);
Slider$1.displayName = SLIDER_NAME;
var [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext(SLIDER_NAME, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
});
var SliderHorizontal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      min,
      max,
      dir,
      inverted,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const [slider, setSlider] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setSlider(node));
    const rectRef = reactExports.useRef(void 0);
    const direction = useDirection(dir);
    const isDirectionLTR = direction === "ltr";
    const isSlidingFromLeft = isDirectionLTR && !inverted || !isDirectionLTR && inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || slider.getBoundingClientRect();
      const input = [0, rect.width];
      const output = isSlidingFromLeft ? [min, max] : [max, min];
      const value = linearScale(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.left);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: isSlidingFromLeft ? "left" : "right",
        endEdge: isSlidingFromLeft ? "right" : "left",
        direction: isSlidingFromLeft ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SliderImpl,
          {
            dir: direction,
            "data-orientation": "horizontal",
            ...sliderProps,
            ref: composedRefs,
            style: {
              ...sliderProps.style,
              ["--radix-slider-thumb-transform"]: "translateX(-50%)"
            },
            onSlideStart: (event) => {
              const value = getValueFromPointer(event.clientX);
              onSlideStart?.(value);
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.clientX);
              onSlideMove?.(value);
            },
            onSlideEnd: () => {
              rectRef.current = void 0;
              onSlideEnd?.();
            },
            onStepKeyDown: (event) => {
              const slideDirection = isSlidingFromLeft ? "from-left" : "from-right";
              const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
              onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
var SliderVertical = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      min,
      max,
      inverted,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const sliderRef = reactExports.useRef(null);
    const ref = useComposedRefs(forwardedRef, sliderRef);
    const rectRef = reactExports.useRef(void 0);
    const isSlidingFromBottom = !inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || sliderRef.current.getBoundingClientRect();
      const input = [0, rect.height];
      const output = isSlidingFromBottom ? [max, min] : [min, max];
      const value = linearScale(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.top);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: isSlidingFromBottom ? "bottom" : "top",
        endEdge: isSlidingFromBottom ? "top" : "bottom",
        size: "height",
        direction: isSlidingFromBottom ? 1 : -1,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SliderImpl,
          {
            "data-orientation": "vertical",
            ...sliderProps,
            ref,
            style: {
              ...sliderProps.style,
              ["--radix-slider-thumb-transform"]: "translateY(50%)"
            },
            onSlideStart: (event) => {
              const value = getValueFromPointer(event.clientY);
              onSlideStart?.(value);
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.clientY);
              onSlideMove?.(value);
            },
            onSlideEnd: () => {
              rectRef.current = void 0;
              onSlideEnd?.();
            },
            onStepKeyDown: (event) => {
              const slideDirection = isSlidingFromBottom ? "from-bottom" : "from-top";
              const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
              onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
var SliderImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSlider,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onHomeKeyDown,
      onEndKeyDown,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const context = useSliderContext(SLIDER_NAME, __scopeSlider);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...sliderProps,
        ref: forwardedRef,
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (event.key === "Home") {
            onHomeKeyDown(event);
            event.preventDefault();
          } else if (event.key === "End") {
            onEndKeyDown(event);
            event.preventDefault();
          } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {
            onStepKeyDown(event);
            event.preventDefault();
          }
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          const target = event.target;
          target.setPointerCapture(event.pointerId);
          event.preventDefault();
          if (context.thumbs.has(target)) {
            target.focus();
          } else {
            onSlideStart(event);
          }
        }),
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) onSlideMove(event);
        }),
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
            onSlideEnd(event);
          }
        })
      }
    );
  }
);
var TRACK_NAME = "SliderTrack";
var SliderTrack = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...trackProps } = props;
    const context = useSliderContext(TRACK_NAME, __scopeSlider);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-disabled": context.disabled ? "" : void 0,
        "data-orientation": context.orientation,
        ...trackProps,
        ref: forwardedRef
      }
    );
  }
);
SliderTrack.displayName = TRACK_NAME;
var RANGE_NAME = "SliderRange";
var SliderRange = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...rangeProps } = props;
    const context = useSliderContext(RANGE_NAME, __scopeSlider);
    const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const valuesCount = context.values.length;
    const percentages = context.values.map(
      (value) => convertValueToPercentage(value, context.min, context.max)
    );
    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;
    const offsetEnd = 100 - Math.max(...percentages);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-orientation": context.orientation,
        "data-disabled": context.disabled ? "" : void 0,
        ...rangeProps,
        ref: composedRefs,
        style: {
          ...props.style,
          [orientation.startEdge]: offsetStart + "%",
          [orientation.endEdge]: offsetEnd + "%"
        }
      }
    );
  }
);
SliderRange.displayName = RANGE_NAME;
var THUMB_NAME = "SliderThumb";
var SliderThumb = reactExports.forwardRef(
  (props, forwardedRef) => {
    const getItems = useCollection(props.__scopeSlider);
    const [thumb, setThumb] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));
    const index = reactExports.useMemo(
      () => thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1,
      [getItems, thumb]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderThumbImpl, { ...props, ref: composedRefs, index });
  }
);
var SliderThumbImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, index, name, ...thumbProps } = props;
    const context = useSliderContext(THUMB_NAME, __scopeSlider);
    const orientation = useSliderOrientationContext(THUMB_NAME, __scopeSlider);
    const [thumb, setThumb] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));
    const isFormControl = thumb ? context.form || !!thumb.closest("form") : true;
    const size = useSize(thumb);
    const value = context.values[index];
    const percent = value === void 0 ? 0 : convertValueToPercentage(value, context.min, context.max);
    const label = getLabel(index, context.values.length);
    const orientationSize = size?.[orientation.size];
    const thumbInBoundsOffset = orientationSize ? getThumbInBoundsOffset(orientationSize, percent, orientation.direction) : 0;
    reactExports.useEffect(() => {
      if (thumb) {
        context.thumbs.add(thumb);
        return () => {
          context.thumbs.delete(thumb);
        };
      }
    }, [thumb, context.thumbs]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.ItemSlot, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.span,
            {
              role: "slider",
              "aria-label": props["aria-label"] || label,
              "aria-valuemin": context.min,
              "aria-valuenow": value,
              "aria-valuemax": context.max,
              "aria-orientation": context.orientation,
              "data-orientation": context.orientation,
              "data-disabled": context.disabled ? "" : void 0,
              tabIndex: context.disabled ? void 0 : 0,
              ...thumbProps,
              ref: composedRefs,
              style: value === void 0 ? { display: "none" } : props.style,
              onFocus: composeEventHandlers(props.onFocus, () => {
                context.valueIndexToChangeRef.current = index;
              })
            }
          ) }),
          isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
            SliderBubbleInput,
            {
              name: name ?? (context.name ? context.name + (context.values.length > 1 ? "[]" : "") : void 0),
              form: context.form,
              value
            },
            index
          )
        ]
      }
    );
  }
);
SliderThumb.displayName = THUMB_NAME;
var BUBBLE_INPUT_NAME = "RadioBubbleInput";
var SliderBubbleInput = reactExports.forwardRef(
  ({ __scopeSlider, value, ...props }, forwardedRef) => {
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(ref, forwardedRef);
    const prevValue = usePrevious(value);
    reactExports.useEffect(() => {
      const input = ref.current;
      if (!input) return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(inputProto, "value");
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("input", { bubbles: true });
        setValue.call(input, value);
        input.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.input,
      {
        style: { display: "none" },
        ...props,
        ref: composedRefs,
        defaultValue: value
      }
    );
  }
);
SliderBubbleInput.displayName = BUBBLE_INPUT_NAME;
function getNextSortedValues(prevValues = [], nextValue, atIndex) {
  const nextValues = [...prevValues];
  nextValues[atIndex] = nextValue;
  return nextValues.sort((a, b) => a - b);
}
function convertValueToPercentage(value, min, max) {
  const maxSteps = max - min;
  const percentPerStep = 100 / maxSteps;
  const percentage = percentPerStep * (value - min);
  return clamp(percentage, [0, 100]);
}
function getLabel(index, totalValues) {
  if (totalValues > 2) {
    return `Value ${index + 1} of ${totalValues}`;
  } else if (totalValues === 2) {
    return ["Minimum", "Maximum"][index];
  } else {
    return void 0;
  }
}
function getClosestValueIndex(values, nextValue) {
  if (values.length === 1) return 0;
  const distances = values.map((value) => Math.abs(value - nextValue));
  const closestDistance = Math.min(...distances);
  return distances.indexOf(closestDistance);
}
function getThumbInBoundsOffset(width, left, direction) {
  const halfWidth = width / 2;
  const halfPercent = 50;
  const offset = linearScale([0, halfPercent], [0, halfWidth]);
  return (halfWidth - offset(left) * direction) * direction;
}
function getStepsBetweenValues(values) {
  return values.slice(0, -1).map((value, index) => values[index + 1] - value);
}
function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
  if (minStepsBetweenValues > 0) {
    const stepsBetweenValues = getStepsBetweenValues(values);
    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
    return actualMinStepsBetweenValues >= minStepsBetweenValues;
  }
  return true;
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function getDecimalCount(value) {
  return (String(value).split(".")[1] || "").length;
}
function roundValue(value, decimalCount) {
  const rounder = Math.pow(10, decimalCount);
  return Math.round(value * rounder) / rounder;
}
var Root = Slider$1;
var Track = SliderTrack;
var Range = SliderRange;
var Thumb = SliderThumb;

const Slider = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Root,
  {
    ref,
    className: cn(
      "relative flex w-full touch-none select-none items-center",
      className
    ),
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Track, { className: "relative h-2 w-full grow overflow-hidden rounded-full bg-secondary", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Range, { className: "absolute h-full bg-primary" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Thumb, { className: "block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" })
    ]
  }
));
Slider.displayName = Root.displayName;

const RARITY_COLORS$2 = {
  common: "border-gray-500/30",
  rare: "border-blue-500/30",
  epic: "border-purple-500/30",
  legendary: "border-yellow-500/30"
};
function WeaponDefenseSelector({
  userId,
  type,
  selectedItemId,
  onSelect,
  onOpenShop
}) {
  const [items, setItems] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const loadInventory = async () => {
    try {
      setLoading(true);
      const { data, error } = await supabase.rpc("get_user_battle_inventory");
      if (error) throw error;
      const filtered = (data || []).filter((item) => item.type === type);
      setItems(filtered);
    } catch (error) {
    } finally {
      setLoading(false);
    }
  };
  reactExports.useEffect(() => {
    loadInventory();
    const channel = supabase.channel(`${type}-selector-${userId}`).on(
      "postgres_changes",
      {
        event: "*",
        schema: "public",
        table: "user_battle_items",
        filter: `user_id=eq.${userId}`
      },
      () => loadInventory()
    ).subscribe();
    return () => {
      supabase.removeChannel(channel);
    };
  }, [userId, type]);
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center py-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "h-5 w-5 animate-spin text-cyan-400" }) });
  }
  if (items.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 rounded-lg bg-muted/30 border border-dashed border-border text-center space-y-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-muted-foreground", children: [
        "No ",
        type,
        "s in your inventory"
      ] }),
      onOpenShop && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button,
        {
          size: "sm",
          variant: "ghost",
          onClick: onOpenShop,
          className: "text-cyan-400 hover:text-cyan-300",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(ShoppingBag, { className: "h-3 w-3 mr-1" }),
            "Open Shop"
          ]
        }
      )
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-[180px] rounded-lg border border-border/50 p-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: () => onSelect(null, null),
        className: `
            w-full p-2 rounded-lg border text-left transition-all
            ${selectedItemId === null ? "border-cyan-500/50 bg-cyan-500/10" : "border-border/50 hover:border-border"}
          `,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-muted-foreground", children: [
          "No ",
          type,
          " (default)"
        ] })
      }
    ),
    items.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: () => onSelect(item.item_id, item.code),
        className: `
              w-full p-2 rounded-lg border text-left transition-all
              ${RARITY_COLORS$2[item.rarity] || "border-border/50"}
              ${selectedItemId === item.item_id ? "bg-cyan-500/10 border-cyan-500/50" : "hover:bg-muted/50"}
            `,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start justify-between gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 min-w-0", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
              type === "weapon" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Swords, { className: "h-3 w-3 text-cyan-400 flex-shrink-0" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, { className: "h-3 w-3 text-purple-400 flex-shrink-0" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs font-semibold truncate", children: item.name })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mt-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-[10px] text-muted-foreground", children: [
                "Power: ",
                item.power
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { variant: "outline", className: "text-[9px] px-1 py-0 capitalize", children: item.rarity })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Badge, { variant: "secondary", className: "text-[10px] px-1.5 py-0 flex-shrink-0", children: [
            "x",
            item.quantity
          ] })
        ] })
      },
      item.inventory_id
    ))
  ] }) });
}

const playBeep = (frequency = 800, duration = 100, volume = 0.3) => {
  try {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    oscillator.frequency.value = frequency;
    oscillator.type = "sine";
    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1e3);
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + duration / 1e3);
  } catch (e) {
  }
};
function BattleOverlay({
  isActive,
  attackerName,
  defenderName,
  defenderIsFake,
  weaponUsed,
  stakePercent,
  stakeType,
  onCountdownComplete,
  onCancel
}) {
  const [countdown, setCountdown] = reactExports.useState(10);
  reactExports.useEffect(() => {
    if (isActive) {
      setCountdown(10);
    }
  }, [isActive]);
  reactExports.useEffect(() => {
    if (!isActive) return;
    if (countdown > 0) {
      if (countdown <= 3) {
        playBeep(1200, 150, 0.4);
      } else {
        playBeep(800, 100, 0.3);
      }
      const timer = setTimeout(() => setCountdown((c) => c - 1), 1e3);
      return () => clearTimeout(timer);
    } else {
      playBeep(600, 50, 0.3);
      setTimeout(() => playBeep(900, 50, 0.3), 50);
      setTimeout(() => playBeep(1200, 100, 0.4), 100);
      onCountdownComplete();
    }
  }, [isActive, countdown, onCountdownComplete]);
  if (!isActive) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    motion.div,
    {
      className: "fixed inset-0 z-[3000] bg-black/95 backdrop-blur-md",
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      exit: { opacity: 0 },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-8 left-0 right-0 p-4 z-[3002]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between max-w-lg mx-auto", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center flex-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-cyan-400 uppercase tracking-wider mb-1", children: "Attacker" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xl font-bold text-white", children: attackerName }),
            weaponUsed && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-orange-400 flex items-center justify-center gap-1 mt-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Swords, { className: "h-3 w-3" }),
              " ",
              weaponUsed
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              className: "text-4xl",
              animate: { scale: [1, 1.2, 1], rotate: [0, 5, -5, 0] },
              transition: { duration: 1, repeat: Infinity },
              children: ""
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center flex-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-red-400 uppercase tracking-wider mb-1", children: "Target" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xl font-bold text-white", children: defenderName }),
            defenderIsFake && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-400 mt-1", children: " Test Agent" })
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 flex items-center justify-center z-[3002]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          motion.div,
          {
            className: "text-center",
            initial: { scale: 0.5, opacity: 0 },
            animate: { scale: 1, opacity: 1 },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-cyan-400 uppercase tracking-widest mb-6", children: " Attack launching in..." }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                motion.div,
                {
                  className: "relative",
                  initial: { scale: 2, opacity: 0 },
                  animate: { scale: 1, opacity: 1 },
                  transition: { type: "spring", damping: 10, stiffness: 100 },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      motion.div,
                      {
                        className: "absolute inset-0 rounded-full",
                        style: {
                          width: 200,
                          height: 200,
                          left: "50%",
                          top: "50%",
                          transform: "translate(-50%, -50%)",
                          border: "2px solid rgba(0,212,255,0.3)",
                          boxShadow: "0 0 60px rgba(0,212,255,0.4), inset 0 0 60px rgba(0,212,255,0.2)"
                        },
                        animate: {
                          scale: [1, 1.2, 1],
                          opacity: [0.5, 1, 0.5]
                        },
                        transition: { duration: 1, repeat: Infinity }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        className: "text-[120px] font-bold text-white leading-none",
                        style: {
                          textShadow: "0 0 40px rgba(0,212,255,0.9), 0 0 80px rgba(255,77,240,0.6), 0 0 120px rgba(0,212,255,0.4)",
                          fontFamily: "Orbitron, monospace"
                        },
                        children: countdown
                      }
                    )
                  ]
                },
                countdown
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.div,
                {
                  className: "text-lg text-white/60 mt-8",
                  animate: { opacity: [0.4, 1, 0.4] },
                  transition: { duration: 1.5, repeat: Infinity },
                  children: "Prepare for combat..."
                }
              ),
              onCancel && countdown > 5 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "ghost",
                  onClick: onCancel,
                  className: "mt-8 text-red-400 hover:text-red-300 hover:bg-red-500/10",
                  children: " Cancel Attack"
                }
              )
            ]
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-8 left-0 right-0 text-center z-[3002]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-block px-6 py-3 rounded-full bg-gradient-to-r from-cyan-500/20 to-purple-500/20 border border-cyan-500/30", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-400", children: "Stake: " }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-lg font-bold text-cyan-400", children: [
            stakePercent,
            "% ",
            stakeType
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 overflow-hidden pointer-events-none", children: Array.from({ length: 20 }).map((_, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            className: "absolute w-1 h-1 bg-cyan-400 rounded-full",
            style: {
              left: `${Math.random() * 100}%`,
              top: `${Math.random() * 100}%`
            },
            animate: {
              y: [0, -100, 0],
              opacity: [0, 1, 0]
            },
            transition: {
              duration: 2 + Math.random() * 2,
              repeat: Infinity,
              delay: Math.random() * 2
            }
          },
          i
        )) })
      ]
    }
  );
}

function BattleResultModal({
  isOpen,
  won,
  attackerName,
  defenderName,
  stakePercent,
  stakeType,
  onClose
}) {
  if (!isOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      className: "fixed inset-0 z-[4000] bg-black/90 backdrop-blur-md flex items-center justify-center",
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      exit: { opacity: 0 },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        motion.div,
        {
          className: `relative p-8 rounded-3xl text-center max-w-md mx-4 ${won ? "bg-gradient-to-br from-green-900/80 via-emerald-900/60 to-cyan-900/80" : "bg-gradient-to-br from-red-900/80 via-rose-900/60 to-purple-900/80"}`,
          style: {
            border: won ? "2px solid #10b981" : "2px solid #ef4444",
            boxShadow: won ? "0 0 60px rgba(16, 185, 129, 0.4), 0 0 120px rgba(16, 185, 129, 0.2)" : "0 0 60px rgba(239, 68, 68, 0.4), 0 0 120px rgba(239, 68, 68, 0.2)"
          },
          initial: { scale: 0.5, y: 50, opacity: 0 },
          animate: { scale: 1, y: 0, opacity: 1 },
          exit: { scale: 0.5, y: 50, opacity: 0 },
          transition: { type: "spring", damping: 15 },
          children: [
            won && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 overflow-hidden rounded-3xl pointer-events-none", children: Array.from({ length: 30 }).map((_, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                className: "absolute w-2 h-2 rounded-full",
                style: {
                  backgroundColor: ["#10b981", "#00d4ff", "#ffd700", "#ff00ff"][i % 4],
                  left: `${Math.random() * 100}%`,
                  top: "-10px"
                },
                animate: {
                  y: [0, 400],
                  x: [0, (Math.random() - 0.5) * 100],
                  opacity: [1, 0],
                  rotate: [0, 360]
                },
                transition: {
                  duration: 2 + Math.random(),
                  delay: Math.random() * 0.5,
                  repeat: Infinity,
                  repeatDelay: Math.random() * 2
                }
              },
              i
            )) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                className: "text-8xl mb-6",
                animate: won ? {
                  scale: [1, 1.2, 1],
                  rotate: [0, 10, -10, 0]
                } : {
                  scale: [1, 0.9, 1]
                },
                transition: { duration: 2, repeat: Infinity },
                children: won ? "" : ""
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.h1,
              {
                className: `text-5xl font-bold mb-4 ${won ? "text-green-400" : "text-red-400"}`,
                style: {
                  textShadow: won ? "0 0 20px rgba(16, 185, 129, 0.8)" : "0 0 20px rgba(239, 68, 68, 0.8)",
                  fontFamily: "Orbitron, sans-serif"
                },
                initial: { y: 20, opacity: 0 },
                animate: { y: 0, opacity: 1 },
                transition: { delay: 0.2 },
                children: won ? "VICTORY!" : "DEFEATED!"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.p,
              {
                className: "text-white/80 text-lg mb-6",
                initial: { y: 20, opacity: 0 },
                animate: { y: 0, opacity: 1 },
                transition: { delay: 0.3 },
                children: won ? `You destroyed ${defenderName}!` : `${defenderName} defended successfully!`
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              motion.div,
              {
                className: `inline-flex items-center gap-2 px-4 py-2 rounded-full mb-8 ${won ? "bg-green-500/20 text-green-400" : "bg-red-500/20 text-red-400"}`,
                initial: { scale: 0 },
                animate: { scale: 1 },
                transition: { delay: 0.4, type: "spring" },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Zap, { className: "h-5 w-5" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-bold text-lg", children: [
                    won ? "+" : "-",
                    stakePercent,
                    "% ",
                    stakeType
                  ] })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                initial: { y: 20, opacity: 0 },
                animate: { y: 0, opacity: 1 },
                transition: { delay: 0.5 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    onClick: onClose,
                    className: `w-full h-12 text-lg font-bold ${won ? "bg-gradient-to-r from-green-500 to-cyan-500 hover:from-green-600 hover:to-cyan-600" : "bg-gradient-to-r from-red-500 to-purple-500 hover:from-red-600 hover:to-purple-600"}`,
                    children: won ? "Claim Victory!" : "Continue"
                  }
                )
              }
            )
          ]
        }
      )
    }
  ) });
}

const BATTLE_START_EVENT = "battle-map-start";
const BATTLE_END_EVENT = "battle-map-end";
function BattleCreationForm({
  userId,
  preSelectedOpponent,
  onSuccess,
  onCancel
}) {
  const [stakeType, setStakeType] = reactExports.useState("energy");
  const [stakePercent, setStakePercent] = reactExports.useState(50);
  const [opponentSearch, setOpponentSearch] = reactExports.useState(preSelectedOpponent?.name || "");
  const [arenaName, setArenaName] = reactExports.useState("");
  const [isCreating, setIsCreating] = reactExports.useState(false);
  const [selectedWeaponId, setSelectedWeaponId] = reactExports.useState(null);
  const [selectedWeaponCode, setSelectedWeaponCode] = reactExports.useState(null);
  const [selectedDefenseId, setSelectedDefenseId] = reactExports.useState(null);
  const [selectedDefenseCode, setSelectedDefenseCode] = reactExports.useState(null);
  const [showCountdown, setShowCountdown] = reactExports.useState(false);
  const [showResult, setShowResult] = reactExports.useState(false);
  const [battleResult, setBattleResult] = reactExports.useState(null);
  const { toast } = useToast();
  const isFakeAgent = preSelectedOpponent?.id?.startsWith("fake-agent-");
  const handleCreate = async () => {
    if (!opponentSearch && !preSelectedOpponent) {
      toast({
        title: "Opponent Required",
        description: "Please select an opponent",
        variant: "destructive"
      });
      return;
    }
    if (isFakeAgent) {
      setShowCountdown(true);
      return;
    }
    setIsCreating(true);
    try {
      toast({
        title: " Battle Created!",
        description: "Waiting for opponent to accept..."
      });
      onSuccess?.();
    } catch (error) {
      toast({
        title: "Creation Failed",
        description: error?.message || "Unknown error",
        variant: "destructive"
      });
    } finally {
      setIsCreating(false);
    }
  };
  const handleCountdownComplete = reactExports.useCallback(() => {
    setShowCountdown(false);
    const defenderLat = preSelectedOpponent?.lat || 0;
    const defenderLng = preSelectedOpponent?.lng || 0;
    const battleEvent = {
      attackerId: userId,
      defenderId: preSelectedOpponent?.id || "",
      defenderName: preSelectedOpponent?.name || "Unknown",
      defenderLat,
      defenderLng,
      weaponCode: selectedWeaponCode || void 0,
      battleDuration: 15
      // 15 seconds for demo (can be 120 for production)
    };
    window.dispatchEvent(new CustomEvent(BATTLE_START_EVENT, { detail: battleEvent }));
    toast({
      title: " ATTACK LAUNCHED!",
      description: "Watch the map for your missile!"
    });
  }, [preSelectedOpponent, userId, selectedWeaponCode, toast]);
  reactExports.useEffect(() => {
    const handleBattleEnd = (event) => {
      setBattleResult(event.detail);
      setShowResult(true);
    };
    window.addEventListener(BATTLE_END_EVENT, handleBattleEnd);
    return () => {
      window.removeEventListener(BATTLE_END_EVENT, handleBattleEnd);
    };
  }, []);
  const handleResultClose = () => {
    setShowResult(false);
    setBattleResult(null);
    if (battleResult?.won) {
      toast({
        title: " Victory claimed!",
        description: `+${stakePercent}% ${stakeType} earned!`
      });
    }
    onSuccess?.();
  };
  const handleCountdownCancel = () => {
    setShowCountdown(false);
    toast({
      title: "Attack Cancelled",
      description: "Battle aborted"
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      BattleOverlay,
      {
        isActive: showCountdown,
        attackerName: "You",
        defenderName: preSelectedOpponent?.name || "Unknown",
        defenderIsFake: isFakeAgent,
        weaponUsed: selectedWeaponCode || void 0,
        stakePercent,
        stakeType,
        onCountdownComplete: handleCountdownComplete,
        onCancel: handleCountdownCancel
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      BattleResultModal,
      {
        isOpen: showResult,
        won: battleResult?.won || false,
        attackerName: "You",
        defenderName: preSelectedOpponent?.name || "Unknown",
        stakePercent,
        stakeType,
        onClose: handleResultClose
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6 relative", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { htmlFor: "arena-name", children: "Arena Name (optional)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              id: "arena-name",
              placeholder: "e.g., Downtown Showdown",
              value: arenaName,
              onChange: (e) => setArenaName(e.target.value),
              className: "bg-background/50"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { htmlFor: "opponent", children: "Target" }),
          preSelectedOpponent ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `p-3 rounded-lg border ${isFakeAgent ? "bg-red-500/10 border-red-500/30" : "bg-cyan-500/10 border-cyan-500/30"}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Target, { className: `h-4 w-4 ${isFakeAgent ? "text-red-400" : "text-cyan-400"}` }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `text-sm font-semibold ${isFakeAgent ? "text-red-400" : "text-cyan-400"}`, children: preSelectedOpponent.name })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground mt-1", children: isFakeAgent ? " Test Agent - 10s countdown  missile on map!" : "Pre-selected agent" })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Search, { className: "absolute left-3 top-3 h-4 w-4 text-muted-foreground" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                id: "opponent",
                placeholder: "Search agent code or handle...",
                value: opponentSearch,
                onChange: (e) => setOpponentSearch(e.target.value),
                className: "pl-10 bg-background/50"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { htmlFor: "stake-type", children: "Stake Type" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { value: stakeType, onValueChange: setStakeType, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { id: "stake-type", className: "bg-background/50", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: STAKE_TYPES.map((type) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: type.value, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: type.icon }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: type.label })
            ] }) }, type.value)) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Label, { children: [
            "Stake: ",
            stakePercent,
            "%"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Slider,
            {
              value: [stakePercent],
              onValueChange: (vals) => setStakePercent(vals[0]),
              min: 25,
              max: 75,
              step: 25,
              className: "w-full"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between text-xs text-muted-foreground", children: STAKE_PERCENTS.map((p) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => setStakePercent(p),
              className: `px-2 py-1 rounded ${stakePercent === p ? "bg-cyan-500/20 text-cyan-400" : "hover:bg-muted"}`,
              children: [
                p,
                "%"
              ]
            },
            p
          )) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Label, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Swords, { className: "inline h-3 w-3 mr-1" }),
              "Weapon (optional)"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              WeaponDefenseSelector,
              {
                userId,
                type: "weapon",
                selectedItemId: selectedWeaponId,
                onSelect: (id, code) => {
                  setSelectedWeaponId(id);
                  setSelectedWeaponCode(code);
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Label, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, { className: "inline h-3 w-3 mr-1" }),
              "Defense (optional)"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              WeaponDefenseSelector,
              {
                userId,
                type: "defense",
                selectedItemId: selectedDefenseId,
                onSelect: (id, code) => {
                  setSelectedDefenseId(id);
                  setSelectedDefenseCode(code);
                }
              }
            )
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [
        onCancel && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "outline",
            onClick: onCancel,
            disabled: isCreating || showCountdown,
            className: "flex-1",
            children: "Cancel"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            onClick: handleCreate,
            disabled: isCreating || showCountdown || !opponentSearch && !preSelectedOpponent,
            className: `flex-1 ${isFakeAgent ? "bg-gradient-to-r from-red-500 to-orange-500 hover:from-red-600 hover:to-orange-600" : "bg-gradient-to-r from-cyan-500 to-purple-500 hover:from-cyan-600 hover:to-purple-600"}`,
            children: isCreating ? "Creating..." : isFakeAgent ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Target, { className: "mr-2 h-4 w-4" }),
              "LAUNCH ATTACK!"
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              "Create Battle",
              /* @__PURE__ */ jsxRuntimeExports.jsx(Zap, { className: "ml-2 h-4 w-4" })
            ] })
          }
        )
      ] })
    ] })
  ] });
}

const RARITY_COLORS$1 = {
  common: "bg-gray-500/20 text-gray-300 border-gray-500/30",
  rare: "bg-blue-500/20 text-blue-300 border-blue-500/30",
  epic: "bg-purple-500/20 text-purple-300 border-purple-500/30",
  legendary: "bg-yellow-500/20 text-yellow-300 border-yellow-500/30"
};
const RARITY_GLOW = {
  common: "shadow-gray-500/20",
  rare: "shadow-blue-500/30",
  epic: "shadow-purple-500/40",
  legendary: "shadow-yellow-500/50"
};
function BattleShop({ userId }) {
  const [items, setItems] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [purchasing, setPurchasing] = reactExports.useState(null);
  const { toast } = useToast();
  const { unitsData, isLoading: m1uLoading, refetch: refetchM1U } = useM1UnitsRealtime(userId);
  const balance = unitsData?.balance || 0;
  const loadItems = async () => {
    try {
      setLoading(true);
      const { data, error } = await supabase.rpc("list_available_battle_items");
      if (error) throw error;
      setItems(data || []);
    } catch (error) {
      toast({
        title: "Failed to load shop",
        description: error?.message || "Unknown error",
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  };
  reactExports.useEffect(() => {
    loadItems();
    const channel = supabase.channel(`battle-shop-${userId}`).on(
      "postgres_changes",
      {
        event: "*",
        schema: "public",
        table: "user_battle_items",
        filter: `user_id=eq.${userId}`
      },
      () => loadItems()
    ).subscribe();
    return () => {
      supabase.removeChannel(channel);
    };
  }, [userId]);
  const handlePurchase = async (item) => {
    if (balance < item.base_price_m1u) {
      toast({
        title: "Insufficient M1U",
        description: `You need ${item.base_price_m1u} M1U but only have ${balance} M1U`,
        variant: "destructive"
      });
      return;
    }
    setPurchasing(item.item_id);
    try {
      const { data, error } = await supabase.rpc("purchase_battle_item", {
        p_item_id: item.item_id,
        p_quantity: 1
      });
      if (error) {
        const { error: updateError } = await supabase.from("profiles").update({
          m1_units: balance - item.base_price_m1u,
          updated_at: (/* @__PURE__ */ new Date()).toISOString()
        }).eq("id", userId);
        if (updateError) {
          throw updateError;
        }
        const { error: inventoryError } = await supabase.from("user_battle_items").upsert({
          user_id: userId,
          item_id: item.item_id,
          quantity: (item.owned_quantity || 0) + 1,
          purchased_at: (/* @__PURE__ */ new Date()).toISOString()
        }, {
          onConflict: "user_id,item_id"
        });
        if (inventoryError) {
          await supabase.from("profiles").update({ m1_units: balance }).eq("id", userId);
          throw inventoryError;
        }
        const newBalance = balance - item.base_price_m1u;
        window.dispatchEvent(new CustomEvent("m1u-spent", {
          detail: {
            amount: item.base_price_m1u,
            newBalance,
            reason: "battle_item_purchase_fallback"
          }
        }));
        toast({
          title: " Purchase Complete!",
          description: `${item.name} added to your inventory (-${item.base_price_m1u} M1U)`
        });
        await Promise.all([loadItems(), refetchM1U()]);
        return;
      }
      const result = data;
      if (!result?.success) {
        throw new Error(result?.error || "Purchase failed");
      }
      toast({
        title: " Purchase Complete!",
        description: `${item.name} added to your inventory (-${result.total_cost || item.base_price_m1u} M1U)`
      });
      window.dispatchEvent(new CustomEvent("m1u-spent", {
        detail: {
          amount: result.total_cost || item.base_price_m1u,
          newBalance: result.new_balance,
          reason: "battle_item_purchase"
        }
      }));
      await Promise.all([loadItems(), refetchM1U()]);
    } catch (error) {
      toast({
        title: "Purchase Failed",
        description: error?.message || "Unknown error",
        variant: "destructive"
      });
    } finally {
      setPurchasing(null);
    }
  };
  const weapons = items.filter((i) => i.type === "weapon");
  const defenses = items.filter((i) => i.type === "defense");
  const renderItem = (item) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `
        p-4 rounded-lg border bg-gradient-to-br from-background to-background/50
        ${RARITY_COLORS$1[item.rarity]}
        ${RARITY_GLOW[item.rarity]}
        shadow-lg
      `,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-start justify-between mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mb-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold text-sm", children: item.name }),
            item.is_owned && /* @__PURE__ */ jsxRuntimeExports.jsxs(Badge, { variant: "outline", className: "text-[10px] px-1 py-0 border-green-500/50 text-green-400", children: [
              "Owned ",
              item.owned_quantity,
              "x"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground line-clamp-2", children: item.description })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-2 text-xs mb-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swords, { className: "h-3 w-3 text-cyan-400" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-muted-foreground", children: "Power:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold", children: item.power })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { variant: "outline", className: "text-[10px] px-1.5 py-0 capitalize", children: item.rarity }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1 text-cyan-400 font-semibold", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Coins, { className: "h-4 w-4" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              item.base_price_m1u,
              " M1U"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              size: "sm",
              onClick: () => handlePurchase(item),
              disabled: purchasing === item.item_id || balance < item.base_price_m1u || item.is_owned && item.owned_quantity >= item.max_stack,
              className: "h-7 px-3 bg-gradient-to-r from-cyan-500 to-purple-500 hover:from-cyan-600 hover:to-purple-600",
              children: purchasing === item.item_id ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "h-3 w-3 mr-1 animate-spin" }),
                "Buying..."
              ] }) : item.is_owned && item.owned_quantity >= item.max_stack ? "Max Stack" : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ShoppingCart, { className: "h-3 w-3 mr-1" }),
                "Buy"
              ] })
            }
          )
        ] })
      ]
    },
    item.item_id
  );
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center py-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "h-8 w-8 animate-spin text-cyan-400" }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 rounded-lg bg-gradient-to-r from-cyan-950/30 to-purple-950/30 border border-cyan-500/30", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-muted-foreground", children: "Your Balance" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-2", children: m1uLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "h-4 w-4 animate-spin text-cyan-400" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Coins, { className: "h-5 w-5 text-cyan-400" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-2xl font-bold text-cyan-400", children: balance }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-muted-foreground", children: "M1U" })
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, { defaultValue: "weapons", className: "w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { className: "w-full grid grid-cols-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "weapons", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Swords, { className: "h-4 w-4 mr-2" }),
          "Weapons (",
          weapons.length,
          ")"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "defenses", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, { className: "h-4 w-4 mr-2" }),
          "Defenses (",
          defenses.length,
          ")"
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "weapons", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-[400px] pr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid gap-3", children: weapons.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-8 text-sm text-muted-foreground", children: "No weapons available" }) : weapons.map(renderItem) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "defenses", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-[400px] pr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid gap-3", children: defenses.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-8 text-sm text-muted-foreground", children: "No defenses available" }) : defenses.map(renderItem) }) }) })
    ] })
  ] });
}

function BattleModal({
  isOpen,
  onClose,
  userId,
  activeBattles,
  pendingChallenges,
  loading,
  preSelectedOpponent
}) {
  const [activeTab, setActiveTab] = reactExports.useState("overview");
  const [acceptingId, setAcceptingId] = reactExports.useState(null);
  const { toast } = useToast();
  const navigate = useSafeNavigate();
  const activeBattle = activeBattles[0];
  const handleAcceptChallenge = async (battleId) => {
    setAcceptingId(battleId);
    try {
      await acceptBattle(battleId);
      toast({
        title: " Battle Accepted!",
        description: "Prepare for combat..."
      });
      onClose();
    } catch (error) {
      toast({
        title: "Accept Failed",
        description: error?.message || "Unknown error",
        variant: "destructive"
      });
    } finally {
      setAcceptingId(null);
    }
  };
  const formatBattleStatus = (battle) => {
    switch (battle.status) {
      case "pending":
        return "Awaiting opponent";
      case "accepted":
        return "Ready to start";
      case "ready":
        return "Get ready!";
      case "countdown":
        return "Countdown active";
      case "active":
        return "Battle in progress";
      default:
        return battle.status;
    }
  };
  const getTimeRemaining = (battle) => {
    if (battle.expires_at) {
      const remaining = new Date(battle.expires_at).getTime() - Date.now();
      if (remaining > 0) {
        const minutes = Math.floor(remaining / 6e4);
        return `${minutes}m left`;
      }
    }
    return "Expiring soon";
  };
  if (!userId) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: "fixed inset-0 bg-black/60 backdrop-blur-sm z-[1100]",
          initial: { opacity: 0 },
          animate: { opacity: 1 },
          exit: { opacity: 0 },
          onClick: onClose
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        motion.div,
        {
          className: "fixed inset-x-4 top-[10%] bottom-[10%] z-[1101] bg-background/95 backdrop-blur-xl border border-cyan-500/30 rounded-2xl shadow-2xl overflow-hidden",
          style: {
            maxWidth: "600px",
            margin: "0 auto"
          },
          initial: { opacity: 0, scale: 0.9, y: 20 },
          animate: { opacity: 1, scale: 1, y: 0 },
          exit: { opacity: 0, scale: 0.9, y: 20 },
          transition: { type: "spring", stiffness: 300, damping: 30 },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-4 border-b border-cyan-500/30 bg-gradient-to-r from-cyan-950/30 to-purple-950/30", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-10 w-10 rounded-full bg-gradient-to-br from-cyan-500 to-purple-500 flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Swords, { className: "h-5 w-5 text-white" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-bold text-cyan-400", children: "TRON Battle" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: "Manage your battles" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "ghost",
                  size: "icon",
                  onClick: onClose,
                  className: "h-8 w-8 rounded-full hover:bg-cyan-500/10",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { className: "h-5 w-5" })
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, { value: activeTab, onValueChange: setActiveTab, className: "flex-1 flex flex-col h-[calc(100%-73px)]", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { className: "w-full grid grid-cols-3 bg-muted/30 rounded-none border-b border-border/50", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "overview", children: "Overview" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "new", children: "New Battle" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "shop", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(ShoppingBag, { className: "h-4 w-4 mr-1" }),
                  "Shop"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "overview", className: "flex-1 overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 space-y-4", children: [
                loading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-8 text-sm text-muted-foreground", children: "Loading battles..." }),
                !loading && pendingChallenges.length === 0 && activeBattles.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-12 space-y-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Swords, { className: "h-16 w-16 mx-auto text-muted-foreground opacity-30" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "No active battles" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Button,
                    {
                      onClick: () => setActiveTab("new"),
                      size: "sm",
                      className: "bg-gradient-to-r from-cyan-500 to-purple-500 hover:from-cyan-600 hover:to-purple-600",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Swords, { className: "mr-2 h-4 w-4" }),
                        "Create Battle"
                      ]
                    }
                  )
                ] }),
                pendingChallenges.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 text-sm font-semibold text-yellow-400", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Zap, { className: "h-4 w-4" }),
                    "Challenges (",
                    pendingChallenges.length,
                    ")"
                  ] }),
                  pendingChallenges.map((battle) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    motion.div,
                    {
                      initial: { opacity: 0, x: -20 },
                      animate: { opacity: 1, x: 0 },
                      className: "p-4 rounded-lg bg-yellow-500/10 border border-yellow-500/30 space-y-2",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-semibold text-sm", children: battle.arena_name || "Battle Arena" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-muted-foreground", children: [
                            battle.stake_amount,
                            " ",
                            battle.stake_type,
                            "  ",
                            getTimeRemaining(battle)
                          ] })
                        ] }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Button,
                          {
                            onClick: () => handleAcceptChallenge(battle.id),
                            disabled: acceptingId === battle.id,
                            size: "sm",
                            className: "bg-green-600 hover:bg-green-700",
                            children: acceptingId === battle.id ? "Accepting..." : "Accept"
                          }
                        )
                      ] })
                    },
                    battle.id
                  ))
                ] }),
                activeBattles.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 text-sm font-semibold text-cyan-400", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Clock, { className: "h-4 w-4 animate-pulse" }),
                    "Active Battles (",
                    activeBattles.length,
                    ")"
                  ] }),
                  activeBattles.map((battle) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    motion.div,
                    {
                      initial: { opacity: 0, x: -20 },
                      animate: { opacity: 1, x: 0 },
                      className: "p-4 rounded-lg bg-cyan-500/10 border border-cyan-500/30 cursor-pointer hover:bg-cyan-500/20 transition-colors",
                      onClick: () => navigate(`/battle/${battle.id}`),
                      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-semibold text-sm", children: battle.arena_name || "Battle Arena" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-muted-foreground", children: [
                            formatBattleStatus(battle),
                            "  ",
                            battle.stake_amount,
                            " ",
                            battle.stake_type
                          ] })
                        ] }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { variant: "outline", className: "border-cyan-500/50 text-cyan-400", children: battle.status })
                      ] })
                    },
                    battle.id
                  ))
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Button,
                  {
                    variant: "ghost",
                    onClick: () => {
                      navigate("/battle");
                      onClose();
                    },
                    className: "w-full text-sm text-muted-foreground hover:text-foreground",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(ExternalLink, { className: "mr-2 h-3 w-3" }),
                      "Open full Battle Arena"
                    ]
                  }
                )
              ] }) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "new", className: "flex-1 overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                BattleCreationForm,
                {
                  userId,
                  preSelectedOpponent,
                  onSuccess: () => {
                    toast({
                      title: " Battle Created!",
                      description: "Waiting for opponent..."
                    });
                    setActiveTab("overview");
                  },
                  onCancel: () => setActiveTab("overview")
                }
              ) }) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "shop", className: "flex-1 overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4", children: userId ? /* @__PURE__ */ jsxRuntimeExports.jsx(BattleShop, { userId }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-12 text-sm text-muted-foreground", children: "Please log in to access the shop" }) }) }) })
            ] })
          ]
        }
      )
    ] }) }),
    activeBattle && /* @__PURE__ */ jsxRuntimeExports.jsx(
      BattleMount,
      {
        sessionId: activeBattle.id,
        onClose: () => {
        }
      }
    )
  ] });
}

function BattlePill({ userId }) {
  const [isModalOpen, setIsModalOpen] = reactExports.useState(false);
  const { activeBattles, pendingChallenges, loading } = useMyActiveBattles(userId);
  const totalBadgeCount = activeBattles.length + pendingChallenges.length;
  if (!userId) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      motion.button,
      {
        className: "pill-orb fixed z-[1001]",
        style: {
          left: "16px",
          bottom: "calc(env(safe-area-inset-bottom, 34px) + 240px)"
        },
        onClick: () => setIsModalOpen(true),
        initial: { scale: 0 },
        animate: { scale: 1 },
        whileHover: { scale: 1.03 },
        whileTap: { scale: 0.97 },
        transition: { type: "spring", stiffness: 300, damping: 20 },
        "aria-label": "Battle System",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Swords, { className: "w-5 h-5 text-red-400" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dot", style: { background: "#f44", boxShadow: "0 0 8px #f44" } }),
          totalBadgeCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Badge,
            {
              className: "absolute -top-1 -right-1 h-5 w-5 p-0 flex items-center justify-center text-[10px] bg-gradient-to-br from-red-500 to-pink-600 border-2 border-background",
              variant: "destructive",
              children: totalBadgeCount
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      BattleModal,
      {
        isOpen: isModalOpen,
        onClose: () => setIsModalOpen(false),
        userId,
        activeBattles,
        pendingChallenges,
        loading
      }
    )
  ] });
}

const RARITY_COLORS = {
  common: "border-gray-500/30 bg-gray-500/10",
  rare: "border-blue-500/30 bg-blue-500/10",
  epic: "border-purple-500/30 bg-purple-500/10",
  legendary: "border-yellow-500/30 bg-yellow-500/10"
};
function BattleShopPill({ userId, className = "" }) {
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const [inventory, setInventory] = reactExports.useState([]);
  const [loadingInventory, setLoadingInventory] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (isOpen && userId) {
      loadInventory();
    }
  }, [isOpen, userId]);
  const loadInventory = async () => {
    setLoadingInventory(true);
    try {
      const { data, error } = await supabase.rpc("get_user_battle_inventory");
      if (error) throw error;
      setInventory(data || []);
    } catch (err) {
    } finally {
      setLoadingInventory(false);
    }
  };
  const weapons = inventory.filter((i) => i.type === "weapon");
  const defenses = inventory.filter((i) => i.type === "defense");
  const totalItems = inventory.reduce((sum, i) => sum + i.quantity, 0);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      motion.button,
      {
        className: `pill-orb ${className}`,
        onClick: () => setIsOpen(true),
        "aria-label": "Open Battle Shop",
        whileHover: { scale: 1.03 },
        whileTap: { scale: 0.97 },
        initial: { scale: 0 },
        animate: { scale: 1 },
        transition: { type: "spring", stiffness: 300, damping: 20 },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ShoppingBag, { className: "w-5 h-5 text-cyan-100" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dot", style: { background: "#f0f", boxShadow: "0 0 8px #f0f" } }),
          totalItems > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Badge,
            {
              className: "absolute -top-1 -right-1 h-5 w-5 p-0 flex items-center justify-center text-[10px] bg-gradient-to-br from-purple-500 to-pink-600 border-2 border-background",
              children: totalItems
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      motion.div,
      {
        className: "fixed inset-0 z-[5000] flex items-center justify-center p-4",
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              className: "absolute inset-0 bg-black/80 backdrop-blur-sm",
              onClick: () => setIsOpen(false)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            motion.div,
            {
              className: "relative w-full max-w-md max-h-[85vh] overflow-hidden rounded-2xl",
              style: {
                background: "linear-gradient(180deg, rgba(15,23,42,0.98) 0%, rgba(30,41,59,0.98) 100%)",
                border: "1px solid rgba(0, 255, 255, 0.2)",
                boxShadow: "0 0 40px rgba(0, 255, 255, 0.15), 0 25px 50px rgba(0, 0, 0, 0.5)"
              },
              initial: { scale: 0.9, y: 20, opacity: 0 },
              animate: { scale: 1, y: 0, opacity: 1 },
              exit: { scale: 0.9, y: 20, opacity: 0 },
              transition: { type: "spring", damping: 25 },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative px-6 py-4 border-b border-white/10", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        className: "p-2.5 rounded-xl",
                        style: {
                          background: "radial-gradient(circle at 30% 30%, rgba(0,255,255,0.2), rgba(139,92,246,0.3) 80%)",
                          border: "1px solid rgba(0, 255, 255, 0.3)"
                        },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ShoppingBag, { className: "w-5 h-5 text-cyan-400" })
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-bold text-white font-orbitron", children: "Arsenal" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-400", children: "Shop & Inventory" })
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      onClick: () => setIsOpen(false),
                      className: "absolute top-4 right-4 p-2 rounded-full hover:bg-white/10 transition-colors",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { className: "w-5 h-5 text-gray-400" })
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, { defaultValue: "shop", className: "w-full", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { className: "w-full grid grid-cols-2 mx-4 mt-4", style: { width: "calc(100% - 32px)" }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "shop", className: "gap-2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(ShoppingBag, { className: "h-4 w-4" }),
                      "Shop"
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsTrigger, { value: "inventory", className: "gap-2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Package, { className: "h-4 w-4" }),
                      "Inventory (",
                      totalItems,
                      ")"
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "shop", className: "mt-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 max-h-[calc(85vh-180px)] overflow-y-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(BattleShop, { userId }) }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "inventory", className: "mt-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-[calc(85vh-180px)] p-4", children: loadingInventory ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center py-12", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderCircle, { className: "h-8 w-8 animate-spin text-cyan-400" }) }) : inventory.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-12", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Package, { className: "h-12 w-12 text-gray-600 mx-auto mb-3" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-400 text-sm", children: "No items in inventory" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-500 text-xs mt-1", children: "Purchase items from the Shop!" })
                  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
                    weapons.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mb-3", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Swords, { className: "h-4 w-4 text-red-400" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-semibold text-white", children: "Weapons" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { variant: "outline", className: "text-[10px] border-red-500/30 text-red-400", children: weapons.length })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid gap-2", children: weapons.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "div",
                        {
                          className: `p-3 rounded-lg border ${RARITY_COLORS[item.rarity] || RARITY_COLORS.common}`,
                          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-semibold text-white", children: item.name }),
                                /* @__PURE__ */ jsxRuntimeExports.jsxs(Badge, { variant: "outline", className: "text-[9px] px-1.5 py-0", children: [
                                  "x",
                                  item.quantity
                                ] })
                              ] }),
                              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3 mt-1 text-xs text-gray-400", children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                                  "Power: ",
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-cyan-400", children: item.power })
                                ] }),
                                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "capitalize", children: item.rarity })
                              ] })
                            ] }),
                            item.is_equipped && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { className: "bg-green-500/20 text-green-400 border-green-500/30 text-[10px]", children: "Equipped" })
                          ] })
                        },
                        item.inventory_id
                      )) })
                    ] }),
                    defenses.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mb-3", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, { className: "h-4 w-4 text-cyan-400" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-semibold text-white", children: "Defenses" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { variant: "outline", className: "text-[10px] border-cyan-500/30 text-cyan-400", children: defenses.length })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid gap-2", children: defenses.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "div",
                        {
                          className: `p-3 rounded-lg border ${RARITY_COLORS[item.rarity] || RARITY_COLORS.common}`,
                          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-semibold text-white", children: item.name }),
                                /* @__PURE__ */ jsxRuntimeExports.jsxs(Badge, { variant: "outline", className: "text-[9px] px-1.5 py-0", children: [
                                  "x",
                                  item.quantity
                                ] })
                              ] }),
                              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3 mt-1 text-xs text-gray-400", children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                                  "Power: ",
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-cyan-400", children: item.power })
                                ] }),
                                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "capitalize", children: item.rarity })
                              ] })
                            ] }),
                            item.is_equipped && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { className: "bg-green-500/20 text-green-400 border-green-500/30 text-[10px]", children: "Equipped" })
                          ] })
                        },
                        item.inventory_id
                      )) })
                    ] })
                  ] }) }) })
                ] })
              ]
            }
          )
        ]
      }
    ) })
  ] });
}

const STATUS_CONFIG = {
  available: {
    label: "Available for Battle",
    color: "text-green-400",
    bgColor: "bg-green-500/10",
    borderColor: "border-green-500/30"
  },
  ghost: {
    label: "Ghost Mode Active",
    color: "text-purple-400",
    bgColor: "bg-purple-500/10",
    borderColor: "border-purple-500/30"
  },
  shielded: {
    label: "Shield Active",
    color: "text-blue-400",
    bgColor: "bg-blue-500/10",
    borderColor: "border-blue-500/30"
  },
  in_battle: {
    label: "Currently in Battle",
    color: "text-red-400",
    bgColor: "bg-red-500/10",
    borderColor: "border-red-500/30"
  }
};
function AgentBattleCard({
  isOpen,
  onClose,
  agentCode,
  displayName,
  rank,
  reputation,
  isAttackable,
  status = "available",
  onAttack
}) {
  const statusConfig = STATUS_CONFIG[status];
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.div,
      {
        className: "fixed inset-0 bg-black/40 backdrop-blur-sm z-[1200]",
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: onClose
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.div,
      {
        className: "fixed left-1/2 top-[20%] z-[1201] w-[90%] max-w-[400px]",
        style: { marginLeft: "-45%" },
        initial: { opacity: 0, scale: 0.9, y: -20 },
        animate: { opacity: 1, scale: 1, y: 0 },
        exit: { opacity: 0, scale: 0.9, y: -20 },
        transition: { type: "spring", stiffness: 300, damping: 25 },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-2xl bg-background/95 backdrop-blur-xl border border-cyan-500/30 shadow-2xl overflow-hidden", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative p-4 bg-gradient-to-r from-cyan-950/50 to-purple-950/50 border-b border-cyan-500/20", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-12 w-12 rounded-full bg-gradient-to-br from-cyan-500 to-purple-500 flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Swords, { className: "h-6 w-6 text-white" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-bold text-cyan-400", children: agentCode }),
                displayName && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: displayName })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "ghost",
                size: "icon",
                onClick: onClose,
                className: "h-8 w-8 rounded-full hover:bg-cyan-500/10",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { className: "h-5 w-5" })
              }
            )
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 space-y-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-3", children: [
              rank && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-3 rounded-lg bg-muted/30 border border-border/50", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground mb-1", children: "Rank" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-semibold text-sm", children: rank })
              ] }),
              reputation !== void 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-3 rounded-lg bg-muted/30 border border-border/50", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground mb-1", children: "Reputation" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-semibold text-sm", children: reputation })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: `
                    p-3 rounded-lg border ${statusConfig.bgColor} ${statusConfig.borderColor}
                  `,
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                  status === "shielded" && /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, { className: "h-4 w-4" }),
                  status === "in_battle" && /* @__PURE__ */ jsxRuntimeExports.jsx(Clock, { className: "h-4 w-4 animate-pulse" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `text-sm font-medium ${statusConfig.color}`, children: statusConfig.label })
                ] })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Button,
              {
                onClick: onAttack,
                disabled: !isAttackable,
                className: "w-full h-12 bg-gradient-to-r from-cyan-500 to-purple-500 hover:from-cyan-600 hover:to-purple-600 disabled:opacity-50 disabled:cursor-not-allowed",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Swords, { className: "mr-2 h-5 w-5" }),
                  isAttackable ? "Attack this Agent" : "Cannot Attack"
                ]
              }
            ),
            !isAttackable && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-center text-muted-foreground", children: "This agent is currently unavailable for battle" })
          ] })
        ] })
      }
    )
  ] }) });
}

function RewardCounterPill({ className = "" }) {
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const [stats, setStats] = reactExports.useState({ total: 0, claimed: 0, available: 0 });
  const [isLoading, setIsLoading] = reactExports.useState(true);
  const loadStats = async () => {
    try {
      setIsLoading(true);
      const { data: markersData, error: markersError } = await supabase.from("markers").select("id").eq("active", true);
      if (markersError) {
        setStats({ total: 99, claimed: 0, available: 99 });
        return;
      }
      const totalMarkers = markersData?.length || 99;
      const { data: claimsData, error: claimsError } = await supabase.from("marker_claims").select("marker_id");
      if (claimsError) {
        setStats({ total: totalMarkers, claimed: 0, available: totalMarkers });
        return;
      }
      const claimedMarkerIds = new Set((claimsData || []).map((c) => c.marker_id));
      const claimedCount = claimedMarkerIds.size;
      setStats({
        total: Math.max(totalMarkers, 99),
        // At least 99
        claimed: claimedCount,
        available: Math.max(totalMarkers, 99) - claimedCount
      });
    } catch (error) {
      setStats({ total: 99, claimed: 0, available: 99 });
    } finally {
      setIsLoading(false);
    }
  };
  reactExports.useEffect(() => {
    loadStats();
    const channel = supabase.channel("reward-counter-updates").on(
      "postgres_changes",
      { event: "*", schema: "public", table: "marker_claims" },
      () => {
        loadStats();
      }
    ).on(
      "postgres_changes",
      { event: "*", schema: "public", table: "markers" },
      () => {
        loadStats();
      }
    ).subscribe();
    return () => {
      supabase.removeChannel(channel);
    };
  }, []);
  const availablePercent = stats.total > 0 ? Math.round(stats.available / stats.total * 100) : 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      motion.button,
      {
        className: `pill-orb ${className}`,
        onClick: () => setIsOpen(true),
        "aria-label": "Marker Rewards disponibili",
        whileHover: { scale: 1.03 },
        whileTap: { scale: 0.97 },
        initial: { scale: 0 },
        animate: { scale: 1 },
        transition: { type: "spring", stiffness: 300, damping: 20 },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Gift, { className: "w-5 h-5 text-yellow-300" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dot", style: { background: "#ffd700", boxShadow: "0 0 8px #ffd700" } }),
          !isLoading && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Badge,
            {
              className: "absolute -top-1 -right-1 h-5 min-w-[28px] px-1.5 flex items-center justify-center text-[9px] bg-gradient-to-br from-yellow-500 to-orange-600 border-2 border-background font-bold",
              children: [
                stats.available,
                "/",
                stats.total
              ]
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      motion.div,
      {
        className: "fixed inset-0 z-[5000] flex items-center justify-center p-4",
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              className: "absolute inset-0 bg-black/80 backdrop-blur-sm",
              onClick: () => setIsOpen(false)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            motion.div,
            {
              className: "relative w-full max-w-sm overflow-hidden rounded-2xl",
              style: {
                background: "linear-gradient(180deg, rgba(15,23,42,0.98) 0%, rgba(30,41,59,0.98) 100%)",
                border: "1px solid rgba(255, 215, 0, 0.3)",
                boxShadow: "0 0 40px rgba(255, 215, 0, 0.15), 0 25px 50px rgba(0, 0, 0, 0.5)"
              },
              initial: { scale: 0.9, y: 20, opacity: 0 },
              animate: { scale: 1, y: 0, opacity: 1 },
              exit: { scale: 0.9, y: 20, opacity: 0 },
              transition: { type: "spring", damping: 25 },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative px-6 py-4 border-b border-white/10", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        className: "p-2.5 rounded-xl",
                        style: {
                          background: "radial-gradient(circle at 30% 30%, rgba(255,215,0,0.2), rgba(255,165,0,0.3) 80%)",
                          border: "1px solid rgba(255, 215, 0, 0.3)"
                        },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Gift, { className: "w-5 h-5 text-yellow-400" })
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-bold text-white font-orbitron", children: "Rewards" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-400", children: "Premi sulla Mappa" })
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      onClick: () => setIsOpen(false),
                      className: "absolute top-4 right-4 p-2 rounded-full hover:bg-white/10 transition-colors",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { className: "w-5 h-5 text-gray-400" })
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-6 space-y-6", children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center py-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-8 h-8 border-2 border-yellow-500 border-t-transparent rounded-full animate-spin" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-32 h-32", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-full h-full transform -rotate-90", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "circle",
                        {
                          cx: "64",
                          cy: "64",
                          r: "56",
                          fill: "none",
                          stroke: "rgba(255,255,255,0.1)",
                          strokeWidth: "8"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "circle",
                        {
                          cx: "64",
                          cy: "64",
                          r: "56",
                          fill: "none",
                          stroke: "url(#rewardGradient)",
                          strokeWidth: "8",
                          strokeLinecap: "round",
                          strokeDasharray: `${availablePercent * 3.52} 352`
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "rewardGradient", x1: "0%", y1: "0%", x2: "100%", y2: "0%", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#ffd700" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#ff8c00" })
                      ] }) })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute inset-0 flex flex-col items-center justify-center", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-3xl font-bold text-yellow-400", children: stats.available }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-gray-400", children: "disponibili" })
                    ] })
                  ] }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-3", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white/5 rounded-xl p-3 text-center border border-white/10", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MapPin, { className: "w-5 h-5 text-yellow-400 mx-auto mb-1" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xl font-bold text-white", children: stats.total }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-[10px] text-gray-400 uppercase", children: "Totali" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-green-500/10 rounded-xl p-3 text-center border border-green-500/20", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheckBig, { className: "w-5 h-5 text-green-400 mx-auto mb-1" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xl font-bold text-green-400", children: stats.claimed }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-[10px] text-gray-400 uppercase", children: "Riscattati" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-yellow-500/10 rounded-xl p-3 text-center border border-yellow-500/20", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Clock, { className: "w-5 h-5 text-yellow-400 mx-auto mb-1" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xl font-bold text-yellow-400", children: stats.available }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-[10px] text-gray-400 uppercase", children: "Disponibili" })
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-yellow-500/10 rounded-xl p-4 border border-yellow-500/20", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-yellow-200/80 text-center", children: [
                    " Trova i marker ",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-yellow-400 font-semibold", children: "gialli" }),
                    " sulla mappa per riscattare premi istantanei!"
                  ] }) })
                ] }) })
              ]
            }
          )
        ]
      }
    ) })
  ] });
}

const FinalShootContext = reactExports.createContext(null);
const isTestMode = () => {
  if (typeof window === "undefined") return false;
  const params = new URLSearchParams(window.location.search);
  return params.get("test-final-shoot") === "true";
};
const TEST_COORDINATES = { lat: 45.4642, lng: 9.19 };
function FinalShootProvider({ children }) {
  const [state, setState] = reactExports.useState({
    isAvailable: false,
    isActive: false,
    remainingAttempts: 3,
    daysRemaining: 0,
    hasWon: false,
    isLoading: true,
    lastAttempt: null
  });
  const [missionData, setMissionData] = reactExports.useState({
    missionId: null,
    prizeLocation: null,
    endsAt: null
  });
  const [isLocked, setIsLocked] = reactExports.useState(true);
  const [totalMissionDays, setTotalMissionDays] = reactExports.useState(30);
  const getHintFromDistance = (distanceMeters) => {
    if (distanceMeters <= 19) return " PERFETTO! HAI VINTO!";
    if (distanceMeters <= 50) return " Caldissimo! Sei vicinissimo!";
    if (distanceMeters <= 100) return " Molto caldo! Quasi ci sei!";
    if (distanceMeters <= 250) return " Caldo! Stai andando bene!";
    if (distanceMeters <= 500) return " Tiepido. Direzione giusta!";
    if (distanceMeters <= 1e3) return " Freddo. Riprova!";
    if (distanceMeters <= 2e3) return " Molto freddo. Sei lontano.";
    return " Freddissimo! Sei molto lontano.";
  };
  reactExports.useEffect(() => {
    const checkAvailability = async () => {
      try {
        const testMode = isTestMode();
        if (testMode) {
          setMissionData({
            missionId: "test-mission-id",
            prizeLocation: TEST_COORDINATES,
            endsAt: new Date(Date.now() + 3 * 24 * 60 * 60 * 1e3)
          });
          setIsLocked(false);
          setState({
            isAvailable: true,
            isActive: false,
            remainingAttempts: 3,
            daysRemaining: 3,
            hasWon: false,
            isLoading: false,
            lastAttempt: null
          });
          setTotalMissionDays(30);
          return;
        }
        const { data: mission, error: missionError } = await supabase.from("current_mission_data").select("id, prize_lat, prize_lng, mission_ends_at, mission_started_at, mission_status, linked_mission_id").eq("mission_status", "active").order("created_at", { ascending: false }).limit(1).maybeSingle();
        if (missionError || !mission) {
          setState((prev) => ({ ...prev, isLoading: false, isAvailable: false }));
          setIsLocked(true);
          return;
        }
        const startedAt = mission.mission_started_at ? new Date(mission.mission_started_at) : null;
        const endsAt = mission.mission_ends_at ? new Date(mission.mission_ends_at) : null;
        const missionDuration = startedAt && endsAt ? Math.ceil((endsAt.getTime() - startedAt.getTime()) / (1e3 * 60 * 60 * 24)) : 30;
        setTotalMissionDays(missionDuration);
        const now = /* @__PURE__ */ new Date();
        const daysRemaining = endsAt ? Math.max(0, Math.ceil((endsAt.getTime() - now.getTime()) / (1e3 * 60 * 60 * 24))) : 0;
        const isAvailable = daysRemaining > 0 && daysRemaining <= 7;
        setIsLocked(!isAvailable);
        setMissionData({
          missionId: mission.linked_mission_id || mission.id,
          prizeLocation: mission.prize_lat && mission.prize_lng ? { lat: mission.prize_lat, lng: mission.prize_lng } : null,
          endsAt
        });
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) {
          setState((prev) => ({ ...prev, isLoading: false, isAvailable: false }));
          return;
        }
        const { data: attempts, error: attemptsError } = await supabase.from("final_shoot_attempts").select("*").eq("user_id", user.id).eq("mission_id", mission.linked_mission_id || mission.id).order("created_at", { ascending: false });
        if (attemptsError) {
        }
        const attemptsCount = attempts?.length || 0;
        const hasWon = attempts?.some((a) => a.is_winner) || false;
        const remainingAttempts = Math.max(0, 3 - attemptsCount);
        const lastAttempt = attempts?.[0] ? { distance: attempts[0].distance_meters, hint: getHintFromDistance(attempts[0].distance_meters) } : null;
        setState({
          isAvailable,
          isActive: false,
          remainingAttempts,
          daysRemaining,
          hasWon,
          isLoading: false,
          lastAttempt
        });
      } catch (error) {
        setState((prev) => ({ ...prev, isLoading: false }));
      }
    };
    checkAvailability();
  }, []);
  const activateFinalShoot = reactExports.useCallback(() => {
    if (!state.isAvailable || state.remainingAttempts <= 0 || state.hasWon) {
      return;
    }
    setState((prev) => ({ ...prev, isActive: true }));
    ue.info(" FINAL SHOOT ATTIVATO!", {
      description: `Clicca sulla mappa dove pensi sia il premio. Hai ${state.remainingAttempts} tentativi.`,
      duration: 5e3
    });
  }, [state.isAvailable, state.remainingAttempts, state.hasWon]);
  const deactivateFinalShoot = reactExports.useCallback(() => {
    setState((prev) => ({ ...prev, isActive: false }));
  }, []);
  const executeShoot = reactExports.useCallback(async (lat, lng) => {
    if (!missionData.missionId || !missionData.prizeLocation) {
      ue.error("Errore: Missione non trovata");
      return false;
    }
    if (state.remainingAttempts <= 0) {
      ue.error("Hai esaurito tutti i tentativi!");
      return false;
    }
    if (state.hasWon) {
      ue.success("Hai gi vinto il Final Shoot!");
      return false;
    }
    try {
      const R = 6371e3;
      const dLat = (missionData.prizeLocation.lat - lat) * Math.PI / 180;
      const dLng = (missionData.prizeLocation.lng - lng) * Math.PI / 180;
      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat * Math.PI / 180) * Math.cos(missionData.prizeLocation.lat * Math.PI / 180) * Math.sin(dLng / 2) * Math.sin(dLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      const distance = R * c;
      const isWinner = distance <= 19;
      const hint = getHintFromDistance(distance);
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        ue.error("Devi essere loggato");
        return false;
      }
      if (!isTestMode()) {
        const { error: insertError } = await supabase.from("final_shoot_attempts").insert({
          user_id: user.id,
          mission_id: missionData.missionId,
          attempt_lat: lat,
          attempt_lng: lng,
          distance_meters: distance,
          is_winner: isWinner,
          attempt_number: 4 - state.remainingAttempts
        });
        if (insertError) {
          ue.error("Errore nel salvataggio del tentativo");
          return false;
        }
      }
      setState((prev) => ({
        ...prev,
        remainingAttempts: prev.remainingAttempts - 1,
        hasWon: isWinner,
        isActive: isWinner ? false : prev.isActive,
        lastAttempt: { distance, hint }
      }));
      if (isWinner) {
        ue.success(" HAI VINTO IL FINAL SHOOT!", {
          description: "Complimenti! Hai trovato la posizione esatta del premio!",
          duration: 1e4
        });
        if ("vibrate" in navigator) {
          navigator.vibrate([500, 200, 500, 200, 500]);
        }
      } else {
        ue.info(hint, {
          description: `Tentativi rimasti: ${state.remainingAttempts - 1}`,
          duration: 5e3
        });
      }
      return isWinner;
    } catch (error) {
      ue.error("Errore durante il tentativo");
      return false;
    }
  }, [missionData, state.remainingAttempts, state.hasWon]);
  const value = {
    ...state,
    missionData,
    isLocked,
    totalMissionDays,
    isTestMode: isTestMode(),
    activateFinalShoot,
    deactivateFinalShoot,
    executeShoot
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FinalShootContext.Provider, { value, children });
}
function useFinalShootContext() {
  const context = reactExports.useContext(FinalShootContext);
  if (!context) {
    throw new Error("useFinalShootContext must be used within a FinalShootProvider");
  }
  return context;
}

const FinalShootPill = () => {
  const {
    isAvailable,
    isActive,
    isLocked,
    remainingAttempts,
    daysRemaining,
    totalMissionDays,
    hasWon,
    isLoading,
    isTestMode,
    activateFinalShoot,
    deactivateFinalShoot
  } = useFinalShootContext();
  const [showInfoModal, setShowInfoModal] = reactExports.useState(false);
  if (isLoading) {
    return null;
  }
  const daysUntilAvailable = Math.max(0, daysRemaining - 7);
  const getState = () => {
    if (hasWon) return "won";
    if (isAvailable && remainingAttempts <= 0) return "exhausted";
    if (isActive) return "active";
    if (isLocked) return "locked";
    return "available";
  };
  const state = getState();
  const getIcon = () => {
    switch (state) {
      case "won":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Trophy, { className: "w-5 h-5 text-yellow-400" });
      case "exhausted":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { className: "w-5 h-5 text-gray-400" });
      case "active":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Target, { className: "w-5 h-5 text-red-400" });
      case "locked":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Lock, { className: "w-5 h-5 text-gray-400" });
      default:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Crosshair, { className: "w-5 h-5 text-cyan-400" });
    }
  };
  const handleClick = () => {
    if (state === "won" || state === "exhausted") return;
    if (state === "active") {
      deactivateFinalShoot();
    } else if (state === "locked") {
      setShowInfoModal(true);
    } else {
      activateFinalShoot();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      motion.button,
      {
        className: `pill-orb final-shoot-pill final-shoot-pill--${state}`,
        onClick: handleClick,
        initial: { scale: 0 },
        animate: { scale: 1 },
        whileHover: { scale: 1.03 },
        whileTap: { scale: 0.97 },
        transition: { type: "spring", stiffness: 300, damping: 20 },
        "aria-label": "Final Shoot",
        children: [
          getIcon(),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dot" }),
          isTestMode && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute -top-1 -right-1 px-1.5 py-0.5 text-[8px] bg-yellow-500 rounded-full text-black font-bold", children: "TEST" }),
          state === "won" && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute -top-3 text-sm", children: "" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: showInfoModal && /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.div,
      {
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        className: "fixed inset-0 z-[9999] flex items-center justify-center bg-black/70 backdrop-blur-sm p-4",
        onClick: () => setShowInfoModal(false),
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          motion.div,
          {
            initial: { scale: 0.8, y: 20 },
            animate: { scale: 1, y: 0 },
            exit: { scale: 0.8, y: 20 },
            className: "relative max-w-md w-full p-6 rounded-2xl bg-gradient-to-b from-gray-900 via-gray-900 to-black border border-cyan-500/30 shadow-2xl shadow-cyan-500/20",
            onClick: (e) => e.stopPropagation(),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => setShowInfoModal(false),
                  className: "absolute top-4 right-4 p-2 rounded-full bg-white/5 hover:bg-white/10 transition-colors",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { className: "w-5 h-5 text-white/60" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-4 mb-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-3 rounded-xl bg-gradient-to-br from-purple-500/20 to-pink-500/20 border border-purple-400/30", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Crosshair, { className: "w-8 h-8 text-cyan-400" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-bold text-white font-orbitron", children: "FINAL SHOOT" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-cyan-400", children: "La Mossa Finale" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4 mb-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 rounded-xl bg-white/5 border border-white/10", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "font-bold text-white mb-2 flex items-center gap-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Target, { className: "w-4 h-4 text-pink-400" }),
                    "Cos' Final Shoot?"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-white/70 leading-relaxed", children: [
                    " la tua ultima possibilit di vincere! Negli ",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-cyan-400 font-bold", children: "ultimi 7 giorni" }),
                    " della missione, puoi indicare sulla mappa dove pensi si trovi il premio."
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 rounded-xl bg-white/5 border border-white/10", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "font-bold text-white mb-2 flex items-center gap-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Zap, { className: "w-4 h-4 text-yellow-400" }),
                    "Come Funziona"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "text-sm text-white/70 space-y-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-start gap-2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-cyan-400 font-bold", children: "1." }),
                      "Attiva Final Shoot toccando questo pulsante"
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-start gap-2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-cyan-400 font-bold", children: "2." }),
                      "Tocca sulla mappa dove pensi sia il premio"
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-start gap-2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-cyan-400 font-bold", children: "3." }),
                      "Ricevi feedback sulla distanza dal premio"
                    ] })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 rounded-xl bg-gradient-to-r from-red-500/10 to-orange-500/10 border border-red-400/20", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "font-bold text-red-300 mb-2 flex items-center gap-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(CircleAlert, { className: "w-4 h-4" }),
                    "Attenzione"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-white/70", children: [
                    "Hai solo ",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red-400 font-bold", children: "3 tentativi" }),
                    " per l'intera missione. Usa gli indizi raccolti per aumentare le tue probabilit!"
                  ] })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 rounded-xl bg-gradient-to-r from-cyan-500/10 to-purple-500/10 border border-cyan-400/30", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-white/60", children: "Si attiva tra" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-2xl font-bold text-cyan-400 font-orbitron", children: [
                    daysUntilAvailable,
                    " GIORNI"
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-white/60", children: "Giorni missione" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-lg font-bold text-white", children: [
                    totalMissionDays - daysRemaining,
                    "/",
                    totalMissionDays
                  ] })
                ] })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => setShowInfoModal(false),
                  className: "mt-6 w-full py-3 rounded-xl bg-gradient-to-r from-cyan-500/20 to-purple-500/20 border border-cyan-400/30 text-white font-bold hover:border-cyan-400/50 transition-colors",
                  children: "Ho Capito"
                }
              )
            ]
          }
        )
      }
    ) })
  ] });
};

const FinalShootOverlay = ({ map }) => {
  const ctx = useFinalShootContext();
  const [showConfirm, setShowConfirm] = reactExports.useState(false);
  const [targetCoords, setTargetCoords] = reactExports.useState(null);
  const [phase, setPhase] = reactExports.useState("idle");
  const [progress, setProgress] = reactExports.useState(0);
  const [result, setResult] = reactExports.useState(null);
  const timerRef = reactExports.useRef(null);
  const beatTimerRef = reactExports.useRef(null);
  const audioCtxRef = reactExports.useRef(null);
  const cleanup = reactExports.useCallback(() => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
      timerRef.current = null;
    }
    if (beatTimerRef.current) {
      clearTimeout(beatTimerRef.current);
      beatTimerRef.current = null;
    }
    if (audioCtxRef.current) {
      try {
        audioCtxRef.current.close();
      } catch {
      }
      audioCtxRef.current = null;
    }
  }, []);
  const progressRef = reactExports.useRef(0);
  const playBeat = reactExports.useCallback(() => {
    const p = progressRef.current;
    if (p >= 1) return;
    try {
      const ac = new (window.AudioContext || window.webkitAudioContext)();
      const osc = ac.createOscillator();
      const gain = ac.createGain();
      osc.type = "sine";
      const freq = 40 + p * 160;
      osc.frequency.setValueAtTime(freq, ac.currentTime);
      osc.frequency.exponentialRampToValueAtTime(freq * 0.3, ac.currentTime + 0.12);
      const vol = 0.2 + p * 0.5;
      gain.gain.setValueAtTime(vol, ac.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ac.currentTime + 0.15);
      osc.connect(gain);
      gain.connect(ac.destination);
      osc.start();
      osc.stop(ac.currentTime + 0.2);
      setTimeout(() => ac.close(), 300);
      if ("vibrate" in navigator) navigator.vibrate(15 + Math.floor(p * 45));
    } catch {
    }
    const interval = Math.max(100, 550 - p * 450);
    if (p < 1) {
      beatTimerRef.current = window.setTimeout(playBeat, interval);
    }
  }, []);
  const startHeartbeat = reactExports.useCallback(() => {
    progressRef.current = 0;
    playBeat();
  }, [playBeat]);
  const playWinSound = reactExports.useCallback(() => {
    try {
      const ac = new (window.AudioContext || window.webkitAudioContext)();
      const play = (f, t, d, type = "square") => {
        const o = ac.createOscillator();
        const g = ac.createGain();
        o.type = type;
        o.frequency.value = f;
        g.gain.setValueAtTime(0.25, ac.currentTime + t);
        g.gain.exponentialRampToValueAtTime(0.01, ac.currentTime + t + d);
        o.connect(g);
        g.connect(ac.destination);
        o.start(ac.currentTime + t);
        o.stop(ac.currentTime + t + d + 0.05);
      };
      play(523, 0, 0.3);
      play(659, 0, 0.3);
      play(784, 0, 0.3);
      play(784, 0.35, 0.3);
      play(988, 0.35, 0.3);
      play(1175, 0.35, 0.3);
      play(1047, 0.7, 0.5);
      play(1319, 0.7, 0.5);
      play(1568, 0.7, 0.5);
      play(2093, 0.7, 0.5, "sawtooth");
      [2093, 2349, 2637, 3136, 3520, 4186].forEach((f, i) => play(f, 1.2 + i * 0.08, 0.15, "sine"));
      setTimeout(() => ac.close(), 3e3);
    } catch {
    }
  }, []);
  const playFailSound = reactExports.useCallback(() => {
    try {
      const ac = new (window.AudioContext || window.webkitAudioContext)();
      const play = (f, t, d) => {
        const o = ac.createOscillator();
        const g = ac.createGain();
        o.type = "triangle";
        o.frequency.value = f;
        g.gain.setValueAtTime(0.35, ac.currentTime + t);
        g.gain.exponentialRampToValueAtTime(0.01, ac.currentTime + t + d);
        o.connect(g);
        g.connect(ac.destination);
        o.start(ac.currentTime + t);
        o.stop(ac.currentTime + t + d + 0.05);
      };
      play(392, 0, 0.25);
      play(349, 0.3, 0.25);
      play(262, 0.6, 0.7);
      const bass = ac.createOscillator();
      const bg = ac.createGain();
      bass.type = "sine";
      bass.frequency.value = 55;
      bg.gain.setValueAtTime(0.4, ac.currentTime + 0.6);
      bg.gain.exponentialRampToValueAtTime(0.01, ac.currentTime + 1.5);
      bass.connect(bg);
      bg.connect(ac.destination);
      bass.start(ac.currentTime + 0.6);
      bass.stop(ac.currentTime + 1.6);
      setTimeout(() => ac.close(), 2e3);
    } catch {
    }
  }, []);
  reactExports.useEffect(() => {
    if (!map || !ctx.isActive || showConfirm || phase !== "idle") return;
    const onClick = (e) => {
      setTargetCoords({ lat: e.lngLat.lat, lng: e.lngLat.lng });
      setShowConfirm(true);
    };
    map.on("click", onClick);
    map.getCanvas().style.cursor = "crosshair";
    return () => {
      map.off("click", onClick);
      map.getCanvas().style.cursor = "";
    };
  }, [map, ctx.isActive, showConfirm, phase]);
  const resetToIdle = reactExports.useCallback(() => {
    cleanup();
    setPhase("idle");
    setProgress(0);
    setResult(null);
    setTargetCoords(null);
    setShowConfirm(false);
  }, [cleanup]);
  const showResult = reactExports.useCallback((isWinner, hint) => {
    cleanup();
    setResult({ isWinner, hint });
    setPhase("result");
    if (isWinner) {
      playWinSound();
      if (typeof confetti === "function") {
        for (let i = 0; i < 5; i++) {
          setTimeout(() => confetti({ particleCount: 150, spread: 100 + i * 20, origin: { y: 0.5 }, colors: ["#FFD700", "#FF6B6B", "#00FFFF", "#FF00FF"] }), i * 250);
        }
      }
      if ("vibrate" in navigator) navigator.vibrate([200, 100, 200, 100, 500]);
    } else {
      playFailSound();
      if ("vibrate" in navigator) navigator.vibrate([400, 100, 400]);
    }
    setTimeout(() => {
      resetToIdle();
      if (isWinner || ctx.remainingAttempts <= 1) {
        ctx.deactivateFinalShoot();
      }
    }, isWinner ? 8e3 : 4e3);
  }, [cleanup, playWinSound, playFailSound, resetToIdle, ctx]);
  const confirmShoot = reactExports.useCallback(() => {
    if (!targetCoords) {
      return;
    }
    const lat = targetCoords.lat;
    const lng = targetCoords.lng;
    cleanup();
    setShowConfirm(false);
    setPhase("suspense");
    setProgress(0);
    if ("vibrate" in navigator) navigator.vibrate([100, 50, 100]);
    startHeartbeat();
    const duration = 15e3;
    const startTime = Date.now();
    let isRunning = true;
    const tick = () => {
      if (!isRunning) return;
      const elapsed = Date.now() - startTime;
      const p = Math.min(elapsed / duration, 1);
      setProgress(p);
      progressRef.current = p;
      if (p < 1) {
        timerRef.current = window.setTimeout(tick, 50);
      } else {
        isRunning = false;
        cleanup();
        ctx.executeShoot(lat, lng).then((isWinner) => {
          const hint = isWinner ? " PERFETTO!" : ctx.lastAttempt?.hint || "Riprova!";
          showResult(isWinner, hint);
        }).catch((err) => {
          showResult(false, "Errore - Riprova!");
        });
      }
    };
    timerRef.current = window.setTimeout(tick, 50);
  }, [targetCoords, startHeartbeat, cleanup, ctx, showResult]);
  const cancelConfirm = reactExports.useCallback(() => {
    setShowConfirm(false);
    setTargetCoords(null);
  }, []);
  reactExports.useEffect(() => {
    return () => {
      cleanup();
    };
  }, [cleanup]);
  if (!ctx.isActive && phase === "idle") return null;
  const borderOpacity = phase === "suspense" ? 0.3 + progress * 0.7 : 0.3;
  const borderSize = phase === "suspense" ? 60 + progress * 240 : 60;
  const pulseSpeed = phase === "suspense" ? Math.max(0.3, 2 - progress * 1.7) : 2;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    (ctx.isActive || phase === "suspense") && phase !== "result" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fixed inset-0 z-[1500] pointer-events-none", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { className: "absolute inset-0", animate: { boxShadow: [`inset 0 0 ${borderSize}px rgba(239, 68, 68, ${borderOpacity * 0.8})`, `inset 0 0 ${borderSize * 1.3}px rgba(239, 68, 68, ${borderOpacity})`, `inset 0 0 ${borderSize}px rgba(239, 68, 68, ${borderOpacity * 0.8})`] }, transition: { duration: pulseSpeed, repeat: Infinity, ease: "easeInOut" } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { className: "absolute inset-0", animate: { boxShadow: [`inset 0 0 ${borderSize * 1.5}px rgba(200, 0, 0, ${borderOpacity * 0.5})`, `inset 0 0 ${borderSize * 2}px rgba(200, 0, 0, ${borderOpacity * 0.7})`, `inset 0 0 ${borderSize * 1.5}px rgba(200, 0, 0, ${borderOpacity * 0.5})`] }, transition: { duration: pulseSpeed * 0.8, repeat: Infinity, ease: "easeInOut" } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { className: "absolute inset-0", animate: { boxShadow: [`inset 0 0 ${borderSize * 2.5}px rgba(150, 0, 0, ${borderOpacity * 0.3})`, `inset 0 0 ${borderSize * 3}px rgba(150, 0, 0, ${borderOpacity * 0.5})`, `inset 0 0 ${borderSize * 2.5}px rgba(150, 0, 0, ${borderOpacity * 0.3})`] }, transition: { duration: pulseSpeed * 0.6, repeat: Infinity, ease: "easeInOut" } }),
      phase === "suspense" && ["top-0 left-0 border-t-4 border-l-4", "top-0 right-0 border-t-4 border-r-4", "bottom-0 left-0 border-b-4 border-l-4", "bottom-0 right-0 border-b-4 border-r-4"].map((pos, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { className: `absolute ${pos}`, animate: { width: [80, 80 + progress * 80, 80], height: [80, 80 + progress * 80, 80], opacity: [0.5, 1, 0.5] }, transition: { duration: pulseSpeed, repeat: Infinity, delay: i * 0.12 }, style: { borderColor: `rgba(255, 50, 50, ${borderOpacity})` } }, i))
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: ctx.isActive && phase === "idle" && !showConfirm && /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, { initial: { opacity: 0, y: -20 }, animate: { opacity: 1, y: 0 }, exit: { opacity: 0, y: -20 }, className: "fixed z-[1600] left-1/2 -translate-x-1/2 flex items-center gap-3 px-5 py-2.5 rounded-full bg-black/90 border border-red-500/50 backdrop-blur-xl", style: { top: "calc(env(safe-area-inset-top, 0px) + 100px)" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { animate: { scale: [1, 1.2, 1] }, transition: { duration: 1, repeat: Infinity }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Target, { className: "w-5 h-5 text-red-400" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red-200 font-orbitron font-bold text-sm", children: "FINAL SHOOT" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-white/30", children: "|" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-cyan-300 font-bold text-sm", children: [
        ctx.remainingAttempts,
        " tentativi"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: ctx.deactivateFinalShoot, className: "ml-2 p-1 rounded-full hover:bg-white/10", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircleX, { className: "w-5 h-5 text-white/60 hover:text-white" }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: phase === "suspense" && /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { initial: { opacity: 0, scale: 0.9 }, animate: { opacity: 1, scale: 1 }, exit: { opacity: 0, scale: 0.9 }, className: "fixed inset-0 z-[1600] flex items-center justify-center pointer-events-none px-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-black/90 backdrop-blur-xl rounded-2xl p-4 sm:p-6 border border-red-500/50 shadow-2xl shadow-red-500/30 w-full max-w-xs sm:max-w-sm", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, { className: "text-5xl sm:text-7xl font-orbitron font-black text-center mb-3 sm:mb-4", style: { color: `rgb(255, ${Math.floor(255 - progress * 200)}, ${Math.floor(255 - progress * 200)})`, textShadow: `0 0 ${30 + progress * 50}px rgba(255, 0, 0, ${0.5 + progress * 0.5})` }, animate: { scale: [1, 1.08, 1] }, transition: { duration: pulseSpeed * 0.4, repeat: Infinity }, children: [
        Math.floor(progress * 100),
        "%"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-3 sm:h-4 bg-white/10 rounded-full overflow-hidden mb-3 sm:mb-4 border border-white/20", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-full rounded-full transition-all duration-100", style: { width: `${progress * 100}%`, background: `linear-gradient(90deg, #00ffff 0%, #ff00ff 50%, #ff0000 100%)`, boxShadow: `0 0 30px rgba(255, 0, 0, ${progress})` } }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, { className: "text-base sm:text-xl font-orbitron text-white text-center tracking-wider sm:tracking-widest", animate: { opacity: [0.6, 1, 0.6] }, transition: { duration: 0.4, repeat: Infinity }, children: [
        progress < 0.25 && " ANALISI...",
        progress >= 0.25 && progress < 0.5 && " SCANSIONE...",
        progress >= 0.5 && progress < 0.75 && " CALCOLO...",
        progress >= 0.75 && progress < 0.95 && " QUASI...",
        progress >= 0.95 && " VERDETTO! "
      ] })
    ] }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: phase === "result" && result && /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 z-[2000] flex flex-col items-center justify-center pointer-events-none overflow-hidden", children: result.isWinner ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-full h-full flex flex-col items-center justify-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { className: "absolute inset-0", initial: { opacity: 0 }, animate: { opacity: 1 }, style: { background: "radial-gradient(circle, rgba(255,215,0,0.6) 0%, rgba(255,100,0,0.4) 30%, rgba(0,0,0,0.95) 70%)" } }),
      [...Array(16)].map((_, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { className: "absolute w-2 bg-gradient-to-t from-transparent via-yellow-400/80 to-transparent", style: { height: "200%", left: "50%", top: "-50%", transformOrigin: "50% 100%", transform: `rotate(${i * 22.5}deg)` }, initial: { opacity: 0, scaleY: 0 }, animate: { opacity: [0, 1, 0], scaleY: [0, 1, 0] }, transition: { duration: 2, delay: i * 0.06, repeat: Infinity } }, i)),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, { initial: { scale: 0, rotate: -180 }, animate: { scale: 1, rotate: 0 }, transition: { type: "spring", stiffness: 100, damping: 10, delay: 0.1 }, className: "relative z-10 mb-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { animate: { scale: [1, 1.15, 1], rotate: [0, 8, -8, 0] }, transition: { duration: 1.5, repeat: Infinity }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trophy, { className: "w-40 h-40 sm:w-56 sm:h-56 text-yellow-400", strokeWidth: 1, style: { filter: "drop-shadow(0 0 80px rgba(255, 215, 0, 1)) drop-shadow(0 0 150px rgba(255, 165, 0, 0.9))" } }) }),
        [...Array(12)].map((_, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { className: "absolute top-1/2 left-1/2", animate: { x: [0, Math.cos(i * 30 * Math.PI / 180) * 180], y: [0, Math.sin(i * 30 * Math.PI / 180) * 180], scale: [0, 2, 0], opacity: [1, 1, 0], rotate: [0, 360] }, transition: { duration: 1.2, delay: 0.3 + i * 0.08, repeat: Infinity, repeatDelay: 0.8 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Star, { className: "w-6 h-6 sm:w-10 sm:h-10 text-yellow-300 fill-yellow-300" }) }, i))
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, { initial: { opacity: 0, y: 60 }, animate: { opacity: 1, y: 0 }, transition: { delay: 0.4 }, className: "text-center z-10 px-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { animate: { scale: [1, 1.06, 1] }, transition: { duration: 0.4, repeat: Infinity }, className: "text-5xl sm:text-7xl md:text-9xl font-orbitron font-black mb-4 sm:mb-6", style: { background: "linear-gradient(90deg, #FFD700, #FFA500, #FF6B6B, #FFD700)", backgroundSize: "300% 100%", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent", animation: "shimmer 1.5s linear infinite" }, children: "HAI VINTO!" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, transition: { delay: 0.8 }, className: "text-2xl sm:text-4xl text-white", children: " COMPLIMENTI AGENTE! " }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, transition: { delay: 1.2 }, className: "text-xl sm:text-2xl text-cyan-400 mt-4", children: "Hai trovato il premio!" })
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-full h-full flex flex-col items-center justify-center px-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { className: "absolute inset-0", style: { background: "radial-gradient(circle, rgba(100,0,0,0.4) 0%, rgba(0,0,0,0.95) 70%)" } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { initial: { scale: 0, opacity: 0 }, animate: { scale: 1, opacity: 1 }, transition: { type: "spring", stiffness: 200 }, className: "mb-6 sm:mb-8 z-10", children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { animate: { scale: [1, 0.95, 1] }, transition: { duration: 1, repeat: Infinity }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Target, { className: "w-32 h-32 sm:w-44 sm:h-44 text-red-500/40", strokeWidth: 1 }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, { initial: { opacity: 0, y: 40 }, animate: { opacity: 1, y: 0 }, transition: { delay: 0.2 }, className: "text-center z-10", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-4xl sm:text-6xl font-orbitron font-bold text-red-500 mb-4 sm:mb-6", style: { textShadow: "0 0 40px rgba(255, 0, 0, 0.5)" }, children: "MANCATO!" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xl sm:text-2xl text-white/80 mb-4", children: result.hint }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-lg sm:text-xl text-cyan-400 font-bold", children: [
          "Tentativi rimasti: ",
          ctx.remainingAttempts
        ] })
      ] })
    ] }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: showConfirm && targetCoords && /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 z-[2500] flex items-center justify-center bg-black/60 backdrop-blur-sm px-4", onClick: cancelConfirm, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, { initial: { scale: 0.8, y: 20 }, animate: { scale: 1, y: 0 }, exit: { scale: 0.8, y: 20 }, className: "p-5 sm:p-6 rounded-2xl bg-gradient-to-b from-gray-900 to-black border border-cyan-500/30 shadow-xl max-w-sm w-full", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3 mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-2 rounded-full bg-red-500/20 border border-red-400/30", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleAlert, { className: "w-6 h-6 text-red-400" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-bold text-white font-orbitron", children: "CONFERMA" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-white/60", children: "Sei sicuro?" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-5 p-3 rounded-lg bg-white/5 border border-white/10", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-white/70", children: "Coordinate:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-white font-mono text-sm break-all", children: [
          targetCoords.lat.toFixed(6),
          "N, ",
          targetCoords.lng.toFixed(6),
          "E"
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: cancelConfirm, className: "flex-1 px-4 py-3 rounded-xl bg-white/5 border border-white/20 text-white font-medium hover:bg-white/10 active:scale-95 transition-all", children: "Annulla" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: confirmShoot, className: "flex-1 px-4 py-3 rounded-xl bg-gradient-to-r from-red-600 to-pink-600 border border-red-400/50 text-white font-bold font-orbitron hover:from-red-500 hover:to-pink-500 active:scale-95 transition-all", children: " SPARA!" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 text-center text-xs text-white/40", children: [
        "Tentativi: ",
        ctx.remainingAttempts
      ] })
    ] }) }) })
  ] });
};
if (typeof document !== "undefined" && !document.querySelector("#final-shoot-v8")) {
  const s = document.createElement("style");
  s.id = "final-shoot-v8";
  s.textContent = "@keyframes shimmer{0%{background-position:300% 0}100%{background-position:-300% 0}}";
  document.head.appendChild(s);
}

const DebugMapPanel = () => {
  const { user, session, isAuthenticated } = useUnifiedAuth();
  const { nextLevel, nextRadiusKm, nextCostM1U } = useBuzzMapPricingNew(user?.id);
  const { unitsData } = useM1UnitsRealtime(user?.id);
  const [collapsed, setCollapsed] = reactExports.useState(true);
  const [geoPermission, setGeoPermission] = reactExports.useState("unknown");
  const [currentPos, setCurrentPos] = reactExports.useState(null);
  const [lastResult, setLastResult] = reactExports.useState(null);
  reactExports.useEffect(() => {
    if (navigator.permissions) {
      navigator.permissions.query({ name: "geolocation" }).then((result) => {
        setGeoPermission(result.state);
      });
    }
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          setCurrentPos({
            lat: position.coords.latitude,
            lng: position.coords.longitude
          });
        },
        (error) => {
        }
      );
    }
  }, []);
  const getJwtInfo = () => {
    if (!session?.access_token) return { len: 0, exp: null };
    try {
      const parts = session.access_token.split(".");
      if (parts.length !== 3) return { len: 0, exp: null };
      const payload = JSON.parse(atob(parts[1]));
      return {
        len: session.access_token.length,
        exp: payload.exp ? new Date(payload.exp * 1e3).toISOString() : null
      };
    } catch (e) {
      return { len: session.access_token.length, exp: null };
    }
  };
  const testMapGeneration = async () => {
    try {
      const coords = currentPos || { lat: 41.9028, lng: 12.4964 };
      const { data, error } = await supabase.functions.invoke("handle-buzz-press", {
        body: {
          generateMap: true,
          coordinates: coords,
          sessionId: "debug_" + Date.now()
        },
        headers: { "x-m1-debug": "1" }
      });
      const result = {
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        success: !error,
        data,
        error: error?.message || null,
        coordinates: coords
      };
      setLastResult(result);
    } catch (e) {
      setLastResult({ error: e.message });
    }
  };
  if (!isAuthenticated) return null;
  const panel = /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        position: "fixed",
        bottom: "80px",
        right: "10px",
        backgroundColor: "rgba(0, 0, 0, 0.95)",
        color: "#fff",
        padding: collapsed ? "8px" : "12px",
        borderRadius: "8px",
        fontSize: "11px",
        zIndex: 2147483e3,
        maxWidth: "320px",
        maxHeight: collapsed ? "40px" : "60vh",
        overflow: "auto",
        fontFamily: "monospace",
        border: "1px solid #10b981"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            onClick: () => setCollapsed(!collapsed),
            style: {
              cursor: "pointer",
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between",
              fontWeight: "bold",
              marginBottom: collapsed ? 0 : "8px"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " MAP DEBUG" }),
              collapsed ? /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUp, { size: 16 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { size: 16 })
            ]
          }
        ),
        !collapsed && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "8px", paddingTop: "8px", borderTop: "1px solid #444" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: "bold", marginBottom: "4px" }, children: "Auth & Session" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              "Auth: ",
              isAuthenticated ? "" : ""
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              "User ID: ",
              user?.id?.substring(0, 12),
              "..."
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              "JWT Len: ",
              getJwtInfo().len
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "8px", paddingTop: "8px", borderTop: "1px solid #444" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: "bold", marginBottom: "4px" }, children: "Geolocation" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              "Permission: ",
              geoPermission
            ] }),
            currentPos && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                "Lat: ",
                currentPos.lat.toFixed(4)
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                "Lng: ",
                currentPos.lng.toFixed(4)
              ] })
            ] }),
            !currentPos && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { color: "#ef4444" }, children: "No position" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "8px", paddingTop: "8px", borderTop: "1px solid #444" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: "bold", marginBottom: "4px" }, children: "Economy" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              "Balance M1U: ",
              unitsData?.balance || 0
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              "Cost M1U: ",
              nextCostM1U
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              "Next Level: ",
              nextLevel
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              "Next Radius: ",
              nextRadiusKm,
              "km"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "8px", paddingTop: "8px", borderTop: "1px solid #444" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: "bold", marginBottom: "4px" }, children: "Payload Preview" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { style: { fontSize: "9px", margin: 0 }, children: JSON.stringify({
              generateMap: true,
              coordinates: currentPos || { lat: "N/A", lng: "N/A" },
              sessionId: "xxx"
            }, null, 1) })
          ] }),
          lastResult && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "8px", paddingTop: "8px", borderTop: "1px solid #444" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: "bold", marginBottom: "4px" }, children: "Last Test" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              "Success: ",
              lastResult.success ? "" : ""
            ] }),
            lastResult.data?.area_id && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                "Area ID: ",
                lastResult.data.area_id.substring(0, 12),
                "..."
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                "Radius: ",
                lastResult.data.radius_km,
                "km"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                "Level: ",
                lastResult.data.level
              ] })
            ] }),
            lastResult.error && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { color: "#ef4444" }, children: [
              "Error: ",
              lastResult.error
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(CopyJsonButton, { data: lastResult, label: "Copy Result" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", gap: "4px", paddingTop: "8px", borderTop: "1px solid #444" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: testMapGeneration,
              style: {
                padding: "4px 8px",
                fontSize: "10px",
                backgroundColor: "#10b981",
                color: "white",
                border: "none",
                borderRadius: "4px",
                cursor: "pointer"
              },
              children: "Test MAP"
            }
          ) })
        ] })
      ]
    }
  );
  return typeof document !== "undefined" ? reactDomExports.createPortal(panel, document.body) : panel;
};

const DEV_MOCKS = false;
const DEV_VIEW_LOCK = undefined                                         === "true";
function MapTiler3D() {
  const containerRef = reactExports.useRef(null);
  const mapRef = reactExports.useRef(null);
  const debugEnabled = useDebugFlag();
  useMapGlitchEffect();
  const [diag, setDiag] = reactExports.useState({
    keyMode: "?",
    tiles: "?",
    pbf: "?",
    glyph: "?",
    style: "-",
    error: null
  });
  reactExports.useEffect(() => {
  }, []);
  const [layerVisibility, setLayerVisibility] = reactExports.useState({
    agents: true,
    portals: true,
    rewards: true,
    areas: true,
    notes: true
  });
  const DEFAULT_LOCATION = [41.9028, 12.4964];
  const devMocks = use3DDevMocks();
  const { currentWeekAreas, reloadAreas } = useBuzzMapLogic();
  const { position, status: geoStatus, enable: enableGeo, enabled: geoEnabled, isBlocked, isIOS, isPWA, retry: retryGeo} = useGeolocation();
  useAgentLocationUpdater(position || void 0, geoEnabled);
  const { portals, agents: liveAgents, events, zones, loading: liveLoading } = useLiveLayers(true);
  const {
    searchAreas,
    isAddingSearchArea,
    setActiveSearchArea,
    handleAddArea,
    handleMapClickArea,
    deleteSearchArea,
    setPendingRadius
  } = useSearchAreasLogic();
  const handleAddAreaWithRadius = (radius) => {
    if (radius) setPendingRadius(radius);
    handleAddArea(radius);
  };
  const {
    isAddingMarker,
    handleMapClickMarker} = useMapMarkersLogic();
  const { isAuthenticated, user } = useUnifiedAuth();
  const [rewardMarkersLive, setRewardMarkersLive] = reactExports.useState([]);
  const [isUserAdmin, setIsUserAdmin] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (!user?.id) {
      setIsUserAdmin(false);
      return;
    }
    const checkAdmin = async () => {
      const { data } = await supabase.from("profiles").select("role").eq("id", user.id).maybeSingle();
      setIsUserAdmin(!!data?.role && ["admin", "owner"].some((r) => data.role.toLowerCase().includes(r)));
    };
    checkAdmin();
  }, [user?.id]);
  reactExports.useEffect(() => {
    let mounted = true;
    if (!isAuthenticated) {
      setRewardMarkersLive([]);
      return;
    }
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const load = async () => {
      try {
        const { data: markersData, error } = await supabase.from("markers").select("id, lat, lng, title, active, visible_from, visible_to").eq("active", true).or(`visible_from.is.null,visible_from.lte.${now}`).or(`visible_to.is.null,visible_to.gte.${now}`).limit(2e3);
        if (!mounted) return;
        if (error) {
          return;
        }
        const markerIds = (markersData || []).map((m) => m.id);
        const { data: claimsData } = await supabase.from("marker_claims").select("marker_id").in("marker_id", markerIds);
        const claimedIds = new Set((claimsData || []).map((c) => c.marker_id));
        setRewardMarkersLive((markersData || []).map((m) => ({
          id: m.id,
          lat: m.lat,
          lng: m.lng,
          title: m.title,
          claimed: claimedIds.has(m.id)
          //  VIOLA se riscattato
        })));
      } catch (e) {
      }
    };
    load();
    const channel = supabase.channel("markers-changes-3d").on("postgres_changes", { event: "*", schema: "public", table: "markers" }, () => load()).on("postgres_changes", { event: "*", schema: "public", table: "marker_claims" }, () => load()).subscribe();
    return () => {
      mounted = false;
      supabase.removeChannel(channel);
    };
  }, [isAuthenticated]);
  reactExports.useEffect(() => {
    if (!isAuthenticated) return;
    let lastRefetch = 0;
    const REFETCH_THROTTLE_MS = 3e3;
    const refetchAgentsSilently = async () => {
      const now = Date.now();
      if (now - lastRefetch < REFETCH_THROTTLE_MS) {
        return;
      }
      lastRefetch = now;
    };
    const channel = supabase.channel("agent-locations-live-3d").on("postgres_changes", {
      event: "*",
      schema: "public",
      table: "agent_locations"
    }, refetchAgentsSilently).subscribe();
    return () => {
      supabase.removeChannel(channel);
    };
  }, [isAuthenticated]);
  reactExports.useEffect(() => {
    if (geoStatus === "idle") {
      enableGeo();
    }
  }, [geoStatus, enableGeo]);
  reactExports.useEffect(() => {
    if (!isAuthenticated) return;
    const setup = async () => {
      const { data: { session } } = await supabase.auth.getSession();
      const uid = session?.user?.id;
      if (!uid) return;
      const currentWeek = getCurrentWeekOfYear();
      const channel = supabase.channel(`map3d_buzz_fit_${uid}`).on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "user_map_areas",
          filter: `user_id=eq.${uid}`
        },
        async (payload) => {
          if (payload.new?.source === "buzz_map" && payload.new?.week === currentWeek) {
            const map = mapRef.current;
            if (!map) return;
            const lat = payload.new.center_lat ?? payload.new.lat;
            const lng = payload.new.center_lng ?? payload.new.lng;
            const radiusKm = payload.new.radius_km || 500;
            const radiusMeters = radiusKm * 1e3;
            await reloadAreas();
            window.dispatchEvent(new CustomEvent("areasReloaded", {
              detail: {
                lat,
                lng,
                radius_km: radiusKm
              }
            }));
            window.dispatchEvent(new CustomEvent("buzzAreaCreated", {
              detail: {
                lat,
                lng,
                radius_km: radiusKm
              }
            }));
            setTimeout(() => {
              const latDeltaDeg = radiusMeters / 111320;
              const lngDeltaDeg = radiusMeters / (111320 * Math.cos(lat * Math.PI / 180));
              const bbox = [
                [lng - lngDeltaDeg, lat - latDeltaDeg],
                [lng + lngDeltaDeg, lat + latDeltaDeg]
              ];
              const maxZoom = radiusKm > 150 ? 6 : radiusKm > 80 ? 8 : 10;
              map.fitBounds(bbox, {
                padding: 80,
                maxZoom,
                duration: 800
              });
            }, 400);
          }
        }
      ).subscribe();
      return () => supabase.removeChannel(channel);
    };
    setup();
  }, [isAuthenticated]);
  reactExports.useEffect(() => {
    return;
  }, [devMocks.notesSeed]);
  const realAgents = liveAgents && liveAgents.length > 0 ? liveAgents : [];
  const fakeAgents = reactExports.useMemo(() => {
    const WORLD_AGENTS = [
      { name: "AG-CHINA", lat: 39.9042, lng: 116.4074, country: "Beijing, China" },
      { name: "AG-RUSSIA", lat: 55.7558, lng: 37.6173, country: "Moscow, Russia" },
      { name: "AG-AUSTRALIA", lat: -33.8688, lng: 151.2093, country: "Sydney, Australia" },
      { name: "AG-USA", lat: 40.7128, lng: -74.006, country: "New York, USA" },
      { name: "AG-BRAZIL", lat: -22.9068, lng: -43.1729, country: "Rio de Janeiro, Brazil" },
      { name: "AG-JAPAN", lat: 35.6762, lng: 139.6503, country: "Tokyo, Japan" },
      { name: "AG-INDIA", lat: 28.6139, lng: 77.209, country: "New Delhi, India" },
      { name: "AG-EGYPT", lat: 30.0444, lng: 31.2357, country: "Cairo, Egypt" },
      { name: "AG-UK", lat: 51.5074, lng: -0.1278, country: "London, UK" },
      { name: "AG-SOUTH-AFRICA", lat: -33.9249, lng: 18.4241, country: "Cape Town, South Africa" }
    ];
    return WORLD_AGENTS.map((agent, index) => ({
      id: `fake-agent-${index}`,
      username: agent.name,
      agent_code: agent.name,
      status: "online",
      lat: agent.lat,
      lng: agent.lng,
      avatar_url: void 0,
      lastSeen: (/* @__PURE__ */ new Date()).toISOString(),
      rank_id: Math.floor(Math.random() * 5) + 1,
      is_fake: true,
      country: agent.country
      // Extra info for display
    }));
  }, []);
  const effectiveAgents = [...realAgents, ...fakeAgents];
  const effectiveRewardMarkers = rewardMarkersLive;
  const effectiveUserAreas = currentWeekAreas?.length ? currentWeekAreas.map((a) => ({
    id: a.id,
    lat: a.lat,
    lng: a.lng,
    radius: a.radius_km * 1e3,
    level: a.level,
    radius_km: a.radius_km
  })) : [];
  reactExports.useEffect(() => {
  }, []);
  const filteredUserAreas = effectiveUserAreas.length > 0 ? [effectiveUserAreas[0]] : [];
  const latestArea = effectiveUserAreas[0] || null;
  const currentAreaVersion = reactExports.useMemo(() => {
    if (!latestArea) return "none";
    return `${latestArea.id}|${latestArea.level}|${latestArea.radius_km}`;
  }, [latestArea?.id, latestArea?.level, latestArea?.radius_km]);
  reactExports.useEffect(() => {
  }, [latestArea?.id, latestArea?.radius_km]);
  const effectiveSearchAreas = searchAreas?.length ? searchAreas.map((a) => ({ id: a.id, lat: a.lat, lng: a.lng, radius: a.radius })) : [];
  reactExports.useEffect(() => {
  }, [events.length, zones.length, portals.length, effectiveAgents.length, liveLoading]);
  reactExports.useEffect(() => {
  }, [effectiveAgents.length, effectiveRewardMarkers.length, filteredUserAreas.length, effectiveSearchAreas.length]);
  const mapCenter = position ? [position.lat, position.lng] : void 0;
  const handleBuzz = () => {
  };
  const handleAreaGenerated = (lat, lng, radiusMeters) => {
    const radiusKm = radiusMeters / 1e3;
    reloadAreas();
    if (mapRef.current) {
      const map = mapRef.current;
      setTimeout(() => {
        const latDeltaDeg = radiusMeters / 111320;
        const lngDeltaDeg = radiusMeters / (111320 * Math.cos(lat * Math.PI / 180));
        const bbox = [
          [lng - lngDeltaDeg, lat - latDeltaDeg],
          [lng + lngDeltaDeg, lat + latDeltaDeg]
        ];
        const maxZoom = radiusKm > 150 ? 6 : radiusKm > 80 ? 8 : 10;
        map.fitBounds(bbox, {
          padding: 80,
          maxZoom,
          duration: 800
        });
      }, 300);
    }
  };
  const toggleLayer = (layer) => {
    setLayerVisibility((prev) => {
      const newState = { ...prev, [layer]: !prev[layer] };
      return newState;
    });
  };
  reactExports.useEffect(() => {
    return () => void 0;
  }, []);
  reactExports.useEffect(() => {
    const sp = new URLSearchParams(window.location.search);
    const forceKey = sp.get("forceKey");
    const hostname = window.location.hostname;
    const isPreview = hostname.includes("lovable") || hostname.includes("pages.dev") || hostname === "localhost" || hostname === "127.0.0.1";
    const devKey = "gw2gQRfg512G0yw3DbWn";
    const prodKey = "M2JlRFvsxjcMvVXw1HN1";
    let key;
    let mode;
    if (forceKey === "DEV") {
      key = devKey;
      mode = "DEV (forced)";
    } else if (forceKey === "PROD") {
      key = prodKey;
      mode = "PROD (forced)";
    } else {
      key = isPreview ? devKey : prodKey;
      mode = isPreview ? "DEV (auto)" : "PROD (auto)";
    }
    if (!key) {
      const msg = "MapTiler secrets not loaded. Please wait for rebuild or hard refresh.";
      ue.error(msg);
      setDiag((prev) => ({ ...prev, error: msg }));
      return;
    }
    const lat = parseFloat(sp.get("lat") || "41.9028");
    const lng = parseFloat(sp.get("lng") || "12.4964");
    const z = parseFloat(sp.get("z") || "15.5");
    const pitch = parseFloat(sp.get("pitch") || "55");
    const bearing = parseFloat(sp.get("bearing") || "25");
    if (!containerRef.current || !key) {
      setDiag((prev) => ({ ...prev, error: "Container or key missing" }));
      return;
    }
    setDiag((prev) => ({ ...prev, keyMode: mode, style: "M1SSION Neon 3D" }));
    fetch(`https://api.maptiler.com/tiles/v3/tiles.json?key=${key}`).then((r) => {
      setDiag((prev) => ({ ...prev, tiles: String(r.status) }));
    }).catch(() => {
      setDiag((prev) => ({ ...prev, tiles: "NET_ERR" }));
    });
    const style = JSON.parse(JSON.stringify(neonStyleTemplate));
    if (key && style.sources) {
      Object.keys(style.sources).forEach((sourceKey) => {
        const source = style.sources[sourceKey];
        if (source.url && source.url.includes("{key}")) {
          source.url = source.url.replace("{key}", key);
        }
        if (source.url && source.url.includes("YOUR_MAPTILER_API_KEY_HERE")) {
          source.url = source.url.replace("YOUR_MAPTILER_API_KEY_HERE", key);
        }
        if (source.tiles && Array.isArray(source.tiles)) {
          source.tiles = source.tiles.map(
            (tile) => tile.replace("{key}", key).replace("YOUR_MAPTILER_API_KEY_HERE", key)
          );
        }
      });
      if (style.glyphs) {
        style.glyphs = style.glyphs.replace("{key}", key).replace("YOUR_MAPTILER_API_KEY_HERE", key);
      }
      if (style.sprite) {
        style.sprite = style.sprite.replace("{key}", key).replace("YOUR_MAPTILER_API_KEY_HERE", key);
      }
    }
    let sanitized = false;
    if (Array.isArray(style.layers)) {
      style.layers = style.layers.map((layer) => {
        if (layer?.type === "fill-extrusion" && layer.paint) {
          if ("fill-extrusion-ambient-occlusion-intensity" in layer.paint) {
            delete layer.paint["fill-extrusion-ambient-occlusion-intensity"];
            sanitized = true;
          }
          if ("fill-extrusion-vertical-gradient" in layer.paint) {
            delete layer.paint["fill-extrusion-vertical-gradient"];
            sanitized = true;
          }
        }
        return layer;
      });
    }
    if (sanitized) {
      setDiag((prev) => ({ ...prev, style: "M1SSION Neon 3D (sanitized)" }));
    }
    try {
      const map = new maplibreGlExports.Map({
        container: containerRef.current,
        style,
        center: [lng, lat],
        zoom: z,
        pitch,
        bearing,
        hash: true,
        attributionControl: false
        // Hide MapLibre/MapTiler attribution
      });
      mapRef.current = map;
      map.on("error", (e) => {
        if (e?.error?.status === 403) {
          setDiag((prev) => ({
            ...prev,
            error: `403 Forbidden - Add hostname to MapTiler origins`
          }));
        }
      });
      map.on("load", () => {
        const buildId = "build-mizzito4";
        const urlParams = new URLSearchParams(window.location.search);
        const isDebug = urlParams.has("debug");
        const uaOnly = urlParams.has("uaOnly");
        if (isDebug) {
          window.M1_MAP = map;
          window.supabase = supabase;
          window.__bypassSW = () => {
            if ("serviceWorker" in navigator) {
              navigator.serviceWorker.getRegistrations().then((regs) => {
                regs.forEach((reg) => reg.unregister());
              });
            }
          };
          window.__hideLayer = (id) => {
            if (map.getLayer(id)) {
              map.setLayoutProperty(id, "visibility", "none");
            } else {
            }
          };
          window.__onlyUserAreas = () => {
            const keep = /* @__PURE__ */ new Set(["user-areas-fill", "user-areas-border"]);
            const layers = map.getStyle()?.layers || [];
            let hidden = 0;
            layers.forEach((l) => {
              const isFillOrLine = l.type === "fill" || l.type === "line";
              if (isFillOrLine && !keep.has(l.id)) {
                try {
                  map.setLayoutProperty(l.id, "visibility", "none");
                  hidden++;
                } catch {
                }
              }
            });
            try {
              const ua = map.getSource("user-areas");
              if (ua && ua.setData) {
                ua.setData({ type: "FeatureCollection", features: [] });
              }
            } catch (e) {
            }
          };
          window.__whoDrawsHere = (lng2, lat2) => {
            const point = map.project([lng2, lat2]);
            const features = map.queryRenderedFeatures(point);
            const rows = (features || []).map((f) => ({
              layer: f.layer?.id || "unknown",
              source: f.source,
              sourceLayer: f.sourceLayer,
              type: f.geometry.type,
              properties: JSON.stringify(f.properties)
            }));
            return rows;
          };
          window.__inventoryLayers = () => {
            const layers = (map.getStyle()?.layers || []).map((l, i) => ({
              index: i,
              id: l.id,
              type: l.type,
              source: l.source,
              visible: (() => {
                try {
                  return (map.getLayoutProperty(l.id, "visibility") ?? "visible") !== "none";
                } catch {
                  return true;
                }
              })()
            }));
            return layers;
          };
          window.__bypassSW = async () => {
            try {
              const regs = await navigator.serviceWorker.getRegistrations();
              await Promise.all(regs.map((r) => r.unregister()));
              const keys = await caches.keys();
              await Promise.all(keys.map((k) => caches.delete(k)));
              location.reload();
            } catch (e) {
            }
          };
          window.__killOverlay = () => {
            const overlays = document.querySelectorAll('#map-space,[data-overlay="map-space"],.map-overlay-circle');
            overlays.forEach((el) => {
              el.remove();
            });
            if (overlays.length === 0) {
            }
          };
          setTimeout(() => {
            window.__inventoryLayers();
            try {
              const c = map.getCenter();
              const feats = map.queryRenderedFeatures(map.project(c));
            } catch (e) {
            }
          }, 1500);
          if (uaOnly) {
            setTimeout(() => {
              const keep = /* @__PURE__ */ new Set(["user-areas-fill", "user-areas-border"]);
              const layers = map.getStyle()?.layers || [];
              let hidden = 0;
              layers.forEach((l) => {
                const isFillOrLine = l.type === "fill" || l.type === "line";
                if (isFillOrLine && !keep.has(l.id)) {
                  try {
                    map.setLayoutProperty(l.id, "visibility", "none");
                    hidden++;
                  } catch {
                  }
                }
              });
              window.__killOverlay?.();
            }, 500);
          }
          setTimeout(() => {
            const layers = map.getStyle().layers || [];
            const areaLayers = layers.filter(
              (l) => l.id.includes("areas") || l.id.includes("search")
            );
          }, 1e3);
        }
        const loadedStyle = map.getStyle();
        const hasExtrusionLayer = loadedStyle?.layers?.some(
          (l) => l.type === "fill-extrusion"
        );
        if (!hasExtrusionLayer) {
          try {
            map.addLayer({
              id: "m1-buildings-extrusion",
              type: "fill-extrusion",
              source: "openmaptiles",
              "source-layer": "building",
              minzoom: 12,
              paint: {
                "fill-extrusion-color": "#6f78ff",
                "fill-extrusion-opacity": 0.92,
                "fill-extrusion-height": ["coalesce", ["get", "render_height"], ["get", "height"], 15],
                "fill-extrusion-base": ["coalesce", ["get", "render_min_height"], 0]
              }
            });
          } catch (e) {
          }
        }
        fetch(`https://api.maptiler.com/fonts/Noto%20Sans%20Regular/0-255.pbf?key=${key}`).then((r) => setDiag((prev) => ({ ...prev, glyph: String(r.status) }))).catch(() => setDiag((prev) => ({ ...prev, glyph: "NET_ERR" })));
        const tileCoords = getTileCoordinates(lng, lat, 15);
        fetch(`https://api.maptiler.com/tiles/v3/${tileCoords.z}/${tileCoords.x}/${tileCoords.y}.pbf?key=${key}`).then((r) => setDiag((prev) => ({ ...prev, pbf: String(r.status) }))).catch(() => setDiag((prev) => ({ ...prev, pbf: "NET_ERR" })));
        if (DEV_MOCKS) ;
      });
    } catch (error) {
      setDiag((prev) => ({ ...prev, error: `MapLibre creation failed` }));
      return;
    }
    return () => {
      if (mapRef.current) {
        mapRef.current.remove();
        mapRef.current = null;
      }
    };
  }, []);
  reactExports.useEffect(() => {
    const map = mapRef.current;
    if (!map) return;
    const handleClick = (e) => {
      const { lng, lat } = e.lngLat;
      if (isAddingMarker) {
        handleMapClickMarker({ latLng: { lat: () => lat, lng: () => lng } });
      } else if (isAddingSearchArea) {
        handleMapClickArea({ latlng: { lat, lng } });
      }
    };
    map.on("click", handleClick);
    return () => {
      map.off("click", handleClick);
    };
  }, [isAddingMarker, isAddingSearchArea, handleMapClickMarker, handleMapClickArea]);
  reactExports.useEffect(() => {
    const map = mapRef.current;
    if (!map || !position) return;
    if (!map.loaded()) {
      map.once("load", () => {
        map.flyTo({
          center: [position.lng, position.lat],
          zoom: 15.5,
          pitch: 55,
          bearing: 25,
          essential: true,
          duration: 2e3
        });
      });
    } else {
      map.flyTo({
        center: [position.lng, position.lat],
        zoom: 15.5,
        pitch: 55,
        bearing: 25,
        essential: true,
        duration: 2e3
      });
    }
  }, [position]);
  const handleCenterLocation = () => {
    if (mapRef.current && position) {
      mapRef.current.flyTo({
        center: [position.lng, position.lat],
        zoom: 15.5,
        pitch: 55,
        bearing: 25,
        essential: true,
        duration: 1500
      });
    }
  };
  const handleResetView = () => {
    if (mapRef.current) {
      mapRef.current.flyTo({
        center: [DEFAULT_LOCATION[1], DEFAULT_LOCATION[0]],
        zoom: 15.5,
        pitch: 55,
        bearing: 25,
        essential: true,
        duration: 1500
      });
    }
  };
  const handleResetBearing = () => {
    if (mapRef.current) {
      mapRef.current.easeTo({
        bearing: 0,
        pitch: 0,
        duration: 800
      });
    }
  };
  const handleFindMyLocation = () => {
    if (mapRef.current && position) {
      mapRef.current.flyTo({
        center: [position.lng, position.lat],
        zoom: 16,
        essential: true,
        duration: 1500
      });
    } else if (geoStatus === "idle") {
      enableGeo();
      ue.info("Attivazione geolocalizzazione...");
    } else {
      ue.info("Geolocalizzazione non disponibile");
    }
  };
  reactExports.useEffect(() => {
    const map = mapRef.current;
    if (!map || !map.loaded()) return;
    return;
  }, [
    DEV_MOCKS,
    DEV_VIEW_LOCK,
    effectiveAgents,
    effectiveRewardMarkers,
    filteredUserAreas,
    effectiveSearchAreas
  ]);
  const { profileImage } = useProfileImage();
  const {
    notifications,
    unreadCount,
    markAllAsRead,
    deleteNotification,
    notificationsBannerOpen,
    closeNotificationsBanner
  } = useNotificationManager();
  const { battleFxMode } = usePerformanceSettings();
  const [battleUserId, setBattleUserId] = reactExports.useState(null);
  const [selectedAgent, setSelectedAgent] = reactExports.useState(null);
  const [showAgentCard, setShowAgentCard] = reactExports.useState(false);
  const [showBattleModal, setShowBattleModal] = reactExports.useState(false);
  const [preSelectedOpponent, setPreSelectedOpponent] = reactExports.useState();
  const [selectedAgentRank, setSelectedAgentRank] = reactExports.useState("Agent");
  const [activeBattleOnMap, setActiveBattleOnMap] = reactExports.useState(null);
  const [battleTimeLeft, setBattleTimeLeft] = reactExports.useState(0);
  const [showBattleResult, setShowBattleResult] = reactExports.useState(null);
  reactExports.useEffect(() => {
    supabase.auth.getUser().then(({ data }) => {
      setBattleUserId(data.user?.id || null);
    });
  }, []);
  reactExports.useEffect(() => {
    if (!selectedAgent?.rank_id) {
      setSelectedAgentRank("Agent");
      return;
    }
    const fetchRank = async () => {
      try {
        const { data: rank } = await supabase.from("agent_ranks").select("code, name_en").eq("id", selectedAgent.rank_id).single();
        if (rank) {
          setSelectedAgentRank(rank.name_en || rank.code || "Agent");
        }
      } catch (err) {
        setSelectedAgentRank("Agent");
      }
    };
    fetchRank();
  }, [selectedAgent?.rank_id]);
  const handleAgentClick = (agent) => {
    setSelectedAgent(agent);
    setShowAgentCard(true);
  };
  const handleAttackAgent = () => {
    setShowAgentCard(false);
    setPreSelectedOpponent({
      id: selectedAgent.id,
      name: selectedAgent.username || selectedAgent.agent_code || `Agent ${selectedAgent.id.slice(0, 6)}`,
      lat: selectedAgent.lat,
      lng: selectedAgent.lng
    });
    setShowBattleModal(true);
  };
  reactExports.useEffect(() => {
    const handleBattleStart = (event) => {
      const { defenderLat, defenderLng, defenderName, battleDuration } = event.detail;
      const attackerLat = position?.lat || 0;
      const attackerLng = position?.lng || 0;
      setActiveBattleOnMap({
        attackerLat,
        attackerLng,
        defenderLat,
        defenderLng,
        defenderName,
        duration: battleDuration,
        startTime: Date.now()
      });
      setBattleTimeLeft(battleDuration);
      setShowBattleModal(false);
    };
    window.addEventListener("battle-map-start", handleBattleStart);
    return () => {
      window.removeEventListener("battle-map-start", handleBattleStart);
    };
  }, [position]);
  reactExports.useEffect(() => {
    if (!activeBattleOnMap || battleTimeLeft <= 0) return;
    const timer = setInterval(() => {
      setBattleTimeLeft((prev) => {
        if (prev <= 1) {
          clearInterval(timer);
          const won = Math.random() > 0.35;
          setShowBattleResult({ won });
          window.dispatchEvent(new CustomEvent("battle-map-end", {
            detail: { won }
          }));
          setTimeout(() => {
            setActiveBattleOnMap(null);
            setShowBattleResult(null);
          }, 5e3);
          return 0;
        }
        return prev - 1;
      });
    }, 1e3);
    return () => clearInterval(timer);
  }, [activeBattleOnMap, battleTimeLeft]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(FinalShootProvider, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        id: "mission-header-container",
        style: {
          position: "fixed",
          top: 0,
          left: 0,
          right: 0,
          width: "100vw",
          zIndex: 1e4,
          isolation: "isolate",
          transform: "translateZ(0)",
          willChange: "transform",
          display: "block",
          visibility: "visible",
          opacity: 1
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(UnifiedHeader, { profileImage })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: notificationsBannerOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.div,
      {
        initial: { opacity: 0, y: -20 },
        animate: { opacity: 1, y: 0 },
        exit: { opacity: 0, y: -20 },
        transition: { duration: 0.3 },
        style: {
          position: "fixed",
          top: "calc(env(safe-area-inset-top, 0px) + 140px)",
          left: 0,
          right: 0,
          zIndex: 2e4,
          paddingLeft: "8px",
          paddingRight: "8px"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          NotificationsBanner,
          {
            notifications,
            open: notificationsBannerOpen,
            unreadCount,
            onClose: closeNotificationsBanner,
            onMarkAllAsRead: markAllAsRead,
            onDeleteNotification: deleteNotification
          }
        )
      }
    ) }),
    isBlocked && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
      position: "fixed",
      top: "calc(env(safe-area-inset-top, 0px) + 64px)",
      left: 0,
      right: 0,
      zIndex: 9999,
      padding: "8px"
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      GeolocationPermissionGuide,
      {
        isIOS,
        isPWA,
        onRetry: retryGeo
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: containerRef,
        id: "ml-sandbox",
        style: {
          position: "fixed",
          inset: 0,
          zIndex: 1
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FinalShootOverlay, { map: mapRef.current }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          position: "fixed",
          bottom: "calc(env(safe-area-inset-bottom, 34px) + 240px)",
          right: "16px",
          zIndex: 1e3,
          display: "flex",
          flexDirection: "column",
          gap: "12px"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            motion.button,
            {
              onClick: handleResetBearing,
              className: "pill-orb",
              whileHover: { scale: 1.03 },
              whileTap: { scale: 0.97 },
              title: "Reset bearing to north",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Compass, { className: "w-5 h-5 text-cyan-400" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dot", style: { background: "#0ff", boxShadow: "0 0 8px #0ff" } })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            motion.button,
            {
              onClick: handleFindMyLocation,
              className: "pill-orb",
              whileHover: { scale: 1.03 },
              whileTap: { scale: 0.97 },
              title: "Find my location",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Navigation, { className: "w-5 h-5 text-cyan-400" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dot", style: { background: "#0ff", boxShadow: "0 0 8px #0ff" } })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            motion.button,
            {
              onClick: handleCenterLocation,
              className: "pill-orb",
              whileHover: { scale: 1.03 },
              whileTap: { scale: 0.97 },
              title: "Centra su posizione",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Crosshair, { className: "w-5 h-5 text-cyan-400" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dot", style: { background: "#0ff", boxShadow: "0 0 8px #0ff" } })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            motion.button,
            {
              onClick: handleResetView,
              className: "pill-orb",
              whileHover: { scale: 1.03 },
              whileTap: { scale: 0.97 },
              title: "Reset vista",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(RotateCcw, { className: "w-5 h-5 text-cyan-400" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dot", style: { background: "#0ff", boxShadow: "0 0 8px #0ff" } })
              ]
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      PortalContainer,
      {
        portalCount: portals.length,
        onPortalAction: (type) => void 0
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AgentsLayer3D,
      {
        map: mapRef.current,
        enabled: layerVisibility.agents,
        agents: effectiveAgents,
        mePosition: position ? { lat: position.lat, lng: position.lng } : null,
        currentUserId: user?.id || null,
        onAgentClick: handleAgentClick
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PortalsLayer3D, { map: mapRef.current, enabled: layerVisibility.portals }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      RewardsLayer3D,
      {
        map: mapRef.current,
        enabled: layerVisibility.rewards,
        markers: effectiveRewardMarkers,
        userPosition: position ? { lat: position.lat, lng: position.lng } : void 0,
        isAdmin: isUserAdmin
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AreasLayer3D,
      {
        map: mapRef.current,
        enabled: layerVisibility.areas,
        userAreas: filteredUserAreas,
        searchAreas: effectiveSearchAreas,
        onDeleteSearchArea: (id) => deleteSearchArea(id),
        currentAreaVersion
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(NotesLayer3D, { map: mapRef.current, enabled: layerVisibility.notes }),
    mapRef.current && /* @__PURE__ */ jsxRuntimeExports.jsx(
      BattleFxLayer,
      {
        map: mapRef.current,
        battleFxMode
      }
    ),
    mapRef.current && activeBattleOnMap && /* @__PURE__ */ jsxRuntimeExports.jsx(
      MapBattleOverlay,
      {
        map: mapRef.current,
        battle: activeBattleOnMap,
        timeLeft: battleTimeLeft,
        result: showBattleResult
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        id: "m1u-pill-map3d-slot",
        className: "fixed left-4 z-[1001] flex items-center gap-2",
        style: {
          top: "calc(env(safe-area-inset-top, 0px) + 96px)",
          paddingLeft: "max(0px, env(safe-area-inset-left, 0px))",
          pointerEvents: "auto"
        },
        "aria-hidden": false,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(M1UPill, { showLabel: true, showPlusButton: true })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DevNotesPanel, { map: mapRef.current }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DevAreasPanel,
        {
          map: mapRef.current,
          searchAreas: effectiveSearchAreas,
          onDelete: (id) => deleteSearchArea(id),
          onFocus: (id) => setActiveSearchArea(id),
          onAddArea: handleAddAreaWithRadius
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LayerTogglePanel, { layers: layerVisibility, onToggle: toggleLayer }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "fixed z-[1001]",
        style: {
          left: "16px",
          bottom: "calc(env(safe-area-inset-bottom, 34px) + 450px)"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(FinalShootPill, {})
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "fixed z-[1001]",
        style: {
          left: "16px",
          bottom: "calc(env(safe-area-inset-bottom, 34px) + 380px)"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(RewardCounterPill, {})
      }
    ),
    battleUserId && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "fixed z-[1001]",
        style: {
          left: "16px",
          bottom: "calc(env(safe-area-inset-bottom, 34px) + 310px)"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(BattleShopPill, { userId: battleUserId })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BattlePill, { userId: battleUserId }),
    selectedAgent && /* @__PURE__ */ jsxRuntimeExports.jsx(
      AgentBattleCard,
      {
        isOpen: showAgentCard,
        onClose: () => setShowAgentCard(false),
        agentCode: selectedAgent.agent_code || `AG-${selectedAgent.id.slice(0, 6).toUpperCase()}`,
        displayName: selectedAgent.username,
        rank: selectedAgentRank,
        isAttackable: true,
        status: "available",
        onAttack: handleAttackAgent
      }
    ),
    showBattleModal && battleUserId && /* @__PURE__ */ jsxRuntimeExports.jsx(
      BattleModal,
      {
        isOpen: showBattleModal,
        onClose: () => setShowBattleModal(false),
        userId: battleUserId,
        activeBattles: [],
        pendingChallenges: [],
        loading: false,
        preSelectedOpponent
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          position: "fixed",
          bottom: "calc(env(safe-area-inset-bottom, 34px) + 100px)",
          left: "50%",
          transform: "translateX(-50%)",
          zIndex: 1001
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          BuzzMapButtonSecure,
          {
            onBuzzPress: handleBuzz,
            mapCenter: mapCenter || DEFAULT_LOCATION,
            onAreaGenerated: handleAreaGenerated
          }
        )
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        id: "mission-bottom-nav-container",
        style: {
          position: "fixed",
          bottom: 0,
          left: 0,
          right: 0,
          width: "100vw",
          zIndex: 1e4,
          isolation: "isolate",
          transform: "translateZ(0)",
          willChange: "transform",
          display: "block",
          visibility: "visible",
          opacity: 1
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(BottomNavigation, {})
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BuzzDebugBadge, { latestArea }),
    debugEnabled && /* @__PURE__ */ jsxRuntimeExports.jsx(MapVerificationPanel, {}),
    debugEnabled && /* @__PURE__ */ jsxRuntimeExports.jsx(DebugMapPanel, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BuzzDiagnosticPanel, {})
  ] });
}
function getTileCoordinates(lng, lat, zoom) {
  const n = Math.pow(2, zoom);
  const x = Math.floor((lng + 180) / 360 * n);
  const latRad = lat * Math.PI / 180;
  const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);
  return { x, y, z: zoom };
}

export { MapTiler3D as default };
